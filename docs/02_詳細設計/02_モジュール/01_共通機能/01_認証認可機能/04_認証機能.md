# 認証機能 詳細設計

## バージョン管理
| バージョン | 日付 | 更新者 | 更新内容 |
|----------|------|-------|---------|
| 0.1 | 2025-05-10 | 設計担当者 | 初版作成 |

## 1. 概要

### 1.1 目的
認証機能は、SES業務システムにおけるユーザー認証、セッション管理、トークン発行・検証などのセキュリティ基盤機能を提供する。本モジュールにより、正規のユーザーのみがシステムにアクセスでき、安全なセッション維持が可能となる。

### 1.2 機能範囲
- ユーザー認証（ID/パスワード）
- JWTトークン発行・検証
- リフレッシュトークン管理
- 多要素認証（MFA）
- パスワード管理（リセット、変更）
- アカウントロック管理
- ログイン／ログアウト処理

### 1.3 関連モジュール
- ユーザー管理モジュール：ユーザー情報の取得に利用
- 通知モジュール：パスワードリセットメール送信などに利用
- 監査ログモジュール：セキュリティイベント記録に利用

## 2. コンポーネント構成

### 2.1 コントローラー

#### AuthenticationController
- **責務**：認証関連のRESTエンドポイントを提供
- **エンドポイント**：
  - POST /api/v1/auth/login：ユーザーログイン
  - POST /api/v1/auth/refresh：トークンのリフレッシュ
  - POST /api/v1/auth/logout：ログアウト
  - POST /api/v1/auth/mfa/verify：多要素認証の検証
  - POST /api/v1/auth/mfa/setup：多要素認証のセットアップ
  - POST /api/v1/auth/password/reset-request：パスワードリセット要求
  - POST /api/v1/auth/password/reset：パスワードリセット実行
  - POST /api/v1/auth/password/change：パスワード変更

#### 主要メソッド
```java
@RestController
@RequestMapping("/api/v1/auth")
public class AuthenticationController {
    @Autowired
    private AuthenticationService authService;
    
    @Autowired
    private AuditLogService auditLogService;
    
    /**
     * ユーザーログイン処理
     */
    @PostMapping("/login")
    public ResponseEntity<TokenResponse> login(@Valid @RequestBody LoginRequest request) {
        // 認証処理を実行
        TokenResponse response = authService.authenticate(
            new Credentials(request.getEmail(), request.getPassword(), request.isRememberMe())
        );
        
        // 監査ログに記録
        auditLogService.logAuthenticationEvent(new AuthenticationEvent(
            response.getUserId(),
            request.getEmail(),
            AuthenticationResult.SUCCESS,
            AuthenticationMethod.PASSWORD,
            request.getIpAddress(),
            request.getUserAgent(),
            new Date(),
            null,
            0
        ));
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * トークンリフレッシュ処理
     */
    @PostMapping("/refresh")
    public ResponseEntity<TokenResponse> refreshToken(@Valid @RequestBody RefreshTokenRequest request) {
        TokenResponse response = authService.refreshToken(request.getRefreshToken());
        return ResponseEntity.ok(response);
    }
    
    // 他のエンドポイントメソッドも同様に実装
}
```

### 2.2 サービス

#### AuthenticationServiceImpl
- **責務**：認証ロジックの実装、AuthenticationServiceインターフェースの実装
- **主要メソッド**：
  - authenticate：ユーザー認証とトークン発行
  - refreshToken：リフレッシュトークンによるアクセストークン更新
  - validateToken：トークンの検証
  - logout/logoutAll：セッション無効化
  - verifyMfaCode/setupMfa：多要素認証の処理

```java
@Service
public class AuthenticationServiceImpl implements AuthenticationService {
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private RefreshTokenRepository refreshTokenRepository;
    
    @Autowired
    private JwtTokenProvider tokenProvider;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Autowired
    private MfaService mfaService;
    
    @Autowired
    private NotificationService notificationService;
    
    @Override
    public TokenResponse authenticate(Credentials credentials) {
        // ユーザー検証
        User user = userRepository.findByEmail(credentials.getEmail())
            .orElseThrow(() -> new AuthenticationException(
                AuthenticationErrorCode.INVALID_CREDENTIALS, "Invalid email or password"));
        
        // パスワード検証
        if (!passwordEncoder.matches(credentials.getPassword(), user.getPasswordHash())) {
            // ログイン失敗をカウント
            updateFailedLoginAttempts(user);
            throw new AuthenticationException(
                AuthenticationErrorCode.INVALID_CREDENTIALS, "Invalid email or password");
        }
        
        // アカウント状態チェック
        validateAccountStatus(user);
        
        // アクセストークン発行
        String accessToken = tokenProvider.generateAccessToken(user);
        
        // リフレッシュトークン発行
        String refreshToken = generateRefreshToken(user, credentials.isRememberMe());
        
        // MFA要件チェック
        boolean requiresMfa = user.isMfaEnabled();
        
        return new TokenResponse(accessToken, refreshToken, 
            tokenProvider.getAccessTokenExpiration(), requiresMfa, user.getId());
    }
    
    @Override
    public TokenResponse refreshToken(String refreshToken) {
        // リフレッシュトークン検証
        String tokenId = tokenProvider.validateRefreshToken(refreshToken);
        RefreshToken token = refreshTokenRepository.findById(UUID.fromString(tokenId))
            .orElseThrow(() -> new AuthenticationException(
                AuthenticationErrorCode.INVALID_TOKEN, "Invalid refresh token"));
        
        // トークン状態検証
        validateRefreshToken(token);
        
        // ユーザー取得
        User user = userRepository.findById(token.getUserId())
            .orElseThrow(() -> new AuthenticationException(
                AuthenticationErrorCode.INVALID_TOKEN, "User not found"));
        
        // 新しいアクセストークン発行
        String newAccessToken = tokenProvider.generateAccessToken(user);
        
        // 新しいリフレッシュトークンは必要に応じて発行
        String newRefreshToken = rotateRefreshTokenIfNeeded(token);
        
        return new TokenResponse(newAccessToken, newRefreshToken, 
            tokenProvider.getAccessTokenExpiration(), false, user.getId());
    }
    
    @Override
    public void logout(UUID userId, String refreshToken) {
        // リフレッシュトークン無効化
        String tokenId = tokenProvider.extractRefreshTokenId(refreshToken);
        if (tokenId != null) {
            refreshTokenRepository.findById(UUID.fromString(tokenId))
                .ifPresent(token -> {
                    token.setRevoked(true);
                    token.setRevokedAt(new Date());
                    refreshTokenRepository.save(token);
                });
        }
    }
    
    // 他のメソッドも同様に実装
}
```

#### JwtTokenProvider
- **責務**：JWTトークンの生成・検証・管理
- **主要メソッド**：
  - generateAccessToken：アクセストークン生成
  - generateRefreshToken：リフレッシュトークン生成
  - validateAccessToken：アクセストークン検証
  - validateRefreshToken：リフレッシュトークン検証
  - getAuthentication：トークンから認証情報を取得

```java
@Component
public class JwtTokenProvider {
    @Value("${app.security.jwt.access-secret}")
    private String accessTokenSecret;
    
    @Value("${app.security.jwt.refresh-secret}")
    private String refreshTokenSecret;
    
    @Value("${app.security.jwt.access-expiration-ms}")
    private long accessTokenExpirationMs;
    
    @Value("${app.security.jwt.refresh-expiration-ms}")
    private long refreshTokenExpirationMs;
    
    @Value("${app.security.jwt.refresh-remember-me-expiration-ms}")
    private long refreshTokenRememberMeExpirationMs;
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private RoleService roleService;
    
    /**
     * アクセストークンを生成する
     */
    public String generateAccessToken(User user) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + accessTokenExpirationMs);
        
        // ユーザーの権限を取得
        List<String> roles = userService.getUserRoles(user.getId())
            .stream()
            .map(Role::getName)
            .collect(Collectors.toList());
        
        List<String> permissions = roleService.getRolePermissions(user.getRoleId())
            .stream()
            .map(Permission::getName)
            .collect(Collectors.toList());
        
        // トークンを作成
        return Jwts.builder()
            .setSubject(user.getId().toString())
            .setIssuedAt(now)
            .setExpiration(expiryDate)
            .claim("roles", roles)
            .claim("permissions", permissions)
            .claim("name", user.getName())
            .claim("email", user.getEmail())
            .signWith(SignatureAlgorithm.RS256, getAccessTokenPrivateKey())
            .compact();
    }
    
    /**
     * リフレッシュトークンを生成する
     */
    public String generateRefreshToken(UUID userId, UUID tokenId, boolean rememberMe) {
        Date now = new Date();
        long expirationMs = rememberMe ? 
            refreshTokenRememberMeExpirationMs : refreshTokenExpirationMs;
        Date expiryDate = new Date(now.getTime() + expirationMs);
        
        return Jwts.builder()
            .setSubject(userId.toString())
            .setId(tokenId.toString())
            .setIssuedAt(now)
            .setExpiration(expiryDate)
            .signWith(SignatureAlgorithm.RS256, getRefreshTokenPrivateKey())
            .compact();
    }
    
    /**
     * アクセストークンを検証する
     */
    public UserPrincipal validateAccessToken(String token) {
        try {
            Claims claims = Jwts.parser()
                .setSigningKey(getAccessTokenPublicKey())
                .parseClaimsJws(token)
                .getBody();
            
            UUID userId = UUID.fromString(claims.getSubject());
            String email = claims.get("email", String.class);
            String name = claims.get("name", String.class);
            List<String> roles = claims.get("roles", List.class);
            List<String> permissions = claims.get("permissions", List.class);
            
            return new UserPrincipal(userId, email, name, roles, permissions);
        } catch (ExpiredJwtException e) {
            throw new AuthenticationException(
                AuthenticationErrorCode.TOKEN_EXPIRED, "Access token expired");
        } catch (JwtException | IllegalArgumentException e) {
            throw new AuthenticationException(
                AuthenticationErrorCode.INVALID_TOKEN, "Invalid access token");
        }
    }
    
    // 他のメソッドも同様に実装
}
```

#### MfaService
- **責務**：多要素認証の処理
- **主要メソッド**：
  - setupTotpMfa：TOTPベースの多要素認証セットアップ
  - verifyTotpCode：TOTPコードの検証
  - generateRecoveryCodes：リカバリーコード生成
  - verifyRecoveryCode：リカバリーコード検証

```java
@Service
public class MfaService {
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private MfaRecoveryCodeRepository recoveryCodeRepository;
    
    @Autowired
    private EncryptionService encryptionService;
    
    /**
     * TOTP多要素認証をセットアップする
     */
    public MfaSetupResponse setupTotpMfa(UUID userId) {
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new ResourceNotFoundException("User not found"));
        
        // 秘密鍵の生成
        String secretKey = generateSecretKey();
        
        // QRコード用のURIを生成
        String qrCodeUri = generateQrCodeUri(user.getEmail(), secretKey);
        
        // リカバリーコードの生成
        List<String> recoveryCodes = generateRecoveryCodes(userId);
        
        // 暗号化して保存
        user.setMfaSecret(encryptionService.encrypt(secretKey));
        user.setMfaEnabled(true);
        userRepository.save(user);
        
        return new MfaSetupResponse(secretKey, qrCodeUri, recoveryCodes);
    }
    
    /**
     * TOTPコードを検証する
     */
    public boolean verifyTotpCode(UUID userId, String code) {
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new ResourceNotFoundException("User not found"));
        
        // MFAが有効でない場合
        if (!user.isMfaEnabled() || user.getMfaSecret() == null) {
            return false;
        }
        
        // 秘密鍵を復号化
        String secretKey = encryptionService.decrypt(user.getMfaSecret());
        
        // TOTPコードを検証
        return validateTotp(secretKey, code);
    }
    
    /**
     * リカバリーコードを生成する
     */
    public List<String> generateRecoveryCodes(UUID userId) {
        // 既存のリカバリーコードを削除
        recoveryCodeRepository.deleteByUserId(userId);
        
        // 新しいリカバリーコードを生成
        List<String> plainCodes = new ArrayList<>();
        List<MfaRecoveryCode> codeEntities = new ArrayList<>();
        
        for (int i = 0; i < 10; i++) {
            String code = generateRandomCode();
            plainCodes.add(code);
            
            MfaRecoveryCode codeEntity = new MfaRecoveryCode();
            codeEntity.setUserId(userId);
            codeEntity.setCodeHash(passwordEncoder.encode(code));
            codeEntity.setUsed(false);
            codeEntities.add(codeEntity);
        }
        
        // 保存
        recoveryCodeRepository.saveAll(codeEntities);
        
        return plainCodes;
    }
    
    // 他のメソッドも同様に実装
}
```

### 2.3 リポジトリ

#### UserRepository
- **責務**：ユーザーエンティティのデータアクセス
- **主要メソッド**：
  - findById：IDによるユーザー検索
  - findByEmail：メールアドレスによるユーザー検索
  - save：ユーザー保存

```java
@Repository
public interface UserRepository extends JpaRepository<User, UUID> {
    Optional<User> findByEmail(String email);
    
    @Modifying
    @Query("UPDATE User u SET u.lastLoginAt = :lastLoginAt WHERE u.id = :userId")
    void updateLastLogin(@Param("userId") UUID userId, @Param("lastLoginAt") LocalDateTime lastLoginAt);
    
    @Modifying
    @Query("UPDATE User u SET u.loginFailCount = :count WHERE u.id = :userId")
    void updateLoginFailCount(@Param("userId") UUID userId, @Param("count") int count);
    
    @Modifying
    @Query("UPDATE User u SET u.accountLocked = :locked, u.lockedUntil = :lockedUntil WHERE u.id = :userId")
    void updateAccountLockStatus(
        @Param("userId") UUID userId, 
        @Param("locked") boolean locked, 
        @Param("lockedUntil") LocalDateTime lockedUntil
    );
}
```

#### RefreshTokenRepository
- **責務**：リフレッシュトークンエンティティのデータアクセス
- **主要メソッド**：
  - findById：IDによるトークン検索
  - findByUserIdAndRevoked：ユーザーIDによる有効なトークン検索
  - save：トークン保存
  - deleteByExpiresAtBefore：期限切れトークン削除

```java
@Repository
public interface RefreshTokenRepository extends JpaRepository<RefreshToken, UUID> {
    List<RefreshToken> findByUserIdAndRevoked(UUID userId, boolean revoked);
    
    @Modifying
    @Query("UPDATE RefreshToken r SET r.revoked = true, r.revokedAt = :now WHERE r.userId = :userId")
    void revokeAllUserTokens(@Param("userId") UUID userId, @Param("now") LocalDateTime now);
    
    @Modifying
    @Query("DELETE FROM RefreshToken r WHERE r.expiresAt < :expiryDate")
    void deleteByExpiresAtBefore(@Param("expiryDate") LocalDateTime expiryDate);
    
    @Modifying
    @Query("DELETE FROM RefreshToken r WHERE r.revoked = true AND r.revokedAt < :date")
    void deleteRevokedBefore(@Param("date") LocalDateTime date);
}
```

### 2.4 セキュリティ設定

#### SecurityConfig
- **責務**：Spring Securityの設定
- **主要設定**：
  - セキュリティフィルターチェーン
  - 認証プロバイダー
  - CSRFやCORSの設定
  - セキュリティヘッダー設定

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Autowired
    private JwtAuthenticationFilter jwtAuthenticationFilter;
    
    @Autowired
    private CustomUserDetailsService userDetailsService;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
            .csrf().disable()  // API向けにCSRF保護を無効化
            .cors().configurationSource(corsConfigurationSource())
            .and()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .authorizeRequests()
                .antMatchers("/api/v1/auth/**").permitAll()
                .antMatchers("/api/v1/public/**").permitAll()
                .anyRequest().authenticated()
            .and()
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
            .headers()
                .frameOptions().deny()
                .xssProtection().block(true)
                .contentSecurityPolicy("default-src 'self'")
            .and()
            .build();
    }
    
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }
    
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(userDetailsService);
        provider.setPasswordEncoder(passwordEncoder);
        return provider;
    }
    
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("https://example.com"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setAllowCredentials(true);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}
```

#### JwtAuthenticationFilter
- **責務**：リクエストからJWTトークンを抽出し、認証処理を行う
- **主要機能**：
  - トークン抽出
  - トークン検証
  - 認証情報の設定

```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    @Autowired
    private JwtTokenProvider tokenProvider;
    
    @Override
    protected void doFilterInternal(
            HttpServletRequest request, 
            HttpServletResponse response, 
            FilterChain filterChain) throws ServletException, IOException {
        
        try {
            // リクエストからトークンを抽出
            String token = getTokenFromRequest(request);
            
            // トークンが存在し、有効な場合は認証情報を設定
            if (token != null) {
                UserPrincipal userPrincipal = tokenProvider.validateAccessToken(token);
                
                // Spring Securityの認証情報を設定
                UsernamePasswordAuthenticationToken authentication = 
                    new UsernamePasswordAuthenticationToken(
                        userPrincipal, 
                        null, 
                        getAuthorities(userPrincipal)
                    );
                
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (AuthenticationException e) {
            // トークンが無効な場合は認証情報をクリア
            SecurityContextHolder.clearContext();
            
            // エラーハンドリング
            if (e.getErrorCode() == AuthenticationErrorCode.TOKEN_EXPIRED) {
                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                response.getWriter().write("{\"error\":\"token_expired\",\"message\":\"Access token expired\"}");
                return;
            }
        }
        
        filterChain.doFilter(request, response);
    }
    
    private String getTokenFromRequest(HttpServletRequest request) {
        // Authorizationヘッダーからトークンを抽出
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
    
    private Collection<? extends GrantedAuthority> getAuthorities(UserPrincipal userPrincipal) {
        Set<GrantedAuthority> authorities = new HashSet<>();
        
        // ロールベースの権限
        userPrincipal.getRoles().forEach(role -> 
            authorities.add(new SimpleGrantedAuthority("ROLE_" + role)));
        
        // 権限ベースの権限
        userPrincipal.getPermissions().forEach(permission -> 
            authorities.add(new SimpleGrantedAuthority(permission)));
        
        return authorities;
    }
}
```

### 2.5 データモデル

#### User
- ユーザー情報を表すエンティティ
- 属性：ID、メールアドレス、パスワードハッシュ、ユーザー名など

```java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;
    
    @Column(unique = true, nullable = false)
    private String email;
    
    @Column(nullable = false)
    private String passwordHash;
    
    @Column(nullable = false)
    private String name;
    
    private String department;
    
    private String position;
    
    private String phone;
    
    @Column(nullable = false)
    private UUID roleId;
    
    private LocalDateTime lastLoginAt;
    
    @Column(nullable = false)
    private boolean mfaEnabled = false;
    
    private String mfaSecret;
    
    @Column(nullable = false)
    private boolean accountLocked = false;
    
    private LocalDateTime lockedUntil;
    
    private LocalDateTime accountExpiresAt;
    
    @Column(nullable = false)
    private LocalDateTime passwordExpiresAt;
    
    @Column(nullable = false)
    private int loginFailCount = 0;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    @Column(nullable = false)
    private LocalDateTime updatedAt;
    
    // getter/setter、equals/hashCode、toString
}
```

#### RefreshToken
- リフレッシュトークン情報を表すエンティティ
- 属性：ID、ユーザーID、トークンハッシュ、有効期限など

```java
@Entity
@Table(name = "refresh_tokens")
public class RefreshToken {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;
    
    @Column(nullable = false)
    private UUID userId;
    
    @Column(nullable = false)
    private String tokenHash;
    
    @Column(nullable = false)
    private LocalDateTime expiresAt;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    @Column(nullable = false)
    private boolean revoked = false;
    
    private LocalDateTime revokedAt;
    
    // getter/setter、equals/hashCode、toString
}
```

#### MfaRecoveryCode
- 多要素認証のリカバリーコードを表すエンティティ
- 属性：ID、ユーザーID、コードハッシュ、使用済みフラグなど

```java
@Entity
@Table(name = "mfa_recovery_codes")
public class MfaRecoveryCode {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;
    
    @Column(nullable = false)
    private UUID userId;
    
    @Column(nullable = false)
    private String codeHash;
    
    @Column(nullable = false)
    private boolean used = false;
    
    private LocalDateTime usedAt;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    // getter/setter、equals/hashCode、toString
}
```

## 3. 主要処理フロー

### 3.1 ユーザー認証フロー

1. クライアントがログイン情報（メールアドレス、パスワード）を送信
2. AuthenticationControllerがリクエストを受け取る
3. AuthenticationServiceがユーザー情報を検証
   - ユーザーの存在確認
   - パスワードのハッシュ照合
   - アカウント状態チェック
4. JWTトークン（アクセス＋リフレッシュ）を生成
5. クライアントにトークンレスポンスを返却
6. 必要に応じて多要素認証を要求
   - MFAが有効な場合、requiresMfaフラグをtrueに設定
   - クライアントがMFAコードを送信
   - MfaServiceがコードを検証

```
sequenceDiagram
    Client->>AuthenticationController: POST /api/v1/auth/login
    AuthenticationController->>AuthenticationServiceImpl: authenticate(credentials)
    AuthenticationServiceImpl->>UserRepository: findByEmail(email)
    UserRepository-->>AuthenticationServiceImpl: User
    
    AuthenticationServiceImpl->>PasswordEncoder: matches(password, passwordHash)
    PasswordEncoder-->>AuthenticationServiceImpl: true/false
    
    alt パスワード不一致
        AuthenticationServiceImpl->>UserRepository: updateLoginFailCount(+1)
        AuthenticationServiceImpl-->>AuthenticationController: throw AuthenticationException
        AuthenticationController-->>Client: 401 Unauthorized
    else パスワード一致
        AuthenticationServiceImpl->>AuthenticationServiceImpl: validateAccountStatus(user)
        AuthenticationServiceImpl->>JwtTokenProvider: generateAccessToken(user)
        JwtTokenProvider-->>AuthenticationServiceImpl: accessToken
        
        AuthenticationServiceImpl->>AuthenticationServiceImpl: generateRefreshToken(user)
        AuthenticationServiceImpl->>RefreshTokenRepository: save(refreshToken)
        
        AuthenticationServiceImpl-->>AuthenticationController: TokenResponse
        AuthenticationController->>AuditLogService: logAuthenticationEvent()
        AuthenticationController-->>Client: 200 OK + TokenResponse
        
        alt MFA有効
            Client->>AuthenticationController: POST /api/v1/auth/mfa/verify
            AuthenticationController->>MfaService: verifyTotpCode(userId, code)
            MfaService-->>AuthenticationController: true/false
            AuthenticationController-->>Client: 200 OK / 401 Unauthorized
        end
    end
```

### 3.2 トークンリフレッシュフロー

1. クライアントがリフレッシュトークンを送信
2. AuthenticationControllerがリクエストを受け取る
3. JwtTokenProviderがリフレッシュトークンを検証
4. RefreshTokenRepositoryがトークンの存在と有効性を確認
5. 新しいアクセストークンを生成
6. 必要に応じてリフレッシュトークンもローテーション
7. クライアントに新しいトークンレスポンスを返却

```
sequenceDiagram
    Client->>AuthenticationController: POST /api/v1/auth/refresh
    AuthenticationController->>AuthenticationServiceImpl: refreshToken(refreshToken)
    
    AuthenticationServiceImpl->>JwtTokenProvider: validateRefreshToken(refreshToken)
    JwtTokenProvider-->>AuthenticationServiceImpl: tokenId
    
    AuthenticationServiceImpl->>RefreshTokenRepository: findById(tokenId)
    RefreshTokenRepository-->>AuthenticationServiceImpl: RefreshToken
    
    AuthenticationServiceImpl->>AuthenticationServiceImpl: validateRefreshToken(token)
    
    AuthenticationServiceImpl->>UserRepository: findById(token.getUserId())
    UserRepository-->>AuthenticationServiceImpl: User
    
    AuthenticationServiceImpl->>JwtTokenProvider: generateAccessToken(user)
    JwtTokenProvider-->>AuthenticationServiceImpl: newAccessToken
    
    alt トークンローテーションが必要
        AuthenticationServiceImpl->>AuthenticationServiceImpl: rotateRefreshToken(token)
        AuthenticationServiceImpl->>RefreshTokenRepository: save(newRefreshToken)
        RefreshTokenRepository-->>AuthenticationServiceImpl: savedToken
    end
    
    AuthenticationServiceImpl-->>AuthenticationController: TokenResponse
    AuthenticationController-->>Client: 200 OK + TokenResponse
```

### 3.3 パスワードリセットフロー

1. ユーザーがパスワードリセットをリクエスト
2. AuthenticationControllerがリクエストを受け取る
3. UserServiceがユーザーの存在確認
4. パスワードリセットトークンを生成・保存
5. NotificationServiceがリセットメールを送信
6. ユーザーがメールのリンクからリセットページにアクセス
7. 新しいパスワードを入力・送信
8. AuthenticationControllerがリセットトークンを検証
9. UserServiceがパスワードを更新（ハッシュ化して保存）
10. 既存のセッションを無効化
11. ユーザーにリセット成功を通知

```
sequenceDiagram
    Client->>AuthenticationController: POST /api/v1/auth/password/reset-request
    AuthenticationController->>UserService: requestPasswordReset(email)
    
    UserService->>UserRepository: findByEmail(email)
    UserRepository-->>UserService: User
    
    UserService->>PasswordResetTokenService: generateToken(userId)
    PasswordResetTokenService-->>UserService: resetToken
    
    UserService->>NotificationService: sendEmail(resetEmailRequest)
    NotificationService-->>UserService: sent
    
    UserService-->>AuthenticationController: success
    AuthenticationController-->>Client: 200 OK
    
    Note over Client,AuthenticationController: ユーザーがメールを確認しリセットページへアクセス
    
    Client->>AuthenticationController: POST /api/v1/auth/password/reset
    AuthenticationController->>UserService: resetPassword(request)
    
    UserService->>PasswordResetTokenService: validateToken(token)
    PasswordResetTokenService-->>UserService: userId
    
    UserService->>PasswordValidator: validate(newPassword)
    PasswordValidator-->>UserService: valid
    
    UserService->>PasswordEncoder: encode(newPassword)
    PasswordEncoder-->>UserService: passwordHash
    
    UserService->>UserRepository: updatePassword(userId, passwordHash)
    UserRepository-->>UserService: updated
    
    UserService->>RefreshTokenRepository: revokeAllUserTokens(userId)
    RefreshTokenRepository-->>UserService: done
    
    UserService-->>AuthenticationController: success
    AuthenticationController-->>Client: 200 OK
```

### 3.4 多要素認証セットアップフロー

1. ユーザーがMFAセットアップをリクエスト
2. AuthenticationControllerがリクエストを受け取る
3. MfaServiceが秘密鍵を生成
4. QRコード用のURIを生成
5. リカバリーコードを生成
6. 秘密鍵を暗号化してユーザーに紐づけて保存
7. QRコードURIとリカバリーコードをクライアントに返却
8. ユーザーが認証アプリでQRコードをスキャン
9. 認証アプリが生成したコードを送信
10. MfaServiceがコードを検証
11. 検証成功時にMFAを有効化

```
sequenceDiagram
    Client->>AuthenticationController: POST /api/v1/auth/mfa/setup
    AuthenticationController->>MfaService: setupTotpMfa(userId)
    
    MfaService->>UserRepository: findById(userId)
    UserRepository-->>MfaService: User
    
    MfaService->>MfaService: generateSecretKey()
    MfaService->>MfaService: generateQrCodeUri(email, secretKey)
    
    MfaService->>MfaService: generateRecoveryCodes(userId)
    MfaService->>MfaRecoveryCodeRepository: saveAll(recoveryCodes)
    
    MfaService->>EncryptionService: encrypt(secretKey)
    EncryptionService-->>MfaService: encryptedSecret
    
    MfaService->>UserRepository: save(updatedUser)
    UserRepository-->>MfaService: savedUser
    
    MfaService-->>AuthenticationController: MfaSetupResponse
    AuthenticationController-->>Client: 200 OK + MfaSetupResponse
    
    Note over Client,AuthenticationController: ユーザーがQRコードをスキャンし検証コードを取得
    
    Client->>AuthenticationController: POST /api/v1/auth/mfa/verify
    AuthenticationController->>MfaService: verifyTotpCode(userId, code)
    
    MfaService->>UserRepository: findById(userId)
    UserRepository-->>MfaService: User
    
    MfaService->>EncryptionService: decrypt(user.getMfaSecret())
    EncryptionService-->>MfaService: secretKey
    
    MfaService->>MfaService: validateTotp(secretKey, code)
    MfaService-->>AuthenticationController: valid
    
    AuthenticationController-->>Client: 200 OK
```

## 4. 例外処理

### 4.1 認証例外階層

```java
// 基底例外クラス
public class AuthenticationException extends RuntimeException {
    private final AuthenticationErrorCode errorCode;
    
    public AuthenticationException(AuthenticationErrorCode errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }
    
    public AuthenticationErrorCode getErrorCode() {
        return errorCode;
    }
}

// エラーコード
public enum AuthenticationErrorCode {
    INVALID_CREDENTIALS,   // 資格情報無効
    ACCOUNT_LOCKED,        // アカウントロック
    ACCOUNT_EXPIRED,       // アカウント期限切れ
    PASSWORD_EXPIRED,      // パスワード期限切れ
    MFA_REQUIRED,          // 多要素認証必須
    MFA_FAILED,            // 多要素認証失敗
    INVALID_TOKEN,         // トークン無効
    TOKEN_EXPIRED,         // トークン期限切れ
    REFRESH_TOKEN_REVOKED  // リフレッシュトークン無効化済み
}
```

### 4.2 グローバル例外ハンドラー

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleAuthenticationException(AuthenticationException ex) {
        HttpStatus status;
        
        // エラーコードごとに適切なHTTPステータスを設定
        switch (ex.getErrorCode()) {
            case INVALID_CREDENTIALS:
            case MFA_FAILED:
                status = HttpStatus.UNAUTHORIZED;
                break;
            case ACCOUNT_LOCKED:
                status = HttpStatus.FORBIDDEN;
                break;
            case ACCOUNT_EXPIRED:
            case PASSWORD_EXPIRED:
                status = HttpStatus.UNAUTHORIZED;
                break;
            case MFA_REQUIRED:
                status = HttpStatus.UNAUTHORIZED;
                break;
            case INVALID_TOKEN:
            case TOKEN_EXPIRED:
            case REFRESH_TOKEN_REVOKED:
                status = HttpStatus.UNAUTHORIZED;
                break;
            default:
                status = HttpStatus.INTERNAL_SERVER_ERROR;
        }
        
        // エラーレスポンスを生成
        ErrorResponse errorResponse = new ErrorResponse(
            ex.getErrorCode().name(),
            ex.getMessage()
        );
        
        return new ResponseEntity<>(errorResponse, status);
    }
    
    // その他の例外ハンドラーも実装
}
```

## 5. セキュリティ対策

### 5.1 パスワードセキュリティ

- **ハッシュ化アルゴリズム**: BCrypt（コストパラメータ = 12）
- **パスワード強度検証**:
  - 8文字以上
  - 大文字/小文字/数字/特殊文字から3種類以上の組み合わせ
  - 共通パスワードブラックリストとの照合
- **パスワード有効期限**: 90日（設定により変更可能）
- **パスワード履歴**: 過去5回使用したパスワードの再利用禁止

### 5.2 JWT対策

- **署名アルゴリズム**: RS256（RSA-SHA256）を使用、キー長2048ビット以上
- **有効期限**: アクセストークン30分、リフレッシュトークン最大2週間
- **クレーム内容の最小化**: 必要最小限の情報のみ含める
- **リフレッシュトークン管理**: データベースでの追跡・無効化機能
- **ローテーション**: 定期的なリフレッシュトークンのローテーション

### 5.3 アカウント保護

- **アカウントロック**: 5回連続のログイン失敗でアカウントを一時的にロック（30分）
- **ログイン試行遅延**: 失敗回数に応じて指数関数的に遅延を増加
- **多要素認証**: 管理者アカウントは必須、他のユーザーはオプション
- **リカバリーコード**: 多要素認証のバックアップとして一度限りのリカバリーコード

### 5.4 トランスポートセキュリティ

- **HTTPS強制**: HTTPSでのみアクセス可能（HTTP⇨HTTPSリダイレクト）
- **セキュリティヘッダー**:
  - Strict-Transport-Security
  - X-Content-Type-Options: nosniff
  - X-Frame-Options: DENY
  - Content-Security-Policy
  - X-XSS-Protection

## 6. 特記事項

### 6.1 実装上の注意点

- **セッション管理**: セッションはステートレスに設計し、サーバー側での情報保持を最小限にする
- **スケーラビリティ**: JWT検証は各サーバーで独立して行えるため、水平スケーリングが容易
- **鍵管理**: JWT署名用の秘密鍵は安全に管理し、定期的にローテーションする仕組みを導入
- **トークン漏洩対策**: HTTPヘッダーでの送信、HTTPS強制、XSS対策の徹底

### 6.2 パフォーマンス考慮点

- **キャッシュの活用**: ユーザー情報や権限情報のキャッシュを適切に設定
- **非同期処理**: メール送信などの非同期処理を導入
- **バッチ処理**: 期限切れトークンの定期的なクリーンアップ
- **インデックス最適化**: ユーザー検索、トークン検証のためのインデックス設定

### 6.3 テストの観点

- **単体テスト**: 各サービスクラスのメソッドごとのテスト
- **統合テスト**: 認証フロー全体のE2Eテスト
- **セキュリティテスト**: パスワード強度検証、JWT実装の脆弱性テスト
- **パフォーマンステスト**: 多数のユーザーによる同時ログインテスト

## 7. 参照情報

- [Spring Security Documentation](https://docs.spring.io/spring-security/reference/index.html)
- [JWT.io](https://jwt.io/)
- [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
- [TOTP Algorithm (RFC 6238)](https://tools.ietf.org/html/rfc6238)