# 認可機能 詳細設計

## バージョン管理
| バージョン | 日付 | 更新者 | 更新内容 |
|----------|------|-------|---------|
| 0.1 | 2025-05-10 | 設計担当者 | 初版作成 |

## 1. 概要

### 1.1 目的
認可機能は、SES業務システムにおけるユーザーのアクセス制御を担当するモジュールです。本モジュールは、各ユーザーがどのリソースにどのようなアクションを実行できるかを判定し、システム全体のセキュリティポリシーを一貫して適用することを目的としています。

### 1.2 機能範囲
- ロールベースアクセス制御（RBAC）
- 属性ベースアクセス制御（ABAC）
- リソースレベルの権限管理
- アクションレベルの権限管理
- 動的ポリシー評価
- データフィルタリング
- 管理者向け権限管理インターフェース

### 1.3 関連モジュール
- 認証モジュール：ユーザーの認証情報を取得
- ユーザー管理モジュール：ユーザー情報の取得
- ロギングモジュール：権限チェックの監査ログ記録

## 2. コンポーネント構成

### 2.1 コントローラー

#### RoleController
- **責務**：ロール管理のRESTエンドポイントを提供
- **エンドポイント**：
  - GET /api/v1/admin/roles：ロール一覧取得
  - GET /api/v1/admin/roles/{id}：ロール詳細取得
  - POST /api/v1/admin/roles：ロール作成
  - PUT /api/v1/admin/roles/{id}：ロール更新
  - DELETE /api/v1/admin/roles/{id}：ロール削除
  - GET /api/v1/admin/roles/{id}/permissions：ロールの権限取得
  - PUT /api/v1/admin/roles/{id}/permissions：ロールの権限更新

#### 主要メソッド
```java
@RestController
@RequestMapping("/api/v1/admin/roles")
public class RoleController {
    @Autowired
    private RoleService roleService;
    
    @Autowired
    private AuditLogService auditLogService;
    
    /**
     * 全てのロールを取得
     */
    @GetMapping
    public ResponseEntity<List<RoleResponse>> getAllRoles() {
        List<Role> roles = roleService.getAllRoles();
        List<RoleResponse> responseList = roles.stream()
            .map(RoleMapper::toResponse)
            .collect(Collectors.toList());
        
        return ResponseEntity.ok(responseList);
    }
    
    /**
     * ロールを作成
     */
    @PostMapping
    public ResponseEntity<RoleResponse> createRole(
            @Valid @RequestBody RoleCreateRequest request,
            Authentication authentication) {
        
        Role role = roleService.createRole(RoleMapper.toCreateDto(request));
        
        // 監査ログに記録
        auditLogService.log(AuditLogEntry.builder()
            .userId(getUserIdFromAuthentication(authentication))
            .action("ROLE_CREATE")
            .targetType("ROLE")
            .targetId(role.getId().toString())
            .details("Role created: " + role.getName())
            .build());
        
        return ResponseEntity.status(HttpStatus.CREATED)
            .body(RoleMapper.toResponse(role));
    }
    
    /**
     * ロールの権限を更新
     */
    @PutMapping("/{id}/permissions")
    public ResponseEntity<Void> updateRolePermissions(
            @PathVariable UUID id,
            @Valid @RequestBody RolePermissionUpdateRequest request,
            Authentication authentication) {
        
        roleService.assignPermissionsToRole(id, request.getPermissionIds());
        
        // 監査ログに記録
        auditLogService.log(AuditLogEntry.builder()
            .userId(getUserIdFromAuthentication(authentication))
            .action("ROLE_PERMISSIONS_UPDATE")
            .targetType("ROLE")
            .targetId(id.toString())
            .details("Role permissions updated, count: " + request.getPermissionIds().size())
            .build());
        
        return ResponseEntity.noContent().build();
    }
    
    // 他のエンドポイントメソッドも同様に実装
}
```

#### PermissionController
- **責務**：権限管理のRESTエンドポイントを提供
- **エンドポイント**：
  - GET /api/v1/admin/permissions：権限一覧取得
  - GET /api/v1/admin/permissions/{id}：権限詳細取得
  - POST /api/v1/admin/permissions：権限作成
  - PUT /api/v1/admin/permissions/{id}：権限更新
  - DELETE /api/v1/admin/permissions/{id}：権限削除

### 2.2 サービス

#### AuthorizationServiceImpl
- **責務**：認可ロジックの実装、AuthorizationServiceインターフェースの実装
- **主要メソッド**：
  - hasPermission：ユーザーの権限チェック
  - isAllowed：リソースアクセス権限チェック
  - hasRole：ロール所有チェック
  - getUserPermissions：ユーザーの権限取得
  - evaluateAccess：属性ベースのアクセス制御評価

```java
@Service
public class AuthorizationServiceImpl implements AuthorizationService {
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private RoleRepository roleRepository;
    
    @Autowired
    private PermissionRepository permissionRepository;
    
    @Autowired
    private ResourceRepository resourceRepository;
    
    @Autowired
    private PolicyEvaluator policyEvaluator;
    
    @Autowired
    private AuditLogService auditLogService;
    
    @Autowired
    private CacheManager cacheManager;
    
    @Override
    public boolean hasPermission(UUID userId, String permission) {
        // キャッシュから権限を取得（なければ計算）
        List<String> userPermissions = getUserPermissionsCached(userId);
        
        // 権限チェック
        boolean hasPermission = userPermissions.contains(permission);
        
        // 権限チェック結果を監査ログに記録
        auditLogService.logAuthorizationEvent(AuthorizationEvent.builder()
            .userId(userId)
            .resource("PERMISSION")
            .action(permission)
            .allowed(hasPermission)
            .reason(hasPermission ? "Permission granted" : "Permission denied")
            .build());
        
        return hasPermission;
    }
    
    @Override
    public boolean isAllowed(UUID userId, String resourceType, String resourceId, String action) {
        // ABAC評価を準備
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new ResourceNotFoundException("User not found"));
        
        Resource resource = null;
        if (resourceId != null) {
            resource = resourceRepository.findByTypeAndExternalId(resourceType, resourceId)
                .orElse(null);
        }
        
        // 主体（ユーザー）の準備
        Subject subject = new Subject(userId, buildUserAttributes(user));
        
        // リソースの準備
        Resource resourceObj = resource != null ? 
            new Resource(resourceType, resourceId, buildResourceAttributes(resource)) : 
            new Resource(resourceType, null, new HashMap<>());
        
        // アクションの準備
        Action actionObj = new Action(action, new HashMap<>());
        
        // 環境情報の準備
        Environment environment = new Environment(
            new Date(),
            "127.0.0.1", // 実際の実装ではリクエスト元IPを取得
            "web",
            new HashMap<>()
        );
        
        // ポリシー評価
        boolean allowed = evaluateAccess(subject, resourceObj, actionObj, environment);
        
        // 結果を監査ログに記録
        auditLogService.logAuthorizationEvent(AuthorizationEvent.builder()
            .userId(userId)
            .resource(resourceType + ":" + resourceId)
            .action(action)
            .allowed(allowed)
            .reason(allowed ? "Access allowed by policy" : "Access denied by policy")
            .build());
        
        return allowed;
    }
    
    @Override
    public boolean hasRole(UUID userId, String roleName) {
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new ResourceNotFoundException("User not found"));
        
        Role userRole = roleRepository.findById(user.getRoleId())
            .orElseThrow(() -> new ResourceNotFoundException("Role not found"));
        
        return userRole.getName().equals(roleName);
    }
    
    @Override
    @Cacheable(value = "userPermissions", key = "#userId")
    public List<Permission> getUserPermissions(UUID userId) {
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new ResourceNotFoundException("User not found"));
        
        Role role = roleRepository.findById(user.getRoleId())
            .orElseThrow(() -> new ResourceNotFoundException("Role not found"));
        
        return permissionRepository.findByRoleId(role.getId());
    }
    
    private List<String> getUserPermissionsCached(UUID userId) {
        // キャッシュから権限リストを取得または計算
        Cache cache = cacheManager.getCache("userPermissions");
        if (cache != null) {
            Cache.ValueWrapper wrapper = cache.get(userId);
            if (wrapper != null) {
                @SuppressWarnings("unchecked")
                List<String> permissions = (List<String>) wrapper.get();
                if (permissions != null) {
                    return permissions;
                }
            }
        }
        
        // キャッシュになければ権限を取得して変換
        List<Permission> permissions = getUserPermissions(userId);
        List<String> permissionNames = permissions.stream()
            .map(Permission::getName)
            .collect(Collectors.toList());
        
        // キャッシュに格納
        if (cache != null) {
            cache.put(userId, permissionNames);
        }
        
        return permissionNames;
    }
    
    @Override
    public boolean evaluateAccess(Subject subject, Resource resource, Action action, Environment environment) {
        // ポリシーエンジンによるアクセス評価
        return policyEvaluator.evaluate(subject, resource, action, environment);
    }
    
    private Map<String, Object> buildUserAttributes(User user) {
        Map<String, Object> attributes = new HashMap<>();
        attributes.put("department", user.getDepartment());
        attributes.put("position", user.getPosition());
        // その他の属性も追加
        return attributes;
    }
    
    private Map<String, Object> buildResourceAttributes(Resource resource) {
        Map<String, Object> attributes = new HashMap<>();
        attributes.put("owner", resource.getOwner());
        attributes.put("sensitivityLevel", resource.getSensitivityLevel());
        // その他の属性も追加
        return attributes;
    }
}
```

#### PolicyEvaluator
- **責務**：ポリシーベースのアクセス制御評価
- **主要メソッド**：
  - evaluate：アクセスポリシーの評価
  - loadPolicies：ポリシーの読み込み
  - evaluateCondition：条件式の評価

```java
@Component
public class PolicyEvaluator {
    @Autowired
    private PolicyRepository policyRepository;
    
    @Autowired
    private ExpressionEngine expressionEngine;
    
    /**
     * アクセスポリシーを評価する
     */
    public boolean evaluate(Subject subject, Resource resource, Action action, Environment environment) {
        // 関連するすべてのポリシーを取得
        List<Policy> applicablePolicies = loadPolicies(resource.getType(), action.getName());
        
        if (applicablePolicies.isEmpty()) {
            // デフォルトのポリシー（明示的なポリシーがない場合はアクセス拒否）
            return false;
        }
        
        // 評価コンテキストを準備
        Map<String, Object> context = new HashMap<>();
        context.put("subject", subject);
        context.put("resource", resource);
        context.put("action", action);
        context.put("environment", environment);
        
        // 各ポリシーを評価
        for (Policy policy : applicablePolicies) {
            // ポリシーの効果（許可/拒否）
            boolean effect = "ALLOW".equals(policy.getEffect());
            
            // 条件がない場合や条件評価が真の場合はポリシーを適用
            if (policy.getCondition() == null || 
                expressionEngine.evaluateCondition(policy.getCondition(), context)) {
                return effect;
            }
        }
        
        // 適用されるポリシーがない場合はデフォルトでアクセス拒否
        return false;
    }
    
    /**
     * リソースタイプとアクションに関連するポリシーを読み込む
     */
    private List<Policy> loadPolicies(String resourceType, String action) {
        return policyRepository.findByResourceTypeAndActionOrderByPriorityDesc(resourceType, action);
    }
}
```

#### RoleServiceImpl
- **責務**：ロール管理ロジックの実装
- **主要メソッド**：
  - createRole：ロール作成
  - updateRole：ロール更新
  - deleteRole：ロール削除
  - getRoleById：ロール取得
  - getAllRoles：全ロール取得
  - assignPermissionsToRole：ロールへの権限割り当て

```java
@Service
public class RoleServiceImpl implements RoleService {
    @Autowired
    private RoleRepository roleRepository;
    
    @Autowired
    private PermissionRepository permissionRepository;
    
    @Autowired
    private RolePermissionRepository rolePermissionRepository;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private CacheManager cacheManager;
    
    @Override
    public Role createRole(RoleCreateRequest createRequest) {
        // ロール名の一意性チェック
        if (roleRepository.existsByName(createRequest.getName())) {
            throw new DuplicateResourceException("Role with name " + createRequest.getName() + " already exists");
        }
        
        // ロールエンティティの作成
        Role role = new Role();
        role.setName(createRequest.getName());
        role.setDescription(createRequest.getDescription());
        role.setCreatedAt(LocalDateTime.now());
        role.setUpdatedAt(LocalDateTime.now());
        
        // ロールの保存
        Role savedRole = roleRepository.save(role);
        
        // 権限の割り当て（指定されている場合）
        if (createRequest.getPermissionIds() != null && !createRequest.getPermissionIds().isEmpty()) {
            assignPermissionsToRole(savedRole.getId(), createRequest.getPermissionIds());
        }
        
        return savedRole;
    }
    
    @Override
    public Role updateRole(UUID roleId, RoleUpdateRequest updateRequest) {
        // ロールの存在確認
        Role role = roleRepository.findById(roleId)
            .orElseThrow(() -> new ResourceNotFoundException("Role not found"));
        
        // ロール名の変更がある場合、一意性チェック
        if (!role.getName().equals(updateRequest.getName()) &&
            roleRepository.existsByName(updateRequest.getName())) {
            throw new DuplicateResourceException("Role with name " + updateRequest.getName() + " already exists");
        }
        
        // 情報の更新
        role.setName(updateRequest.getName());
        role.setDescription(updateRequest.getDescription());
        role.setUpdatedAt(LocalDateTime.now());
        
        // ロールの保存
        return roleRepository.save(role);
    }
    
    @Override
    public void deleteRole(UUID roleId) {
        // ロールの存在確認
        Role role = roleRepository.findById(roleId)
            .orElseThrow(() -> new ResourceNotFoundException("Role not found"));
        
        // ロールが使用中でないことを確認
        if (userRepository.countByRoleId(roleId) > 0) {
            throw new BusinessException("Cannot delete role that is assigned to users");
        }
        
        // ロール-権限関連の削除
        rolePermissionRepository.deleteByRoleId(roleId);
        
        // ロールの削除
        roleRepository.delete(role);
        
        // 関連するキャッシュの削除
        evictRoleCache(roleId);
    }
    
    @Override
    public void assignPermissionsToRole(UUID roleId, List<UUID> permissionIds) {
        // ロールの存在確認
        Role role = roleRepository.findById(roleId)
            .orElseThrow(() -> new ResourceNotFoundException("Role not found"));
        
        // 権限の存在確認
        List<Permission> permissions = permissionRepository.findAllById(permissionIds);
        if (permissions.size() != permissionIds.size()) {
            throw new ResourceNotFoundException("One or more permissions not found");
        }
        
        // 既存の権限関連をすべて削除
        rolePermissionRepository.deleteByRoleId(roleId);
        
        // 新しい権限関連を作成
        List<RolePermission> rolePermissions = new ArrayList<>();
        for (UUID permissionId : permissionIds) {
            RolePermission rolePermission = new RolePermission();
            rolePermission.setRoleId(roleId);
            rolePermission.setPermissionId(permissionId);
            rolePermission.setCreatedAt(LocalDateTime.now());
            rolePermissions.add(rolePermission);
        }
        
        // 権限関連の保存
        rolePermissionRepository.saveAll(rolePermissions);
        
        // このロールを持つユーザーの権限キャッシュを無効化
        evictUserPermissionCache(roleId);
    }
    
    @Override
    public List<Permission> getRolePermissions(UUID roleId) {
        // ロールの存在確認
        if (!roleRepository.existsById(roleId)) {
            throw new ResourceNotFoundException("Role not found");
        }
        
        // ロールの権限を取得
        return permissionRepository.findByRoleId(roleId);
    }
    
    /**
     * ロール関連のキャッシュを無効化する
     */
    private void evictRoleCache(UUID roleId) {
        Cache roleCache = cacheManager.getCache("roles");
        if (roleCache != null) {
            roleCache.evict(roleId);
        }
    }
    
    /**
     * このロールを持つユーザーの権限キャッシュを無効化する
     */
    private void evictUserPermissionCache(UUID roleId) {
        // このロールを持つすべてのユーザーを取得
        List<User> users = userRepository.findByRoleId(roleId);
        
        // 各ユーザーの権限キャッシュを無効化
        Cache userPermissionsCache = cacheManager.getCache("userPermissions");
        if (userPermissionsCache != null) {
            for (User user : users) {
                userPermissionsCache.evict(user.getId());
            }
        }
    }
    
    // 他のメソッドも同様に実装
}
```

### 2.3 リポジトリ

#### RoleRepository
- **責務**：ロールエンティティのデータアクセス
- **主要メソッド**：
  - findById：IDによるロール検索
  - findByName：名前によるロール検索
  - existsByName：ロール名の存在確認
  - save：ロール保存

```java
@Repository
public interface RoleRepository extends JpaRepository<Role, UUID> {
    Optional<Role> findByName(String name);
    
    boolean existsByName(String name);
    
    @Query("SELECT r FROM Role r ORDER BY r.name")
    List<Role> findAllOrderByName();
}
```

#### PermissionRepository
- **責務**：権限エンティティのデータアクセス
- **主要メソッド**：
  - findById：IDによる権限検索
  - findByName：名前による権限検索
  - findByRoleId：ロールIDによる権限検索

```java
@Repository
public interface PermissionRepository extends JpaRepository<Permission, UUID> {
    Optional<Permission> findByName(String name);
    
    @Query("SELECT p FROM Permission p JOIN RolePermission rp ON p.id = rp.permissionId " +
           "WHERE rp.roleId = :roleId")
    List<Permission> findByRoleId(@Param("roleId") UUID roleId);
    
    @Query("SELECT p FROM Permission p WHERE p.resourceType = :resourceType " +
           "AND p.action = :action")
    List<Permission> findByResourceTypeAndAction(
        @Param("resourceType") String resourceType,
        @Param("action") String action
    );
}
```

#### PolicyRepository
- **責務**：ポリシーエンティティのデータアクセス
- **主要メソッド**：
  - findByResourceTypeAndAction：リソースタイプとアクションによるポリシー検索
  - findByPriority：優先度によるポリシー検索

```java
@Repository
public interface PolicyRepository extends JpaRepository<Policy, UUID> {
    List<Policy> findByResourceTypeAndActionOrderByPriorityDesc(
        String resourceType,
        String action
    );
    
    List<Policy> findByPriorityGreaterThanOrderByPriorityAsc(int priority);
}
```

### 2.4 データモデル

#### Role
- ロールを表すエンティティ
- 属性：ID、ロール名、説明など

```java
@Entity
@Table(name = "roles")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;
    
    @Column(unique = true, nullable = false)
    private String name;
    
    @Column(length = 500)
    private String description;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    @Column(nullable = false)
    private LocalDateTime updatedAt;
    
    // getter/setter、equals/hashCode、toString
}
```

#### Permission
- 権限を表すエンティティ
- 属性：ID、権限名、説明、リソース種別、アクションなど

```java
@Entity
@Table(name = "permissions")
public class Permission {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;
    
    @Column(unique = true, nullable = false)
    private String name;
    
    @Column(length = 500)
    private String description;
    
    @Column(nullable = false)
    private String resourceType;
    
    @Column(nullable = false)
    private String action;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    @Column(nullable = false)
    private LocalDateTime updatedAt;
    
    // getter/setter、equals/hashCode、toString
}
```

#### RolePermission
- ロールと権限の多対多関連を表すエンティティ
- 属性：ロールID、権限ID、作成日時

```java
@Entity
@Table(name = "role_permissions")
@IdClass(RolePermissionId.class)
public class RolePermission {
    @Id
    @Column(name = "role_id")
    private UUID roleId;
    
    @Id
    @Column(name = "permission_id")
    private UUID permissionId;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    // getter/setter、equals/hashCode、toString
}

// 複合主キーを表すクラス
public class RolePermissionId implements Serializable {
    private UUID roleId;
    private UUID permissionId;
    
    // コンストラクタ、equals/hashCode
}
```

#### Policy
- アクセスポリシーを表すエンティティ
- 属性：ID、リソース種別、アクション、効果（許可/拒否）、条件式など

```java
@Entity
@Table(name = "policies")
public class Policy {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(length = 500)
    private String description;
    
    @Column(nullable = false)
    private String resourceType;
    
    @Column(nullable = false)
    private String action;
    
    // "ALLOW" または "DENY"
    @Column(nullable = false)
    private String effect;
    
    // 優先度（大きいほど優先）
    @Column(nullable = false)
    private int priority;
    
    // 条件式（SPEL形式）
    @Column(length = 1000)
    private String condition;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    @Column(nullable = false)
    private LocalDateTime updatedAt;
    
    // getter/setter、equals/hashCode、toString
}
```

## 3. 主要処理フロー

### 3.1 認可チェックフロー

1. クライアントがリソースに対するアクセスをリクエスト
2. JwtAuthenticationFilterが認証情報を抽出・設定
3. API/メソッドレベルで@PreAuthorizeアノテーションによる権限チェック
4. BusinessServiceクラスが必要に応じてAuthorizationServiceを呼び出し
5. AuthorizationServiceがユーザーの権限をチェック
6. ポリシーに基づいてアクセス可否を判定
7. 判定結果を監査ログに記録
8. アクセス可の場合は処理を続行、アクセス拒否の場合は例外をスロー

```
sequenceDiagram
    Client->>Controller: APIリクエスト
    Controller->>SecurityInterceptor: 処理
    SecurityInterceptor->>@PreAuthorize: 評価
    @PreAuthorize->>AuthorizationServiceImpl: hasPermission(userId, permission)
    
    AuthorizationServiceImpl->>CacheManager: 権限キャッシュ取得
    
    alt キャッシュHit
        CacheManager-->>AuthorizationServiceImpl: キャッシュデータ
    else キャッシュMiss
        AuthorizationServiceImpl->>UserRepository: findById(userId)
        UserRepository-->>AuthorizationServiceImpl: User
        
        AuthorizationServiceImpl->>RoleRepository: findById(user.getRoleId())
        RoleRepository-->>AuthorizationServiceImpl: Role
        
        AuthorizationServiceImpl->>PermissionRepository: findByRoleId(roleId)
        PermissionRepository-->>AuthorizationServiceImpl: Permissions
        
        AuthorizationServiceImpl->>CacheManager: 権限をキャッシュ
    end
    
    AuthorizationServiceImpl->>AuthorizationServiceImpl: 権限チェック
    AuthorizationServiceImpl->>AuditLogService: logAuthorizationEvent()
    
    alt 権限あり
        AuthorizationServiceImpl-->>@PreAuthorize: true
        @PreAuthorize-->>SecurityInterceptor: アクセス許可
        SecurityInterceptor-->>Controller: 処理継続
        Controller-->>Client: 200 OK + リソース
    else 権限なし
        AuthorizationServiceImpl-->>@PreAuthorize: false
        @PreAuthorize-->>SecurityInterceptor: アクセス拒否
        SecurityInterceptor-->>Client: 403 Forbidden
    end
```

### 3.2 ポリシー評価フロー

1. AuthorizationServiceが属性ベースのアクセス制御を要求
2. 主体（ユーザー）、リソース、アクション、環境情報を取得・構築
3. PolicyEvaluatorに評価を依頼
4. 適用可能なポリシーをデータベースから取得
5. 優先度順にポリシーを評価
6. 条件式をExpressionEngineで評価
7. 条件に合致する最初のポリシーの効果（許可/拒否）を適用
8. 評価結果を返却

```
sequenceDiagram
    AuthorizationServiceImpl->>PolicyEvaluator: evaluate(subject, resource, action, environment)
    PolicyEvaluator->>PolicyRepository: findByResourceTypeAndActionOrderByPriorityDesc()
    PolicyRepository-->>PolicyEvaluator: List<Policy>
    
    PolicyEvaluator->>PolicyEvaluator: 評価コンテキスト準備
    
    loop 各ポリシーを優先度順に評価
        PolicyEvaluator->>ExpressionEngine: evaluateCondition(condition, context)
        ExpressionEngine-->>PolicyEvaluator: 条件評価結果
        
        alt 条件に合致
            PolicyEvaluator-->>AuthorizationServiceImpl: ポリシーの効果（許可/拒否）
        end
    end
    
    alt 合致するポリシーがない
        PolicyEvaluator-->>AuthorizationServiceImpl: デフォルト結果（拒否）
    end
    
    AuthorizationServiceImpl->>AuditLogService: logAuthorizationEvent()
```

### 3.3 ロール・権限管理フロー

1. 管理者がロール管理APIを呼び出し
2. RoleControllerがリクエストを受け取る
3. RoleServiceがロール情報を検証・処理
4. 操作結果を監査ログに記録
5. 必要に応じてキャッシュを無効化
6. 結果をクライアントに返却

```
sequenceDiagram
    Client->>RoleController: POST /api/v1/admin/roles
    RoleController->>RoleServiceImpl: createRole(request)
    
    RoleServiceImpl->>RoleRepository: existsByName(name)
    RoleRepository-->>RoleServiceImpl: boolean
    
    alt 名前重複
        RoleServiceImpl-->>RoleController: throw DuplicateResourceException
        RoleController-->>Client: 409 Conflict
    else 名前OK
        RoleServiceImpl->>RoleRepository: save(role)
        RoleRepository-->>RoleServiceImpl: savedRole
        
        alt 権限指定あり
            RoleServiceImpl->>PermissionRepository: findAllById(permissionIds)
            PermissionRepository-->>RoleServiceImpl: permissions
            
            RoleServiceImpl->>RolePermissionRepository: saveAll(rolePermissions)
        end
        
        RoleServiceImpl-->>RoleController: Role
        RoleController->>AuditLogService: log()
        RoleController-->>Client: 201 Created + Role
    end
```

### 3.4 権限キャッシュ更新フロー

1. ロールに対する権限変更が発生
2. RoleServiceがロールへの権限割り当てを処理
3. 既存の権限関連を削除
4. 新しい権限関連を保存
5. このロールを持つすべてのユーザーの権限キャッシュを無効化
6. 必要に応じてロールキャッシュも無効化

```
sequenceDiagram
    Client->>RoleController: PUT /api/v1/admin/roles/{id}/permissions
    RoleController->>RoleServiceImpl: assignPermissionsToRole(id, permissionIds)
    
    RoleServiceImpl->>RoleRepository: findById(roleId)
    RoleRepository-->>RoleServiceImpl: Role
    
    RoleServiceImpl->>PermissionRepository: findAllById(permissionIds)
    PermissionRepository-->>RoleServiceImpl: List<Permission>
    
    RoleServiceImpl->>RolePermissionRepository: deleteByRoleId(roleId)
    RoleServiceImpl->>RolePermissionRepository: saveAll(rolePermissions)
    
    RoleServiceImpl->>UserRepository: findByRoleId(roleId)
    UserRepository-->>RoleServiceImpl: List<User>
    
    loop 各ユーザーのキャッシュ無効化
        RoleServiceImpl->>CacheManager: userPermissionsCache.evict(userId)
    end
    
    RoleServiceImpl->>CacheManager: roleCache.evict(roleId)
    
    RoleServiceImpl-->>RoleController: 完了
    RoleController->>AuditLogService: log()
    RoleController-->>Client: 204 No Content
```

## 4. 例外処理

### 4.1 認可例外階層

```java
// 基底例外クラス
public class AuthorizationException extends RuntimeException {
    private final AuthorizationErrorCode errorCode;
    
    public AuthorizationException(AuthorizationErrorCode errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }
    
    public AuthorizationErrorCode getErrorCode() {
        return errorCode;
    }
}

// エラーコード
public enum AuthorizationErrorCode {
    ACCESS_DENIED,          // アクセス拒否
    INSUFFICIENT_PRIVILEGES,// 権限不足
    INVALID_ROLE,           // 無効ロール
    RESOURCE_ACCESS_DENIED, // リソースアクセス拒否
    POLICY_EVALUATION_ERROR // ポリシー評価エラー
}
```

### 4.2 グローバル例外ハンドラー

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(AuthorizationException.class)
    public ResponseEntity<ErrorResponse> handleAuthorizationException(AuthorizationException ex) {
        HttpStatus status;
        
        // エラーコードごとに適切なHTTPステータスを設定
        switch (ex.getErrorCode()) {
            case ACCESS_DENIED:
            case INSUFFICIENT_PRIVILEGES:
            case RESOURCE_ACCESS_DENIED:
                status = HttpStatus.FORBIDDEN;
                break;
            case INVALID_ROLE:
                status = HttpStatus.BAD_REQUEST;
                break;
            case POLICY_EVALUATION_ERROR:
                status = HttpStatus.INTERNAL_SERVER_ERROR;
                break;
            default:
                status = HttpStatus.INTERNAL_SERVER_ERROR;
        }
        
        // エラーレスポンスを生成
        ErrorResponse errorResponse = new ErrorResponse(
            ex.getErrorCode().name(),
            ex.getMessage()
        );
        
        return new ResponseEntity<>(errorResponse, status);
    }
    
    // その他の例外ハンドラーも実装
}
```

## 5. セキュリティ対策

### 5.1 権限管理のセキュリティ

- **最小権限の原則**: ユーザーには職務遂行に必要な最小限の権限のみを付与
- **職務分掌原則**: 不正行為防止のため、重要な操作の権限を適切に分離
- **権限変更監査**: すべての権限変更を監査ログに記録し、追跡可能にする
- **権限管理者の制限**: 権限管理機能へのアクセスを厳密に制限

### 5.2 認可ポリシーのセキュリティ

- **デフォルト拒否**: 明示的に許可されていないアクセスはすべて拒否（Deny by default）
- **多層防御**: アプリケーション層、サービス層、データアクセス層での認可チェック
- **動的ポリシー評価**: コンテキスト（時間、場所など）に基づく柔軟なアクセス制御
- **ポリシー変更監査**: ポリシー変更の全履歴を記録・追跡

### 5.3 実装上のセキュリティ

- **権限チェック抜け防止**: AOP（アスペクト指向プログラミング）による権限チェックの強制
- **サイドチャネル攻撃対策**: 認可判定の処理時間が権限情報を漏らさないよう配慮
- **権限情報の漏洩防止**: エラーメッセージによる権限情報の漏洩を防止
- **認可バイパス対策**: フロントエンド・バックエンド両方での一貫した認可チェック

## 6. 特記事項

### 6.1 実装上の注意点

- **パフォーマンスと権限更新の即時反映のバランス**: キャッシュの適切な管理が重要
- **ポリシー設計の簡潔性**: 複雑すぎるポリシーは管理・デバッグが困難になる
- **権限設計の粒度**: 細かすぎる権限設計は管理コストを増大させる
- **スコープベースの権限設計**: リソース所有者や部署に基づくスコープ制限の実装

### 6.2 パフォーマンス考慮点

- **権限キャッシュ**: ユーザー権限をキャッシュしてデータベースアクセスを削減
- **ポリシー評価の最適化**: 頻繁に使用されるポリシーを優先的に評価
- **バッチ権限チェック**: 複数リソースの権限を一括でチェックする機能
- **クエリの最適化**: 権限・ロール・ポリシーに関するデータベースクエリの最適化

### 6.3 テストの観点

- **認可ルールの単体テスト**: 各認可ルールの正確性を個別にテスト
- **ポリシー評価の単体テスト**: ポリシー評価エンジンの正確性をテスト
- **権限管理機能の統合テスト**: ロール・権限管理APIの一貫性テスト
- **セキュリティテスト**: 認可バイパス攻撃に対する耐性テスト

## 7. 参照情報

- [Spring Security Authorization Documentation](https://docs.spring.io/spring-security/reference/servlet/authorization/index.html)
- [OWASP Authorization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html)
- [NIST Guide to Attribute Based Access Control (ABAC)](https://nvlpubs.nist.gov/nistpubs/specialpublications/NIST.sp.800-162.pdf)
- [XACML (eXtensible Access Control Markup Language)](https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=xacml)