# エラー処理機能 - 例外ハンドリング

## バージョン管理
| バージョン | 日付 | 更新者 | 更新内容 |
|----------|------|-------|---------|
| 0.1 | 2025-05-10 | 設計担当者 | 初版作成 |
| 0.2 | 2025-05-11 | 設計担当者 | 実装コード削除による軽量化 |

## 1. 機能概要

例外ハンドリング機能は、SES業務システム全体での統一的かつ一貫性のある例外処理を実現します。アプリケーション内で発生するさまざまな例外を適切に変換し、意味のあるフィードバックをクライアントに提供すると同時に、開発者や運用担当者が問題を迅速に特定して対応するための情報を記録します。

## 2. 主要コンポーネント構成

例外ハンドリング機能は以下のコンポーネントで構成されます：

### 2.1 コンポーネント構成図

```
                           ┌─────────────────────┐
                           │ GlobalExceptionHandler │
                           └───────────┬───────────┘
                                       │
                                       ▼
┌────────────────────┐   ┌──────────────────────────┐   ┌────────────────┐
│ ErrorResponseBuilder │◄──┤ ExceptionHandlingService │──►│ ErrorLogger    │
└────────────────────┘   └──────────────┬───────────┘   └────────────────┘
                                        │
                                        ▼
                         ┌─────────────────────────┐
                         │ ErrorCodeRegistry       │
                         └─────────────────────────┘
```

### 2.2 コンポーネント説明

- **GlobalExceptionHandler**: Web/API層で発生する例外を一元的に捕捉して処理するコンポーネント
- **ExceptionHandlingService**: 例外の変換と処理のための中核サービス
- **ErrorResponseBuilder**: エラーレスポンスを構築するユーティリティ
- **ErrorLogger**: エラー情報のログ記録を担当するコンポーネント
- **ErrorCodeRegistry**: エラーコードの管理と参照を担当するサービス

## 3. 例外階層構造

SES業務システムでは、以下の階層構造で例外を設計します：

```
java.lang.Throwable
   │
   ├── java.lang.Exception
   │      │
   │      └── java.lang.RuntimeException
   │             │
   │             └── BaseException (基底アプリケーション例外)
   │                    │
   │                    ├── ValidationException (検証例外)
   │                    │
   │                    ├── BusinessException (業務例外)
   │                    │
   │                    ├── SystemException (システム例外)
   │                    │
   │                    ├── SecurityException (セキュリティ例外)
   │                    │
   │                    └── ResourceException (抽象リソース例外)
   │                           │
   │                           ├── ResourceNotFoundException (リソース未検出例外)
   │                           │
   │                           └── ResourceAlreadyExistsException (リソース重複例外)
   │
   └── java.lang.Error
```

## 4. 例外ハンドリングフロー

### 4.1 Web/APIレイヤーでの例外ハンドリングフロー

1. クライアントからリクエストを受信
2. コントローラ・サービス・リポジトリなどの処理過程で例外が発生
3. 発生した例外がGlobalExceptionHandlerによって捕捉される
4. 例外の種類に応じた適切なハンドラメソッドが選択される
5. ExceptionHandlingServiceを用いて例外情報を処理
6. ErrorLoggerを利用してエラー情報をログに記録
7. ErrorResponseBuilderを使用してクライアント向けのエラーレスポンスを構築
8. 適切なHTTPステータスコードと共にエラーレスポンスをクライアントに返却

### 4.2 ビジネスロジックレイヤーでの例外ハンドリングフロー

1. 業務ロジック内でビジネスルール違反を検出
2. ExceptionHandlingServiceを利用して適切な種類のビジネス例外を生成
3. 例外をスローしてフローを中断
4. 上位レイヤーに例外が伝搬
5. 最終的にGlobalExceptionHandlerで捕捉されるか、トランザクション管理機能と連携してロールバック

### 4.3 インフラストラクチャレイヤーでの例外ハンドリングフロー

1. データベースアクセスやマイクロサービス呼び出しなどで技術的例外が発生
2. 発生した技術的例外を捕捉
3. ExceptionHandlingServiceを用いて技術的例外をアプリケーション例外（SystemExceptionなど）に変換
4. 変換した例外をスローして上位レイヤーに伝搬
5. 最終的にGlobalExceptionHandlerで捕捉

## 5. HTTPステータスコードとエラーレスポンスの対応

### 5.1 HTTPステータスコードの対応表

| 例外クラス | HTTPステータスコード | 説明 |
|----------|-------------------|------|
| ValidationException | 400 Bad Request | クライアントからの入力値の検証エラー |
| BusinessException | 422 Unprocessable Entity | ビジネスルール違反などの業務的なエラー |
| SecurityException | 403 Forbidden | 認可エラーなどのセキュリティ制約違反 |
| ResourceNotFoundException | 404 Not Found | 要求されたリソースが存在しない |
| ResourceAlreadyExistsException | 409 Conflict | 既存のリソースと競合する操作 |
| SystemException | 500 Internal Server Error | システム内部エラー |
| その他の未処理例外 | 500 Internal Server Error | その他のシステムエラー |

### 5.2 エラーレスポンス形式

API呼び出し時のエラーレスポンスは、以下のような統一された形式でJSONとして返却します：

```json
{
  "status": "error",
  "errorCode": "E-01101",
  "errorType": "VALIDATION",
  "message": "入力値「ユーザー名」は必須項目です。",
  "details": [
    {
      "field": "username",
      "message": "ユーザー名は必須項目です",
      "code": "NotBlank",
      "rejectedValue": ""
    }
  ],
  "timestamp": "2025-05-10T10:15:30+09:00",
  "requestId": "req-123456",
  "path": "/api/users",
  "traceId": "trace-789012"
}
```

### 5.3 環境別の情報開示制御

エラーレスポンスの内容は、実行環境に応じて適切に制御します：

| 情報項目 | 開発環境 | ステージング環境 | 本番環境 |
|---------|---------|---------------|---------|
| エラーコード | ○ | ○ | ○ |
| エラーメッセージ | ○ | ○ | ○ |
| 詳細情報 | ○ | ○ | ○（機密情報を除く） |
| 原因例外 | ○ | ○ | × |
| スタックトレース | ○ | × | × |
| トレースID | ○ | ○ | ○ |
| タイムスタンプ | ○ | ○ | ○ |

## 6. トランザクション管理との連携

### 6.1 例外の種類とトランザクション動作の対応

| 例外の種類 | トランザクション動作 | 説明 |
|----------|------------------|------|
| ValidationException | ロールバック | 入力検証エラーは処理を中断し、トランザクションをロールバック |
| BusinessException | ロールバック | ビジネスルール違反はトランザクションをロールバック |
| SystemException | ロールバック | システムエラーは常にトランザクションをロールバック |
| SecurityException | ロールバック | セキュリティエラーは常にトランザクションをロールバック |
| ResourceNotFoundException | 状況による | read-onlyの場合は継続、更新操作の場合はロールバック |
| チェック例外 | コミット | 特別に@Transactional(rollbackFor)で指定しない限りコミット |

### 6.2 分散トランザクションでの例外ハンドリング

複数のサービスやマイクロサービスにまたがる分散トランザクションでは、以下の原則に従います：

1. **Try-Confirm-Cancel（TCC）パターン**: 
   - 各サービスで準備（Try）操作を実行
   - 成功した場合は確定（Confirm）操作を実行
   - 失敗した場合は取り消し（Cancel）操作を実行

2. **補償トランザクション**:
   - 処理の途中で例外が発生した場合、それまでに成功した操作の補償処理を実行
   - 補償処理の状態も管理し、最終的な整合性を確保

3. **Saga パターン**:
   - 長期実行トランザクションを複数の小さなトランザクションに分割
   - 各ステップに対応する補償処理を定義
   - 例外発生時は逆順に補償処理を実行

## 7. 例外処理ベストプラクティス

### 7.1 例外ハンドリングのガイドライン

1. **例外の適切な層での処理**:
   - 技術的な例外（SQLException等）はインフラストラクチャ層で捕捉し、アプリケーション例外に変換
   - ビジネスロジック層では業務例外をスロー
   - プレゼンテーション層では未処理例外を捕捉してユーザーフレンドリーなメッセージを表示

2. **例外のログ記録**:
   - ValidationException: INFO レベルでログ記録
   - BusinessException: WARN レベルでログ記録
   - SystemException: ERROR レベルでログ記録
   - SecurityException: WARN または ERROR レベルでログ記録（状況による）

3. **例外メッセージの作成**:
   - ユーザー向けメッセージは明確で簡潔に
   - 機密情報（SQL文、パスワード、個人情報など）を含めない
   - 技術的な詳細は開発者向けのログにのみ記録

### 7.2 例外テスト戦略

1. **例外発生のテスト**:
   - 各種例外が適切な状況で発生することを確認
   - モックを使用して技術的例外の発生をシミュレート

2. **例外変換のテスト**:
   - 技術的例外が適切なアプリケーション例外に変換されることを確認
   - 変換後の例外に必要な情報が含まれていることを検証

3. **エラーレスポンスのテスト**:
   - 各種例外に対して適切なHTTPステータスコードとエラーレスポンスが返されることを確認
   - 環境別の情報開示制御が正しく機能することを検証

## 8. 国際化（i18n）対応

### 8.1 エラーメッセージの国際化

エラーメッセージは以下の方法で国際化に対応します：

1. **メッセージリソースファイルの準備**:
   - 各言語ごとに messages_xx.properties ファイルを用意
   - エラーコードをキーとして各言語のメッセージを定義

2. **ロケール解決**:
   - リクエストヘッダーの Accept-Language を基にロケールを解決
   - ユーザー設定のロケール情報が存在する場合はそれを優先

3. **メッセージ解決と置換**:
   - MessageSource を使用して対応するメッセージを取得
   - プレースホルダーをエラーパラメータで置換

### 8.2 多言語対応エラーページ

エラーページも多言語対応とし、以下の方法で実現します：

1. **テンプレートの多言語化**:
   - Thymeleaf や FreeMarker などのテンプレートエンジンで多言語対応
   - メッセージキーを使用してコンテンツを動的に切り替え

2. **言語選択UI**:
   - エラーページに言語切り替えのUIを用意
   - 言語切り替え時にはロケールをセッションまたはCookieに保存