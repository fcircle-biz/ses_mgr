# アプリケーションログ機能

## 1. 機能概要

アプリケーションログ機能は、システムの動作状況、警告、エラーなどの情報を構造化されたフォーマットで記録する機能です。すべてのモジュールから利用される基本的なロギング機能であり、システムの監視、障害調査、動作検証などに活用されます。

### 1.1 機能の目的

- システム動作状況の可視化と監視
- 例外発生時のエラー情報の詳細記録
- トラブルシューティングのための情報収集
- アプリケーションの動作証跡の保持
- システムの健全性確認

### 1.2 主要機能

- 異なるログレベル（ERROR, WARN, INFO, DEBUG, TRACE）での出力制御
- 構造化ログフォーマット（JSON）による出力
- コンテキスト情報の自動付加
- 例外情報の詳細記録
- ログローテーションと保持期間管理
- 環境別ログ設定の切り替え

## 2. 処理フロー

### 2.1 ログ出力の基本フロー

```
1. アプリケーションコード内でロガーインスタンスを取得
2. 適切なログレベルでメソッドを呼び出し
3. ログレベルのフィルタリング（無効なレベルの場合は処理終了）
4. MDC（Mapped Diagnostic Context）からコンテキスト情報を取得
5. ログメッセージの整形
6. アペンダーによるログの出力（ファイル、コンソールなど）
7. 非同期処理の場合はキューに投入
```

### 2.2 ログ初期化フロー

```
1. アプリケーション起動時にLogback設定ファイルを読み込み
2. 環境変数またはシステムプロパティから設定値を解決
3. アペンダーの初期化（ファイル、コンソール、その他）
4. フィルターの設定
5. デフォルトMDC値の設定
6. 非同期アペンダーの初期化（使用する場合）
7. ロガーツリーの構成
```

### 2.3 例外ログ記録フロー

```
1. try-catchブロックでの例外捕捉
2. LoggingFacadeのerrorメソッド呼び出し
3. エラー処理モジュールと連携して例外情報を強化
4. スタックトレースの整形と記録
5. エラーコードと関連情報の付加
6. 構造化フォーマットでログ出力
```

## 3. 主要コンポーネント構成

### 3.1 LoggingFacadeImpl クラス

LoggingFacadeインターフェースの実装クラスで、SLF4J APIをラップしています。

#### 主要責務
- SLF4J Loggerインスタンスのラッピング
- ログレベルごとのメソッド提供（error, warn, info, debug, trace）
- 例外付きログ出力の最適化
- MDC（Mapped Diagnostic Context）の操作
- ログマーカーによるカテゴリ分け
- ログ出力前のレベルチェックによる最適化

#### 主要メソッド
- `error(String message, Object... args)` - エラーレベルのログ出力
- `error(String message, Throwable t, Object... args)` - 例外情報付きエラーログ出力
- `warn(String message, Object... args)` - 警告レベルのログ出力
- `info(String message, Object... args)` - 情報レベルのログ出力
- `debug(String message, Object... args)` - デバッグレベルのログ出力
- `trace(String message, Object... args)` - トレースレベルのログ出力
- `isEnabled(LogLevel level)` - 指定レベルのログ出力が有効かを判定
- `putMdc(String key, String value)` - MDCにコンテキスト情報を設定
- `removeMdc(String key)` - MDCからコンテキスト情報を削除
- `withMarker(LoggingMarker marker)` - 指定マーカー付きのロガーを取得

### 3.2 LoggingFactoryImpl クラス

LoggingFacadeインスタンスを生成するファクトリークラスです。

#### 主要責務
- LoggingFacadeインスタンスの生成と管理
- ロガー名に基づくインスタンス提供
- クラスベースのロガー名解決
- 呼び出し元クラスの自動検出

#### 主要メソッド
- `getInstance()` - シングルトンインスタンスの取得
- `getLogger()` - 呼び出し元クラスに基づくロガーの取得
- `getLogger(Class<?> clazz)` - 指定クラスに基づくロガーの取得
- `getLogger(String name)` - 指定名に基づくロガーの取得

### 3.3 LoggingMarkerFactory クラス

ログマーカーを生成・管理するファクトリークラスです。

#### 主要責務
- ログマーカーの生成と管理
- 標準マーカーの提供（AUDIT, PERFORMANCE, SECURITY, BUSINESS, EXTERNAL）
- マーカー階層の構築
- マーカーキャッシュの提供

#### 主要メソッド
- `getMarker(String name)` - 指定名のマーカーを取得または生成
- `getMarker(String name, LoggingMarker parent)` - 親マーカー付きで取得または生成

### 3.4 LoggingAutoConfiguration クラス

Spring Boot環境での自動設定を行うクラスです。

#### 主要責務
- Spring環境でのロギング機能の自動設定
- コンポーネント登録と依存関係解決
- 標準ロガーのBean定義
- プロパティからの設定値読み込み

#### 主要Bean定義
- `loggingFactory()` - LoggingFactoryのBean定義
- `systemLogger()` - システムロガーのBean定義
- `applicationLogger()` - アプリケーションロガーのBean定義
- `securityLogger()` - セキュリティロガーのBean定義

### 3.5 LoggingProperties クラス

ロギング機能の設定プロパティクラスです。

#### 主要プロパティ
- `defaultLevel` - デフォルトのログレベル
- `jsonFormat` - JSON形式でログ出力するかどうか
- `asyncLogging` - 非同期ロギングを使用するかどうか
- `includeCallerData` - 呼び出し元情報を含めるかどうか
- `applicationName` - アプリケーション名
- `environmentName` - 環境名（dev/test/prod）
- `mdc` - MDCに自動的に含める項目の設定
- `fileLogging` - ファイルログの設定

## 4. 設定詳細

### 4.1 Logback設定ファイル

Spring Bootアプリケーションでは、`logback-spring.xml`ファイルを使用して詳細な設定を行います。主な設定内容は以下の通りです：

- プロパティ定義（環境変数またはシステムプロパティから取得）
- コンソールアペンダーの設定
- JSONファイルアペンダーの設定
- 非同期アペンダーの設定
- 環境別ロガー設定（development, test, production）
- ロガーレベルの階層設定
- デフォルト設定

### 4.2 アプリケーションプロパティでの設定

Spring Bootアプリケーションの`application.yml`ファイルでロギング機能を設定できます。主な設定項目は以下の通りです：

- ログレベル設定
- JSON形式出力設定
- 非同期ロギング設定
- コンテキスト情報設定
- ファイルローテーション設定
- 環境別設定
- パッケージ別ログレベル設定

## 5. 使用例

### 5.1 基本的なログ出力

```
// ロガーの取得
private static final LoggingFacade logger = LoggingFactory.getInstance().getLogger(SampleService.class);

// INFOレベルのログ出力
logger.info("処理を開始します: id={}", id);

// 例外情報付きエラーログ
try {
    // 処理ロジック
} catch (Exception e) {
    logger.error("処理中にエラーが発生しました: id={}", id, e);
    throw e;
}

// 条件付きログ出力（パフォーマンス最適化）
if (logger.isEnabled(LogLevel.DEBUG)) {
    logger.debug("詳細情報: {}", buildDetailedInfo());
}
```

### 5.2 MDCを利用したコンテキスト情報の付加

```
// MDCにコンテキスト情報を設定
logger.putMdc("transactionId", transactionId)
      .putMdc("userId", userId);

try {
    // ビジネスロジック実行（ログ出力時に自動的にMDC情報が付加される）
    logger.info("トランザクション処理開始");
    processTransaction();
    logger.info("トランザクション処理完了");
} finally {
    // MDCのクリーンアップ
    logger.removeMdc("transactionId")
          .removeMdc("userId");
}
```

### 5.3 マーカーを使用したログのカテゴリ分け

```
// 標準マーカーを使用したロガー取得
LoggingFacade businessLogger = logger.withMarker(LoggingMarkerFactory.BUSINESS);
LoggingFacade securityLogger = logger.withMarker(LoggingMarkerFactory.SECURITY);

// ビジネスイベントのログ出力
businessLogger.info("注文処理を開始します: 注文ID={}", orderId);

// セキュリティイベントのログ出力
securityLogger.warn("パスワード変更が実行されました: ユーザーID={}", userId);

// 外部連携処理のログ出力
logger.withMarker(LoggingMarkerFactory.EXTERNAL)
      .info("外部システムへのリクエスト送信: URL={}", url);
```

### 5.4 Spring Bootでの依存注入によるロガー取得

```
// コンストラクタ注入でのロガー取得
@Service
public class CustomerService {
    private final LoggingFacade logger;
    
    public CustomerService(LoggingFactory loggingFactory) {
        this.logger = loggingFactory.getLogger(CustomerService.class);
    }
    
    public void processCustomer(Customer customer) {
        logger.info("顧客処理開始: ID={}, 名前={}", customer.getId(), customer.getName());
        // 処理ロジック
    }
}

// 名前付きBeanの注入
@Service
public class AdminService {
    private final LoggingFacade securityLogger;
    
    public AdminService(@Qualifier("securityLogger") LoggingFacade securityLogger) {
        this.securityLogger = securityLogger;
    }
    
    public void adminOperation(String adminId, String operation) {
        securityLogger.info("管理者操作実行: 管理者ID={}, 操作={}", adminId, operation);
        // 処理ロジック
    }
}
```

## 6. 例外処理

### 6.1 一般的な例外ハンドリング

ログ出力中の例外は基本的にキャッチして上位に伝播させません。ロギング処理の失敗がビジネスロジックに影響を与えないようにします。ただし、初期化時の例外は起動失敗として扱います。

例外ハンドリングの基本方針は以下の通りです：

- ロギング自体の例外はキャッチして抑制
- 初期化時の例外は適切に処理（起動時の例外として伝播）
- ロギング失敗時の最終手段としての標準エラー出力
- 複数のアペンダーを使用する場合の例外分離

### 6.2 非同期ロギングの例外処理

非同期処理の場合、例外は別スレッドで発生するため、適切なエラーハンドラを設定します。主なポイントは以下の通りです：

- 非同期アペンダーの設定（キューサイズ、破棄しきい値）
- 非同期処理中の例外キャッチ
- メインスレッドへの例外伝播防止
- ロギング失敗時のリカバリ戦略

### 6.3 ディスク容量不足時の対応

ディスク容量不足などでログ書き込みができない場合の対策を実装します。実装ポイントは以下の通りです：

- ディスク空き容量チェックフィルタの適用
- 書き込み失敗時の代替ストラテジー
- 重要ログの優先的な保存
- アラート通知の実装

### 6.4 リソース管理と解放

ロギングコンポーネントのリソース管理と適切な解放を実装します。主なポイントは以下の通りです：

- アプリケーション終了時のクリーンアップ処理
- MDCのクリア処理
- ロギングコンテキストの適切なシャットダウン
- ファイルハンドルの解放

## 7. パフォーマンス考慮事項

### 7.1 非同期ロギングの活用

パフォーマンスへの影響を最小限に抑えるため、非同期ロギングを推奨します。特に大量のログ出力が予想される場面では重要です。主なポイントは以下の通りです：

- AsyncAppenderの適切な設定
- キューサイズと破棄ポリシーの最適化
- 非同期I/Oの活用
- バッファ戦略の検討

### 7.2 条件付きログ出力

不要なログ処理コストを削減するため、コストの高いログ出力は条件チェックを行います。主なポイントは以下の通りです：

- `isEnabled()`を使用した条件チェック
- 高コストな文字列連結やオブジェクト生成の最適化
- ランタイムレベルに基づく処理分岐
- デバッグログの条件化

### 7.3 ログレベルの適切な使い分け

本番環境では必要なログレベルのみを有効にし、パフォーマンスを最適化します。環境別の設定ポイントは以下の通りです：

- 開発環境：DEBUG以上
- テスト環境：INFO以上
- 本番環境：WARN以上（必要に応じてINFO）
- 障害調査時：必要な範囲で一時的にDEBUGを有効化

### 7.4 バッファサイズの最適化

非同期アペンダーのキューサイズやバッファサイズを適切に設定します。設定ポイントは以下の通りです：

- キューサイズ：256-1024が一般的な範囲
- 破棄しきい値：キューの80%が埋まった時点で優先度の低いログを破棄
- バッファフラッシュ間隔の調整
- メモリ使用量と処理遅延のバランス調整

## 8. バージョン履歴

| バージョン | 更新日     | 担当者    | 変更内容                                |
|----------|------------|---------|--------------------------------------|
| 0.1      | 2023/10/01 | 山田太郎  | 初版作成                               |
| 0.2      | 2023/11/15 | 佐藤次郎  | JSON形式ログ出力対応追加                  |
| 0.3      | 2024/01/20 | 鈴木三郎  | 非同期ログ機能強化                        |
| 0.4      | 2024/05/10 | 一丸柴也  | 実装コードを削除し、設計情報のみに修正     |