# フィルタ検索機能

## 1. 機能概要

フィルタ検索機能は、特定のリソースタイプに対して複数の条件を組み合わせて絞り込み検索を行うための機能です。ユーザーが選択した条件に基づいて検索結果をフィルタリングし、効率的に目的のデータにアクセスできるようにします。

### 1.1 機能の目的

- 特定のリソースタイプに対する詳細な条件指定検索を提供
- 複数の検索条件の組み合わせによる高度な絞り込み
- 検索結果のファセット情報の表示によるさらなる絞り込み支援
- 検索条件の保存と再利用
- 効率的なフィルタリング処理による高速な検索実行

### 1.2 主要機能

- 複数フィルタ条件の組み合わせ検索
- リソースタイプ固有のフィルタセット提供
- 動的なファセット情報の集計と表示
- 検索条件の保存と共有
- 検索結果のソート（複数フィールド、昇順/降順）
- ページング処理

## 2. 処理フロー

### 2.1 フィルタ検索の基本フロー

```
1. リクエスト受信と検証
   a. 検索対象リソースタイプとフィルタ条件の取得
   b. パラメータの妥当性チェック
   c. 検索クエリオブジェクトの構築

2. フィルタ条件変換
   a. フィルタパラメータの型変換
   b. リソースタイプ固有のフィルタ処理適用
   c. アクセス権限フィルタの適用

3. 検索エンジンへのクエリ実行
   a. Elasticsearchクエリの構築
   b. フィルタとクエリの組み合わせ
   c. ファセット集計の追加
   d. 検索の実行

4. 検索結果の後処理
   a. ファセット情報の処理
   b. 検索結果アイテムの変換
   c. アクセス権限による結果フィルタリング

5. レスポンス生成
   a. ページネーション処理
   b. レスポンスDTOの構築
   c. 検索履歴への保存（オプション）
```

### 2.2 フィルタ条件構築フロー

```
1. フィルタパラメータの解析
   a. パラメータ名と値の抽出
   b. 配列パラメータの処理（複数値）
   c. 範囲パラメータの処理（min/max, from/to）
   d. 特殊フィルタの処理（exists, geo等）

2. リソースタイプ別フィルタマッピング
   a. リソースタイプに応じたフィルタフィールドマッピング
   b. フィールド名の正規化（APIパラメータ名→DBフィールド名）
   c. データ型の検証と変換

3. フィルタクエリ構築
   a. 各フィルタ条件のElasticsearchクエリ変換
   b. BoolQueryへの条件追加（must, should, must_not）
   c. フィルタのネスト（複合条件）
```

### 2.3 ファセット集計フロー

```
1. ファセット対象フィールドの特定
   a. リソースタイプごとのファセット対象設定
   b. ユーザー指定のファセット要求処理

2. ファセット集計設定
   a. 用語集計（term aggregation）設定
   b. 範囲集計（range aggregation）設定
   c. 日付ヒストグラム集計設定

3. ファセット結果の処理
   a. 集計結果の取得と変換
   b. 選択済みファセット値のマーキング
   c. ファセット表示名の多言語化
```

## 3. 主要コンポーネント構成

### 3.1 FilterQueryBuilder クラス

フィルタ検索のクエリを構築するクラスです。

```java
// 主要メソッドのみを示します
public class FilterQueryBuilder {
    
    // リソースタイプ別のフィルタフィールド定義
    private final Map<String, Map<String, String>> resourceTypeFilterMappings;
    
    /**
     * フィルタ検索クエリを構築します
     */
    public QueryBuilder buildFilterQuery(String resourceType, Map<String, Object> filters) {
        BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
        
        // リソースタイプのフィルタマッピングを取得
        Map<String, String> filterMapping = getFilterMappingForResourceType(resourceType);
        
        // 各フィルタの処理
        for (Map.Entry<String, Object> entry : filters.entrySet()) {
            String apiParamName = entry.getKey();
            Object value = entry.getValue();
            
            // APIパラメータ名からフィールド名へのマッピング
            String fieldName = mapToFieldName(apiParamName, filterMapping);
            
            // フィルタタイプに応じたクエリビルダーの追加
            addFilterQuery(boolQuery, fieldName, value);
        }
        
        return boolQuery;
    }
    
    /**
     * 集計設定を構築します
     */
    public void addFacetAggregations(SearchSourceBuilder sourceBuilder, 
                                    String resourceType, 
                                    Map<String, Object> filters) {
        // リソースタイプに応じたファセットフィールド定義を取得
        List<FacetField> facetFields = getFacetFieldsForResourceType(resourceType);
        
        // 各ファセットフィールドの集計設定を追加
        for (FacetField facetField : facetFields) {
            if (facetField.getType() == FacetType.TERMS) {
                // 用語集計
                TermsAggregationBuilder termsAgg = AggregationBuilders
                    .terms(facetField.getName())
                    .field(facetField.getFieldName())
                    .size(facetField.getSize());
                
                sourceBuilder.aggregation(termsAgg);
            } else if (facetField.getType() == FacetType.RANGE) {
                // 範囲集計
                addRangeAggregation(sourceBuilder, facetField);
            }
        }
    }
    
    // その他のメソッド...
}
```

### 3.2 FilterSearchService 実装クラス

フィルタ検索サービスの実装クラスです。

```java
// 主要メソッドのみを示します
@Service
public class FilterSearchServiceImpl implements FilterSearchService {
    
    private final RestHighLevelClient elasticsearchClient;
    private final FilterQueryBuilder queryBuilder;
    private final SearchResultProcessor resultProcessor;
    private final FacetProcessor facetProcessor;
    
    /**
     * リソースタイプに対するフィルタ検索を実行します
     */
    @Override
    public SearchResultDto filterSearch(String resourceType, 
                                       Map<String, Object> filters, 
                                       String sortField, 
                                       String sortOrder, 
                                       int page, 
                                       int pageSize) throws SearchException {
        try {
            // 検索対象のインデックスを決定
            String indexName = getIndexNameForResourceType(resourceType);
            
            // 検索ソースビルダーの作成
            SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
            
            // フィルタクエリの構築と設定
            QueryBuilder filterQuery = queryBuilder.buildFilterQuery(resourceType, filters);
            sourceBuilder.query(filterQuery);
            
            // ファセット集計の追加
            queryBuilder.addFacetAggregations(sourceBuilder, resourceType, filters);
            
            // ページネーション設定
            sourceBuilder.from(page * pageSize);
            sourceBuilder.size(pageSize);
            
            // ソート設定
            if (sortField != null && !sortField.isEmpty()) {
                SortOrder order = "desc".equalsIgnoreCase(sortOrder) ? 
                                SortOrder.DESC : SortOrder.ASC;
                sourceBuilder.sort(sortField, order);
            }
            
            // 検索リクエストの作成
            SearchRequest searchRequest = new SearchRequest(indexName);
            searchRequest.source(sourceBuilder);
            
            // 検索の実行
            SearchResponse response = elasticsearchClient.search(searchRequest, RequestOptions.DEFAULT);
            
            // 検索結果の処理
            SearchResultDto result = resultProcessor.processSearchResponse(response);
            
            // ファセット情報の処理
            Map<String, List<FacetValueDto>> facets = 
                facetProcessor.processFacets(response.getAggregations(), filters);
            result.setFacets(facets);
            
            return result;
            
        } catch (Exception e) {
            throw new SearchException("フィルタ検索の実行中にエラーが発生しました", e);
        }
    }
}
```

### 3.3 FacetProcessor クラス

ファセット情報を処理するクラスです。

```java
// 主要メソッドのみを示します
@Component
public class FacetProcessor {
    
    /**
     * 集計結果からファセット情報を処理します
     */
    public Map<String, List<FacetValueDto>> processFacets(Aggregations aggregations, 
                                                       Map<String, Object> selectedFilters) {
        if (aggregations == null) {
            return Collections.emptyMap();
        }
        
        Map<String, List<FacetValueDto>> facets = new HashMap<>();
        
        // 各集計の処理
        for (Aggregation agg : aggregations.asList()) {
            String facetName = agg.getName();
            
            if (agg instanceof Terms) {
                // 用語集計の処理
                List<FacetValueDto> values = processTermsAggregation((Terms) agg, selectedFilters);
                facets.put(facetName, values);
            } else if (agg instanceof Range) {
                // 範囲集計の処理
                List<FacetValueDto> values = processRangeAggregation((Range) agg, selectedFilters);
                facets.put(facetName, values);
            }
        }
        
        return facets;
    }
    
    /**
     * 用語集計を処理します
     */
    private List<FacetValueDto> processTermsAggregation(Terms termsAgg, 
                                                     Map<String, Object> selectedFilters) {
        List<FacetValueDto> facetValues = new ArrayList<>();
        
        for (Terms.Bucket bucket : termsAgg.getBuckets()) {
            String value = bucket.getKeyAsString();
            long count = bucket.getDocCount();
            
            // 選択済みかどうかの判定
            boolean selected = isValueSelected(termsAgg.getName(), value, selectedFilters);
            
            // 表示名の取得
            String displayName = getDisplayName(termsAgg.getName(), value);
            
            // ファセット値DTOの作成
            FacetValueDto facetValue = FacetValueDto.builder()
                .value(value)
                .displayName(displayName)
                .count((int) count)
                .selected(selected)
                .build();
            
            facetValues.add(facetValue);
        }
        
        return facetValues;
    }
    
    // その他のメソッド...
}
```

### 3.4 ResourceTypeFilterConfig クラス

リソースタイプごとのフィルタ設定を提供するクラスです。

```java
@Configuration
public class ResourceTypeFilterConfig {
    
    /**
     * 技術者リソースタイプのフィルタ設定を提供します
     */
    @Bean
    public ResourceTypeFilterDefinition engineerFilterDefinition() {
        return ResourceTypeFilterDefinition.builder()
            .resourceType("engineers")
            .filterMappings(Map.of(
                "skills", "skills.keyword",
                "experience_years_min", "experienceYears",
                "experience_years_max", "experienceYears",
                "status", "status.keyword",
                "availability_date", "availabilityDate",
                "locations", "preferredLocation.keyword",
                "min_rate", "monthlyRate",
                "max_rate", "monthlyRate",
                "job_types", "jobType.keyword",
                "industries", "industries.keyword"
            ))
            .facetFields(List.of(
                new FacetField("skills", "skills.keyword", FacetType.TERMS, 10),
                new FacetField("status", "status.keyword", FacetType.TERMS, 5),
                new FacetField("job_types", "jobType.keyword", FacetType.TERMS, 5),
                new FacetField("locations", "preferredLocation.keyword", FacetType.TERMS, 10),
                new FacetField("industries", "industries.keyword", FacetType.TERMS, 10),
                new FacetField("experience_years", "experienceYears", FacetType.RANGE, createExperienceRanges())
            ))
            .build();
    }
    
    /**
     * 案件リソースタイプのフィルタ設定を提供します
     */
    @Bean
    public ResourceTypeFilterDefinition projectFilterDefinition() {
        return ResourceTypeFilterDefinition.builder()
            .resourceType("projects")
            .filterMappings(Map.of(
                "required_skills", "requiredSkills.keyword",
                "locations", "location.keyword",
                "project_types", "projectType.keyword",
                "industries", "industry.keyword",
                "statuses", "status.keyword",
                "min_rate", "monthlyRate",
                "max_rate", "monthlyRate",
                "period_from", "periodStart",
                "period_to", "periodEnd",
                "contract_types", "contractType.keyword"
            ))
            .facetFields(List.of(
                new FacetField("required_skills", "requiredSkills.keyword", FacetType.TERMS, 10),
                new FacetField("locations", "location.keyword", FacetType.TERMS, 10),
                new FacetField("project_types", "projectType.keyword", FacetType.TERMS, 5),
                new FacetField("industries", "industry.keyword", FacetType.TERMS, 10),
                new FacetField("statuses", "status.keyword", FacetType.TERMS, 5),
                new FacetField("contract_types", "contractType.keyword", FacetType.TERMS, 5)
            ))
            .build();
    }
    
    // その他のリソースタイプ定義...
}
```

## 4. クライアントインターフェース

### 4.1 REST API

フィルタ検索機能を提供するREST APIです。

```java
// 主要メソッドのみを示します
@RestController
@RequestMapping("/api/v1/common/search")
public class FilterSearchController {
    
    private final FilterSearchService filterSearchService;
    
    /**
     * 特定のリソースタイプに対するフィルタ検索を実行します
     */
    @GetMapping("/{resourceType}")
    public ResponseEntity<SearchResultDto> filterSearch(
            @PathVariable String resourceType,
            @RequestParam Map<String, String> requestParams) {
        
        try {
            // リクエストパラメータから検索パラメータを抽出
            Map<String, Object> filters = extractFilters(requestParams);
            
            // ソート情報の抽出
            String sortField = requestParams.get("sort");
            String sortOrder = requestParams.get("order");
            
            // ページネーション情報の抽出
            int page = getIntParam(requestParams, "page", 0);
            int size = getIntParam(requestParams, "size", 20);
            
            // 検索の実行
            SearchResultDto result = filterSearchService.filterSearch(
                resourceType, filters, sortField, sortOrder, page, size);
            
            return ResponseEntity.ok(result);
            
        } catch (SearchException e) {
            // エラーハンドリングは実際の実装ではグローバルエラーハンドラで行う
            throw new RuntimeException(e);
        }
    }
    
    /**
     * リクエストパラメータからフィルタを抽出します
     */
    private Map<String, Object> extractFilters(Map<String, String> requestParams) {
        Map<String, Object> filters = new HashMap<>();
        
        // 特殊パラメータを除外
        Set<String> specialParams = Set.of("sort", "order", "page", "size");
        
        for (Map.Entry<String, String> entry : requestParams.entrySet()) {
            String key = entry.getKey();
            
            // 特殊パラメータはスキップ
            if (specialParams.contains(key)) {
                continue;
            }
            
            // 値の処理
            String value = entry.getValue();
            
            if (key.endsWith("_min") || key.endsWith("_max") || 
                key.endsWith("_from") || key.endsWith("_to")) {
                // 範囲パラメータの処理
                processRangeParam(filters, key, value);
            } else if (value.contains(",")) {
                // カンマ区切りの複数値
                filters.put(key, Arrays.asList(value.split(",")));
            } else {
                // 単一値
                filters.put(key, value);
            }
        }
        
        return filters;
    }
    
    // その他のメソッド...
}
```

### 4.2 FilterSearchComponent (React)

フロントエンドのフィルタ検索コンポーネント例です（コード量を削減するため簡略化しています）。

```typescript
// 主要部分のみを示します
import React, { useState, useEffect } from 'react';
import { SearchService } from '../services/SearchService';
import { SearchResult, FacetValue } from '../types/search';

interface FilterSearchComponentProps {
  resourceType: string;
  initialFilters?: Record<string, any>;
  onResultsChange?: (results: SearchResult) => void;
}

export const FilterSearchComponent: React.FC<FilterSearchComponentProps> = ({
  resourceType,
  initialFilters = {},
  onResultsChange
}) => {
  const [filters, setFilters] = useState<Record<string, any>>(initialFilters);
  const [results, setResults] = useState<SearchResult | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [sortField, setSortField] = useState<string>('');
  const [sortOrder, setSortOrder] = useState<string>('asc');
  const [page, setPage] = useState<number>(0);
  
  // 検索サービスのインスタンス
  const searchService = new SearchService();
  
  // 検索実行
  const executeSearch = async () => {
    setLoading(true);
    
    try {
      const result = await searchService.filterSearch(
        resourceType,
        filters,
        sortField,
        sortOrder,
        page,
        20
      );
      
      setResults(result);
      
      if (onResultsChange) {
        onResultsChange(result);
      }
    } catch (error) {
      console.error('検索実行中にエラーが発生しました', error);
    } finally {
      setLoading(false);
    }
  };
  
  // フィルタ変更時に検索実行
  useEffect(() => {
    executeSearch();
  }, [resourceType, filters, sortField, sortOrder, page]);
  
  // フィルタ値の更新
  const updateFilter = (name: string, value: any) => {
    setFilters(prev => ({
      ...prev,
      [name]: value
    }));
    
    // ページをリセット
    setPage(0);
  };
  
  // ファセット値の選択
  const handleFacetSelect = (facetName: string, facetValue: FacetValue) => {
    const currentValues = filters[facetName] || [];
    
    if (Array.isArray(currentValues)) {
      // 既に選択されている場合は削除、そうでなければ追加
      if (currentValues.includes(facetValue.value)) {
        updateFilter(
          facetName,
          currentValues.filter(v => v !== facetValue.value)
        );
      } else {
        updateFilter(facetName, [...currentValues, facetValue.value]);
      }
    } else {
      // 単一値の場合は置き換え
      updateFilter(facetName, facetValue.value);
    }
  };
  
  // フィルタクリア
  const clearFilters = () => {
    setFilters({});
    setPage(0);
  };
  
  // レンダリング（UI部分）
  return (
    <div className="filter-search-container">
      {/* フィルタパネル */}
      <div className="filter-panel">
        {/* リソースタイプに応じたフィルタコントロール */}
        {renderFilterControls()}
        
        {/* 選択中のフィルタ表示 */}
        <div className="active-filters">
          {Object.entries(filters).map(([key, value]) => (
            <div key={key} className="filter-tag">
              {getFilterDisplayName(key)}: {getFilterValueDisplay(key, value)}
              <button onClick={() => updateFilter(key, undefined)}>×</button>
            </div>
          ))}
          {Object.keys(filters).length > 0 && (
            <button onClick={clearFilters}>すべてクリア</button>
          )}
        </div>
      </div>
      
      {/* 検索結果表示 */}
      <div className="search-results">
        {/* ソートコントロール */}
        <div className="sort-controls">
          <select 
            value={sortField} 
            onChange={e => setSortField(e.target.value)}
          >
            <option value="">関連度順</option>
            <option value="createdAt">作成日</option>
            <option value="updatedAt">更新日</option>
            {/* リソースタイプ固有のソートオプション */}
            {renderSortOptions()}
          </select>
          
          <select 
            value={sortOrder} 
            onChange={e => setSortOrder(e.target.value)}
          >
            <option value="asc">昇順</option>
            <option value="desc">降順</option>
          </select>
        </div>
        
        {/* 結果一覧 */}
        {loading ? (
          <div className="loading">検索中...</div>
        ) : (
          <>
            {results?.items?.map(item => (
              <div key={item.id} className="search-result-item">
                <h3>{item.title}</h3>
                <div>{item.description}</div>
              </div>
            ))}
            
            {/* ページネーション */}
            <div className="pagination">
              <button 
                disabled={page === 0} 
                onClick={() => setPage(p => Math.max(0, p - 1))}
              >
                前へ
              </button>
              <span>
                {page + 1} / {results?.totalPages || 1}
              </span>
              <button 
                disabled={!results || page >= results.totalPages - 1} 
                onClick={() => setPage(p => p + 1)}
              >
                次へ
              </button>
            </div>
          </>
        )}
      </div>
      
      {/* ファセット情報表示 */}
      <div className="facets-panel">
        {results?.facets && Object.entries(results.facets).map(([facetName, values]) => (
          <div key={facetName} className="facet-group">
            <h3>{getFilterDisplayName(facetName)}</h3>
            <ul>
              {values.map(value => (
                <li 
                  key={value.value}
                  className={value.selected ? 'selected' : ''}
                  onClick={() => handleFacetSelect(facetName, value)}
                >
                  <span>{value.displayName}</span>
                  <span className="facet-count">({value.count})</span>
                </li>
              ))}
            </ul>
          </div>
        ))}
      </div>
    </div>
  );
};
```

## 5. リソースタイプ別フィルタ設定

### 5.1 技術者（engineers）フィルタ

技術者リソースタイプのフィルタ設定です。

| フィルター名 | 説明 | タイプ | ファセット |
|------------|------|------|----------|
| skills | 保有スキル | 複数選択 | あり |
| skill_levels | スキルレベル | マップ | なし |
| experience_years_min | 最小経験年数 | 数値 | なし |
| experience_years_max | 最大経験年数 | 数値 | なし |
| status | 稼働状況 | 複数選択 | あり |
| availability_date | 稼働可能日 | 日付 | なし |
| locations | 希望勤務地 | 複数選択 | あり |
| min_rate | 最低単価 | 数値 | なし |
| max_rate | 最高単価 | 数値 | なし |
| job_types | 職種 | 複数選択 | あり |
| industries | 経験業界 | 複数選択 | あり |

具体的なマッピング：

```
skills -> skills.keyword
experience_years_min -> experienceYears (範囲下限)
experience_years_max -> experienceYears (範囲上限)
status -> status.keyword
availability_date -> availabilityDate
locations -> preferredLocation.keyword
min_rate -> monthlyRate (範囲下限)
max_rate -> monthlyRate (範囲上限)
job_types -> jobType.keyword
industries -> industries.keyword
```

### 5.2 案件（projects）フィルタ

案件リソースタイプのフィルタ設定です。

| フィルター名 | 説明 | タイプ | ファセット |
|------------|------|------|----------|
| required_skills | 必要スキル | 複数選択 | あり |
| locations | 勤務地 | 複数選択 | あり |
| project_types | 案件種別 | 複数選択 | あり |
| industries | 業界 | 複数選択 | あり |
| statuses | 案件状態 | 複数選択 | あり |
| min_rate | 最低単価 | 数値 | なし |
| max_rate | 最高単価 | 数値 | なし |
| period_from | 開始日 | 日付 | なし |
| period_to | 終了日 | 日付 | なし |
| contract_types | 契約形態 | 複数選択 | あり |

具体的なマッピング：

```
required_skills -> requiredSkills.keyword
locations -> location.keyword
project_types -> projectType.keyword
industries -> industry.keyword
statuses -> status.keyword
min_rate -> monthlyRate (範囲下限)
max_rate -> monthlyRate (範囲上限)
period_from -> periodStart (範囲)
period_to -> periodEnd (範囲)
contract_types -> contractType.keyword
```

### 5.3 契約（contracts）フィルタ

契約リソースタイプのフィルタ設定です。

| フィルター名 | 説明 | タイプ | ファセット |
|------------|------|------|----------|
| client_ids | クライアントID | 複数選択 | あり |
| engineer_ids | 技術者ID | 複数選択 | あり |
| project_ids | 案件ID | 複数選択 | あり |
| statuses | 契約状態 | 複数選択 | あり |
| contract_types | 契約形態 | 複数選択 | あり |
| start_date_from | 開始日（範囲下限） | 日付 | なし |
| start_date_to | 開始日（範囲上限） | 日付 | なし |
| end_date_from | 終了日（範囲下限） | 日付 | なし |
| end_date_to | 終了日（範囲上限） | 日付 | なし |
| signed | 署名状態 | 真偽値 | あり |

### 5.4 請求書（invoices）フィルタ

請求書リソースタイプのフィルタ設定です。

| フィルター名 | 説明 | タイプ | ファセット |
|------------|------|------|----------|
| client_ids | クライアントID | 複数選択 | あり |
| contract_ids | 契約ID | 複数選択 | あり |
| engineer_ids | 技術者ID | 複数選択 | あり |
| statuses | 請求書状態 | 複数選択 | あり |
| issue_date_from | 発行日（範囲下限） | 日付 | なし |
| issue_date_to | 発行日（範囲上限） | 日付 | なし |
| due_date_from | 支払期限（範囲下限） | 日付 | なし |
| due_date_to | 支払期限（範囲上限） | 日付 | なし |
| min_amount | 最低請求金額 | 数値 | なし |
| max_amount | 最高請求金額 | 数値 | なし |

## 6. ファセット処理

### 6.1 ファセットの種類

フィルタ検索で利用するファセットの種類です。

#### 6.1.1 用語ファセット（Term Facet）

特定のフィールドの値ごとに件数を集計するファセットです。

```json
{
  "aggregations": {
    "skills": {
      "terms": {
        "field": "skills.keyword",
        "size": 10
      }
    }
  }
}
```

#### 6.1.2 範囲ファセット（Range Facet）

数値や日付フィールドを特定の範囲で区切って集計するファセットです。

```json
{
  "aggregations": {
    "experience_years": {
      "range": {
        "field": "experienceYears",
        "ranges": [
          { "to": 3, "key": "0-3年" },
          { "from": 3, "to": 5, "key": "3-5年" },
          { "from": 5, "to": 10, "key": "5-10年" },
          { "from": 10, "key": "10年以上" }
        ]
      }
    }
  }
}
```

#### 6.1.3 日付ヒストグラムファセット（Date Histogram Facet）

日付フィールドを特定の期間（年、月、日など）で区切って集計するファセットです。

```json
{
  "aggregations": {
    "contract_dates": {
      "date_histogram": {
        "field": "startDate",
        "calendar_interval": "month",
        "format": "yyyy-MM"
      }
    }
  }
}
```

### 6.2 ファセット表示処理

ファセット情報の表示処理フローです。

1. ファセット値の取得
   - Elasticsearchの集計結果からファセット値と件数を取得
   - 選択済みファセットのマーキング

2. ファセット表示名の設定
   - コード値から表示名への変換
   - 多言語対応（必要に応じて）

3. ファセットのソート
   - 件数順
   - アルファベット順
   - 特定の優先順位に基づく

4. ファセットの表示制御
   - 選択済みファセットの強調表示
   - 0件のファセット値の非表示/表示
   - ファセット値の制限（表示上限と「もっと見る」機能）

## 7. 例外処理

### 7.1 フィルタパラメータ検証エラー

無効なフィルタパラメータが指定された場合の例外処理です。

```java
/**
 * フィルタパラメータを検証します
 */
private void validateFilters(String resourceType, Map<String, Object> filters) throws SearchException {
    Map<String, String> validFilterFields = getValidFilterFields(resourceType);
    
    for (String filterName : filters.keySet()) {
        // 基本パラメータ名の抽出（_min, _max, _from, _to などのサフィックスを除去）
        String baseFilterName = filterName.replaceAll("_(min|max|from|to)$", "");
        
        // 有効なフィルタフィールドでない場合はエラー
        if (!validFilterFields.containsKey(baseFilterName)) {
            throw new SearchException(
                "INVALID_FILTER", 
                "リソースタイプ " + resourceType + " に対して無効なフィルターです: " + filterName
            );
        }
        
        // フィルターの値の型チェック
        validateFilterValue(filterName, validFilterFields.get(baseFilterName), filters.get(filterName));
    }
}
```

### 7.2 フィルタ値の型変換エラー

フィルタ値の型変換に失敗した場合の例外処理です。

```java
/**
 * フィルタ値を検証します
 */
private void validateFilterValue(String filterName, String fieldType, Object value) throws SearchException {
    if (value == null) {
        return; // null値は有効（フィルタのクリアに使用）
    }
    
    try {
        switch (fieldType) {
            case "integer":
                if (value instanceof String) {
                    Integer.parseInt((String) value);
                } else if (!(value instanceof Integer)) {
                    throw new IllegalArgumentException("整数値が必要です");
                }
                break;
            case "float":
            case "double":
                if (value instanceof String) {
                    Double.parseDouble((String) value);
                } else if (!(value instanceof Number)) {
                    throw new IllegalArgumentException("数値が必要です");
                }
                break;
            case "date":
                if (value instanceof String) {
                    // ISO 8601形式の日付チェック
                    if (!((String) value).matches("\\d{4}-\\d{2}-\\d{2}(T\\d{2}:\\d{2}:\\d{2}(Z|([+-]\\d{2}:\\d{2}))?)?")) {
                        throw new IllegalArgumentException("有効な日付形式ではありません");
                    }
                }
                break;
            case "boolean":
                if (value instanceof String) {
                    if (!((String) value).equalsIgnoreCase("true") && 
                        !((String) value).equalsIgnoreCase("false")) {
                        throw new IllegalArgumentException("真偽値（true/false）が必要です");
                    }
                } else if (!(value instanceof Boolean)) {
                    throw new IllegalArgumentException("真偽値が必要です");
                }
                break;
            // その他の型...
        }
    } catch (IllegalArgumentException e) {
        throw new SearchException(
            "INVALID_FILTER_VALUE", 
            "フィルター " + filterName + " の値が無効です: " + e.getMessage()
        );
    }
}
```

### 7.3 フィルタ上限超過エラー

フィルタ条件が多すぎる場合の例外処理です。

```java
/**
 * フィルタ数の上限をチェックします
 */
private void checkFilterLimit(Map<String, Object> filters) throws SearchException {
    int maxAllowedFilters = 20; // 最大許容フィルタ数
    
    if (filters.size() > maxAllowedFilters) {
        throw new SearchException(
            "TOO_MANY_FILTERS", 
            "フィルタの数が上限を超えています。最大 " + maxAllowedFilters + " 個までのフィルタが使用可能です。"
        );
    }
}
```

## 8. パフォーマンス最適化

### 8.1 フィルタクエリのキャッシュ

頻繁に使用されるフィルタクエリのキャッシュ処理です。

```java
/**
 * フィルタクエリをキャッシュします
 */
@Cacheable(
    value = "filterQueries", 
    key = "#resourceType + '_' + #filters.hashCode() + '_' + #page + '_' + #pageSize",
    condition = "#filters.size() <= 10", // 少数のフィルタのみキャッシュ
    unless = "#result.totalHits < 10" // 少数の結果はキャッシュしない
)
public SearchResultDto getCachedFilterSearch(
    String resourceType, 
    Map<String, Object> filters, 
    String sortField, 
    String sortOrder, 
    int page, 
    int pageSize) throws SearchException {
    
    // 実際の検索処理を呼び出し
    return filterSearch(resourceType, filters, sortField, sortOrder, page, pageSize);
}
```

### 8.2 ファセット計算の最適化

ファセット計算を最適化する例です。

```java
/**
 * ファセット集計を最適化します
 */
private void optimizeFacetAggregations(
    SearchSourceBuilder sourceBuilder, 
    String resourceType, 
    Map<String, Object> filters) {
    
    // リソースタイプに応じたファセットフィールド定義を取得
    List<FacetField> facetFields = getFacetFieldsForResourceType(resourceType);
    
    // 各ファセットフィールドの集計設定を追加
    for (FacetField facetField : facetFields) {
        // 既に選択されているファセットは集計をスキップ（最適化）
        if (filters.containsKey(facetField.getName()) && 
            !isRangeFilter(facetField.getName())) {
            continue;
        }
        
        // ファセット集計の追加
        AggregationBuilder aggregation = buildAggregation(facetField);
        
        // サブ集計の追加
        if (facetField.getType() == FacetType.TERMS && 
            !isHighCardinalityField(facetField.getFieldName())) {
            
            // ファセット値ごとの詳細集計を追加
            aggregation.subAggregation(
                AggregationBuilders.topHits("top_hits")
                    .size(1)
                    .fetchSource(false)
            );
        }
        
        sourceBuilder.aggregation(aggregation);
    }
}
```

### 8.3 動的ファセット表示

フィルタ条件に応じて動的にファセット表示を制御する例です。

```java
/**
 * 表示するファセットを動的に選択します
 */
private List<FacetField> selectActiveFacets(
    String resourceType, 
    Map<String, Object> filters, 
    int resultCount) {
    
    List<FacetField> allFacets = getFacetFieldsForResourceType(resourceType);
    List<FacetField> activeFacets = new ArrayList<>();
    
    // 結果が0件の場合は、現在のフィルタに関連するファセットのみ表示
    if (resultCount == 0) {
        for (FacetField facet : allFacets) {
            if (isRelatedToCurrentFilters(facet.getName(), filters)) {
                activeFacets.add(facet);
            }
        }
        return activeFacets;
    }
    
    // 結果が少ない場合（10件未満）は、より多くのファセットを表示
    int maxFacets = resultCount < 10 ? 10 : 5;
    
    // ファセットの重要度によるソート
    List<FacetField> sortedFacets = allFacets.stream()
        .sorted(Comparator.comparing(facet -> getFacetImportance(facet.getName(), resourceType)))
        .collect(Collectors.toList());
    
    // 上位N個のファセットを選択
    for (int i = 0; i < Math.min(maxFacets, sortedFacets.size()); i++) {
        activeFacets.add(sortedFacets.get(i));
    }
    
    return activeFacets;
}
```

## 9. テスト方針

### 9.1 単体テスト

フィルタ検索機能の単体テストは以下の観点で実施します：

- **FilterQueryBuilderのテスト**：
  - フィルタパラメータの解析の正確性
  - クエリ構築の正確性
  - ファセット集計設定の正確性

- **FacetProcessorのテスト**：
  - ファセット情報の処理
  - 選択済みファセットのマーキング

- **ResourceTypeFilterConfigのテスト**：
  - リソースタイプごとのフィルタ設定の正確性

### 9.2 統合テスト

フィルタ検索機能の統合テストは以下の観点で実施します：

- **フィルタ検索フロー全体のテスト**：
  - フィルタ条件から結果取得までの一連の流れ
  - リソースタイプごとの固有フィルタの動作確認

- **ファセット情報の検証**：
  - ファセット集計結果の正確性
  - ファセット選択時の挙動確認

- **権限制御との連携テスト**：
  - アクセス権限に基づくフィルタリングの確認

### 9.3 UIテスト

フィルタ検索機能のUIテストは以下の観点で実施します：

- **フィルタUIの操作性テスト**：
  - フィルタ選択の操作性
  - ファセット表示の正確性
  - 選択済みフィルタの表示と解除

- **レスポンシブ対応テスト**：
  - さまざまな画面サイズでの表示確認
  - モバイル環境での操作性確認