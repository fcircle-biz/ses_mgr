# トランザクション管理機能 インターフェース定義

## バージョン管理
| バージョン | 日付 | 更新者 | 更新内容 |
|----------|------|-------|---------|
| 0.1 | 2025-05-10 | 設計担当者 | 初版作成 |
| 0.2 | 2025-05-11 | 設計担当者 | 実装コード削除による軽量化 |

## 1. 概要

本ドキュメントでは、トランザクション管理機能が提供するインターフェースと、外部システムからの依存インターフェースを定義します。これらのインターフェースは、トランザクション管理機能を他のモジュールと統合するための主要な契約となります。

## 2. 提供インターフェース

### 2.1 TransactionManager

トランザクション管理の主要なエントリポイントとなるサービスインターフェースです。基本的なトランザクション操作を提供します。

```java
public interface TransactionManager {
    /**
     * 新しいトランザクションを開始する
     * @param propagation 伝播方式
     * @param isolation 分離レベル
     * @param timeout タイムアウト（秒）
     * @param readOnly 読み取り専用フラグ
     * @return トランザクション情報
     */
    TransactionStatus begin(
        PropagationBehavior propagation, 
        IsolationLevel isolation, 
        int timeout, 
        boolean readOnly
    );
    
    /**
     * 現在のトランザクションをコミットする
     * @throws NoTransactionException アクティブなトランザクションがない場合
     * @throws TransactionSystemException コミット処理中にエラーが発生した場合
     */
    void commit() throws NoTransactionException, TransactionSystemException;
    
    /**
     * 現在のトランザクションをロールバックする
     * @throws NoTransactionException アクティブなトランザクションがない場合
     * @throws TransactionSystemException ロールバック処理中にエラーが発生した場合
     */
    void rollback() throws NoTransactionException, TransactionSystemException;
    
    /**
     * 現在アクティブなトランザクションがあるか確認する
     * @return トランザクションがアクティブな場合はtrue
     */
    boolean isActive();
    
    /**
     * 現在のトランザクション情報を取得する
     * @return トランザクション情報（存在しない場合はEmpty）
     */
    Optional<TransactionStatus> getCurrentTransaction();
    
    /**
     * 現在のトランザクションを一時停止する
     * @return 停止したトランザクションの状態
     * @throws NoTransactionException アクティブなトランザクションがない場合
     */
    TransactionStatus suspend() throws NoTransactionException;
    
    /**
     * 一時停止したトランザクションを再開する
     * @param status 再開するトランザクションの状態
     * @throws InvalidTransactionException 無効なトランザクション状態の場合
     */
    void resume(TransactionStatus status) throws InvalidTransactionException;
    
    /**
     * 指定した例外発生時にロールバックするかどうかを設定する
     * @param exceptionClass 例外クラス
     * @param rollback ロールバックするかどうか
     */
    void setRollbackOnlyForException(Class<? extends Throwable> exceptionClass, boolean rollback);
}
```

### 2.2 TransactionTemplate

宣言的なプログラミングスタイルでトランザクション処理を実行するためのテンプレートインターフェースです。

```java
public interface TransactionTemplate {
    /**
     * トランザクション内で処理を実行する
     * @param action 実行する処理
     * @param <T> 戻り値の型
     * @return 処理結果
     * @throws TransactionException トランザクション処理中にエラーが発生した場合
     */
    <T> T execute(TransactionCallback<T> action) throws TransactionException;
    
    /**
     * 読み取り専用トランザクション内で処理を実行する
     * @param action 実行する処理
     * @param <T> 戻り値の型
     * @return 処理結果
     * @throws TransactionException トランザクション処理中にエラーが発生した場合
     */
    <T> T executeReadOnly(TransactionCallback<T> action) throws TransactionException;
    
    /**
     * 新しいトランザクションを作成して処理を実行する
     * @param action 実行する処理
     * @param <T> 戻り値の型
     * @return 処理結果
     * @throws TransactionException トランザクション処理中にエラーが発生した場合
     */
    <T> T executeWithNewTransaction(TransactionCallback<T> action) throws TransactionException;
    
    /**
     * トランザクションの伝播方式を設定する
     * @param propagationBehavior 伝播方式
     * @return 自身のインスタンス
     */
    TransactionTemplate setPropagationBehavior(PropagationBehavior propagationBehavior);
    
    /**
     * トランザクションの分離レベルを設定する
     * @param isolationLevel 分離レベル
     * @return 自身のインスタンス
     */
    TransactionTemplate setIsolationLevel(IsolationLevel isolationLevel);
    
    /**
     * トランザクションのタイムアウトを設定する
     * @param timeout タイムアウト（秒）
     * @return 自身のインスタンス
     */
    TransactionTemplate setTimeout(int timeout);
    
    /**
     * 読み取り専用フラグを設定する
     * @param readOnly 読み取り専用の場合はtrue
     * @return 自身のインスタンス
     */
    TransactionTemplate setReadOnly(boolean readOnly);
}
```

### 2.3 TransactionSynchronizationManager

トランザクションの実行前後に処理を挿入するための同期マネージャインターフェースです。

```java
public interface TransactionSynchronizationManager {
    /**
     * トランザクション同期処理を登録する
     * @param synchronization 同期処理
     * @throws IllegalStateException アクティブなトランザクションがない場合
     */
    void registerSynchronization(TransactionSynchronization synchronization) 
            throws IllegalStateException;
    
    /**
     * 現在トランザクションが有効かどうか確認する
     * @return トランザクションが有効な場合はtrue
     */
    boolean isSynchronizationActive();
    
    /**
     * 現在のトランザクションがロールバックのみ可能かどうか確認する
     * @return ロールバックのみ可能な場合はtrue
     */
    boolean isCurrentTransactionReadOnly();
    
    /**
     * 現在のトランザクション名を取得する
     * @return トランザクション名（存在しない場合はnull）
     */
    String getCurrentTransactionName();
    
    /**
     * リソースをトランザクションにバインドする
     * @param key リソースキー
     * @param value リソース値
     */
    void bindResource(Object key, Object value);
    
    /**
     * トランザクションからリソースを取得する
     * @param key リソースキー
     * @return バインドされたリソース（存在しない場合はnull）
     */
    Object getResource(Object key);
    
    /**
     * トランザクションからリソースをアンバインドする
     * @param key リソースキー
     * @return アンバインドされたリソース
     */
    Object unbindResource(Object key);
}
```

### 2.4 DistributedTransactionManager

分散トランザクションを管理するためのインターフェースです。

```java
public interface DistributedTransactionManager {
    /**
     * 分散トランザクションを開始する
     * @param transactionConfig 分散トランザクション設定
     * @return 分散トランザクションID
     * @throws DistributedTransactionException 分散トランザクション開始中にエラーが発生した場合
     */
    String beginDistributedTransaction(DistributedTransactionConfig transactionConfig) 
            throws DistributedTransactionException;
    
    /**
     * 分散トランザクションを完了する（準備フェーズを実行）
     * @param transactionId 分散トランザクションID
     * @return 準備フェーズの結果
     * @throws DistributedTransactionException 準備フェーズでエラーが発生した場合
     */
    PrepareResult prepare(String transactionId) throws DistributedTransactionException;
    
    /**
     * 分散トランザクションをコミットする
     * @param transactionId 分散トランザクションID
     * @throws DistributedTransactionException コミット中にエラーが発生した場合
     */
    void commit(String transactionId) throws DistributedTransactionException;
    
    /**
     * 分散トランザクションをロールバックする
     * @param transactionId 分散トランザクションID
     * @throws DistributedTransactionException ロールバック中にエラーが発生した場合
     */
    void rollback(String transactionId) throws DistributedTransactionException;
    
    /**
     * サービスを分散トランザクションに参加させる
     * @param transactionId 分散トランザクションID
     * @param participantConfig 参加者設定
     * @throws DistributedTransactionException 参加処理中にエラーが発生した場合
     */
    void enlistParticipant(String transactionId, ParticipantConfig participantConfig) 
            throws DistributedTransactionException;
    
    /**
     * 分散トランザクションの状態を取得する
     * @param transactionId 分散トランザクションID
     * @return 分散トランザクションステータス
     * @throws DistributedTransactionException 状態取得中にエラーが発生した場合
     */
    DistributedTransactionStatus getTransactionStatus(String transactionId) 
            throws DistributedTransactionException;
    
    /**
     * 未解決のトランザクションを回復する
     * @return 回復したトランザクション数
     */
    int recoverInDoubtTransactions();
}
```

### 2.5 SagaCoordinator

SAGAパターンによる分散トランザクションを調整するためのインターフェースです。

```java
public interface SagaCoordinator {
    /**
     * SAGAプロセスを開始する
     * @param sagaDefinitionId SAGAプロセス定義ID
     * @param initialData 初期データ
     * @return SAGA実行ID
     * @throws SagaException SAGA開始中にエラーが発生した場合
     */
    String startSaga(String sagaDefinitionId, Map<String, Object> initialData) throws SagaException;
    
    /**
     * SAGAプロセスを完了する
     * @param sagaExecutionId SAGA実行ID
     * @param result 最終結果
     * @throws SagaException SAGA完了中にエラーが発生した場合
     */
    void endSaga(String sagaExecutionId, Map<String, Object> result) throws SagaException;
    
    /**
     * SAGAプロセスを中止し、補償トランザクションを実行する
     * @param sagaExecutionId SAGA実行ID
     * @param cause 中止理由
     * @throws SagaException SAGA中止中にエラーが発生した場合
     */
    void abortSaga(String sagaExecutionId, Throwable cause) throws SagaException;
    
    /**
     * SAGAステップを実行する
     * @param sagaExecutionId SAGA実行ID
     * @param stepId ステップID
     * @param stepData ステップデータ
     * @return ステップ実行結果
     * @throws SagaException ステップ実行中にエラーが発生した場合
     */
    StepExecutionResult executeStep(String sagaExecutionId, String stepId, 
                                   Map<String, Object> stepData) throws SagaException;
    
    /**
     * SAGAの現在の状態を取得する
     * @param sagaExecutionId SAGA実行ID
     * @return SAGA状態情報
     * @throws SagaException 状態取得中にエラーが発生した場合
     */
    SagaState getSagaState(String sagaExecutionId) throws SagaException;
    
    /**
     * 実行中のSAGAプロセスをリストアップする
     * @return 実行中のSAGA実行IDリスト
     */
    List<String> listActiveSagas();
}
```

### 2.6 TransactionEventPublisher

トランザクション関連イベントを発行するためのインターフェースです。

```java
public interface TransactionEventPublisher {
    /**
     * トランザクションイベントを発行する
     * @param event 発行するイベント
     */
    void publishEvent(TransactionEvent event);
    
    /**
     * トランザクションイベントリスナーを登録する
     * @param listener イベントリスナー
     * @param eventTypes 購読するイベント種別
     */
    void subscribeListener(TransactionEventListener listener, TransactionEventType... eventTypes);
    
    /**
     * トランザクションイベントリスナーの登録を解除する
     * @param listener 解除するイベントリスナー
     */
    void unsubscribeListener(TransactionEventListener listener);
}
```

### 2.7 TransactionLogService

トランザクションログを管理するためのインターフェースです。

```java
public interface TransactionLogService {
    /**
     * トランザクションログを記録する
     * @param transactionId トランザクションID
     * @param eventType イベント種別
     * @param detail 詳細情報
     * @param successful 成功フラグ
     * @param errorCode エラーコード（エラー時のみ）
     * @param errorMessage エラーメッセージ（エラー時のみ）
     * @return 記録されたログID
     */
    String logTransactionEvent(String transactionId, TransactionEventType eventType, 
                              String detail, boolean successful, 
                              String errorCode, String errorMessage);
    
    /**
     * トランザクションのログを取得する
     * @param transactionId トランザクションID
     * @return 該当トランザクションのログリスト
     */
    List<TransactionLog> getTransactionLogs(String transactionId);
    
    /**
     * 期間内のエラーログを検索する
     * @param startTime 開始時間
     * @param endTime 終了時間
     * @param pageable ページ情報
     * @return エラーログのページ
     */
    Page<TransactionLog> findErrorLogs(LocalDateTime startTime, 
                                      LocalDateTime endTime, 
                                      Pageable pageable);
    
    /**
     * トランザクションログを検索する
     * @param criteria 検索条件
     * @param pageable ページ情報
     * @return ログのページ
     */
    Page<TransactionLog> searchLogs(TransactionLogSearchCriteria criteria, 
                                   Pageable pageable);
    
    /**
     * 古いログをアーカイブする
     * @param cutoffTime 基準時間（これより前のログをアーカイブ）
     * @return アーカイブされたログの数
     */
    int archiveOldLogs(LocalDateTime cutoffTime);
}
```

## 3. データ転送オブジェクト (DTO)

### 3.1 TransactionStatus

トランザクションの状態を表すDTOです。

```java
public class TransactionStatus {
    private String transactionId;        // トランザクションID
    private TransactionStatusEnum status; // トランザクション状態
    private LocalDateTime startTime;     // 開始時間
    private boolean newTransaction;      // 新規トランザクションフラグ
    private boolean completed;           // 完了フラグ
    private boolean rollbackOnly;        // ロールバックのみフラグ
    private Integer timeout;             // タイムアウト（秒）
    private IsolationLevel isolationLevel; // 分離レベル
    private boolean readOnly;            // 読み取り専用フラグ
    
    // getters and setters
}
```

### 3.2 TransactionConfig

トランザクション設定を表すDTOです。

```java
public class TransactionConfig {
    private PropagationBehavior propagation = PropagationBehavior.REQUIRED; // 伝播方式
    private IsolationLevel isolation = IsolationLevel.READ_COMMITTED;      // 分離レベル
    private int timeout = 60;                                               // タイムアウト（秒）
    private boolean readOnly = false;                                       // 読み取り専用フラグ
    private Set<Class<? extends Throwable>> rollbackFor = new HashSet<>();  // ロールバック対象例外
    private Set<Class<? extends Throwable>> noRollbackFor = new HashSet<>(); // ロールバック対象外例外
    private String transactionManagerName;                                  // トランザクションマネージャ名
    
    // getters, setters, and builder methods
}
```

### 3.3 DistributedTransactionConfig

分散トランザクション設定を表すDTOです。

```java
public class DistributedTransactionConfig {
    private String coordinatorId;                     // コーディネータID
    private List<String> participantIds = new ArrayList<>(); // 参加者IDリスト
    private int timeout = 120;                         // タイムアウト（秒）
    private DistributedTransactionType type = DistributedTransactionType.TWO_PHASE_COMMIT; // トランザクション種別
    private Map<String, Object> properties = new HashMap<>(); // 追加プロパティ
    
    // getters, setters, and builder methods
}
```

### 3.4 ParticipantConfig

分散トランザクション参加者の設定を表すDTOです。

```java
public class ParticipantConfig {
    private String participantId;         // 参加者ID
    private String endpoint;              // エンドポイントURL
    private String resourceManagerName;   // リソースマネージャ名
    private int timeout = 60;             // タイムアウト（秒）
    private Map<String, Object> properties = new HashMap<>(); // 追加プロパティ
    
    // getters, setters, and builder methods
}
```

### 3.5 SagaDefinitionDto

SAGAプロセス定義を表すDTOです。

```java
public class SagaDefinitionDto {
    private String id;                      // 定義ID
    private String name;                    // 名前
    private String description;             // 説明
    private Integer version;                // バージョン
    private List<SagaStepDto> steps = new ArrayList<>(); // ステップリスト
    private boolean active = true;          // 有効フラグ
    
    // getters, setters, and builder methods
}
```

### 3.6 SagaStepDto

SAGAステップ定義を表すDTOです。

```java
public class SagaStepDto {
    private String stepId;                  // ステップID
    private String serviceId;               // サービスID
    private String actionName;              // アクション名
    private String compensationActionName;  // 補償アクション名
    private Integer order;                  // 実行順序
    private Integer timeout = 60;           // タイムアウト（秒）
    private RetryPolicyDto retryPolicy;     // リトライポリシー
    
    // getters, setters, and builder methods
}
```

### 3.7 TransactionLogSearchCriteria

トランザクションログ検索条件を表すDTOです。

```java
public class TransactionLogSearchCriteria {
    private Set<String> transactionIds;      // トランザクションIDリスト
    private Set<TransactionEventType> eventTypes; // イベント種別リスト
    private LocalDateTime startTime;         // 開始時間
    private LocalDateTime endTime;           // 終了時間
    private Boolean successful;              // 成功フラグ
    private String resourceName;             // リソース名
    private String errorCode;                // エラーコード
    
    // getters, setters, and builder methods
}
```

## 4. API エンドポイント

### 4.1 管理用REST API

トランザクション管理機能は、運用管理のための以下のREST APIエンドポイントを提供します。

#### 4.1.1 アクティブトランザクション管理API

| メソッド | パス | 説明 | リクエスト | レスポンス | ステータスコード |
|--------|-----|------|-----------|-----------|--------------|
| GET | /api/transactions | アクティブなトランザクション一覧取得 | - | TransactionSummaryDto[] | 200 OK |
| GET | /api/transactions/{id} | トランザクション詳細取得 | - | TransactionDetailDto | 200 OK, 404 Not Found |
| POST | /api/transactions/{id}/force-terminate | トランザクション強制終了 | - | TerminationResultDto | 200 OK, 404 Not Found |

#### 4.1.2 分散トランザクション管理API

| メソッド | パス | 説明 | リクエスト | レスポンス | ステータスコード |
|--------|-----|------|-----------|-----------|--------------|
| GET | /api/distributed-transactions | 分散トランザクション一覧取得 | - | DistributedTransactionSummaryDto[] | 200 OK |
| GET | /api/distributed-transactions/{id} | 分散トランザクション詳細取得 | - | DistributedTransactionDetailDto | 200 OK, 404 Not Found |
| POST | /api/distributed-transactions/{id}/resolve | 未解決トランザクション解決 | ResolutionActionDto | ResolutionResultDto | 200 OK, 404 Not Found |

#### 4.1.3 SAGAプロセス管理API

| メソッド | パス | 説明 | リクエスト | レスポンス | ステータスコード |
|--------|-----|------|-----------|-----------|--------------|
| GET | /api/saga-definitions | SAGA定義一覧取得 | - | SagaDefinitionSummaryDto[] | 200 OK |
| GET | /api/saga-definitions/{id} | SAGA定義詳細取得 | - | SagaDefinitionDto | 200 OK, 404 Not Found |
| POST | /api/saga-definitions | SAGA定義登録 | SagaDefinitionDto | SagaDefinitionDto | 201 Created |
| PUT | /api/saga-definitions/{id} | SAGA定義更新 | SagaDefinitionDto | SagaDefinitionDto | 200 OK, 404 Not Found |
| GET | /api/saga-executions | SAGA実行一覧取得 | - | SagaExecutionSummaryDto[] | 200 OK |
| GET | /api/saga-executions/{id} | SAGA実行詳細取得 | - | SagaExecutionDetailDto | 200 OK, 404 Not Found |
| POST | /api/saga-executions/{id}/abort | SAGA実行中止 | - | AbortResultDto | 200 OK, 404 Not Found |

#### 4.1.4 トランザクションログAPI

| メソッド | パス | 説明 | リクエスト | レスポンス | ステータスコード |
|--------|-----|------|-----------|-----------|--------------|
| GET | /api/transaction-logs | トランザクションログ検索 | TransactionLogSearchCriteria | Page<TransactionLogDto> | 200 OK |
| GET | /api/transaction-logs/transaction/{id} | トランザクションのログ取得 | - | TransactionLogDto[] | 200 OK |
| GET | /api/transaction-logs/statistics | トランザクションログ統計情報取得 | - | TransactionStatisticsDto | 200 OK |

### 4.2 JMXエンドポイント

トランザクション管理機能は、監視・管理のために以下のJMXエンドポイントを提供します。

#### 4.2.1 TransactionManagerMXBean

```java
public interface TransactionManagerMXBean {
    // 属性
    int getActiveTransactionCount();
    long getTotalTransactionCount();
    long getCommittedTransactionCount();
    long getRolledBackTransactionCount();
    long getTransactionTimeoutSeconds();
    double getAverageTransactionDurationMs();
    
    // 操作
    void setDefaultTimeout(int seconds);
    String[] listActiveTransactions();
    boolean forceTerminateTransaction(String transactionId);
    Map<String, Object> getTransactionStatistics();
}
```

#### 4.2.2 DistributedTransactionManagerMXBean

```java
public interface DistributedTransactionManagerMXBean {
    // 属性
    int getActiveDistributedTransactionCount();
    long getTotalDistributedTransactionCount();
    long getSuccessfulDistributedTransactionCount();
    long getFailedDistributedTransactionCount();
    long getInDoubtTransactionCount();
    
    // 操作
    String[] listActiveDistributedTransactions();
    String[] listInDoubtTransactions();
    boolean resolveInDoubtTransaction(String transactionId, String resolution);
    int recoverInDoubtTransactions();
    Map<String, Object> getDistributedTransactionStatistics();
}
```

## 5. 依存インターフェース

トランザクション管理機能が依存する外部システムインターフェースを定義します。

### 5.1 PlatformTransactionManager

Spring Framework互換のトランザクションマネージャインターフェースです。

```java
public interface PlatformTransactionManager {
    /**
     * 指定された属性に従ってトランザクションを開始する
     * @param definition トランザクション定義
     * @return トランザクションステータス
     */
    TransactionStatus getTransaction(TransactionDefinition definition);
    
    /**
     * 現在のトランザクションをコミットする
     * @param status トランザクションステータス
     */
    void commit(TransactionStatus status);
    
    /**
     * 現在のトランザクションをロールバックする
     * @param status トランザクションステータス
     */
    void rollback(TransactionStatus status);
}
```

### 5.2 TransactionOperations

Spring Framework互換のトランザクション操作インターフェースです。

```java
public interface TransactionOperations {
    /**
     * トランザクション内で処理を実行する
     * @param action 実行する処理
     * @param <T> 戻り値の型
     * @return 処理結果
     */
    <T> T execute(TransactionCallback<T> action);
}
```

### 5.3 ResourceManager

分散トランザクションで利用するリソースマネージャインターフェースです。

```java
public interface ResourceManager {
    /**
     * リソースマネージャの一意識別子を取得する
     * @return リソースマネージャID
     */
    String getResourceManagerId();
    
    /**
     * トランザクションの準備処理を実行する
     * @param xid トランザクション識別子
     * @return 準備結果
     * @throws XAException XA例外
     */
    int prepare(Xid xid) throws XAException;
    
    /**
     * トランザクションをコミットする
     * @param xid トランザクション識別子
     * @param onePhase 1フェーズコミットか
     * @throws XAException XA例外
     */
    void commit(Xid xid, boolean onePhase) throws XAException;
    
    /**
     * トランザクションをロールバックする
     * @param xid トランザクション識別子
     * @throws XAException XA例外
     */
    void rollback(Xid xid) throws XAException;
    
    /**
     * 未解決トランザクションのリストを取得する
     * @return 未解決トランザクションのXID配列
     * @throws XAException XA例外
     */
    Xid[] recover(int flag) throws XAException;
}
```

### 5.4 MetricsRegistry

メトリクス登録のためのインターフェースです。

```java
public interface MetricsRegistry {
    /**
     * カウンターメトリクスを登録する
     * @param name メトリクス名
     * @param description 説明
     * @return カウンターメトリクス
     */
    Counter registerCounter(String name, String description);
    
    /**
     * ゲージメトリクスを登録する
     * @param name メトリクス名
     * @param description 説明
     * @param supplier 値の供給元
     */
    <T> void registerGauge(String name, String description, Supplier<T> supplier);
    
    /**
     * タイマーメトリクスを登録する
     * @param name メトリクス名
     * @param description 説明
     * @return タイマーメトリクス
     */
    Timer registerTimer(String name, String description);
}
```

### 5.5 EventPublisher

イベント発行のためのインターフェースです。

```java
public interface EventPublisher {
    /**
     * イベントを発行する
     * @param event 発行するイベント
     */
    void publishEvent(Object event);
}
```

## 6. 例外階層

トランザクション管理機能が発生させる主な例外クラスを定義します。

### 6.1 TransactionException

トランザクション処理の基本例外クラスです。

```java
public class TransactionException extends RuntimeException {
    private final String transactionId;
    
    public TransactionException(String message) {
        super(message);
        this.transactionId = null;
    }
    
    public TransactionException(String message, String transactionId) {
        super(message);
        this.transactionId = transactionId;
    }
    
    public TransactionException(String message, Throwable cause) {
        super(message, cause);
        this.transactionId = null;
    }
    
    public TransactionException(String message, String transactionId, Throwable cause) {
        super(message, cause);
        this.transactionId = transactionId;
    }
    
    public String getTransactionId() {
        return transactionId;
    }
}
```

### 6.2 派生例外クラス

以下の例外クラスは `TransactionException` から派生します。

```java
// トランザクションが存在しない場合の例外
public class NoTransactionException extends TransactionException {
    public NoTransactionException(String message) {
        super(message);
    }
}

// トランザクションの作成に失敗した場合の例外
public class TransactionCreationException extends TransactionException {
    public TransactionCreationException(String message) {
        super(message);
    }
    
    public TransactionCreationException(String message, Throwable cause) {
        super(message, cause);
    }
}

// トランザクションのコミットに失敗した場合の例外
public class TransactionCommitException extends TransactionException {
    public TransactionCommitException(String message, String transactionId) {
        super(message, transactionId);
    }
    
    public TransactionCommitException(String message, String transactionId, Throwable cause) {
        super(message, transactionId, cause);
    }
}

// トランザクションのロールバックに失敗した場合の例外
public class TransactionRollbackException extends TransactionException {
    public TransactionRollbackException(String message, String transactionId) {
        super(message, transactionId);
    }
    
    public TransactionRollbackException(String message, String transactionId, Throwable cause) {
        super(message, transactionId, cause);
    }
}

// トランザクションがタイムアウトした場合の例外
public class TransactionTimeoutException extends TransactionException {
    public TransactionTimeoutException(String message, String transactionId) {
        super(message, transactionId);
    }
}

// システム関連のトランザクションエラーの例外
public class TransactionSystemException extends TransactionException {
    public TransactionSystemException(String message) {
        super(message);
    }
    
    public TransactionSystemException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

### 6.3 分散トランザクション例外

分散トランザクション関連の例外クラスです。

```java
// 分散トランザクション基本例外
public class DistributedTransactionException extends TransactionException {
    public DistributedTransactionException(String message, String transactionId) {
        super(message, transactionId);
    }
    
    public DistributedTransactionException(String message, String transactionId, Throwable cause) {
        super(message, transactionId, cause);
    }
}

// 分散トランザクション通信エラー例外
public class DistributedTransactionCommunicationException extends DistributedTransactionException {
    private final String participantId;
    
    public DistributedTransactionCommunicationException(String message, String transactionId, 
                                                       String participantId) {
        super(message, transactionId);
        this.participantId = participantId;
    }
    
    public String getParticipantId() {
        return participantId;
    }
}

// 分散トランザクション参加者エラー例外
public class ParticipantException extends DistributedTransactionException {
    private final String participantId;
    private final String errorCode;
    
    public ParticipantException(String message, String transactionId, 
                               String participantId, String errorCode) {
        super(message, transactionId);
        this.participantId = participantId;
        this.errorCode = errorCode;
    }
    
    public String getParticipantId() {
        return participantId;
    }
    
    public String getErrorCode() {
        return errorCode;
    }
}
```

### 6.4 SAGAパターン例外

SAGAパターン関連の例外クラスです。

```java
// SAGA基本例外
public class SagaException extends RuntimeException {
    private final String sagaExecutionId;
    
    public SagaException(String message, String sagaExecutionId) {
        super(message);
        this.sagaExecutionId = sagaExecutionId;
    }
    
    public SagaException(String message, String sagaExecutionId, Throwable cause) {
        super(message, cause);
        this.sagaExecutionId = sagaExecutionId;
    }
    
    public String getSagaExecutionId() {
        return sagaExecutionId;
    }
}

// SAGAステップ実行例外
public class SagaStepExecutionException extends SagaException {
    private final String stepId;
    
    public SagaStepExecutionException(String message, String sagaExecutionId, String stepId) {
        super(message, sagaExecutionId);
        this.stepId = stepId;
    }
    
    public SagaStepExecutionException(String message, String sagaExecutionId, 
                                     String stepId, Throwable cause) {
        super(message, sagaExecutionId, cause);
        this.stepId = stepId;
    }
    
    public String getStepId() {
        return stepId;
    }
}

// SAGA補償トランザクション例外
public class SagaCompensationException extends SagaException {
    private final String stepId;
    
    public SagaCompensationException(String message, String sagaExecutionId, String stepId) {
        super(message, sagaExecutionId);
        this.stepId = stepId;
    }
    
    public SagaCompensationException(String message, String sagaExecutionId, 
                                   String stepId, Throwable cause) {
        super(message, sagaExecutionId, cause);
        this.stepId = stepId;
    }
    
    public String getStepId() {
        return stepId;
    }
}
```

## 7. イベント定義

トランザクション管理機能が発行する主なイベントを定義します。

### 7.1 トランザクションイベント基本クラス

```java
public abstract class TransactionEvent {
    private final String transactionId;
    private final LocalDateTime timestamp;
    
    protected TransactionEvent(String transactionId) {
        this.transactionId = transactionId;
        this.timestamp = LocalDateTime.now();
    }
    
    public String getTransactionId() {
        return transactionId;
    }
    
    public LocalDateTime getTimestamp() {
        return timestamp;
    }
}
```

### 7.2 トランザクションライフサイクルイベント

```java
// トランザクション開始イベント
public class TransactionStartedEvent extends TransactionEvent {
    private final PropagationBehavior propagation;
    private final IsolationLevel isolation;
    private final boolean readOnly;
    private final Integer timeout;
    
    public TransactionStartedEvent(String transactionId, PropagationBehavior propagation,
                                 IsolationLevel isolation, boolean readOnly, Integer timeout) {
        super(transactionId);
        this.propagation = propagation;
        this.isolation = isolation;
        this.readOnly = readOnly;
        this.timeout = timeout;
    }
    
    // getters
}

// トランザクションコミットイベント
public class TransactionCommittedEvent extends TransactionEvent {
    private final long executionTimeMs;
    
    public TransactionCommittedEvent(String transactionId, long executionTimeMs) {
        super(transactionId);
        this.executionTimeMs = executionTimeMs;
    }
    
    public long getExecutionTimeMs() {
        return executionTimeMs;
    }
}

// トランザクションロールバックイベント
public class TransactionRolledBackEvent extends TransactionEvent {
    private final long executionTimeMs;
    private final String reason;
    private final Throwable cause;
    
    public TransactionRolledBackEvent(String transactionId, long executionTimeMs, 
                                    String reason, Throwable cause) {
        super(transactionId);
        this.executionTimeMs = executionTimeMs;
        this.reason = reason;
        this.cause = cause;
    }
    
    // getters
}

// トランザクションタイムアウトイベント
public class TransactionTimeoutEvent extends TransactionEvent {
    private final long executionTimeMs;
    
    public TransactionTimeoutEvent(String transactionId, long executionTimeMs) {
        super(transactionId);
        this.executionTimeMs = executionTimeMs;
    }
    
    public long getExecutionTimeMs() {
        return executionTimeMs;
    }
}
```

### 7.3 分散トランザクションイベント

```java
// 分散トランザクション開始イベント
public class DistributedTransactionStartedEvent extends TransactionEvent {
    private final DistributedTransactionType type;
    private final List<String> participantIds;
    
    public DistributedTransactionStartedEvent(String transactionId, 
                                           DistributedTransactionType type,
                                           List<String> participantIds) {
        super(transactionId);
        this.type = type;
        this.participantIds = participantIds;
    }
    
    // getters
}

// 分散トランザクションフェーズ変更イベント
public class DistributedTransactionPhaseChangedEvent extends TransactionEvent {
    private final TransactionPhase previousPhase;
    private final TransactionPhase newPhase;
    
    public DistributedTransactionPhaseChangedEvent(String transactionId, 
                                               TransactionPhase previousPhase,
                                               TransactionPhase newPhase) {
        super(transactionId);
        this.previousPhase = previousPhase;
        this.newPhase = newPhase;
    }
    
    // getters
}

// 分散トランザクション完了イベント
public class DistributedTransactionCompletedEvent extends TransactionEvent {
    private final DistributedTransactionStatus status;
    private final long totalExecutionTimeMs;
    private final Map<String, ParticipantResult> participantResults;
    
    public DistributedTransactionCompletedEvent(String transactionId, 
                                             DistributedTransactionStatus status,
                                             long totalExecutionTimeMs,
                                             Map<String, ParticipantResult> participantResults) {
        super(transactionId);
        this.status = status;
        this.totalExecutionTimeMs = totalExecutionTimeMs;
        this.participantResults = participantResults;
    }
    
    // getters
}
```

### 7.4 SAGAイベント

```java
// SAGA開始イベント
public class SagaStartedEvent {
    private final String sagaExecutionId;
    private final String sagaDefinitionId;
    private final LocalDateTime timestamp;
    private final Map<String, Object> initialData;
    
    public SagaStartedEvent(String sagaExecutionId, String sagaDefinitionId, 
                          Map<String, Object> initialData) {
        this.sagaExecutionId = sagaExecutionId;
        this.sagaDefinitionId = sagaDefinitionId;
        this.timestamp = LocalDateTime.now();
        this.initialData = initialData;
    }
    
    // getters
}

// SAGAステップ実行イベント
public class SagaStepExecutedEvent {
    private final String sagaExecutionId;
    private final String stepId;
    private final LocalDateTime timestamp;
    private final boolean successful;
    private final Map<String, Object> resultData;
    private final Throwable error;
    
    public SagaStepExecutedEvent(String sagaExecutionId, String stepId, 
                               boolean successful, Map<String, Object> resultData,
                               Throwable error) {
        this.sagaExecutionId = sagaExecutionId;
        this.stepId = stepId;
        this.timestamp = LocalDateTime.now();
        this.successful = successful;
        this.resultData = resultData;
        this.error = error;
    }
    
    // getters
}

// SAGA完了イベント
public class SagaCompletedEvent {
    private final String sagaExecutionId;
    private final LocalDateTime timestamp;
    private final boolean successful;
    private final Map<String, Object> resultData;
    private final List<String> executedSteps;
    private final List<String> compensatedSteps;
    
    public SagaCompletedEvent(String sagaExecutionId, boolean successful,
                            Map<String, Object> resultData, List<String> executedSteps,
                            List<String> compensatedSteps) {
        this.sagaExecutionId = sagaExecutionId;
        this.timestamp = LocalDateTime.now();
        this.successful = successful;
        this.resultData = resultData;
        this.executedSteps = executedSteps;
        this.compensatedSteps = compensatedSteps;
    }
    
    // getters
}
```

## 8. クライアント使用例

### 8.1 宣言的トランザクション（アノテーション使用）

```java
@Service
public class OrderService {
    private final OrderRepository orderRepository;
    private final InventoryService inventoryService;
    private final PaymentService paymentService;
    
    @Autowired
    public OrderService(OrderRepository orderRepository,
                        InventoryService inventoryService,
                        PaymentService paymentService) {
        this.orderRepository = orderRepository;
        this.inventoryService = inventoryService;
        this.paymentService = paymentService;
    }
    
    // 標準的なトランザクション
    @Transactional
    public Order createOrder(OrderRequest request) {
        // 注文エンティティの作成と保存
        Order order = new Order();
        order.setCustomerId(request.getCustomerId());
        order.setOrderDate(LocalDateTime.now());
        order.setStatus(OrderStatus.PENDING);
        order = orderRepository.save(order);
        
        // 在庫チェックと更新
        for (OrderItemRequest itemRequest : request.getItems()) {
            inventoryService.reserveInventory(itemRequest.getProductId(), itemRequest.getQuantity());
            OrderItem item = new OrderItem();
            item.setOrder(order);
            item.setProductId(itemRequest.getProductId());
            item.setQuantity(itemRequest.getQuantity());
            item.setPrice(itemRequest.getPrice());
            order.getItems().add(item);
        }
        
        // 更新された注文を保存
        order = orderRepository.save(order);
        
        return order;
    }
    
    // 読み取り専用トランザクション
    @Transactional(readOnly = true)
    public Order getOrderDetails(String orderId) {
        return orderRepository.findById(orderId)
            .orElseThrow(() -> new OrderNotFoundException(orderId));
    }
    
    // カスタムトランザクション設定
    @Transactional(propagation = Propagation.REQUIRES_NEW,
                  isolation = Isolation.SERIALIZABLE,
                  timeout = 30,
                  rollbackFor = {OrderProcessingException.class},
                  noRollbackFor = {InventoryWarningException.class})
    public Order processOrderPayment(String orderId, PaymentDetails paymentDetails) {
        Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new OrderNotFoundException(orderId));
            
        // 支払い処理
        PaymentResult result = paymentService.processPayment(
            order.getCustomerId(), order.getTotalAmount(), paymentDetails);
            
        if (result.isSuccessful()) {
            order.setPaymentId(result.getPaymentId());
            order.setStatus(OrderStatus.PAID);
            return orderRepository.save(order);
        } else {
            throw new OrderProcessingException("Payment failed: " + result.getErrorMessage());
        }
    }
}
```

### 8.2 プログラム的トランザクション（TransactionTemplate使用）

```java
@Service
public class InventoryService {
    private final InventoryRepository inventoryRepository;
    private final ProductRepository productRepository;
    private final TransactionTemplate transactionTemplate;
    private final TransactionTemplate readOnlyTransactionTemplate;
    
    @Autowired
    public InventoryService(InventoryRepository inventoryRepository,
                          ProductRepository productRepository,
                          PlatformTransactionManager transactionManager) {
        this.inventoryRepository = inventoryRepository;
        this.productRepository = productRepository;
        
        // 標準トランザクションテンプレート
        this.transactionTemplate = new TransactionTemplate();
        this.transactionTemplate.setTransactionManager(transactionManager);
        this.transactionTemplate.setTimeout(60);
        
        // 読み取り専用トランザクションテンプレート
        this.readOnlyTransactionTemplate = new TransactionTemplate();
        this.readOnlyTransactionTemplate.setTransactionManager(transactionManager);
        this.readOnlyTransactionTemplate.setReadOnly(true);
    }
    
    public InventoryLevel reserveInventory(String productId, int quantity) {
        return transactionTemplate.execute(status -> {
            try {
                // 在庫の取得
                InventoryLevel inventory = inventoryRepository.findByProductId(productId)
                    .orElseThrow(() -> new ProductNotFoundException(productId));
                
                // 在庫が十分かチェック
                if (inventory.getAvailableQuantity() < quantity) {
                    throw new InsufficientInventoryException(
                        productId, quantity, inventory.getAvailableQuantity());
                }
                
                // 在庫を更新
                inventory.setReservedQuantity(inventory.getReservedQuantity() + quantity);
                inventory.setLastUpdated(LocalDateTime.now());
                
                return inventoryRepository.save(inventory);
            } catch (Exception e) {
                // 明示的にロールバックをマーク
                status.setRollbackOnly();
                throw e;
            }
        });
    }
    
    public Map<String, InventoryLevel> getInventoryLevelsForProducts(List<String> productIds) {
        return readOnlyTransactionTemplate.execute(status -> {
            Map<String, InventoryLevel> result = new HashMap<>();
            
            for (String productId : productIds) {
                inventoryRepository.findByProductId(productId)
                    .ifPresent(level -> result.put(productId, level));
            }
            
            return result;
        });
    }
    
    public void bulkUpdateInventory(List<InventoryUpdateRequest> updates) {
        // カスタムトランザクション設定
        TransactionTemplate customTemplate = new TransactionTemplate();
        customTemplate.setTransactionManager(transactionTemplate.getTransactionManager());
        customTemplate.setPropagationBehavior(PropagationBehavior.REQUIRES_NEW);
        customTemplate.setIsolationLevel(IsolationLevel.REPEATABLE_READ);
        
        customTemplate.execute(status -> {
            for (InventoryUpdateRequest update : updates) {
                InventoryLevel inventory = inventoryRepository.findByProductId(update.getProductId())
                    .orElseGet(() -> {
                        // 新しい在庫レコードを作成
                        InventoryLevel newInventory = new InventoryLevel();
                        newInventory.setProductId(update.getProductId());
                        newInventory.setWarehouseId(update.getWarehouseId());
                        return newInventory;
                    });
                
                // 在庫を更新
                inventory.setTotalQuantity(update.getNewTotalQuantity());
                inventory.setAvailableQuantity(update.getNewAvailableQuantity());
                inventory.setLastUpdated(LocalDateTime.now());
                
                inventoryRepository.save(inventory);
            }
            
            return null;
        });
    }
}
```

### 8.3 分散トランザクション管理

```java
@Service
public class OrderProcessingService {
    private final OrderRepository orderRepository;
    private final DistributedTransactionManager dtxManager;
    private final InventoryServiceClient inventoryServiceClient;
    private final PaymentServiceClient paymentServiceClient;
    private final ShippingServiceClient shippingServiceClient;
    
    @Autowired
    public OrderProcessingService(OrderRepository orderRepository,
                                DistributedTransactionManager dtxManager,
                                InventoryServiceClient inventoryServiceClient,
                                PaymentServiceClient paymentServiceClient,
                                ShippingServiceClient shippingServiceClient) {
        this.orderRepository = orderRepository;
        this.dtxManager = dtxManager;
        this.inventoryServiceClient = inventoryServiceClient;
        this.paymentServiceClient = paymentServiceClient;
        this.shippingServiceClient = shippingServiceClient;
    }
    
    public OrderResult processOrderWithTwoPhaseCommit(OrderRequest request) {
        // 分散トランザクション設定
        DistributedTransactionConfig config = new DistributedTransactionConfig();
        config.setType(DistributedTransactionType.TWO_PHASE_COMMIT);
        config.setTimeout(120); // seconds
        config.getParticipantIds().add("inventory-service");
        config.getParticipantIds().add("payment-service");
        config.getParticipantIds().add("shipping-service");
        
        // トランザクションID生成
        String transactionId = dtxManager.beginDistributedTransaction(config);
        
        try {
            // 注文エンティティの作成（ローカルトランザクション）
            Order order = createOrder(request, transactionId);
            
            // 各サービスをトランザクションに参加させる
            ParticipantConfig inventoryConfig = new ParticipantConfig();
            inventoryConfig.setParticipantId("inventory-service");
            inventoryConfig.setEndpoint(inventoryServiceClient.getTransactionEndpoint());
            dtxManager.enlistParticipant(transactionId, inventoryConfig);
            
            ParticipantConfig paymentConfig = new ParticipantConfig();
            paymentConfig.setParticipantId("payment-service");
            paymentConfig.setEndpoint(paymentServiceClient.getTransactionEndpoint());
            dtxManager.enlistParticipant(transactionId, paymentConfig);
            
            ParticipantConfig shippingConfig = new ParticipantConfig();
            shippingConfig.setParticipantId("shipping-service");
            shippingConfig.setEndpoint(shippingServiceClient.getTransactionEndpoint());
            dtxManager.enlistParticipant(transactionId, shippingConfig);
            
            // 在庫サービス呼び出し
            boolean inventorySuccess = inventoryServiceClient.reserveInventory(
                order.getItems(), transactionId);
            
            // 支払いサービス呼び出し
            boolean paymentSuccess = paymentServiceClient.processPayment(
                order.getCustomerId(), order.getTotalAmount(), request.getPaymentDetails(), 
                transactionId);
            
            // 配送サービス呼び出し
            boolean shippingSuccess = shippingServiceClient.scheduleDelivery(
                order.getId(), request.getShippingAddress(), transactionId);
            
            // すべて成功したら準備フェーズを実行
            if (inventorySuccess && paymentSuccess && shippingSuccess) {
                PrepareResult prepareResult = dtxManager.prepare(transactionId);
                
                if (prepareResult.isAllPrepared()) {
                    // コミットフェーズ実行
                    dtxManager.commit(transactionId);
                    return new OrderResult(order.getId(), OrderStatus.COMPLETED, null);
                } else {
                    // 準備フェーズ失敗
                    dtxManager.rollback(transactionId);
                    return new OrderResult(order.getId(), OrderStatus.FAILED, 
                                         "Preparation phase failed: " + prepareResult.getFailureReason());
                }
            } else {
                // いずれかのサービス呼び出しが失敗
                dtxManager.rollback(transactionId);
                return new OrderResult(order.getId(), OrderStatus.FAILED, 
                                     "Service invocation failed");
            }
            
        } catch (Exception e) {
            // 例外発生時はロールバック
            dtxManager.rollback(transactionId);
            return new OrderResult(null, OrderStatus.FAILED, 
                                 "Order processing failed: " + e.getMessage());
        }
    }
    
    @Transactional
    private Order createOrder(OrderRequest request, String transactionId) {
        Order order = new Order();
        order.setCustomerId(request.getCustomerId());
        order.setOrderDate(LocalDateTime.now());
        order.setStatus(OrderStatus.PROCESSING);
        order.setTransactionId(transactionId);
        
        // 注文項目の作成
        for (OrderItemRequest itemRequest : request.getItems()) {
            OrderItem item = new OrderItem();
            item.setOrder(order);
            item.setProductId(itemRequest.getProductId());
            item.setQuantity(itemRequest.getQuantity());
            item.setPrice(itemRequest.getPrice());
            order.getItems().add(item);
        }
        
        return orderRepository.save(order);
    }
}
```

### 8.4 SAGAパターンによる処理

```java
@Service
public class OrderProcessingSagaService {
    private final OrderRepository orderRepository;
    private final SagaCoordinator sagaCoordinator;
    
    @Autowired
    public OrderProcessingSagaService(OrderRepository orderRepository,
                                    SagaCoordinator sagaCoordinator) {
        this.orderRepository = orderRepository;
        this.sagaCoordinator = sagaCoordinator;
    }
    
    public OrderResult processOrderWithSaga(OrderRequest request) {
        // ローカルトランザクションで注文を作成
        Order order = createInitialOrder(request);
        
        // SAGAプロセスの初期データを準備
        Map<String, Object> sagaData = new HashMap<>();
        sagaData.put("orderId", order.getId());
        sagaData.put("customerId", order.getCustomerId());
        sagaData.put("items", order.getItems().stream()
            .map(item -> Map.of(
                "productId", item.getProductId(),
                "quantity", item.getQuantity(),
                "price", item.getPrice()
            ))
            .collect(Collectors.toList()));
        sagaData.put("totalAmount", order.getTotalAmount());
        sagaData.put("shippingAddress", request.getShippingAddress());
        sagaData.put("paymentDetails", request.getPaymentDetails());
        
        try {
            // SAGAプロセスを開始
            String sagaExecutionId = sagaCoordinator.startSaga(
                "order-processing-saga", sagaData);
            
            // SAGAの実行が完了するまで定期的に状態をチェック
            SagaState sagaState;
            do {
                Thread.sleep(1000);
                sagaState = sagaCoordinator.getSagaState(sagaExecutionId);
            } while (sagaState.getStatus() == SagaStatusEnum.RUNNING);
            
            // 結果に基づいて注文状態を更新
            if (sagaState.getStatus() == SagaStatusEnum.COMPLETED) {
                updateOrderStatus(order.getId(), OrderStatus.COMPLETED);
                Map<String, Object> result = sagaState.getResult();
                return new OrderResult(order.getId(), OrderStatus.COMPLETED, null);
            } else {
                updateOrderStatus(order.getId(), OrderStatus.FAILED);
                return new OrderResult(order.getId(), OrderStatus.FAILED, 
                                     "Saga execution failed: " + sagaState.getErrorMessage());
            }
            
        } catch (Exception e) {
            updateOrderStatus(order.getId(), OrderStatus.FAILED);
            return new OrderResult(order.getId(), OrderStatus.FAILED, 
                                 "Order processing failed: " + e.getMessage());
        }
    }
    
    @Transactional
    private Order createInitialOrder(OrderRequest request) {
        Order order = new Order();
        order.setCustomerId(request.getCustomerId());
        order.setOrderDate(LocalDateTime.now());
        order.setStatus(OrderStatus.PENDING);
        
        // 注文項目の作成
        for (OrderItemRequest itemRequest : request.getItems()) {
            OrderItem item = new OrderItem();
            item.setOrder(order);
            item.setProductId(itemRequest.getProductId());
            item.setQuantity(itemRequest.getQuantity());
            item.setPrice(itemRequest.getPrice());
            order.getItems().add(item);
        }
        
        return orderRepository.save(order);
    }
    
    @Transactional
    private void updateOrderStatus(String orderId, OrderStatus status) {
        Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new OrderNotFoundException(orderId));
        order.setStatus(status);
        orderRepository.save(order);
    }
}
```

## 9. 設定例

### 9.1 Spring XMLベース設定例

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd">

    <!-- トランザクションマネージャ設定 -->
    <bean id="transactionManager" 
          class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>
    
    <!-- トランザクションテンプレート -->
    <bean id="transactionTemplate" 
          class="org.springframework.transaction.support.TransactionTemplate">
        <property name="transactionManager" ref="transactionManager"/>
    </bean>
    
    <!-- 読み取り専用トランザクションテンプレート -->
    <bean id="readOnlyTransactionTemplate" 
          class="org.springframework.transaction.support.TransactionTemplate">
        <property name="transactionManager" ref="transactionManager"/>
        <property name="readOnly" value="true"/>
    </bean>
    
    <!-- アノテーションドリブントランザクション設定 -->
    <tx:annotation-driven transaction-manager="transactionManager"/>
    
    <!-- 分散トランザクションマネージャ -->
    <bean id="distributedTransactionManager" 
          class="com.example.sesmgr.transaction.DistributedTransactionManagerImpl">
        <property name="transactionLogService" ref="transactionLogService"/>
        <property name="eventPublisher" ref="transactionEventPublisher"/>
    </bean>
    
    <!-- SAGAコーディネーター -->
    <bean id="sagaCoordinator" 
          class="com.example.sesmgr.transaction.saga.SagaCoordinatorImpl">
        <property name="sagaDefinitionRepository" ref="sagaDefinitionRepository"/>
        <property name="transactionLogService" ref="transactionLogService"/>
    </bean>
    
    <!-- トランザクションログサービス -->
    <bean id="transactionLogService" 
          class="com.example.sesmgr.transaction.log.TransactionLogServiceImpl">
        <property name="transactionLogRepository" ref="transactionLogRepository"/>
    </bean>
</beans>
```

### 9.2 Spring Javaベース設定例

```java
@Configuration
@EnableTransactionManagement
public class TransactionConfig {
    
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
    
    @Bean
    public TransactionTemplate transactionTemplate(PlatformTransactionManager transactionManager) {
        TransactionTemplate template = new TransactionTemplate();
        template.setTransactionManager(transactionManager);
        template.setTimeout(60); // 60秒
        return template;
    }
    
    @Bean
    public TransactionTemplate readOnlyTransactionTemplate(PlatformTransactionManager transactionManager) {
        TransactionTemplate template = new TransactionTemplate();
        template.setTransactionManager(transactionManager);
        template.setReadOnly(true);
        return template;
    }
    
    @Bean
    public DistributedTransactionManager distributedTransactionManager(
            TransactionLogService transactionLogService,
            TransactionEventPublisher eventPublisher) {
        DistributedTransactionManagerImpl manager = new DistributedTransactionManagerImpl();
        manager.setTransactionLogService(transactionLogService);
        manager.setEventPublisher(eventPublisher);
        return manager;
    }
    
    @Bean
    public SagaCoordinator sagaCoordinator(
            SagaDefinitionRepository sagaDefinitionRepository,
            TransactionLogService transactionLogService) {
        SagaCoordinatorImpl coordinator = new SagaCoordinatorImpl();
        coordinator.setSagaDefinitionRepository(sagaDefinitionRepository);
        coordinator.setTransactionLogService(transactionLogService);
        return coordinator;
    }
    
    @Bean
    public TransactionLogService transactionLogService(
            TransactionLogRepository transactionLogRepository) {
        TransactionLogServiceImpl service = new TransactionLogServiceImpl();
        service.setTransactionLogRepository(transactionLogRepository);
        return service;
    }
    
    @Bean
    public TransactionEventPublisher transactionEventPublisher() {
        return new TransactionEventPublisherImpl();
    }
}
```

### 9.3 トランザクション設定プロパティ例

```yaml
transaction:
  # ローカルトランザクション設定
  local:
    default-timeout: 60
    default-isolation: READ_COMMITTED
    rollback-on-commit-failure: true
    
  # 分散トランザクション設定
  distributed:
    coordinator-id: ses-mgr-coordinator
    timeout: 120
    max-participants: 10
    in-doubt-timeout: 300
    recovery-interval: 300
    
  # SAGAパターン設定
  saga:
    definition-path: classpath:saga-definitions/
    execution-timeout: 300
    async-execution: true
    thread-pool-size: 10
    max-retry-attempts: 3
    
  # ログ設定
  logging:
    enabled: true
    include-details: true
    retention-days: 30
```