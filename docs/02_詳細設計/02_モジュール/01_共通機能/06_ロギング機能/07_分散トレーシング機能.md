# 分散トレーシング機能

## 1. 機能概要

分散トレーシング機能は、マイクロサービスアーキテクチャや複雑なシステム内で、リクエストの流れを追跡し、処理の依存関係やボトルネックを可視化するための機能です。トレースIDとスパンIDを使用して関連する処理を紐付け、エンドツーエンドの処理フローと実行時間の分析を可能にします。

### 1.1 機能の目的

- 複数サービスにまたがるリクエストの追跡
- エンドツーエンドの処理フローの可視化
- サービス間の依存関係やレイテンシの把握
- 障害発生時の原因特定の効率化
- システム全体のパフォーマンス分析
- マイクロサービス間の処理連携の最適化

### 1.2 主要機能

- トレースIDとスパンIDによる関連処理の紐付け
- サービス間でのトレースコンテキスト伝播
- 分散トレーシング情報のログへの自動付加
- トレース情報の収集と可視化
- トレースデータのエクスポートとサードパーティ連携
- バゲージアイテムによる追加コンテキスト情報の伝播

## 2. 処理フロー

### 2.1 トレース生成と伝播の基本フロー

```
1. リクエスト受信
   a. 既存のトレースコンテキストの確認（HTTPヘッダなど）
   b. 既存のコンテキストがある場合は使用、ない場合は新規作成
   c. トレースIDとルートスパンIDの生成または抽出
   d. トレースコンテキストの初期化

2. サービス内処理
   a. 子スパンの作成と開始
   b. 処理の実行
   c. 子スパンの終了と記録

3. 外部サービス呼び出し
   a. トレースコンテキストの伝播準備（HTTPヘッダ設定など）
   b. 外部サービス呼び出し
   c. 外部サービスでのトレース継続

4. レスポンス返却
   a. ルートスパンの終了
   b. トレース情報の記録と送信
```

### 2.2 トレース情報収集フロー

```
1. トレースデータの生成
   a. 各処理ノードでのスパン情報記録
   b. タイミング情報（開始/終了時刻）の記録
   c. タグやアノテーションの追加

2. トレースデータの収集
   a. ログ出力を通じたトレース情報の収集
   b. 専用トレースエージェントによるデータ送信
   c. サンプリングポリシーの適用

3. トレースデータの処理
   a. トレースデータの解析と構造化
   b. スパン間の親子関係の構築
   c. トレースデータの永続化

4. トレースデータの可視化
   a. トレースフローの視覚化
   b. レイテンシヒートマップの生成
   c. サービス依存関係図の生成
```

### 2.3 分散トレースのマージフロー

```
1. 分散したトレース情報の収集
   a. 各サービスからのトレースデータ収集
   b. トレースIDによるグルーピング
   c. タイムスタンプによる順序付け

2. トレースデータのマージ
   a. 親子関係に基づくスパンの連結
   b. 欠損データの検出とハンドリング
   c. 整合性チェックとエラー処理

3. マージしたトレースの分析
   a. エンドツーエンドレイテンシの計算
   b. ボトルネックの特定
   c. 異常検出と警告通知
```

## 3. 主要コンポーネント構成

### 3.1 TracingContextImpl クラス

TracingContextインターフェースの実装クラスです。

#### 主要責務
- トレースIDとスパンIDの管理
- 子スパンの生成と親子関係の構築
- 現在のトレースコンテキスト情報の提供
- バゲージアイテム（メタデータ）の管理
- トレースコンテキストの伝播サポート
- スパンのライフサイクル（作成・終了）の管理

#### 主要メソッド
- `getCurrentTraceId()` - 現在のトレースIDを取得
- `getCurrentSpanId()` - 現在のスパンIDを取得
- `createChildSpan(String spanName)` - 子スパンを作成
- `closeCurrentSpan()` - 現在のスパンを終了
- `addBaggageItem(String key, String value)` - バゲージアイテムを追加
- `getBaggageItem(String key)` - バゲージアイテムを取得
- `getTraceContext()` - トレースコンテキスト情報をマップ形式で取得
- `setTraceContext(Map<String, String> traceContext)` - トレースコンテキストを設定

### 3.2 TraceLoggingFilter クラス

HTTPリクエストのトレースコンテキストを設定するフィルタークラスです。

#### 主要責務
- HTTPリクエストからトレースコンテキスト情報の抽出
- 新規リクエスト時のトレースID生成
- MDCへのトレース情報設定
- リクエスト処理の開始/終了ログ記録
- レスポンス送信時のクリーンアップ処理

#### 主要メソッド
- `doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)` - フィルタ処理の主メソッド
- `extractOrGenerateTraceId(HttpServletRequest request)` - リクエストからトレースIDを抽出または生成
- `generateTraceId()` - 新しいトレースIDを生成

### 3.3 TracedMethodAspect クラス

`@Traced`アノテーションを処理するAOPアスペクトクラスです。

#### 主要責務
- アノテーション付きメソッドのインターセプト
- スパン情報の自動生成（メソッド名に基づく）
- スパンの開始と終了の自動管理
- タグ情報の設定と管理
- エントリ/イグジットログの制御
- 例外発生時のエラー情報記録

#### 主要メソッド
- `traceMethod(ProceedingJoinPoint joinPoint)` - アノテーション処理の主メソッド
- カスタムタグの解析と追加機能
- 例外情報のスパンへの記録

### 3.4 RestTemplateTracingInterceptor クラス

RestTemplateでのトレース情報伝播を行うインターセプタークラスです。

#### 主要責務
- 外部サービス呼び出し時のトレース情報伝播
- HTTPリクエストヘッダーへのトレース情報設定
- 外部呼び出し用の子スパン生成
- 外部APIリクエストのトレースログ記録
- エラー発生時のトレース情報記録

#### 主要メソッド
- `intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution)` - インターセプト処理の主メソッド
- HTTPヘッダー設定メソッド
- スパン生成と管理メソッド
- エラーハンドリングメソッド

### 3.5 TraceExporter クラス

トレース情報をエクスポートするクラスです。

#### 主要責務
- トレースデータの収集と管理
- エクスポート先への送信処理
- バッファリングと定期的なフラッシュ
- トレースデータの永続化サポート
- サンプリング制御

#### 主要メソッド
- `registerTraceData(TraceData traceData)` - トレースデータを登録
- `exportTraces()` - トレースデータをエクスポート（定期実行）
- バッファリングとバッチ処理メソッド
- エクスポート先管理メソッド

## 4. 設定詳細

### 4.1 Spring Cloud Sleuthの設定

Spring Cloud Sleuthを使用した分散トレーシング設定例です。主な設定項目は以下の通りです：

- アプリケーション名設定
- Sleuthの有効化設定
- サンプリングレート設定
- バゲージ設定（相関フィールド、リモートフィールド）
- Zipkinとの連携設定
- サービス名設定
- 送信タイプ設定

### 4.2 RestTemplateの設定

RestTemplateに分散トレーシングを適用する設定です。主な設定ポイントは以下の通りです：

- トレーシングインターセプタの登録
- RestTemplateのカスタマイズ
- タイムアウト設定との連携
- エラーハンドラの登録

### 4.3 WebClientの設定

WebClientに分散トレーシングを適用する設定です。主な設定ポイントは以下の通りです：

- トレーシングフィルタの登録
- リアクティブなコンテキスト伝播の設定
- エラーハンドラの統合
- トレース情報抽出と注入の設定

## 5. 使用例

### 5.1 アノテーションを使用した宣言的トレース

```
// 基本的なトレースアノテーション
@Traced
public List<Contract> findContracts(ContractSearchCriteria criteria) {
    // 契約検索ロジック
    return contractRepository.findByCriteria(criteria);
}

// タグ付きトレースアノテーション
@Traced(tags = {"operation=create", "entity=contract"}, logEntry = true, logExit = true)
public Contract createContract(ContractDto contractDto) {
    // 契約作成ロジック
    Contract contract = new Contract();
    // 契約情報の設定
    
    return contractRepository.save(contract);
}

// 承認プロセスのトレース
@Traced(tags = {"operation=approve", "entity=contract"})
public Contract approveContract(String contractId, String approverId) {
    // 契約承認ロジック
    Contract contract = contractRepository.findById(contractId)
        .orElseThrow(() -> new NotFoundException("契約が見つかりません: " + contractId));
    
    // 承認処理
    contract.setApproved(true);
    contract.setApproverId(approverId);
    contract.setApprovedAt(LocalDateTime.now());
    
    return contractRepository.save(contract);
}
```

### 5.2 プログラムによる明示的なトレース

```
// 明示的なスパン管理
public Report generateReport(ReportRequest request) {
    // ルートスパンの作成
    String rootSpanName = "ReportGeneration";
    String rootSpanId = tracingContext.createChildSpan(rootSpanName);
    
    try {
        // MDCにスパンIDを設定
        logger.putMdc("spanId", rootSpanId);
        
        // レポート情報をトレースに追加
        tracingContext.addBaggageItem("reportType", request.getType());
        tracingContext.addBaggageItem("reportPeriod", request.getPeriodType());
        
        // 処理に進む
        return processReport(request);
        
    } finally {
        tracingContext.closeCurrentSpan();  // ルートスパンの終了
        logger.removeMdc("spanId");
    }
}

// 処理をネストしたスパンで分割
private Report processReport(ReportRequest request) {
    // データ収集スパンの作成
    String dataSpanId = tracingContext.createChildSpan("DataCollection");
    try {
        logger.putMdc("spanId", dataSpanId);
        logger.info("レポートデータ収集開始: type={}, period={}", 
                  request.getType(), request.getPeriodType());
        
        // データ収集処理
        ReportData reportData = collectReportData(request);
        
        logger.info("レポートデータ収集完了: {} レコード", reportData.getRecordCount());
        
        // レポート処理スパンの作成
        return createReportFromData(reportData);
        
    } finally {
        tracingContext.closeCurrentSpan();  // データ収集スパンの終了
    }
}

// さらに細かいスパン
private Report createReportFromData(ReportData reportData) {
    // レポート処理スパンの作成
    String reportSpanId = tracingContext.createChildSpan("ReportProcessing");
    try {
        logger.putMdc("spanId", reportSpanId);
        
        // レポート生成
        Report report = new Report();
        // レポート生成ロジック
        
        return report;
        
    } finally {
        tracingContext.closeCurrentSpan();  // レポート処理スパンの終了
    }
}
```

### 5.3 マイクロサービス間のトレース伝播

```
// RestTemplateを使用した外部サービス呼び出し
public InvoiceResponse generateInvoice(InvoiceRequest request) {
    // RestTemplateを使用した外部サービス呼び出し
    // トレース情報は自動的にヘッダーに追加される
    return restTemplate.postForObject(
        "http://billing-service/api/invoices",
        request,
        InvoiceResponse.class
    );
}

// 手動でトレース情報を設定する例
public PaymentResponse processPayment(PaymentRequest request) {
    // 現在のトレースコンテキストを取得
    Map<String, String> traceContext = tracingContext.getTraceContext();
    
    // HTTPヘッダーを準備
    HttpHeaders headers = new HttpHeaders();
    
    // トレース情報をヘッダーに追加
    if (traceContext.containsKey("traceId")) {
        headers.add("X-B3-TraceId", traceContext.get("traceId"));
    }
    
    if (traceContext.containsKey("spanId")) {
        // 現在のスパンIDを親スパンIDとして設定
        headers.add("X-B3-ParentSpanId", traceContext.get("spanId"));
    }
    
    // 新しいスパンIDを生成
    String spanId = tracingContext.createChildSpan("ProcessPayment");
    headers.add("X-B3-SpanId", spanId);
    
    // サンプリングフラグを追加
    headers.add("X-B3-Sampled", traceContext.getOrDefault("sampled", "1"));
    
    try {
        // HTTPエンティティの作成と外部サービス呼び出し
        HttpEntity<PaymentRequest> entity = new HttpEntity<>(request, headers);
        return restTemplate.exchange(
            "http://payment-service/api/payments",
            HttpMethod.POST,
            entity,
            PaymentResponse.class
        ).getBody();
        
    } finally {
        // スパンの終了
        tracingContext.closeCurrentSpan();
    }
}
```

### 5.4 非同期処理でのトレース伝播

```
// 非同期処理でトレースコンテキストを伝播する例
@Async
public CompletableFuture<ProcessingResult> processAsync(ProcessingRequest request) {
    // 現在のトレースコンテキストを取得
    Map<String, String> parentTraceContext = tracingContext.getTraceContext();
    
    // 現在のスレッドにトレースコンテキストを設定
    tracingContext.setTraceContext(parentTraceContext);
    
    // 新しいスパンを作成
    String spanId = tracingContext.createChildSpan("AsyncProcessing");
    
    try {
        // MDCにスパンIDを設定
        logger.putMdc("spanId", spanId);
        logger.info("非同期処理開始: requestId={}", request.getId());
        
        // 実際の処理
        ProcessingResult result = doProcess(request);
        
        logger.info("非同期処理終了: requestId={}", request.getId());
        return CompletableFuture.completedFuture(result);
        
    } catch (Exception e) {
        logger.error("非同期処理エラー: requestId={}, message={}", 
                   request.getId(), e.getMessage(), e);
        throw e;
        
    } finally {
        // スパンの終了
        tracingContext.closeCurrentSpan();
        
        // MDCのクリーンアップ
        logger.removeMdc("spanId");
    }
}
```

### 5.5 メッセージキューを介したトレース伝播

```
// メッセージキューにトレース情報を含めて送信する例
public void publishMessage(Object payload, String routingKey) {
    // 現在のトレースコンテキストを取得
    Map<String, String> traceContext = tracingContext.getTraceContext();
    
    // メッセージプロパティの作成
    MessageProperties properties = new MessageProperties();
    
    // トレース情報をヘッダーに追加
    if (traceContext.containsKey("traceId")) {
        properties.setHeader("X-B3-TraceId", traceContext.get("traceId"));
    }
    
    if (traceContext.containsKey("spanId")) {
        properties.setHeader("X-B3-ParentSpanId", traceContext.get("spanId"));
    }
    
    // 新しいスパンIDを生成
    String spanId = tracingContext.createChildSpan("PublishMessage");
    properties.setHeader("X-B3-SpanId", spanId);
    
    // サンプリングフラグを追加
    properties.setHeader("X-B3-Sampled", traceContext.getOrDefault("sampled", "1"));
    
    try {
        // MDCにスパンIDを設定
        logger.putMdc("spanId", spanId);
        
        // メッセージの構築と送信
        Message message = MessageBuilder
            .withBody(convertToBytes(payload))
            .andProperties(properties)
            .build();
        
        logger.info("メッセージ送信: routingKey={}", routingKey);
        rabbitTemplate.send(routingKey, message);
        
    } finally {
        // スパンの終了
        tracingContext.closeCurrentSpan();
        
        // MDCのクリーンアップ
        logger.removeMdc("spanId");
    }
}
```

## 6. 例外処理

### 6.1 トレースデータ生成の例外ハンドリング

トレースIDやスパンID生成時のエラーに対する例外処理を実装します。主なポイントは以下の通りです：

- トレースID生成の安全な実装
- UUID生成の例外対策
- 代替トレースID生成手段の提供
- エラーログ出力とリカバリ

### 6.2 トレースコンテキスト復元の例外ハンドリング

トレースコンテキストの復元や伝播処理の例外に対する処理を実装します。主なポイントは以下の通りです：

- 不正なトレースコンテキスト情報のチェック
- 欠損データの適切な処理
- コンテキスト回復の代替手段
- デフォルト値の提供

### 6.3 トレース情報伝播の例外ハンドリング

サービス間のトレース情報伝播時の例外に対する処理を実装します。主なポイントは以下の通りです：

- HTTPヘッダ操作の安全な実装
- エラー発生時のデフォルトトレース情報生成
- エラーのログ記録
- トレース情報なしでの処理継続

## 7. パフォーマンス考慮事項

### 7.1 サンプリングレートの最適化

トレース情報収集のオーバーヘッドを考慮し、適切なサンプリングレートを設定します。主なポイントは以下の通りです：

- 環境別サンプリングレート設定
- 重要な処理パスは常にサンプリング
- デバッグフラグによるオンデマンドサンプリング
- リソース使用状況に基づく動的サンプリング

### 7.2 部分的なトレース収集

すべての処理ではなく重要なポイントのみをトレースすることで、オーバーヘッドを削減します。主なポイントは以下の通りです：

- インクルード/エクスクルードパターンの設定
- 処理時間が短いメソッドのトレース除外
- 内部サービスコールのトレース最適化
- フレームワークコードのトレース除外

### 7.3 トレースデータの非同期処理

トレースデータの処理を非同期化することで、メインの処理への影響を最小限に抑えます。主なポイントは以下の通りです：

- 非同期エクスポート処理
- 専用エグゼキュータの使用
- エラーハンドリング
- リソース管理

### 7.4 トレースデータのバッファリング

トレースデータの送信頻度を調整し、バッチ処理することでネットワーク負荷を軽減します。主なポイントは以下の通りです：

- バッファキューの設定
- 定期的なフラッシュ処理
- バッファサイズ最適化
- バッファオーバーフロー対策

## 8. バージョン履歴

| バージョン | 更新日     | 担当者    | 変更内容                                |
|----------|------------|---------|--------------------------------------|
| 0.1      | 2023/10/01 | 山田太郎  | 初版作成                               |
| 0.2      | 2023/11/15 | 佐藤次郎  | メッセージキュー対応追加                   |
| 0.3      | 2024/01/20 | 鈴木三郎  | WebClient対応追加                      |
| 0.4      | 2024/05/10 | 一丸柴也  | 実装コードを削除し、設計情報のみに修正     |