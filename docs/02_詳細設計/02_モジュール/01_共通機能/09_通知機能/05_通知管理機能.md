# 通知機能 - 通知管理機能

## 1. 機能概要

通知管理機能は、通知の検索、表示、ステータス管理、設定管理など、通知のライフサイクル全体を管理する機能です。主に以下の責務を担います：

- 通知の検索と取得
- 通知の既読/未読管理
- 通知の削除とアーカイブ
- ユーザーごとの通知設定の管理
- 通知テンプレートの管理
- 通知統計情報の集計と分析

## 2. コンポーネント構成

### 2.1 NotificationRepository

通知の永続化と検索を担当するリポジトリコンポーネントです。

#### 責務
- 通知の保存と取得
- 検索条件に基づく通知の検索
- 通知のバッチ処理と集計

#### 主要メソッド

```
public interface NotificationRepository extends JpaRepository<Notification, UUID> {
    // ユーザーの通知を取得
    Page<Notification> findByRecipientUsernameOrderByCreatedAtDesc(
        String username, 
        Pageable pageable
    );
    
    // 未読通知を取得
    Page<Notification> findByRecipientUsernameAndReadOrderByCreatedAtDesc(
        String username, 
        boolean read, 
        Pageable pageable
    );
    
    // 特定タイプの通知を取得
    Page<Notification> findByRecipientUsernameAndTypeOrderByCreatedAtDesc(
        String username, 
        NotificationType type, 
        Pageable pageable
    );
    
    // 複合条件での検索
    Page<Notification> findByRecipientUsernameAndTypeAndReadOrderByCreatedAtDesc(
        String username, 
        NotificationType type, 
        boolean read, 
        Pageable pageable
    );
    
    // 未読通知数の取得
    long countByRecipientUsernameAndRead(String username, boolean read);
    
    // 特定期間の通知検索
    Page<Notification> findByRecipientUsernameAndCreatedAtBetweenOrderByCreatedAtDesc(
        String username, 
        LocalDateTime from, 
        LocalDateTime to, 
        Pageable pageable
    );
    
    // キーワード検索
    @Query("SELECT n FROM Notification n WHERE n.recipientUsername = :username " +
           "AND (LOWER(n.title) LIKE LOWER(CONCAT('%', :keyword, '%')) " +
           "OR LOWER(n.body) LIKE LOWER(CONCAT('%', :keyword, '%')))")
    Page<Notification> searchByKeyword(
        @Param("username") String username, 
        @Param("keyword") String keyword, 
        Pageable pageable
    );
    
    // メタデータ値による検索
    @Query("SELECT n FROM Notification n WHERE n.recipientUsername = :username " +
           "AND n.metadata->>'entityType' = :entityType " +
           "AND n.metadata->>'entityId' = :entityId")
    List<Notification> findByEntityReference(
        @Param("username") String username,
        @Param("entityType") String entityType,
        @Param("entityId") String entityId
    );
    
    // 古い通知をアーカイブ
    @Modifying
    @Query("UPDATE Notification n SET n.archived = true " +
           "WHERE n.createdAt < :cutoffDate AND n.archived = false")
    int archiveNotificationsCreatedBefore(@Param("cutoffDate") LocalDateTime cutoffDate);
    
    // 期限切れ通知を削除
    @Modifying
    @Query("DELETE FROM Notification n WHERE n.archived = true " +
           "AND n.createdAt < :cutoffDate")
    int deleteArchivedNotificationsCreatedBefore(@Param("cutoffDate") LocalDateTime cutoffDate);
}
```

#### クエリ最適化

- インデックス設計
  - recipient_username, created_at（降順）のインデックス
  - recipient_username, type, read のインデックス
  - recipient_username, archived のインデックス

- クエリチューニング
  - 頻繁にアクセスされる未読通知など頻出パターンのキャッシュ
  - 全文検索用の専用インデックス（タイトル、本文）
  - メタデータ用のJSON型インデックス

### 2.2 NotificationPreferenceRepository

通知設定の永続化と取得を担当するリポジトリコンポーネントです。

#### 責務
- ユーザーごとの通知設定の管理
- 通知タイプごとの設定管理
- デフォルト設定の提供

#### 主要メソッド

```
public interface NotificationPreferenceRepository extends JpaRepository<NotificationPreference, Long> {
    // ユーザーの全通知設定を取得
    List<NotificationPreference> findByUserUsername(String username);
    
    // 特定タイプの通知設定を取得
    Optional<NotificationPreference> findByUserUsernameAndNotificationType(
        String username, 
        NotificationType notificationType
    );
    
    // ユーザーのアプリ内通知が有効な通知タイプを取得
    @Query("SELECT np.notificationType FROM NotificationPreference np " +
           "WHERE np.userUsername = :username AND np.appEnabled = true")
    List<NotificationType> findAppEnabledTypesByUsername(@Param("username") String username);
    
    // ユーザーのメール通知が有効な通知タイプを取得
    @Query("SELECT np.notificationType FROM NotificationPreference np " +
           "WHERE np.userUsername = :username AND np.emailEnabled = true")
    List<NotificationType> findEmailEnabledTypesByUsername(@Param("username") String username);
    
    // 既存の設定がない場合はデフォルト設定を使用
    default NotificationPreference getPreferenceOrDefault(String username, NotificationType type) {
        return findByUserUsernameAndNotificationType(username, type)
                .orElseGet(() -> createDefaultPreference(username, type));
    }
    
    // デフォルト設定を作成
    default NotificationPreference createDefaultPreference(String username, NotificationType type) {
        NotificationPreference preference = new NotificationPreference();
        preference.setUserUsername(username);
        preference.setNotificationType(type);
        preference.setAppEnabled(true);
        preference.setEmailEnabled(type == NotificationType.ALERT || type == NotificationType.TASK);
        preference.setRetentionDays(type == NotificationType.ALERT ? 180 : 90);
        return preference;
    }
}
```

### 2.3 NotificationTemplateRepository

通知テンプレートの管理を担当するリポジトリコンポーネントです。

#### 責務
- テンプレートの保存と取得
- テンプレートの検索
- テンプレートの有効/無効管理

#### 主要メソッド

```
public interface NotificationTemplateRepository extends JpaRepository<NotificationTemplate, Long> {
    // キーでテンプレートを検索
    Optional<NotificationTemplate> findByTemplateKey(String templateKey);
    
    // 通知タイプによるテンプレート検索
    List<NotificationTemplate> findByNotificationType(NotificationType notificationType);
    
    // 有効なテンプレートのみ取得
    List<NotificationTemplate> findByActive(boolean active);
    
    // 通知タイプと有効フラグによる検索
    List<NotificationTemplate> findByNotificationTypeAndActive(
        NotificationType notificationType, 
        boolean active
    );
    
    // テンプレートキーの存在確認
    boolean existsByTemplateKey(String templateKey);
    
    // キーワードによるテンプレート検索
    @Query("SELECT t FROM NotificationTemplate t WHERE " +
           "LOWER(t.templateKey) LIKE LOWER(CONCAT('%', :keyword, '%')) OR " +
           "LOWER(t.titleTemplate) LIKE LOWER(CONCAT('%', :keyword, '%')) OR " +
           "LOWER(t.bodyTemplate) LIKE LOWER(CONCAT('%', :keyword, '%'))")
    List<NotificationTemplate> searchByKeyword(@Param("keyword") String keyword);
}
```

## 3. 通知管理機能の実装

### 3.1 通知のステータス管理

通知の状態遷移を管理する機能です。

#### 通知ステータス

通知は以下の状態を持ちます：

1. **作成済み (CREATED)**: 通知が作成されたが、まだ配信されていない状態
2. **配信済み (DELIVERED)**: 通知が配信され、ユーザーがアクセス可能になった状態
3. **既読 (READ)**: ユーザーが通知を閲覧した状態
4. **アーカイブ済み (ARCHIVED)**: 一定期間経過後、またはユーザーによってアーカイブされた状態
5. **削除済み (DELETED)**: ユーザーによって削除された状態

#### 状態遷移の実装

```java
@Service
public class NotificationStatusService {
    private final NotificationRepository repository;
    private final NotificationPreferenceRepository preferenceRepository;
    
    // コンストラクタ、依存性注入
    
    // 通知を既読にする
    @Transactional
    public Notification markAsRead(UUID notificationId, String username) {
        Notification notification = repository.findById(notificationId)
            .orElseThrow(() -> new NotificationNotFoundException("通知が見つかりません"));
            
        // アクセス権チェック
        if (!notification.getRecipient().getUsername().equals(username)) {
            throw new AccessDeniedException("この通知へのアクセス権がありません");
        }
        
        // 既に既読の場合は何もしない
        if (notification.isRead()) {
            return notification;
        }
        
        // 既読状態に更新
        notification.setRead(true);
        notification.setUpdatedAt(LocalDateTime.now());
        
        return repository.save(notification);
    }
    
    // 全ての未読通知を既読にする
    @Transactional
    public int markAllAsRead(String username, NotificationType type) {
        List<Notification> notifications;
        
        if (type != null) {
            notifications = repository.findByRecipientUsernameAndTypeAndRead(
                username, type, false, Pageable.unpaged()).getContent();
        } else {
            notifications = repository.findByRecipientUsernameAndRead(
                username, false, Pageable.unpaged()).getContent();
        }
        
        if (notifications.isEmpty()) {
            return 0;
        }
        
        LocalDateTime now = LocalDateTime.now();
        notifications.forEach(n -> {
            n.setRead(true);
            n.setUpdatedAt(now);
        });
        
        repository.saveAll(notifications);
        return notifications.size();
    }
    
    // 通知をアーカイブする
    @Transactional
    public void archiveNotification(UUID notificationId, String username) {
        Notification notification = repository.findById(notificationId)
            .orElseThrow(() -> new NotificationNotFoundException("通知が見つかりません"));
            
        // アクセス権チェック
        if (!notification.getRecipient().getUsername().equals(username)) {
            throw new AccessDeniedException("この通知へのアクセス権がありません");
        }
        
        // アーカイブ状態に更新
        notification.setArchived(true);
        notification.setUpdatedAt(LocalDateTime.now());
        
        repository.save(notification);
    }
    
    // 通知を削除する（論理削除）
    @Transactional
    public void deleteNotification(UUID notificationId, String username) {
        Notification notification = repository.findById(notificationId)
            .orElseThrow(() -> new NotificationNotFoundException("通知が見つかりません"));
            
        // アクセス権チェック
        if (!notification.getRecipient().getUsername().equals(username)) {
            throw new AccessDeniedException("この通知へのアクセス権がありません");
        }
        
        // 削除状態に更新
        notification.setDeleted(true);
        notification.setUpdatedAt(LocalDateTime.now());
        
        repository.save(notification);
    }
    
    // 期限切れの通知を自動アーカイブ
    @Scheduled(cron = "0 0 2 * * ?") // 毎日午前2時に実行
    @Transactional
    public void autoArchiveExpiredNotifications() {
        Map<NotificationType, Integer> retentionDaysMap = new HashMap<>();
        
        // デフォルトの保持期間を設定
        retentionDaysMap.put(NotificationType.SYSTEM, 90);
        retentionDaysMap.put(NotificationType.TASK, 90);
        retentionDaysMap.put(NotificationType.ALERT, 180);
        retentionDaysMap.put(NotificationType.EVENT, 60);
        
        // 各通知タイプに対して期限切れ通知をアーカイブ
        for (Map.Entry<NotificationType, Integer> entry : retentionDaysMap.entrySet()) {
            NotificationType type = entry.getKey();
            int retentionDays = entry.getValue();
            
            LocalDateTime cutoffDate = LocalDateTime.now().minusDays(retentionDays);
            
            repository.archiveByTypeAndCreatedBefore(type, cutoffDate);
        }
    }
}
```

### 3.2 通知の検索と取得

ユーザーの通知を検索し取得する機能です。

```java
@Service
public class NotificationQueryService {
    private final NotificationRepository repository;
    
    // コンストラクタ、依存性注入
    
    // ユーザーの通知を取得（フィルタリング・ページング対応）
    public Page<NotificationDto> getUserNotifications(
            String username,
            NotificationType type,
            Boolean readStatus,
            String keyword,
            LocalDateTime fromDate,
            LocalDateTime toDate,
            int page,
            int size,
            String sortBy,
            Sort.Direction direction) {
        
        // ページング・ソート情報の構築
        Pageable pageable = PageRequest.of(
            page, 
            size, 
            Sort.by(direction, sortBy != null ? sortBy : "createdAt")
        );
        
        // 検索条件の構築
        Specification<Notification> spec = Specification.where(
            NotificationSpecifications.forUsername(username)
                .and(NotificationSpecifications.notDeleted())
        );
        
        // オプションフィルタの適用
        if (type != null) {
            spec = spec.and(NotificationSpecifications.ofType(type));
        }
        
        if (readStatus != null) {
            spec = spec.and(NotificationSpecifications.withReadStatus(readStatus));
        }
        
        if (keyword != null && !keyword.trim().isEmpty()) {
            spec = spec.and(NotificationSpecifications.containsKeyword(keyword));
        }
        
        if (fromDate != null) {
            spec = spec.and(NotificationSpecifications.createdAfter(fromDate));
        }
        
        if (toDate != null) {
            spec = spec.and(NotificationSpecifications.createdBefore(toDate));
        }
        
        // 検索の実行
        Page<Notification> notifications = repository.findAll(spec, pageable);
        
        // DTOへの変換
        return notifications.map(NotificationDto::from);
    }
    
    // 通知詳細の取得
    public NotificationDto getNotificationDetail(UUID notificationId, String username) {
        Notification notification = repository.findById(notificationId)
            .orElseThrow(() -> new NotificationNotFoundException("通知が見つかりません"));
        
        // アクセス権チェック
        if (!notification.getRecipient().getUsername().equals(username)) {
            throw new AccessDeniedException("この通知へのアクセス権がありません");
        }
        
        // 既読にする（自動的に）
        if (!notification.isRead()) {
            notification.setRead(true);
            notification.setUpdatedAt(LocalDateTime.now());
            repository.save(notification);
        }
        
        return NotificationDto.from(notification);
    }
    
    // エンティティ参照による通知検索
    public List<NotificationDto> findNotificationsByEntityReference(
            String username,
            String entityType,
            String entityId) {
        
        List<Notification> notifications = repository.findByEntityReference(
            username, entityType, entityId);
            
        return notifications.stream()
            .map(NotificationDto::from)
            .collect(Collectors.toList());
    }
    
    // 通知の統計情報を取得
    public NotificationStatisticsDto getNotificationStatistics(String username) {
        NotificationStatisticsDto stats = new NotificationStatisticsDto();
        
        // 未読通知数
        stats.setUnreadCount(repository.countByRecipientUsernameAndRead(username, false));
        
        // タイプ別の未読通知数
        Map<NotificationType, Long> countByType = new HashMap<>();
        for (NotificationType type : NotificationType.values()) {
            long count = repository.countByRecipientUsernameAndTypeAndRead(username, type, false);
            countByType.put(type, count);
        }
        stats.setUnreadCountByType(countByType);
        
        // 最新の通知
        repository.findTopByRecipientUsernameOrderByCreatedAtDesc(username)
            .ifPresent(n -> stats.setLatestNotificationDate(n.getCreatedAt()));
        
        // 今日の通知数
        LocalDateTime startOfDay = LocalDate.now().atStartOfDay();
        stats.setTodayCount(repository.countByRecipientUsernameAndCreatedAtAfter(username, startOfDay));
        
        return stats;
    }
}
```

### 3.3 通知設定の管理

ユーザーごとの通知設定を管理する機能です。

```java
@Service
public class NotificationPreferenceServiceImpl implements NotificationPreferenceService {
    private final NotificationPreferenceRepository repository;
    private final UserService userService;
    
    // コンストラクタ、依存性注入
    
    @Override
    public List<NotificationPreferenceDto> getUserPreferences(String username) {
        // ユーザーの存在確認
        userService.validateUser(username);
        
        // 全ての通知タイプに対する設定を取得（存在しない場合はデフォルト設定を作成）
        List<NotificationPreference> preferences = new ArrayList<>();
        
        for (NotificationType type : NotificationType.values()) {
            NotificationPreference preference = repository
                .findByUserUsernameAndNotificationType(username, type)
                .orElseGet(() -> createDefaultPreference(username, type));
            
            preferences.add(preference);
        }
        
        // DTOに変換して返却
        return preferences.stream()
            .map(NotificationPreferenceDto::from)
            .collect(Collectors.toList());
    }
    
    @Override
    @Transactional
    public NotificationPreferenceDto updatePreference(
            String username,
            NotificationType type,
            boolean appEnabled,
            boolean emailEnabled,
            int retentionDays) {
        
        // ユーザーの存在確認
        userService.validateUser(username);
        
        // 入力値の検証
        validatePreferenceInput(appEnabled, emailEnabled, retentionDays);
        
        // 既存の設定を取得または新規作成
        NotificationPreference preference = repository
            .findByUserUsernameAndNotificationType(username, type)
            .orElseGet(() -> {
                NotificationPreference newPreference = new NotificationPreference();
                newPreference.setUserUsername(username);
                newPreference.setNotificationType(type);
                return newPreference;
            });
        
        // 設定を更新
        preference.setAppEnabled(appEnabled);
        preference.setEmailEnabled(emailEnabled);
        preference.setRetentionDays(retentionDays);
        
        // 保存と返却
        NotificationPreference saved = repository.save(preference);
        return NotificationPreferenceDto.from(saved);
    }
    
    @Override
    @Transactional
    public void resetToDefaults(String username) {
        // ユーザーの存在確認
        userService.validateUser(username);
        
        // 既存の設定を削除
        repository.deleteByUserUsername(username);
        
        // デフォルト設定を作成して保存
        List<NotificationPreference> defaults = Arrays.stream(NotificationType.values())
            .map(type -> createDefaultPreference(username, type))
            .collect(Collectors.toList());
        
        repository.saveAll(defaults);
    }
    
    @Override
    public NotificationPreferenceDto getPreference(String username, NotificationType type) {
        // ユーザーの存在確認
        userService.validateUser(username);
        
        // 設定を取得（存在しない場合はデフォルト設定）
        NotificationPreference preference = repository
            .findByUserUsernameAndNotificationType(username, type)
            .orElseGet(() -> createDefaultPreference(username, type));
        
        return NotificationPreferenceDto.from(preference);
    }
    
    // デフォルト設定の作成
    private NotificationPreference createDefaultPreference(String username, NotificationType type) {
        NotificationPreference preference = new NotificationPreference();
        preference.setUserUsername(username);
        preference.setNotificationType(type);
        
        // タイプごとのデフォルト設定
        switch (type) {
            case SYSTEM:
                preference.setAppEnabled(true);
                preference.setEmailEnabled(false);
                preference.setRetentionDays(90);
                break;
            case TASK:
                preference.setAppEnabled(true);
                preference.setEmailEnabled(true);
                preference.setRetentionDays(90);
                break;
            case ALERT:
                preference.setAppEnabled(true);
                preference.setEmailEnabled(true);
                preference.setRetentionDays(180);
                break;
            case EVENT:
                preference.setAppEnabled(true);
                preference.setEmailEnabled(false);
                preference.setRetentionDays(60);
                break;
            default:
                preference.setAppEnabled(true);
                preference.setEmailEnabled(true);
                preference.setRetentionDays(90);
        }
        
        return preference;
    }
    
    // 入力値の検証
    private void validatePreferenceInput(boolean appEnabled, boolean emailEnabled, int retentionDays) {
        // アプリ内通知とメール通知の両方を無効にすることはできない
        if (!appEnabled && !emailEnabled) {
            throw new InvalidPreferenceException("アプリ内通知とメール通知のいずれか一方は有効にしてください");
        }
        
        // 保持期間は7日から365日の範囲内であること
        if (retentionDays < 7 || retentionDays > 365) {
            throw new InvalidPreferenceException("保持期間は7日から365日の範囲内で設定してください");
        }
    }
}
```

### 3.4 テンプレート管理

通知テンプレートを管理する機能です。

```java
@Service
public class NotificationTemplateServiceImpl implements NotificationTemplateService {
    private final NotificationTemplateRepository repository;
    private final TemplateEngine templateEngine;
    
    // コンストラクタ、依存性注入
    
    @Override
    public NotificationTemplate getTemplateByKey(String templateKey) {
        return repository.findByTemplateKey(templateKey)
            .orElseThrow(() -> new TemplateNotFoundException("テンプレート " + templateKey + " が見つかりません"));
    }
    
    @Override
    @Transactional
    public NotificationTemplate createTemplate(
            String templateKey,
            String titleTemplate,
            String bodyTemplate,
            NotificationType notificationType,
            String metadataTemplate) {
        
        // キーの重複チェック
        if (repository.existsByTemplateKey(templateKey)) {
            throw new TemplateAlreadyExistsException("テンプレートキー " + templateKey + " は既に使用されています");
        }
        
        // テンプレートの検証
        validateTemplate(titleTemplate, bodyTemplate, metadataTemplate);
        
        // 新規テンプレートの作成
        NotificationTemplate template = new NotificationTemplate();
        template.setTemplateKey(templateKey);
        template.setTitleTemplate(titleTemplate);
        template.setBodyTemplate(bodyTemplate);
        template.setNotificationType(notificationType);
        template.setMetadataTemplate(metadataTemplate);
        template.setActive(true);
        
        return repository.save(template);
    }
    
    @Override
    @Transactional
    public NotificationTemplate updateTemplate(
            String templateKey,
            String titleTemplate,
            String bodyTemplate,
            NotificationType notificationType,
            String metadataTemplate) {
        
        // テンプレートの取得
        NotificationTemplate template = repository.findByTemplateKey(templateKey)
            .orElseThrow(() -> new TemplateNotFoundException("テンプレート " + templateKey + " が見つかりません"));
        
        // テンプレートの検証
        validateTemplate(titleTemplate, bodyTemplate, metadataTemplate);
        
        // テンプレートの更新
        template.setTitleTemplate(titleTemplate);
        template.setBodyTemplate(bodyTemplate);
        template.setNotificationType(notificationType);
        template.setMetadataTemplate(metadataTemplate);
        
        return repository.save(template);
    }
    
    @Override
    @Transactional
    public void deleteTemplate(String templateKey) {
        NotificationTemplate template = repository.findByTemplateKey(templateKey)
            .orElseThrow(() -> new TemplateNotFoundException("テンプレート " + templateKey + " が見つかりません"));
        
        repository.delete(template);
    }
    
    @Override
    public List<String> validateTemplate(String template) {
        try {
            return templateEngine.extractRequiredVariables(template);
        } catch (Exception e) {
            throw new InvalidTemplateException("テンプレートの構文が不正です: " + e.getMessage(), e);
        }
    }
    
    // テンプレートの検証（タイトル、本文、メタデータ）
    private void validateTemplate(String titleTemplate, String bodyTemplate, String metadataTemplate) {
        // タイトルと本文は必須
        if (titleTemplate == null || titleTemplate.trim().isEmpty()) {
            throw new InvalidTemplateException("タイトルテンプレートは必須です");
        }
        
        if (bodyTemplate == null || bodyTemplate.trim().isEmpty()) {
            throw new InvalidTemplateException("本文テンプレートは必須です");
        }
        
        // タイトルは短く
        if (titleTemplate.length() > 200) {
            throw new InvalidTemplateException("タイトルテンプレートは200文字以内にしてください");
        }
        
        // 本文の長さ制限
        if (bodyTemplate.length() > 2000) {
            throw new InvalidTemplateException("本文テンプレートは2000文字以内にしてください");
        }
        
        // 構文の検証
        try {
            templateEngine.validateTemplate(titleTemplate);
            templateEngine.validateTemplate(bodyTemplate);
            
            // メタデータが設定されている場合は検証
            if (metadataTemplate != null && !metadataTemplate.trim().isEmpty()) {
                // JSON形式として妥当か検証
                try {
                    new ObjectMapper().readTree(metadataTemplate);
                } catch (JsonProcessingException e) {
                    throw new InvalidTemplateException("メタデータテンプレートが不正なJSON形式です: " + e.getMessage());
                }
                
                // メタデータ内の変数も検証
                templateEngine.validateTemplate(metadataTemplate);
            }
        } catch (Exception e) {
            throw new InvalidTemplateException("テンプレートの構文が不正です: " + e.getMessage(), e);
        }
    }
}
```

## 4. 統計と分析

### 4.1 通知統計情報

通知の統計情報を集計し分析する機能です。

#### 統計DTOクラス

```java
public class NotificationStatisticsDto {
    // 全体統計
    private long totalCount;
    private long unreadCount;
    private long todayCount;
    private LocalDateTime latestNotificationDate;
    
    // タイプごとの統計
    private Map<NotificationType, Long> totalCountByType;
    private Map<NotificationType, Long> unreadCountByType;
    
    // 読まれた割合（%）
    private double readRate;
    
    // 時間帯別統計（1日を24時間に分割）
    private Map<Integer, Long> notificationsByHour;
    
    // 曜日別統計
    private Map<DayOfWeek, Long> notificationsByDayOfWeek;
    
    // 配信チャネル統計
    private long appNotificationCount;
    private long emailNotificationCount;
    
    // 重要度別統計
    private Map<String, Long> notificationsByImportance;
    
    // getters, setters
}
```

#### 統計情報サービス

```java
@Service
public class NotificationAnalyticsService {
    private final NotificationRepository repository;
    
    // コンストラクタ、依存性注入
    
    // ユーザーの通知統計を取得
    public NotificationStatisticsDto getUserStatistics(String username) {
        NotificationStatisticsDto stats = new NotificationStatisticsDto();
        
        // 基本統計
        stats.setTotalCount(repository.countByRecipientUsername(username));
        stats.setUnreadCount(repository.countByRecipientUsernameAndRead(username, false));
        
        LocalDateTime startOfDay = LocalDate.now().atStartOfDay();
        stats.setTodayCount(repository.countByRecipientUsernameAndCreatedAtAfter(username, startOfDay));
        
        repository.findTopByRecipientUsernameOrderByCreatedAtDesc(username)
            .ifPresent(n -> stats.setLatestNotificationDate(n.getCreatedAt()));
        
        // 読まれた割合の計算
        if (stats.getTotalCount() > 0) {
            stats.setReadRate(
                (double) (stats.getTotalCount() - stats.getUnreadCount()) / stats.getTotalCount() * 100
            );
        }
        
        // タイプごとの統計
        Map<NotificationType, Long> totalByType = new HashMap<>();
        Map<NotificationType, Long> unreadByType = new HashMap<>();
        
        for (NotificationType type : NotificationType.values()) {
            totalByType.put(type, repository.countByRecipientUsernameAndType(username, type));
            unreadByType.put(type, repository.countByRecipientUsernameAndTypeAndRead(username, type, false));
        }
        
        stats.setTotalCountByType(totalByType);
        stats.setUnreadCountByType(unreadByType);
        
        // 時間帯別統計の集計
        Map<Integer, Long> byHour = repository.countByRecipientUsernameGroupByHour(username);
        stats.setNotificationsByHour(byHour);
        
        // 曜日別統計の集計
        Map<DayOfWeek, Long> byDayOfWeek = repository.countByRecipientUsernameGroupByDayOfWeek(username);
        stats.setNotificationsByDayOfWeek(byDayOfWeek);
        
        // 配信チャネル統計
        stats.setAppNotificationCount(repository.countAppNotifications(username));
        stats.setEmailNotificationCount(repository.countEmailNotifications(username));
        
        // 重要度別統計
        Map<String, Long> byImportance = repository.countByRecipientUsernameGroupByImportance(username);
        stats.setNotificationsByImportance(byImportance);
        
        return stats;
    }
    
    // 全体の通知統計情報（管理者向け）
    public AdminNotificationStatisticsDto getSystemStatistics() {
        AdminNotificationStatisticsDto stats = new AdminNotificationStatisticsDto();
        
        // 全体統計
        stats.setTotalNotifications(repository.count());
        stats.setTotalUnreadNotifications(repository.countByRead(false));
        
        LocalDateTime yesterday = LocalDateTime.now().minusDays(1);
        stats.setLast24HoursNotifications(repository.countByCreatedAtAfter(yesterday));
        
        // タイプごとの統計
        Map<NotificationType, Long> byType = new HashMap<>();
        for (NotificationType type : NotificationType.values()) {
            byType.put(type, repository.countByType(type));
        }
        stats.setNotificationsByType(byType);
        
        // 月別統計
        Map<YearMonth, Long> byMonth = repository.countGroupByMonth();
        stats.setNotificationsByMonth(byMonth);
        
        // 平均値と中央値
        stats.setAverageNotificationsPerUser(repository.getAverageNotificationsPerUser());
        stats.setMedianNotificationsPerUser(repository.getMedianNotificationsPerUser());
        
        // 最もアクティブなユーザー
        stats.setMostActiveUsers(repository.findTopRecipientsByNotificationCount(10));
        
        // 最もアクティブな送信者
        stats.setMostActiveSenders(repository.findTopSendersByNotificationCount(10));
        
        // 重要度別統計
        stats.setNotificationsByImportance(repository.countGroupByImportance());
        
        return stats;
    }
    
    // 特定期間の通知統計
    public TimeRangeNotificationStatisticsDto getStatisticsByTimeRange(
            LocalDateTime startDate, 
            LocalDateTime endDate,
            String username) {
        
        TimeRangeNotificationStatisticsDto stats = new TimeRangeNotificationStatisticsDto();
        stats.setStartDate(startDate);
        stats.setEndDate(endDate);
        
        // ユーザー指定がある場合はユーザー別、なければ全体統計
        if (username != null) {
            stats.setTotalCount(repository.countByRecipientUsernameAndCreatedAtBetween(
                username, startDate, endDate));
                
            stats.setReadCount(repository.countByRecipientUsernameAndReadAndCreatedAtBetween(
                username, true, startDate, endDate));
                
            // タイプごとの集計
            Map<NotificationType, Long> byType = new HashMap<>();
            for (NotificationType type : NotificationType.values()) {
                byType.put(type, repository.countByRecipientUsernameAndTypeAndCreatedAtBetween(
                    username, type, startDate, endDate));
            }
            stats.setCountByType(byType);
        } else {
            stats.setTotalCount(repository.countByCreatedAtBetween(startDate, endDate));
            stats.setReadCount(repository.countByReadAndCreatedAtBetween(true, startDate, endDate));
            
            // タイプごとの集計
            Map<NotificationType, Long> byType = new HashMap<>();
            for (NotificationType type : NotificationType.values()) {
                byType.put(type, repository.countByTypeAndCreatedAtBetween(type, startDate, endDate));
            }
            stats.setCountByType(byType);
        }
        
        // 読まれた割合の計算
        if (stats.getTotalCount() > 0) {
            stats.setReadRate((double) stats.getReadCount() / stats.getTotalCount() * 100);
        }
        
        // 日ごとの統計
        stats.setDailyStatistics(repository.getDailyStatisticsBetween(
            startDate, endDate, username));
            
        return stats;
    }
}
```

### 4.2 ダッシュボード用データ生成

管理者向けダッシュボードのデータを生成する機能です。

```java
@Service
public class NotificationDashboardService {
    private final NotificationRepository repository;
    private final NotificationAnalyticsService analyticsService;
    
    // コンストラクタ、依存性注入
    
    // ダッシュボード概要データの取得
    public DashboardSummaryDto getDashboardSummary() {
        DashboardSummaryDto summary = new DashboardSummaryDto();
        
        // 今日の統計
        LocalDateTime startOfToday = LocalDate.now().atStartOfDay();
        summary.setTodayNotifications(repository.countByCreatedAtAfter(startOfToday));
        summary.setTodayReadRate(calculateReadRate(startOfToday, LocalDateTime.now()));
        
        // 今週の統計
        LocalDateTime startOfWeek = LocalDate.now().with(DayOfWeek.MONDAY).atStartOfDay();
        summary.setThisWeekNotifications(repository.countByCreatedAtAfter(startOfWeek));
        summary.setThisWeekReadRate(calculateReadRate(startOfWeek, LocalDateTime.now()));
        
        // 今月の統計
        LocalDateTime startOfMonth = LocalDate.now().withDayOfMonth(1).atStartOfDay();
        summary.setThisMonthNotifications(repository.countByCreatedAtAfter(startOfMonth));
        summary.setThisMonthReadRate(calculateReadRate(startOfMonth, LocalDateTime.now()));
        
        // 通知タイプ別の内訳
        Map<NotificationType, Long> byType = new HashMap<>();
        for (NotificationType type : NotificationType.values()) {
            byType.put(type, repository.countByTypeAndCreatedAtAfter(type, startOfMonth));
        }
        summary.setNotificationsByType(byType);
        
        // 前月との比較
        LocalDateTime startOfLastMonth = startOfMonth.minusMonths(1);
        long lastMonthCount = repository.countByCreatedAtBetween(startOfLastMonth, startOfMonth);
        if (lastMonthCount > 0) {
            double changeRate = ((double) summary.getThisMonthNotifications() / lastMonthCount - 1) * 100;
            summary.setMonthlyChangePercent(changeRate);
        }
        
        return summary;
    }
    
    // 週間レポートの生成
    public WeeklyReportDto generateWeeklyReport() {
        WeeklyReportDto report = new WeeklyReportDto();
        
        // レポート期間の設定
        LocalDateTime endDate = LocalDateTime.now();
        LocalDateTime startDate = endDate.minusDays(7);
        report.setStartDate(startDate);
        report.setEndDate(endDate);
        
        // 日別統計の取得
        List<DailyStatisticsDto> dailyStats = repository.getDailyStatisticsBetween(startDate, endDate, null);
        report.setDailyStatistics(dailyStats);
        
        // 総計と平均
        long totalNotifications = dailyStats.stream()
            .mapToLong(DailyStatisticsDto::getTotalCount)
            .sum();
        report.setTotalNotifications(totalNotifications);
        report.setAverageNotificationsPerDay(totalNotifications / 7.0);
        
        // 読まれた割合
        long totalRead = dailyStats.stream()
            .mapToLong(DailyStatisticsDto::getReadCount)
            .sum();
        if (totalNotifications > 0) {
            report.setOverallReadRate((double) totalRead / totalNotifications * 100);
        }
        
        // 最もアクティブな日
        Optional<DailyStatisticsDto> mostActiveDay = dailyStats.stream()
            .max(Comparator.comparing(DailyStatisticsDto::getTotalCount));
        mostActiveDay.ifPresent(report::setMostActiveDay);
        
        // 最もアクティブなユーザー
        report.setMostActiveUsers(repository.findTopRecipientsByNotificationCount(5, startDate, endDate));
        
        // 最もアクティブな送信者
        report.setMostActiveSenders(repository.findTopSendersByNotificationCount(5, startDate, endDate));
        
        // 通知タイプ別の内訳
        Map<NotificationType, Long> byType = new HashMap<>();
        for (NotificationType type : NotificationType.values()) {
            byType.put(type, repository.countByTypeAndCreatedAtBetween(type, startDate, endDate));
        }
        report.setNotificationsByType(byType);
        
        return report;
    }
    
    // ユーザーごとの通知活動レポート
    public UserActivityReportDto getUserActivityReport(String username, int days) {
        UserActivityReportDto report = new UserActivityReportDto();
        report.setUsername(username);
        
        LocalDateTime endDate = LocalDateTime.now();
        LocalDateTime startDate = endDate.minusDays(days);
        report.setStartDate(startDate);
        report.setEndDate(endDate);
        
        // 期間中の通知数
        report.setTotalNotifications(repository.countByRecipientUsernameAndCreatedAtBetween(
            username, startDate, endDate));
            
        // 既読率
        long readCount = repository.countByRecipientUsernameAndReadAndCreatedAtBetween(
            username, true, startDate, endDate);
            
        if (report.getTotalNotifications() > 0) {
            report.setReadRate((double) readCount / report.getTotalNotifications() * 100);
        }
        
        // 最も多い通知タイプ
        Map<NotificationType, Long> typeCount = new HashMap<>();
        for (NotificationType type : NotificationType.values()) {
            typeCount.put(type, repository.countByRecipientUsernameAndTypeAndCreatedAtBetween(
                username, type, startDate, endDate));
        }
        report.setNotificationsByType(typeCount);
        
        // 最も多い通知タイプを特定
        report.setMostCommonType(typeCount.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(null));
            
        // 日ごとの統計
        report.setDailyStatistics(repository.getDailyStatisticsBetween(
            startDate, endDate, username));
            
        // 平均応答時間（通知の作成から既読までの平均時間）
        report.setAverageResponseTimeMinutes(
            repository.getAverageResponseTimeMinutes(username, startDate, endDate));
            
        return report;
    }
    
    // 読まれた割合の計算
    private double calculateReadRate(LocalDateTime from, LocalDateTime to) {
        long total = repository.countByCreatedAtBetween(from, to);
        if (total == 0) {
            return 0;
        }
        
        long read = repository.countByReadAndCreatedAtBetween(true, from, to);
        return (double) read / total * 100;
    }
}
```