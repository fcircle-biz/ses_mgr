# 契約管理機能モジュール詳細設計

## 1. 概要

契約管理機能モジュールは、SES業務システムにおける技術者派遣に関連する契約の作成、承認、電子署名、管理を一元的に行うためのコアモジュールです。案件と技術者のマッチングが成立した後の契約プロセス全体をサポートし、法的要件を満たす契約管理を実現します。

### 1.1 主要機能

- 契約基本情報の管理
- 契約書テンプレート管理
- 契約書生成
- 電子署名・承認ワークフロー
- 契約期間管理・更新通知
- 契約書類のバージョン管理
- 契約書のPDF生成・保存

### 1.2 ユースケース

- 営業担当者が新規契約を作成する
- 契約担当者が契約書を生成・確認する
- 契約書に承認・電子署名を行う
- 契約更新・終了手続きを管理する
- 契約一覧や詳細情報を参照する

## 2. アーキテクチャ設計

契約管理モジュールは、全体アーキテクチャに準拠した4層構造で設計します。契約書生成と電子署名については専用のサービスコンポーネントを用意します。

### 2.1 コンポーネント構成

```
jp.co.system_engineer_service.contract
├── presentation
│   ├── controller
│   │   ├── ContractController.java （Web向けコントローラ）
│   │   ├── ContractRestController.java （REST API向けコントローラ）
│   │   ├── TemplateController.java （テンプレート管理コントローラ）
│   │   └── SignatureController.java （電子署名コントローラ）
│   └── dto
│       ├── ContractDTO.java （契約データDTO）
│       ├── ContractTemplateDTO.java （テンプレートDTO）
│       ├── SignatureRequestDTO.java （署名リクエストDTO）
│       └── ContractSearchDTO.java （契約検索DTO）
├── application
│   ├── service
│   │   ├── ContractService.java （契約サービスインターフェース）
│   │   ├── ContractServiceImpl.java （契約サービス実装）
│   │   ├── TemplateService.java （テンプレートサービスインターフェース）
│   │   ├── TemplateServiceImpl.java （テンプレートサービス実装）
│   │   ├── SignatureService.java （電子署名サービスインターフェース）
│   │   └── SignatureServiceImpl.java （電子署名サービス実装）
│   └── mapper
│       ├── ContractMapper.java （契約エンティティマッパー）
│       └── TemplateMapper.java （テンプレートエンティティマッパー）
├── domain
│   ├── model
│   │   ├── Contract.java （契約エンティティ）
│   │   ├── ContractStatus.java （契約ステータス列挙型）
│   │   ├── ContractTemplate.java （契約テンプレートエンティティ）
│   │   ├── ContractDocument.java （契約書類エンティティ）
│   │   ├── SignatureRequest.java （署名リクエストエンティティ）
│   │   └── SignatureStatus.java （署名ステータス列挙型）
│   ├── repository
│   │   ├── ContractRepository.java （契約リポジトリインターフェース）
│   │   ├── TemplateRepository.java （テンプレートリポジトリインターフェース）
│   │   ├── DocumentRepository.java （書類リポジトリインターフェース）
│   │   └── SignatureRepository.java （署名リポジトリインターフェース）
│   └── service
│       ├── ContractDomainService.java （契約ドメインサービス）
│       ├── DocumentGenerationService.java （書類生成サービス）
│       └── ContractLifecycleService.java （契約ライフサイクルサービス）
└── infrastructure
    ├── repository
    │   ├── ContractRepositoryImpl.java （契約リポジトリ実装）
    │   ├── TemplateRepositoryImpl.java （テンプレートリポジトリ実装）
    │   ├── DocumentRepositoryImpl.java （書類リポジトリ実装）
    │   └── SignatureRepositoryImpl.java （署名リポジトリ実装）
    ├── adapter
    │   ├── PdfGenerationAdapter.java （PDF生成アダプター）
    │   ├── StorageAdapter.java （ストレージアダプター）
    │   └── ElectronicSignatureAdapter.java （電子署名連携アダプター）
    └── entity
        ├── ContractEntity.java （契約DBエンティティ）
        ├── TemplateEntity.java （テンプレートDBエンティティ）
        ├── DocumentEntity.java （書類DBエンティティ）
        └── SignatureEntity.java （署名DBエンティティ）
```

## 3. データモデル設計

### 3.1 エンティティ定義

**Contract（契約）エンティティ**

```java
public class Contract {
    private UUID id;                 // 契約ID
    private String contractNumber;   // 契約番号
    private UUID projectId;          // 案件ID
    private UUID engineerId;         // 技術者ID
    private UUID clientId;           // 顧客ID
    private ContractStatus status;   // 契約ステータス
    private LocalDate startDate;     // 契約開始日
    private LocalDate endDate;       // 契約終了日
    private BigDecimal unitPrice;    // 単価（円/時間 or 円/月）
    private String unitType;         // 単価種別（時間単価/月額固定）
    private Integer workingHoursPerDay; // 1日の稼働時間
    private Integer workingDaysPerMonth; // 月間想定稼働日数
    private String contractTerms;    // 契約条件テキスト
    private String paymentTerms;     // 支払条件
    private String specialConditions; // 特記事項
    private UUID latestDocumentId;   // 最新契約書ID
    private LocalDateTime createdAt;  // 作成日時
    private LocalDateTime updatedAt;  // 更新日時
    private UUID createdBy;          // 作成者ID
    
    // ビジネスメソッド
    public boolean isActive(LocalDate referenceDate) {
        return !referenceDate.isBefore(startDate) && !referenceDate.isAfter(endDate);
    }
    
    public boolean isExpiring(int daysThreshold) {
        LocalDate today = LocalDate.now();
        return isActive(today) && 
               ChronoUnit.DAYS.between(today, endDate) <= daysThreshold;
    }
    
    // コンストラクタ、ゲッター、セッター
}
```

**ContractStatus（契約ステータス）列挙型**

```java
public enum ContractStatus {
    DRAFT("下書き"),
    PENDING_REVIEW("レビュー待ち"),
    PENDING_APPROVAL("承認待ち"),
    PENDING_SIGNATURE("署名待ち"),
    ACTIVE("契約中"),
    EXPIRED("期間満了"),
    TERMINATED("契約終了"),
    CANCELLED("キャンセル");
    
    private final String displayName;
    
    // コンストラクタ、ゲッター
}
```

**ContractTemplate（契約テンプレート）エンティティ**

```java
public class ContractTemplate {
    private UUID id;                 // テンプレートID
    private String name;             // テンプレート名
    private String description;      // 説明
    private String content;          // テンプレート内容（HTMLまたはマークダウン）
    private Map<String, String> placeholders; // プレースホルダー定義
    private boolean active;          // 有効フラグ
    private String templateType;     // テンプレート種別
    private UUID createdBy;          // 作成者ID
    private LocalDateTime createdAt;  // 作成日時
    private LocalDateTime updatedAt;  // 更新日時
    
    // コンストラクタ、ゲッター、セッター
}
```

**ContractDocument（契約書類）エンティティ**

```java
public class ContractDocument {
    private UUID id;                 // 書類ID
    private UUID contractId;         // 契約ID
    private String documentType;     // 書類種別
    private int version;             // バージョン
    private String content;          // 書類内容（HTMLまたはマークダウン）
    private String renderedContent;  // レンダリング済みHTML
    private UUID fileId;             // ファイルID（PDF等）
    private boolean finalVersion;    // 最終版フラグ
    private LocalDateTime createdAt;  // 作成日時
    private UUID createdBy;          // 作成者ID
    
    // コンストラクタ、ゲッター、セッター
}
```

**SignatureRequest（署名リクエスト）エンティティ**

```java
public class SignatureRequest {
    private UUID id;                 // 署名リクエストID
    private UUID contractId;         // 契約ID
    private UUID documentId;         // 書類ID
    private UUID requestToUserId;    // 署名依頼先ユーザーID
    private String requestToEmail;   // 署名依頼先メール
    private String requestToName;    // 署名依頼先氏名
    private SignatureStatus status;  // 署名ステータス
    private LocalDateTime requestedAt; // 依頼日時
    private LocalDateTime completedAt; // 完了日時
    private String signatureData;    // 署名データ
    private String signerIpAddress;  // 署名者IPアドレス
    private String accessToken;      // アクセストークン
    private LocalDateTime expiresAt;  // 有効期限
    
    // コンストラクタ、ゲッター、セッター
}
```

**SignatureStatus（署名ステータス）列挙型**

```java
public enum SignatureStatus {
    PENDING("署名待ち"),
    VIEWED("閲覧済み"),
    COMPLETED("署名完了"),
    REJECTED("拒否"),
    EXPIRED("期限切れ"),
    CANCELLED("キャンセル");
    
    private final String displayName;
    
    // コンストラクタ、ゲッター
}
```

### 3.2 データベース設計

**contracts テーブル**

| カラム名 | データ型 | 制約 | 説明 |
|---------|---------|------|------|
| id | UUID | PK | 契約ID |
| contract_number | VARCHAR(50) | UK, NOT NULL | 契約番号 |
| project_id | UUID | FK, NOT NULL | 案件ID |
| engineer_id | UUID | FK, NOT NULL | 技術者ID |
| client_id | UUID | FK, NOT NULL | 顧客ID |
| status | VARCHAR(50) | NOT NULL | 契約ステータス |
| start_date | DATE | NOT NULL | 契約開始日 |
| end_date | DATE | NOT NULL | 契約終了日 |
| unit_price | DECIMAL(12,2) | NOT NULL | 単価 |
| unit_type | VARCHAR(20) | NOT NULL | 単価種別 |
| working_hours_per_day | INTEGER | | 1日稼働時間 |
| working_days_per_month | INTEGER | | 月間稼働日数 |
| contract_terms | TEXT | | 契約条件テキスト |
| payment_terms | TEXT | | 支払条件 |
| special_conditions | TEXT | | 特記事項 |
| latest_document_id | UUID | FK | 最新契約書ID |
| created_at | TIMESTAMP | NOT NULL | 作成日時 |
| updated_at | TIMESTAMP | NOT NULL | 更新日時 |
| created_by | UUID | FK, NOT NULL | 作成者ID |

**contract_templates テーブル**

| カラム名 | データ型 | 制約 | 説明 |
|---------|---------|------|------|
| id | UUID | PK | テンプレートID |
| name | VARCHAR(200) | NOT NULL | テンプレート名 |
| description | TEXT | | 説明 |
| content | TEXT | NOT NULL | テンプレート内容 |
| placeholders | JSONB | | プレースホルダー定義 |
| active | BOOLEAN | NOT NULL | 有効フラグ |
| template_type | VARCHAR(50) | NOT NULL | テンプレート種別 |
| created_by | UUID | FK, NOT NULL | 作成者ID |
| created_at | TIMESTAMP | NOT NULL | 作成日時 |
| updated_at | TIMESTAMP | NOT NULL | 更新日時 |

**contract_documents テーブル**

| カラム名 | データ型 | 制約 | 説明 |
|---------|---------|------|------|
| id | UUID | PK | 書類ID |
| contract_id | UUID | FK, NOT NULL | 契約ID |
| document_type | VARCHAR(50) | NOT NULL | 書類種別 |
| version | INTEGER | NOT NULL | バージョン |
| content | TEXT | | 書類内容 |
| rendered_content | TEXT | | レンダリング済みHTML |
| file_id | UUID | FK | ファイルID |
| final_version | BOOLEAN | NOT NULL | 最終版フラグ |
| created_at | TIMESTAMP | NOT NULL | 作成日時 |
| created_by | UUID | FK, NOT NULL | 作成者ID |

**signature_requests テーブル**

| カラム名 | データ型 | 制約 | 説明 |
|---------|---------|------|------|
| id | UUID | PK | 署名リクエストID |
| contract_id | UUID | FK, NOT NULL | 契約ID |
| document_id | UUID | FK, NOT NULL | 書類ID |
| request_to_user_id | UUID | FK | 署名依頼先ユーザーID |
| request_to_email | VARCHAR(200) | NOT NULL | 署名依頼先メール |
| request_to_name | VARCHAR(200) | NOT NULL | 署名依頼先氏名 |
| status | VARCHAR(50) | NOT NULL | 署名ステータス |
| requested_at | TIMESTAMP | NOT NULL | 依頼日時 |
| completed_at | TIMESTAMP | | 完了日時 |
| signature_data | TEXT | | 署名データ |
| signer_ip_address | VARCHAR(50) | | 署名者IPアドレス |
| access_token | VARCHAR(100) | NOT NULL | アクセストークン |
| expires_at | TIMESTAMP | NOT NULL | 有効期限 |

## 4. インターフェース設計

### 4.1 Controller

**ContractController（Web画面用）**

```java
@Controller
@RequestMapping("/contracts")
public class ContractController {

    @GetMapping
    public String list(Model model, ContractSearchDTO searchDTO) {
        // 契約一覧表示
    }
    
    @GetMapping("/{id}")
    public String detail(@PathVariable UUID id, Model model) {
        // 契約詳細表示
    }
    
    @GetMapping("/new")
    public String createForm(Model model, @RequestParam(required = false) UUID projectId) {
        // 契約登録フォーム表示
    }
    
    @PostMapping
    public String create(@Valid ContractDTO contractDTO) {
        // 契約登録処理
    }
    
    @GetMapping("/{id}/edit")
    public String editForm(@PathVariable UUID id, Model model) {
        // 契約編集フォーム表示
    }
    
    @PostMapping("/{id}")
    public String update(@PathVariable UUID id, @Valid ContractDTO contractDTO) {
        // 契約更新処理
    }
    
    @GetMapping("/{id}/document")
    public String viewDocument(@PathVariable UUID id, @RequestParam UUID documentId, Model model) {
        // 契約書類表示
    }
    
    @GetMapping("/{id}/document/download")
    public ResponseEntity<Resource> downloadDocument(@PathVariable UUID id, @RequestParam UUID documentId) {
        // 契約書類ダウンロード
    }
    
    @GetMapping("/{id}/renew")
    public String renewForm(@PathVariable UUID id, Model model) {
        // 契約更新フォーム
    }
}
```

**ContractRestController（REST API用）**

```java
@RestController
@RequestMapping("/api/contracts")
public class ContractRestController {

    @GetMapping
    public ResponseEntity<Page<ContractDTO>> search(ContractSearchDTO searchDTO, Pageable pageable) {
        // 契約検索API
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<ContractDTO> getById(@PathVariable UUID id) {
        // 契約詳細取得API
    }
    
    @PostMapping
    public ResponseEntity<ContractDTO> create(@RequestBody @Valid ContractDTO contractDTO) {
        // 契約作成API
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<ContractDTO> update(@PathVariable UUID id, @RequestBody @Valid ContractDTO contractDTO) {
        // 契約更新API
    }
    
    @PatchMapping("/{id}/status")
    public ResponseEntity<Void> updateStatus(@PathVariable UUID id, @RequestBody String status) {
        // 契約ステータス更新API
    }
    
    @GetMapping("/{id}/documents")
    public ResponseEntity<List<ContractDocumentDTO>> getDocuments(@PathVariable UUID id) {
        // 契約書類一覧API
    }
    
    @PostMapping("/{id}/documents")
    public ResponseEntity<ContractDocumentDTO> generateDocument(@PathVariable UUID id, @RequestBody Map<String, Object> parameters) {
        // 契約書類生成API
    }
    
    @GetMapping("/{id}/signatures")
    public ResponseEntity<List<SignatureRequestDTO>> getSignatureRequests(@PathVariable UUID id) {
        // 署名リクエスト一覧API
    }
    
    @PostMapping("/{id}/signature-requests")
    public ResponseEntity<SignatureRequestDTO> createSignatureRequest(@PathVariable UUID id, @RequestBody SignatureRequestDTO requestDTO) {
        // 署名リクエスト作成API
    }
}
```

**SignatureController（署名機能専用）**

```java
@Controller
@RequestMapping("/signatures")
public class SignatureController {

    @GetMapping("/{token}")
    public String signatureView(@PathVariable String token, Model model) {
        // 署名画面表示
    }
    
    @PostMapping("/{token}/sign")
    public String signDocument(@PathVariable String token, @RequestParam String signatureData) {
        // 署名実行処理
    }
    
    @PostMapping("/{token}/reject")
    public String rejectSignature(@PathVariable String token, @RequestParam String reason) {
        // 署名拒否処理
    }
}
```

### 4.2 Service

**ContractService（インターフェース）**

```java
public interface ContractService {
    Page<ContractDTO> searchContracts(ContractSearchDTO searchDTO, Pageable pageable);
    ContractDTO getContractById(UUID id);
    ContractDTO createContract(ContractDTO contractDTO);
    ContractDTO updateContract(UUID id, ContractDTO contractDTO);
    void updateContractStatus(UUID id, ContractStatus status);
    List<ContractDocumentDTO> getContractDocuments(UUID contractId);
    ContractDocumentDTO generateContractDocument(UUID contractId, Map<String, Object> parameters);
    ContractDocumentDTO getLatestContractDocument(UUID contractId);
    Resource downloadContractDocument(UUID documentId);
    ContractDTO renewContract(UUID id, ContractDTO renewalDTO);
    List<ContractDTO> findExpiringContracts(int daysThreshold);
}
```

**ContractServiceImpl（実装クラス）**

```java
@Service
@Transactional(readOnly = true)
public class ContractServiceImpl implements ContractService {

    private final ContractRepository contractRepository;
    private final DocumentRepository documentRepository;
    private final DocumentGenerationService documentGenerationService;
    private final StorageAdapter storageAdapter;
    private final ContractMapper contractMapper;
    private final ProjectService projectService;
    private final EngineerService engineerService;
    
    // コンストラクタ注入
    
    @Override
    public Page<ContractDTO> searchContracts(ContractSearchDTO searchDTO, Pageable pageable) {
        // 検索条件をもとに契約を検索
        Page<Contract> contracts = contractRepository.findByConditions(
            searchDTO.getKeyword(),
            searchDTO.getStatus(),
            searchDTO.getProjectId(),
            searchDTO.getEngineerId(),
            searchDTO.getClientId(),
            searchDTO.getStartDateFrom(),
            searchDTO.getStartDateTo(),
            searchDTO.getEndDateFrom(),
            searchDTO.getEndDateTo(),
            pageable
        );
        
        return contracts.map(contractMapper::toDto);
    }
    
    @Override
    @Transactional
    public ContractDTO createContract(ContractDTO contractDTO) {
        // 契約番号生成
        String contractNumber = generateContractNumber();
        
        // DTOからエンティティに変換
        Contract contract = contractMapper.toEntity(contractDTO);
        contract.setContractNumber(contractNumber);
        
        // 日時設定
        LocalDateTime now = LocalDateTime.now();
        contract.setCreatedAt(now);
        contract.setUpdatedAt(now);
        contract.setCreatedBy(getCurrentUserId());
        
        // 初期ステータス設定
        contract.setStatus(ContractStatus.DRAFT);
        
        // 保存
        Contract savedContract = contractRepository.save(contract);
        
        return contractMapper.toDto(savedContract);
    }
    
    @Override
    @Transactional
    public ContractDocumentDTO generateContractDocument(UUID contractId, Map<String, Object> parameters) {
        // 契約情報取得
        Contract contract = contractRepository.findById(contractId)
            .orElseThrow(() -> new EntityNotFoundException("Contract not found"));
        
        // 関連情報取得（案件、技術者、顧客など）
        Map<String, Object> contextData = new HashMap<>(parameters);
        contextData.put("contract", contractMapper.toDto(contract));
        contextData.put("project", projectService.getProjectById(contract.getProjectId()));
        contextData.put("engineer", engineerService.getEngineerById(contract.getEngineerId()));
        
        // 書類生成
        ContractDocument document = documentGenerationService.generateDocument(
            contract, 
            "STANDARD_CONTRACT", 
            contextData
        );
        
        // PDF変換
        UUID fileId = documentGenerationService.generatePdf(document);
        document.setFileId(fileId);
        
        // バージョン管理
        int version = documentRepository.getMaxVersionForContract(contractId) + 1;
        document.setVersion(version);
        
        // 保存
        ContractDocument savedDocument = documentRepository.save(document);
        
        // 最新書類として設定
        contract.setLatestDocumentId(savedDocument.getId());
        contractRepository.save(contract);
        
        return documentMapper.toDto(savedDocument);
    }
    
    // 他のメソッド実装
}
```

**SignatureService（インターフェース）**

```java
public interface SignatureService {
    SignatureRequestDTO createSignatureRequest(UUID contractId, UUID documentId, SignatureRequestDTO requestDTO);
    List<SignatureRequestDTO> getSignatureRequests(UUID contractId);
    SignatureRequestDTO getSignatureRequestByToken(String token);
    SignatureRequestDTO completeSignature(String token, String signatureData, String ipAddress);
    SignatureRequestDTO rejectSignature(String token, String reason);
    boolean isAllSignaturesCompleted(UUID contractId, UUID documentId);
    void sendSignatureReminders(UUID contractId);
}
```

**TemplateService（インターフェース）**

```java
public interface TemplateService {
    List<ContractTemplateDTO> getAllTemplates();
    List<ContractTemplateDTO> getActiveTemplates();
    ContractTemplateDTO getTemplateById(UUID id);
    ContractTemplateDTO createTemplate(ContractTemplateDTO templateDTO);
    ContractTemplateDTO updateTemplate(UUID id, ContractTemplateDTO templateDTO);
    void activateTemplate(UUID id);
    void deactivateTemplate(UUID id);
    String previewTemplate(UUID id, Map<String, Object> contextData);
}
```

## 5. 書類生成とテンプレート処理

### 5.1 テンプレートエンジン

契約書の生成にはThymeleafテンプレートエンジンを使用します。

```java
@Service
public class DocumentGenerationService {

    private final TemplateEngine templateEngine;
    private final TemplateRepository templateRepository;
    private final PdfGenerationAdapter pdfAdapter;
    private final StorageAdapter storageAdapter;
    
    public DocumentGenerationService(
            TemplateEngine templateEngine,
            TemplateRepository templateRepository,
            PdfGenerationAdapter pdfAdapter,
            StorageAdapter storageAdapter) {
        this.templateEngine = templateEngine;
        this.templateRepository = templateRepository;
        this.pdfAdapter = pdfAdapter;
        this.storageAdapter = storageAdapter;
    }
    
    public ContractDocument generateDocument(Contract contract, String templateType, Map<String, Object> contextData) {
        // テンプレート取得
        ContractTemplate template = templateRepository.findByTypeAndActive(templateType, true)
            .orElseThrow(() -> new IllegalStateException("Active template not found for type: " + templateType));
        
        // テンプレート処理コンテキスト作成
        Context context = new Context();
        for (Map.Entry<String, Object> entry : contextData.entrySet()) {
            context.setVariable(entry.getKey(), entry.getValue());
        }
        
        // テンプレート処理実行
        String processedHtml = templateEngine.process(template.getContent(), context);
        
        // 契約書類エンティティ作成
        ContractDocument document = new ContractDocument();
        document.setContractId(contract.getId());
        document.setDocumentType(templateType);
        document.setContent(template.getContent());  // オリジナルテンプレート保存
        document.setRenderedContent(processedHtml);  // レンダリング済みHTML
        document.setCreatedAt(LocalDateTime.now());
        document.setCreatedBy(getCurrentUserId());
        document.setFinalVersion(false);
        
        return document;
    }
    
    public UUID generatePdf(ContractDocument document) {
        // HTMLからPDF生成
        byte[] pdfContent = pdfAdapter.generatePdf(document.getRenderedContent());
        
        // ストレージに保存
        String fileName = "contract_" + document.getContractId() + "_v" + document.getVersion() + ".pdf";
        UUID fileId = storageAdapter.storeFile(pdfContent, fileName, "application/pdf");
        
        return fileId;
    }
}
```

### 5.2 プレースホルダー管理

テンプレート内のプレースホルダーは標準化し、管理します。

```java
public class ContractTemplatePlaceholders {
    // 契約基本情報
    public static final String CONTRACT_NUMBER = "contract.contractNumber";
    public static final String START_DATE = "contract.startDate";
    public static final String END_DATE = "contract.endDate";
    public static final String UNIT_PRICE = "contract.unitPrice";
    
    // 案件情報
    public static final String PROJECT_NAME = "project.name";
    public static final String PROJECT_DESCRIPTION = "project.description";
    public static final String PROJECT_LOCATION = "project.location";
    
    // 技術者情報
    public static final String ENGINEER_NAME = "engineer.name";
    public static final String ENGINEER_EMAIL = "engineer.email";
    public static final String ENGINEER_SKILLS = "engineer.skills";
    
    // 顧客情報
    public static final String CLIENT_NAME = "client.name";
    public static final String CLIENT_ADDRESS = "client.address";
    public static final String CLIENT_CONTACT_PERSON = "client.contactPerson";
    
    // その他
    public static final String GENERATED_DATE = "generatedDate";
    public static final String COMPANY_NAME = "companyName";
    public static final String COMPANY_ADDRESS = "companyAddress";
    
    // プレースホルダーマップ取得
    public static Map<String, String> getPlaceholderDescriptions() {
        Map<String, String> descriptions = new HashMap<>();
        descriptions.put(CONTRACT_NUMBER, "契約番号");
        descriptions.put(START_DATE, "契約開始日");
        descriptions.put(END_DATE, "契約終了日");
        descriptions.put(UNIT_PRICE, "単価");
        descriptions.put(PROJECT_NAME, "案件名");
        descriptions.put(PROJECT_DESCRIPTION, "案件概要");
        descriptions.put(PROJECT_LOCATION, "勤務地");
        descriptions.put(ENGINEER_NAME, "技術者名");
        descriptions.put(ENGINEER_EMAIL, "技術者メールアドレス");
        descriptions.put(ENGINEER_SKILLS, "技術者スキル");
        descriptions.put(CLIENT_NAME, "顧客名");
        descriptions.put(CLIENT_ADDRESS, "顧客住所");
        descriptions.put(CLIENT_CONTACT_PERSON, "顧客担当者");
        descriptions.put(GENERATED_DATE, "作成日");
        descriptions.put(COMPANY_NAME, "自社名");
        descriptions.put(COMPANY_ADDRESS, "自社住所");
        return descriptions;
    }
}
```

## 6. 電子署名機能

### 6.1 署名リクエスト生成

```java
@Service
@Transactional(readOnly = true)
public class SignatureServiceImpl implements SignatureService {

    private final SignatureRepository signatureRepository;
    private final ContractRepository contractRepository;
    private final DocumentRepository documentRepository;
    private final NotificationService notificationService;
    private final ElectronicSignatureAdapter signatureAdapter;
    
    @Override
    @Transactional
    public SignatureRequestDTO createSignatureRequest(UUID contractId, UUID documentId, SignatureRequestDTO requestDTO) {
        // 契約・書類存在チェック
        Contract contract = contractRepository.findById(contractId)
            .orElseThrow(() -> new EntityNotFoundException("Contract not found"));
        
        ContractDocument document = documentRepository.findById(documentId)
            .orElseThrow(() -> new EntityNotFoundException("Contract document not found"));
        
        // アクセストークン生成
        String accessToken = generateSecureToken();
        
        // 署名リクエスト作成
        SignatureRequest request = new SignatureRequest();
        request.setContractId(contractId);
        request.setDocumentId(documentId);
        request.setRequestToUserId(requestDTO.getRequestToUserId());
        request.setRequestToEmail(requestDTO.getRequestToEmail());
        request.setRequestToName(requestDTO.getRequestToName());
        request.setStatus(SignatureStatus.PENDING);
        request.setRequestedAt(LocalDateTime.now());
        request.setAccessToken(accessToken);
        
        // 有効期限設定（デフォルト14日）
        request.setExpiresAt(LocalDateTime.now().plusDays(14));
        
        // 保存
        SignatureRequest savedRequest = signatureRepository.save(request);
        
        // 通知送信
        notificationService.sendSignatureRequest(savedRequest);
        
        return signatureMapper.toDto(savedRequest);
    }
    
    @Override
    @Transactional
    public SignatureRequestDTO completeSignature(String token, String signatureData, String ipAddress) {
        // トークンから署名リクエスト取得
        SignatureRequest request = signatureRepository.findByAccessToken(token)
            .orElseThrow(() -> new EntityNotFoundException("Signature request not found"));
        
        // 有効期限チェック
        if (LocalDateTime.now().isAfter(request.getExpiresAt())) {
            request.setStatus(SignatureStatus.EXPIRED);
            signatureRepository.save(request);
            throw new IllegalStateException("Signature request has expired");
        }
        
        // 署名データ検証
        signatureAdapter.validateSignature(signatureData);
        
        // 署名完了処理
        request.setStatus(SignatureStatus.COMPLETED);
        request.setCompletedAt(LocalDateTime.now());
        request.setSignatureData(signatureData);
        request.setSignerIpAddress(ipAddress);
        
        SignatureRequest savedRequest = signatureRepository.save(request);
        
        // 全署名完了チェックと契約ステータス更新
        checkAndUpdateContractStatus(request.getContractId(), request.getDocumentId());
        
        // 通知送信
        notificationService.sendSignatureCompleted(savedRequest);
        
        return signatureMapper.toDto(savedRequest);
    }
    
    private void checkAndUpdateContractStatus(UUID contractId, UUID documentId) {
        if (isAllSignaturesCompleted(contractId, documentId)) {
            Contract contract = contractRepository.findById(contractId)
                .orElseThrow(() -> new EntityNotFoundException("Contract not found"));
                
            // 契約ステータス更新
            contract.setStatus(ContractStatus.ACTIVE);
            contractRepository.save(contract);
            
            // 契約書を最終版に設定
            ContractDocument document = documentRepository.findById(documentId)
                .orElseThrow(() -> new EntityNotFoundException("Document not found"));
            document.setFinalVersion(true);
            documentRepository.save(document);
        }
    }
    
    // 他のメソッド実装
}
```

### 6.2 署名トークン生成

```java
private String generateSecureToken() {
    byte[] randomBytes = new byte[32];
    new SecureRandom().nextBytes(randomBytes);
    return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
}
```

## 7. 契約ライフサイクル管理

### 7.1 契約番号生成ロジック

```java
private String generateContractNumber() {
    // 現在年月の取得
    LocalDate now = LocalDate.now();
    int year = now.getYear();
    int month = now.getMonthValue();
    
    // その年月の契約数（シーケンス）を取得
    int sequence = contractRepository.countByYearAndMonth(year, month) + 1;
    
    // フォーマット: CNT-YYYYMM-NNNN
    // 例: CNT-202304-0001
    return String.format("CNT-%d%02d-%04d", year, month, sequence);
}
```

### 7.2 契約ステータス遷移ルール

```java
public boolean canTransitionTo(ContractStatus newStatus) {
    switch (this.status) {
        case DRAFT:
            // 下書きからはレビュー待ちまたはキャンセルに変更可能
            return newStatus == ContractStatus.PENDING_REVIEW || 
                   newStatus == ContractStatus.CANCELLED;
                   
        case PENDING_REVIEW:
            // レビュー待ちからは承認待ち、下書きに戻す、またはキャンセルに変更可能
            return newStatus == ContractStatus.PENDING_APPROVAL || 
                   newStatus == ContractStatus.DRAFT || 
                   newStatus == ContractStatus.CANCELLED;
                   
        case PENDING_APPROVAL:
            // 承認待ちからは署名待ち、レビュー待ちに戻す、またはキャンセルに変更可能
            return newStatus == ContractStatus.PENDING_SIGNATURE || 
                   newStatus == ContractStatus.PENDING_REVIEW || 
                   newStatus == ContractStatus.CANCELLED;
                   
        case PENDING_SIGNATURE:
            // 署名待ちからは契約中、承認待ちに戻す、またはキャンセルに変更可能
            return newStatus == ContractStatus.ACTIVE || 
                   newStatus == ContractStatus.PENDING_APPROVAL || 
                   newStatus == ContractStatus.CANCELLED;
                   
        case ACTIVE:
            // 契約中からは期間満了、契約終了に変更可能
            return newStatus == ContractStatus.EXPIRED || 
                   newStatus == ContractStatus.TERMINATED;
                   
        case EXPIRED:
        case TERMINATED:
        case CANCELLED:
            // 期間満了、契約終了、キャンセルからの変更は不可
            return false;
            
        default:
            return false;
    }
}
```

### 7.3 契約更新処理

```java
@Override
@Transactional
public ContractDTO renewContract(UUID id, ContractDTO renewalDTO) {
    // 元の契約を取得
    Contract originalContract = contractRepository.findById(id)
        .orElseThrow(() -> new EntityNotFoundException("Contract not found"));
    
    // 元の契約が更新可能かチェック（ACTIVE または EXPIRED のみ）
    if (originalContract.getStatus() != ContractStatus.ACTIVE && 
        originalContract.getStatus() != ContractStatus.EXPIRED) {
        throw new IllegalStateException("Contract is not in a renewable state");
    }
    
    // 新規契約を作成
    Contract newContract = new Contract();
    
    // 基本情報をコピー
    newContract.setProjectId(originalContract.getProjectId());
    newContract.setEngineerId(originalContract.getEngineerId());
    newContract.setClientId(originalContract.getClientId());
    
    // 更新情報を設定
    newContract.setStartDate(renewalDTO.getStartDate());
    newContract.setEndDate(renewalDTO.getEndDate());
    newContract.setUnitPrice(renewalDTO.getUnitPrice());
    newContract.setUnitType(renewalDTO.getUnitType());
    newContract.setWorkingHoursPerDay(renewalDTO.getWorkingHoursPerDay());
    newContract.setWorkingDaysPerMonth(renewalDTO.getWorkingDaysPerMonth());
    newContract.setContractTerms(renewalDTO.getContractTerms());
    newContract.setPaymentTerms(renewalDTO.getPaymentTerms());
    newContract.setSpecialConditions(renewalDTO.getSpecialConditions());
    
    // 契約番号生成
    newContract.setContractNumber(generateContractNumber());
    
    // 初期ステータス設定
    newContract.setStatus(ContractStatus.DRAFT);
    
    // 日時設定
    LocalDateTime now = LocalDateTime.now();
    newContract.setCreatedAt(now);
    newContract.setUpdatedAt(now);
    newContract.setCreatedBy(getCurrentUserId());
    
    // 保存
    Contract savedContract = contractRepository.save(newContract);
    
    // 元の契約の状態を更新（既に EXPIRED でなければ）
    if (originalContract.getStatus() == ContractStatus.ACTIVE) {
        originalContract.setStatus(ContractStatus.EXPIRED);
        contractRepository.save(originalContract);
    }
    
    return contractMapper.toDto(savedContract);
}
```

## 8. PDF生成

PDF生成はOpen HTML to PDFライブラリを使用します。

```java
@Component
public class PdfGenerationAdapter {

    private final PdfRendererBuilder pdfRendererBuilder;
    
    public PdfGenerationAdapter() {
        this.pdfRendererBuilder = new PdfRendererBuilder();
        // フォント設定など
    }
    
    public byte[] generatePdf(String htmlContent) {
        try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
            pdfRendererBuilder.withHtmlContent(htmlContent, null);
            pdfRendererBuilder.toStream(outputStream);
            pdfRendererBuilder.run();
            
            return outputStream.toByteArray();
        } catch (Exception e) {
            throw new RuntimeException("PDF generation failed", e);
        }
    }
}
```

## 9. 画面設計

契約管理機能の主要画面遷移は以下の通りです。

```
+----------------+     +-------------------+     +------------------+
| 契約一覧画面   |---->| 契約新規作成画面   |---->| 契約詳細画面     |
| (検索・フィルタ)|     |                   |     | (作成完了表示)   |
+----------------+     +-------------------+     +------------------+
        |
        v
+----------------+     +-------------------+     +------------------+
| 契約詳細画面   |---->| 契約書生成画面     |---->| 契約書プレビュー |
|                |     |                   |     |                  |
+----------------+     +-------------------+     +------------------+
        |                                              |
        v                                              v
+----------------+     +-------------------+     +------------------+
| 署名リクエスト |---->| 署名確認画面       |---->| 署名完了画面     |
| 作成画面       |     | (外部ユーザー向け) |     |                  |
+----------------+     +-------------------+     +------------------+
```

## 10. セキュリティ設計

契約情報は特に機密性の高いデータを含むため、厳格なアクセス制御を実施します。

| 役割 | 契約参照 | 契約作成 | 契約更新 | 書類生成 | 署名依頼 | 書類閲覧 |
|------|---------|---------|---------|---------|---------|---------|
| 管理者 | ○ | ○ | ○ | ○ | ○ | ○ |
| 契約管理者 | ○ | ○ | ○ | ○ | ○ | ○ |
| 営業担当 | 担当案件のみ | ○ | 担当案件のみ | ○ | ○ | 担当案件のみ |
| 技術者 | 自分の契約のみ | × | × | × | × | 自分の契約のみ |

具体的な実装は、Spring Securityのメソッドレベルセキュリティと独自の権限チェックを組み合わせます。

```java
@PreAuthorize("hasAnyRole('ADMIN', 'CONTRACT_MANAGER')")
public ContractDTO createContract(ContractDTO contractDTO);

@PreAuthorize("hasAnyRole('ADMIN', 'CONTRACT_MANAGER') or @contractSecurityService.isSalesPersonForProject(authentication.principal, #contractDTO.projectId)")
public ContractDTO updateContract(UUID id, ContractDTO contractDTO);

@PreAuthorize("hasAnyRole('ADMIN', 'CONTRACT_MANAGER') or @contractSecurityService.isRelatedToContract(authentication.principal, #id)")
public ContractDTO getContractById(UUID id);

@PreAuthorize("hasAnyRole('ADMIN', 'CONTRACT_MANAGER') or @contractSecurityService.isEngineerOfContract(authentication.principal, #contractId)")
public List<ContractDocumentDTO> getContractDocuments(UUID contractId);
```

## 11. 監査ログ

契約関連の重要な操作はすべて監査ログに記録します。

```java
@Aspect
@Component
public class ContractAuditLogAspect {

    private final AuditLogService auditLogService;
    
    @AfterReturning(pointcut = "execution(* jp.co.system_engineer_service.contract.application.service.ContractService.createContract(..))", returning = "result")
    public void logContractCreation(JoinPoint joinPoint, ContractDTO result) {
        Object[] args = joinPoint.getArgs();
        ContractDTO dto = (ContractDTO) args[0];
        
        auditLogService.logEvent(
            "CONTRACT_CREATED",
            "Contract created: " + result.getContractNumber(),
            Map.of(
                "contractId", result.getId().toString(),
                "contractNumber", result.getContractNumber(),
                "projectId", result.getProjectId().toString(),
                "engineerId", result.getEngineerId().toString(),
                "createdBy", result.getCreatedBy().toString()
            )
        );
    }
    
    @AfterReturning(pointcut = "execution(* jp.co.system_engineer_service.contract.application.service.SignatureService.completeSignature(..))", returning = "result")
    public void logSignatureCompletion(JoinPoint joinPoint, SignatureRequestDTO result) {
        String token = (String) joinPoint.getArgs()[0];
        
        auditLogService.logEvent(
            "SIGNATURE_COMPLETED",
            "Signature completed for contract: " + result.getContractId(),
            Map.of(
                "signatureRequestId", result.getId().toString(),
                "contractId", result.getContractId().toString(),
                "signerName", result.getRequestToName(),
                "signerEmail", result.getRequestToEmail(),
                "completedAt", result.getCompletedAt().toString()
            )
        );
    }
    
    // 他の監査ポイント
}
```

## 12. バッチ処理

### 12.1 期限切れ契約チェック

```java
@Component
@EnableScheduling
public class ContractExpirationScheduler {

    private final ContractService contractService;
    private final NotificationService notificationService;
    
    @Scheduled(cron = "0 0 9 * * *") // 毎日午前9時に実行
    public void checkExpiringContracts() {
        // 30日以内に期限切れになる契約を取得
        List<ContractDTO> expiringContracts = contractService.findExpiringContracts(30);
        
        for (ContractDTO contract : expiringContracts) {
            // 残り日数計算
            long daysLeft = ChronoUnit.DAYS.between(LocalDate.now(), contract.getEndDate());
            
            if (daysLeft <= 7) {
                // 7日以内なら緊急通知
                notificationService.sendUrgentContractExpirationNotice(contract);
            } else if (daysLeft <= 14) {
                // 14日以内なら注意通知
                notificationService.sendContractExpirationWarning(contract);
            } else {
                // それ以外は標準通知
                notificationService.sendContractExpirationNotice(contract);
            }
        }
    }
}
```

### 12.2 署名リマインダー

```java
@Component
@EnableScheduling
public class SignatureReminderScheduler {

    private final SignatureService signatureService;
    private final SignatureRepository signatureRepository;
    private final NotificationService notificationService;
    
    @Scheduled(cron = "0 0 10 * * *") // 毎日午前10時に実行
    public void sendSignatureReminders() {
        // 3日以上経過した未署名リクエストを取得
        List<SignatureRequest> pendingRequests = signatureRepository.findPendingSignatureRequests(
            SignatureStatus.PENDING,
            LocalDateTime.now().minusDays(3)
        );
        
        for (SignatureRequest request : pendingRequests) {
            // リマインダー通知送信
            notificationService.sendSignatureReminder(request);
        }
    }
}
```

## 13. テスト計画

### 13.1 単体テスト

- 契約ステータス遷移ロジックのテスト
- 契約番号生成ロジックのテスト
- テンプレート処理のテスト
- PDF生成機能のテスト

### 13.2 結合テスト

- 契約作成から署名完了までのフロー
- 契約更新プロセス
- テンプレート変更と契約書生成の連携

### 13.3 セキュリティテスト

- 権限による機能制限のテスト
- 署名トークンのセキュリティチェック
- 監査ログ記録の検証