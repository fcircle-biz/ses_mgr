# マッチング機能モジュール詳細設計

## 1. 概要

マッチング機能モジュールは、SES業務システムの中核機能として、案件と技術者のマッチングを効率的に行うための機能を提供します。案件要件と技術者スキルの相関分析、類似度スコアリング、提案管理といった機能を通じて、最適な案件-技術者のマッチングを実現します。

### 1.1 主要機能

- 案件-技術者マッチング検索
- マッチングスコア算出
- マッチング候補の管理
- 提案管理
- マッチング履歴管理
- アルゴリズムベースの候補者推薦

### 1.2 ユースケース

- マッチング担当者が案件に適した技術者を検索する
- 営業担当者が技術者に適した案件を検索する
- 技術者のスキルと案件要件の適合度を評価する
- 提案書を作成・管理する
- マッチング成立率を分析する

## 2. アーキテクチャ設計

マッチングモジュールは、全体アーキテクチャに準拠した4層構造で設計します。マッチングアルゴリズムはドメイン層のサービスとして実装します。

### 2.1 コンポーネント構成

```
jp.co.system_engineer_service.matching
├── presentation
│   ├── controller
│   │   ├── MatchingController.java （Web向けコントローラ）
│   │   └── MatchingRestController.java （REST API向けコントローラ）
│   └── dto
│       ├── MatchingSearchDTO.java （検索条件用DTO）
│       ├── MatchingResultDTO.java （マッチング結果DTO）
│       └── ProposalDTO.java （提案用DTO）
├── application
│   ├── service
│   │   ├── MatchingService.java （インターフェース）
│   │   └── MatchingServiceImpl.java（実装クラス）
│   └── mapper
│       ├── MatchingMapper.java （DTO⇔エンティティ変換）
│       └── ProposalMapper.java （提案DTO変換）
├── domain
│   ├── model
│   │   ├── MatchingResult.java （マッチング結果エンティティ）
│   │   ├── MatchingScore.java （スコア計算用値オブジェクト）
│   │   ├── Proposal.java （提案エンティティ）
│   │   └── ProposalStatus.java （提案状態列挙型）
│   ├── repository
│   │   ├── MatchingResultRepository.java （結果リポジトリ）
│   │   └── ProposalRepository.java （提案リポジトリ）
│   └── service
│       ├── MatchingAlgorithmService.java （マッチングアルゴリズム）
│       └── ProposalDomainService.java （提案ドメインサービス）
└── infrastructure
    ├── repository
    │   ├── MatchingResultRepositoryImpl.java （結果リポジトリ実装）
    │   └── ProposalRepositoryImpl.java （提案リポジトリ実装）
    └── entity
        ├── MatchingResultEntity.java （マッチング結果DBエンティティ）
        └── ProposalEntity.java （提案DBエンティティ）
```

## 3. データモデル設計

### 3.1 エンティティ定義

**MatchingResult（マッチング結果）エンティティ**

```java
public class MatchingResult {
    private UUID id;                 // マッチング結果ID
    private UUID projectId;          // 案件ID
    private UUID engineerId;         // 技術者ID
    private double matchingScore;    // マッチングスコア（0-100）
    private Map<String, Double> scoreDetails; // スコア詳細（カテゴリ別）
    private LocalDateTime calculatedAt; // 計算日時
    private String algorithm;        // 使用アルゴリズム
    private UUID calculatedBy;       // 計算実行ユーザーID
    private boolean favorite;        // お気に入りフラグ
    private String memo;             // メモ
    
    // コンストラクタ、ゲッター、セッター
}
```

**Proposal（提案）エンティティ**

```java
public class Proposal {
    private UUID id;                 // 提案ID
    private String proposalNumber;   // 提案番号
    private UUID projectId;          // 案件ID
    private UUID engineerId;         // 技術者ID
    private ProposalStatus status;   // 提案状態
    private LocalDate proposalDate;  // 提案日
    private UUID proposalDocumentId; // 提案書ドキュメントID
    private UUID salesPersonId;      // 提案担当者ID
    private String feedbackNotes;    // フィードバックメモ
    private LocalDate responseDeadline; // 回答期限
    private LocalDateTime createdAt;  // 作成日時
    private LocalDateTime updatedAt;  // 更新日時
    
    // ビジネスメソッド
    public boolean canTransitionTo(ProposalStatus newStatus) {
        // ステータス遷移ルールのチェック
    }
    
    // コンストラクタ、ゲッター、セッター
}
```

**ProposalStatus（提案状態）列挙型**

```java
public enum ProposalStatus {
    DRAFT("下書き"),
    SUBMITTED("提出済"),
    IN_REVIEW("検討中"),
    ACCEPTED("承認"),
    REJECTED("却下"),
    CANCELED("取消");
    
    private final String displayName;
    
    // コンストラクタ、ゲッター
}
```

### 3.2 データベース設計

**matching_results テーブル**

| カラム名 | データ型 | 制約 | 説明 |
|---------|---------|------|------|
| id | UUID | PK | マッチング結果ID |
| project_id | UUID | FK, NOT NULL | 案件ID |
| engineer_id | UUID | FK, NOT NULL | 技術者ID |
| matching_score | DOUBLE | NOT NULL | マッチングスコア |
| score_details | JSONB | | スコア詳細 |
| calculated_at | TIMESTAMP | NOT NULL | 計算日時 |
| algorithm | VARCHAR(100) | | 使用アルゴリズム |
| calculated_by | UUID | FK | 計算実行ユーザーID |
| favorite | BOOLEAN | DEFAULT FALSE | お気に入りフラグ |
| memo | TEXT | | メモ |

**proposals テーブル**

| カラム名 | データ型 | 制約 | 説明 |
|---------|---------|------|------|
| id | UUID | PK | 提案ID |
| proposal_number | VARCHAR(50) | UK, NOT NULL | 提案番号 |
| project_id | UUID | FK, NOT NULL | 案件ID |
| engineer_id | UUID | FK, NOT NULL | 技術者ID |
| status | VARCHAR(50) | NOT NULL | 提案状態 |
| proposal_date | DATE | NOT NULL | 提案日 |
| proposal_document_id | UUID | FK | 提案書ドキュメントID |
| sales_person_id | UUID | FK, NOT NULL | 提案担当者ID |
| feedback_notes | TEXT | | フィードバックメモ |
| response_deadline | DATE | | 回答期限 |
| created_at | TIMESTAMP | NOT NULL | 作成日時 |
| updated_at | TIMESTAMP | NOT NULL | 更新日時 |

## 4. インターフェース設計

### 4.1 Controller

**MatchingController（Web画面用）**

```java
@Controller
@RequestMapping("/matching")
public class MatchingController {

    @GetMapping("/search")
    public String searchForm(Model model) {
        // マッチング検索フォーム表示
    }
    
    @PostMapping("/search")
    public String search(@Valid MatchingSearchDTO searchDTO, Model model) {
        // マッチング検索実行
    }
    
    @GetMapping("/results")
    public String results(Model model, @RequestParam UUID projectId) {
        // 特定案件のマッチング結果一覧表示
    }
    
    @GetMapping("/result/{id}")
    public String resultDetail(@PathVariable UUID id, Model model) {
        // マッチング結果詳細表示
    }
    
    @GetMapping("/proposals")
    public String proposalList(Model model) {
        // 提案一覧表示
    }
    
    @GetMapping("/proposals/{id}")
    public String proposalDetail(@PathVariable UUID id, Model model) {
        // 提案詳細表示
    }
    
    @GetMapping("/proposals/new")
    public String createProposalForm(Model model, @RequestParam UUID matchingResultId) {
        // 提案作成フォーム
    }
    
    @PostMapping("/proposals")
    public String createProposal(@Valid ProposalDTO proposalDTO) {
        // 提案作成処理
    }
}
```

**MatchingRestController（REST API用）**

```java
@RestController
@RequestMapping("/api/matching")
public class MatchingRestController {

    @PostMapping("/search")
    public ResponseEntity<Page<MatchingResultDTO>> search(
            @RequestBody MatchingSearchDTO searchDTO, 
            Pageable pageable) {
        // マッチング検索API
    }
    
    @GetMapping("/projects/{projectId}/results")
    public ResponseEntity<List<MatchingResultDTO>> getResultsByProject(
            @PathVariable UUID projectId) {
        // 案件別マッチング結果API
    }
    
    @GetMapping("/engineers/{engineerId}/results")
    public ResponseEntity<List<MatchingResultDTO>> getResultsByEngineer(
            @PathVariable UUID engineerId) {
        // 技術者別マッチング結果API
    }
    
    @GetMapping("/results/{id}")
    public ResponseEntity<MatchingResultDTO> getResultById(@PathVariable UUID id) {
        // マッチング結果詳細API
    }
    
    @PostMapping("/results/{id}/favorite")
    public ResponseEntity<Void> toggleFavorite(@PathVariable UUID id) {
        // お気に入り切替API
    }
    
    @PostMapping("/proposals")
    public ResponseEntity<ProposalDTO> createProposal(
            @RequestBody @Valid ProposalDTO proposalDTO) {
        // 提案作成API
    }
    
    @GetMapping("/proposals")
    public ResponseEntity<Page<ProposalDTO>> getProposals(
            @RequestParam(required = false) ProposalStatus status,
            Pageable pageable) {
        // 提案一覧取得API
    }
    
    @PatchMapping("/proposals/{id}/status")
    public ResponseEntity<Void> updateProposalStatus(
            @PathVariable UUID id, 
            @RequestBody String status) {
        // 提案ステータス更新API
    }
}
```

### 4.2 Service

**MatchingService（インターフェース）**

```java
public interface MatchingService {
    Page<MatchingResultDTO> searchMatching(MatchingSearchDTO searchDTO, Pageable pageable);
    List<MatchingResultDTO> findMatchingResultsByProject(UUID projectId);
    List<MatchingResultDTO> findMatchingResultsByEngineer(UUID engineerId);
    MatchingResultDTO getMatchingResultById(UUID id);
    void toggleFavorite(UUID matchingResultId);
    MatchingResultDTO calculateSingleMatching(UUID projectId, UUID engineerId);
    List<MatchingResultDTO> calculateBatchMatching(UUID projectId);
    ProposalDTO createProposal(ProposalDTO proposalDTO);
    Page<ProposalDTO> findProposals(ProposalStatus status, Pageable pageable);
    void updateProposalStatus(UUID proposalId, ProposalStatus status);
}
```

**MatchingServiceImpl（実装クラス）**

```java
@Service
@Transactional(readOnly = true)
public class MatchingServiceImpl implements MatchingService {

    private final MatchingResultRepository matchingResultRepository;
    private final ProposalRepository proposalRepository;
    private final MatchingAlgorithmService matchingAlgorithmService;
    private final ProjectService projectService;
    private final EngineerService engineerService;
    private final MatchingMapper matchingMapper;
    private final ProposalMapper proposalMapper;
    
    // コンストラクタ注入
    
    @Override
    public Page<MatchingResultDTO> searchMatching(MatchingSearchDTO searchDTO, Pageable pageable) {
        // 検索条件に基づいてマッチング結果を検索
        Page<MatchingResult> results;
        
        if (searchDTO.getProjectId() != null) {
            // 特定案件のマッチング検索
            results = matchingResultRepository.findByProjectIdAndSkillCriteria(
                searchDTO.getProjectId(),
                searchDTO.getMinimumScore(),
                searchDTO.getSkillIds(),
                searchDTO.getExperienceYears(),
                pageable
            );
        } else if (searchDTO.getEngineerId() != null) {
            // 特定技術者の案件マッチング検索
            results = matchingResultRepository.findByEngineerIdAndProjectCriteria(
                searchDTO.getEngineerId(),
                searchDTO.getMinimumScore(),
                searchDTO.getLocation(),
                searchDTO.getProjectTypes(),
                pageable
            );
        } else {
            // 基本検索条件
            results = matchingResultRepository.findByBasicCriteria(
                searchDTO.getMinimumScore(),
                searchDTO.getFavoriteOnly(),
                pageable
            );
        }
        
        return results.map(matchingMapper::toDto);
    }
    
    @Override
    @Transactional
    public MatchingResultDTO calculateSingleMatching(UUID projectId, UUID engineerId) {
        // 案件データ取得
        ProjectDTO project = projectService.getProjectById(projectId);
        
        // 技術者データ取得
        EngineerDTO engineer = engineerService.getEngineerById(engineerId);
        
        // マッチングアルゴリズム実行
        MatchingScore score = matchingAlgorithmService.calculateMatchingScore(project, engineer);
        
        // マッチング結果の保存
        MatchingResult result = new MatchingResult();
        result.setProjectId(projectId);
        result.setEngineerId(engineerId);
        result.setMatchingScore(score.getTotalScore());
        result.setScoreDetails(score.getCategoryScores());
        result.setCalculatedAt(LocalDateTime.now());
        result.setAlgorithm("StandardMatching-v1");
        result.setCalculatedBy(getCurrentUserId());
        
        MatchingResult savedResult = matchingResultRepository.save(result);
        
        return matchingMapper.toDto(savedResult);
    }
    
    // 他のメソッド実装
}
```

## 5. マッチングアルゴリズム設計

マッチングアルゴリズムはドメインサービスとして実装し、複数の評価軸に基づいてスコアを算出します。

### 5.1 基本アルゴリズム

```java
@Service
public class MatchingAlgorithmService {

    // カテゴリ別の重み付け
    private static final Map<String, Double> CATEGORY_WEIGHTS = Map.of(
        "skills", 0.5,            // スキル適合度
        "experience", 0.25,       // 経験年数
        "availability", 0.15,     // 稼働状況
        "location", 0.10          // 勤務地
    );

    public MatchingScore calculateMatchingScore(ProjectDTO project, EngineerDTO engineer) {
        Map<String, Double> categoryScores = new HashMap<>();
        
        // 1. スキルマッチング（0-100点）
        double skillScore = calculateSkillScore(project.getRequiredSkillIds(), engineer.getSkills());
        categoryScores.put("skills", skillScore);
        
        // 2. 経験年数評価（0-100点）
        double experienceScore = calculateExperienceScore(project, engineer);
        categoryScores.put("experience", experienceScore);
        
        // 3. 稼働状況評価（0-100点）
        double availabilityScore = calculateAvailabilityScore(project.getStartDate(), engineer.getAvailability());
        categoryScores.put("availability", availabilityScore);
        
        // 4. 勤務地評価（0-100点）
        double locationScore = calculateLocationScore(project.getLocation(), engineer.getPreferredLocations());
        categoryScores.put("location", locationScore);
        
        // 総合スコア計算（重み付け平均）
        double totalScore = calculateWeightedScore(categoryScores, CATEGORY_WEIGHTS);
        
        return new MatchingScore(totalScore, categoryScores);
    }
    
    // スキルスコア計算（必須スキルの網羅度と習熟度で評価）
    private double calculateSkillScore(Set<UUID> requiredSkillIds, List<EngineerSkillDTO> engineerSkills) {
        if (requiredSkillIds.isEmpty()) {
            return 100.0; // スキル要件なしの場合は満点
        }
        
        // 技術者のスキルIDと習熟度のマップを作成
        Map<UUID, Integer> engineerSkillMap = engineerSkills.stream()
            .collect(Collectors.toMap(EngineerSkillDTO::getSkillId, EngineerSkillDTO::getLevel));
            
        // 必須スキル一致度と習熟度を評価
        double totalScore = 0.0;
        for (UUID skillId : requiredSkillIds) {
            if (engineerSkillMap.containsKey(skillId)) {
                // スキル習熟度（1-5）を20点刻みのスコアに変換
                totalScore += engineerSkillMap.get(skillId) * 20.0;
            }
        }
        
        // 総合スコアを算出（100点満点）
        return Math.min(100.0, totalScore / requiredSkillIds.size());
    }
    
    // 経験年数スコア計算
    private double calculateExperienceScore(ProjectDTO project, EngineerDTO engineer) {
        // プロジェクトが指定する最低経験年数と技術者の経験年数の比較
        int requiredYears = project.getRequiredExperienceYears() != null ? project.getRequiredExperienceYears() : 0;
        int engineerYears = engineer.getTotalExperienceYears();
        
        if (engineerYears >= requiredYears) {
            // 最低要件を満たす場合
            if (requiredYears == 0) {
                return 100.0; // 経験年数要件なしの場合は満点
            }
            
            // 要件以上の場合はボーナススコア（最大100点）
            return Math.min(100.0, 80.0 + 20.0 * (engineerYears - requiredYears) / 5.0);
        } else {
            // 最低要件を満たさない場合（要件に近いほど高スコア）
            return 60.0 * engineerYears / requiredYears;
        }
    }
    
    // 稼働状況スコア計算
    private double calculateAvailabilityScore(LocalDate projectStartDate, EngineerAvailabilityDTO availability) {
        if (projectStartDate == null || availability == null) {
            return 50.0; // データ不足の場合は中立的なスコア
        }
        
        // プロジェクト開始日における技術者の稼働状況を評価
        LocalDate availableDate = availability.getNextAvailableDate();
        
        if (availableDate == null) {
            return 0.0; // 稼働予定なしの場合は0点
        }
        
        if (availableDate.isBefore(projectStartDate) || availableDate.isEqual(projectStartDate)) {
            return 100.0; // プロジェクト開始日に稼働可能なら満点
        }
        
        // 遅れ日数に応じたスコア減少（1ヶ月で40点減）
        long daysLate = ChronoUnit.DAYS.between(projectStartDate, availableDate);
        return Math.max(0.0, 100.0 - (daysLate / 30.0) * 40.0);
    }
    
    // 勤務地スコア計算
    private double calculateLocationScore(String projectLocation, List<String> preferredLocations) {
        if (projectLocation == null || preferredLocations == null || preferredLocations.isEmpty()) {
            return 50.0; // データ不足の場合は中立的なスコア
        }
        
        // 完全一致
        if (preferredLocations.contains(projectLocation)) {
            return 100.0;
        }
        
        // 都道府県レベルで一致（例: "東京都新宿区" と "東京都" でマッチ）
        String projectPrefecture = extractPrefecture(projectLocation);
        for (String location : preferredLocations) {
            String preferredPrefecture = extractPrefecture(location);
            if (projectPrefecture.equals(preferredPrefecture)) {
                return 80.0;
            }
        }
        
        // 地域レベルで一致（例: "東京都" と "関東" でマッチ）
        String projectRegion = getPrefectureRegion(projectPrefecture);
        for (String location : preferredLocations) {
            String preferredPrefecture = extractPrefecture(location);
            String preferredRegion = getPrefectureRegion(preferredPrefecture);
            
            if (projectRegion.equals(preferredRegion)) {
                return 60.0;
            }
        }
        
        // リモートワーク許容
        if (preferredLocations.contains("リモート") || preferredLocations.contains("在宅")) {
            return 70.0; // リモート可能なら一定スコア
        }
        
        return 30.0; // マッチしない場合は低スコア
    }
    
    // 重み付け平均スコア計算
    private double calculateWeightedScore(Map<String, Double> categoryScores, Map<String, Double> weights) {
        double totalWeightedScore = 0.0;
        double totalWeight = 0.0;
        
        for (Map.Entry<String, Double> entry : categoryScores.entrySet()) {
            String category = entry.getKey();
            Double score = entry.getValue();
            Double weight = weights.getOrDefault(category, 0.0);
            
            totalWeightedScore += score * weight;
            totalWeight += weight;
        }
        
        return totalWeight > 0 ? totalWeightedScore / totalWeight : 0.0;
    }
    
    // ヘルパーメソッド省略
}
```

### 5.2 マッチングスコア値オブジェクト

```java
public class MatchingScore {
    private final double totalScore;
    private final Map<String, Double> categoryScores;
    
    public MatchingScore(double totalScore, Map<String, Double> categoryScores) {
        this.totalScore = totalScore;
        this.categoryScores = Collections.unmodifiableMap(new HashMap<>(categoryScores));
    }
    
    public double getTotalScore() {
        return totalScore;
    }
    
    public Map<String, Double> getCategoryScores() {
        return categoryScores;
    }
    
    public double getCategoryScore(String category) {
        return categoryScores.getOrDefault(category, 0.0);
    }
}
```

## 6. 提案機能設計

### 6.1 提案番号生成ロジック

提案番号は自動生成され、一意の識別子として使用します。

```java
private String generateProposalNumber() {
    // 現在年月の取得
    LocalDate now = LocalDate.now();
    int year = now.getYear();
    int month = now.getMonthValue();
    
    // その年月の提案数（シーケンス）を取得
    int sequence = proposalRepository.countByYearAndMonth(year, month) + 1;
    
    // フォーマット: PRO-YYYYMM-NNNN
    // 例: PRO-202304-0001
    return String.format("PRO-%d%02d-%04d", year, month, sequence);
}
```

### 6.2 提案ステータス遷移ルール

提案のステータス遷移は以下のルールに従います。

```java
public boolean canTransitionTo(ProposalStatus newStatus) {
    switch (this.status) {
        case DRAFT:
            // 下書きからは提出済か取消のみ可能
            return newStatus == ProposalStatus.SUBMITTED || 
                   newStatus == ProposalStatus.CANCELED;
                   
        case SUBMITTED:
            // 提出済からは検討中、取消が可能
            return newStatus == ProposalStatus.IN_REVIEW || 
                   newStatus == ProposalStatus.CANCELED;
                   
        case IN_REVIEW:
            // 検討中からは承認、却下、取消が可能
            return newStatus == ProposalStatus.ACCEPTED || 
                   newStatus == ProposalStatus.REJECTED || 
                   newStatus == ProposalStatus.CANCELED;
                   
        case ACCEPTED:
        case REJECTED:
            // 承認、却下からの変更は不可
            return false;
            
        case CANCELED:
            // 取消からの変更は不可
            return false;
            
        default:
            return false;
    }
}
```

## 7. 画面設計

マッチング機能の主要画面遷移は以下の通りです。

```
+-------------------+     +----------------------+
| マッチング検索画面 |---->| マッチング結果一覧画面 |
|                   |     |                      |
+-------------------+     +----------------------+
                                   |
                                   v
                          +----------------------+     +-------------------+
                          | マッチング結果詳細画面 |---->| 提案作成画面     |
                          |                      |     |                   |
                          +----------------------+     +-------------------+
                                                              |
                                                              v
                                                      +-------------------+
                                                      | 提案一覧画面      |
                                                      |                   |
                                                      +-------------------+
                                                              |
                                                              v
                                                      +-------------------+
                                                      | 提案詳細画面      |
                                                      |                   |
                                                      +-------------------+
```

## 8. セキュリティ設計

マッチング情報へのアクセス権限は以下のように設定します。

| 役割 | マッチング検索 | 結果参照 | 提案作成 | 提案管理 | スコア再計算 |
|------|--------------|---------|---------|---------|------------|
| 管理者 | ○ | ○ | ○ | ○ | ○ |
| マッチング担当 | ○ | ○ | ○ | ○ | ○ |
| 営業担当 | ○ | ○ | ○ | ○ | × |
| 一般ユーザー | × | 一部 | × | × | × |

具体的な実装は、Spring Securityのメソッドレベルセキュリティを使用します。

```java
@PreAuthorize("hasAnyRole('ADMIN', 'MATCHING', 'SALES')")
public Page<MatchingResultDTO> searchMatching(MatchingSearchDTO searchDTO, Pageable pageable);

@PreAuthorize("hasAnyRole('ADMIN', 'MATCHING', 'SALES')")
public MatchingResultDTO getMatchingResultById(UUID id);

@PreAuthorize("hasAnyRole('ADMIN', 'MATCHING', 'SALES')")
public ProposalDTO createProposal(ProposalDTO proposalDTO);

@PreAuthorize("hasAnyRole('ADMIN', 'MATCHING')")
public MatchingResultDTO calculateSingleMatching(UUID projectId, UUID engineerId);

@PreAuthorize("hasAnyRole('ADMIN', 'MATCHING', 'SALES')")
public void updateProposalStatus(UUID proposalId, ProposalStatus status);
```

## 9. パフォーマンス最適化

マッチング検索と計算はシステム全体で最も計算コストの高い処理の一つとなるため、以下の最適化を実施します。

### 9.1 キャッシング戦略

```java
@Service
public class MatchingCacheService {
    private final Cache<UUID, MatchingResult> matchingCache;
    
    public MatchingCacheService() {
        // 有効期限1時間、最大10000エントリのキャッシュ
        this.matchingCache = Caffeine.newBuilder()
            .expireAfterWrite(1, TimeUnit.HOURS)
            .maximumSize(10000)
            .build();
    }
    
    public Optional<MatchingResult> getCachedResult(UUID projectId, UUID engineerId) {
        // プロジェクトID + エンジニアIDの複合キー
        UUID cacheKey = generateCacheKey(projectId, engineerId);
        return Optional.ofNullable(matchingCache.getIfPresent(cacheKey));
    }
    
    public void cacheResult(MatchingResult result) {
        UUID cacheKey = generateCacheKey(result.getProjectId(), result.getEngineerId());
        matchingCache.put(cacheKey, result);
    }
    
    public void invalidateCache(UUID projectId, UUID engineerId) {
        UUID cacheKey = generateCacheKey(projectId, engineerId);
        matchingCache.invalidate(cacheKey);
    }
    
    private UUID generateCacheKey(UUID projectId, UUID engineerId) {
        return UUID.nameUUIDFromBytes(
            (projectId.toString() + ":" + engineerId.toString()).getBytes()
        );
    }
}
```

### 9.2 バッチ処理

一括マッチング計算を効率化するための並列処理実装。

```java
@Service
public class BatchMatchingService {

    private final MatchingAlgorithmService algorithmService;
    private final MatchingResultRepository resultRepository;
    private final ProjectService projectService;
    private final EngineerService engineerService;
    private final ExecutorService executorService;
    
    public BatchMatchingService() {
        // スレッドプールの初期化（プロセッサ数に合わせる）
        this.executorService = Executors.newFixedThreadPool(
            Runtime.getRuntime().availableProcessors()
        );
    }
    
    public CompletableFuture<List<MatchingResult>> calculateBatchMatching(UUID projectId) {
        ProjectDTO project = projectService.getProjectById(projectId);
        
        // 案件要件に基づいて候補技術者検索
        List<EngineerDTO> candidateEngineers = engineerService.findEngineersBySkillRequirements(
            project.getRequiredSkillIds(),
            project.getRequiredExperienceYears()
        );
        
        // 並列処理でマッチング計算
        List<CompletableFuture<MatchingResult>> futures = candidateEngineers.stream()
            .map(engineer -> CompletableFuture.supplyAsync(() -> {
                MatchingScore score = algorithmService.calculateMatchingScore(project, engineer);
                
                MatchingResult result = new MatchingResult();
                result.setProjectId(projectId);
                result.setEngineerId(engineer.getId());
                result.setMatchingScore(score.getTotalScore());
                result.setScoreDetails(score.getCategoryScores());
                result.setCalculatedAt(LocalDateTime.now());
                result.setAlgorithm("BatchMatching-v1");
                
                return resultRepository.save(result);
            }, executorService))
            .toList();
        
        // 全ての計算が終わるのを待つ
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> futures.stream()
                .map(CompletableFuture::join)
                .collect(Collectors.toList()));
    }
}
```

## 10. テスト計画

### 10.1 単体テスト

- マッチングアルゴリズムのスコア計算ロジックテスト
- 提案ステータス遷移ルールのテスト
- リポジトリメソッドのテスト

### 10.2 結合テスト

- マッチング検索処理の統合テスト
- マッチング結果キャッシュの有効性テスト

### 10.3 負荷テスト

- 大量データにおけるマッチング検索のパフォーマンステスト
- 並列バッチマッチング処理の効率テスト

## 11. 運用設計

### 11.1 バッチ処理

- 日次：新規案件の一括マッチング計算
- 週次：技術者情報更新に伴うマッチングスコア再計算
- 月次：マッチングアルゴリズムパラメータ最適化

### 11.2 監視項目

- マッチング計算の平均実行時間
- 高マッチング率（90%以上）の案件数推移
- 提案承認率の推移

### 11.3 改善サイクル

- マッチング精度検証（提案承認率との相関分析）
- アルゴリズムパラメータ調整（カテゴリ重み見直し）
- 新評価軸の追加検討