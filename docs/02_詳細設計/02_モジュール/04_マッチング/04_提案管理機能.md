# マッチング機能モジュール - 提案管理機能

## 1. 提案管理機能概要

提案管理機能は、マッチング結果に基づいて技術者を案件に提案するプロセスを管理します。提案の作成から承認/却下までの状態遷移を追跡し、提案書の生成や顧客からのフィードバック管理を行います。

### 1.1 提案管理の目的

- マッチング結果から正式な提案プロセスへの橋渡し
- 提案状態の一元管理と可視化
- 提案書ドキュメントの標準化と管理
- 提案プロセスのトラッキングと効率化
- 提案履歴とフィードバックの蓄積
- 契約管理モジュールとの連携

### 1.2 提案プロセスフロー

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  下書き      │────>│   提出済    │────>│   検討中    │────>│    承認     │
│ (DRAFT)     │     │ (SUBMITTED) │     │ (IN_REVIEW) │     │ (ACCEPTED)  │
└─────────────┘     └─────────────┘     └─────────────┘     └─────────────┘
      │                    │                   │                    
      │                    │                   │                    
      v                    v                   v                    
┌─────────────┐     ┌─────────────┐                                
│    取消     │<────│    取消     │<───────────────────────────────┘
│ (CANCELED)  │     │ (CANCELED)  │                                
└─────────────┘     └─────────────┘                                
                          │                   │                    
                          │                   │                    
                          │                   v                    
                          │            ┌─────────────┐             
                          └───────────>│    却下     │             
                                       │ (REJECTED)  │             
                                       └─────────────┘             
```

## 2. 提案エンティティと状態管理

### 2.1 提案ステータス（ProposalStatus）列挙型

提案の状態を表す列挙型です。

```java
public enum ProposalStatus {
    DRAFT("下書き"),
    SUBMITTED("提出済"),
    IN_REVIEW("検討中"),
    ACCEPTED("承認"),
    REJECTED("却下"),
    CANCELED("取消");
    
    private final String displayName;
    
    ProposalStatus(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
    
    public boolean isActive() {
        return this == SUBMITTED || this == IN_REVIEW;
    }
    
    public boolean isTerminal() {
        return this == ACCEPTED || this == REJECTED || this == CANCELED;
    }
    
    public boolean isSuccessful() {
        return this == ACCEPTED;
    }
}
```

### 2.2 提案状態遷移ルール

```java
public boolean canTransitionTo(ProposalStatus newStatus) {
    switch (this.status) {
        case DRAFT:
            // 下書きからは提出済か取消のみ可能
            return newStatus == ProposalStatus.SUBMITTED || 
                   newStatus == ProposalStatus.CANCELED;
                   
        case SUBMITTED:
            // 提出済からは検討中、取消が可能
            return newStatus == ProposalStatus.IN_REVIEW || 
                   newStatus == ProposalStatus.CANCELED;
                   
        case IN_REVIEW:
            // 検討中からは承認、却下、取消が可能
            return newStatus == ProposalStatus.ACCEPTED || 
                   newStatus == ProposalStatus.REJECTED || 
                   newStatus == ProposalStatus.CANCELED;
                   
        case ACCEPTED:
        case REJECTED:
            // 承認、却下からの変更は不可
            return false;
            
        case CANCELED:
            // 取消からの変更は不可
            return false;
            
        default:
            return false;
    }
}
```

### 2.3 状態遷移メソッド

```java
public void updateStatus(ProposalStatus newStatus, String comment) {
    if (!canTransitionTo(newStatus)) {
        throw new IllegalStateException(
            String.format("Cannot transition from %s to %s", this.status, newStatus));
    }
    
    // 状態遷移履歴を記録
    ProposalStatusHistory history = new ProposalStatusHistory();
    history.setProposalId(this.id);
    history.setPreviousStatus(this.status);
    history.setNewStatus(newStatus);
    history.setComment(comment);
    history.setChangedAt(LocalDateTime.now());
    history.setChangedBy(SecurityContextHolder.getContext().getAuthentication().getName());
    
    // 状態を更新
    this.status = newStatus;
    this.updatedAt = LocalDateTime.now();
    
    // 承認された場合の処理
    if (newStatus == ProposalStatus.ACCEPTED) {
        this.acceptedAt = LocalDateTime.now();
    }
    
    // 却下された場合の処理
    if (newStatus == ProposalStatus.REJECTED) {
        this.rejectedAt = LocalDateTime.now();
    }
}
```

## 3. 提案番号生成ロジック

提案番号は一意の識別子として使用され、年月とシーケンス番号で構成されます。

### 3.1 提案番号生成サービス

```java
@Service
public class ProposalNumberService {
    
    private final ProposalRepository proposalRepository;
    private final LockService lockService;
    
    @Autowired
    public ProposalNumberService(ProposalRepository proposalRepository, LockService lockService) {
        this.proposalRepository = proposalRepository;
        this.lockService = lockService;
    }
    
    /**
     * 新しい提案番号を生成する
     * @return 生成された提案番号
     */
    @Transactional
    public String generateProposalNumber() {
        // 排他ロックを取得（並列アクセス時の連番重複を防止）
        String lockKey = "proposal-number-generation";
        return lockService.executeWithLock(lockKey, this::doGenerateProposalNumber);
    }
    
    private String doGenerateProposalNumber() {
        // 現在年月の取得
        LocalDate now = LocalDate.now();
        int year = now.getYear();
        int month = now.getMonthValue();
        
        // その年月の提案数（シーケンス）を取得
        int sequence = proposalRepository.countByYearAndMonth(year, month) + 1;
        
        // フォーマット: PRO-YYYYMM-NNNN
        // 例: PRO-202304-0001
        return String.format("PRO-%d%02d-%04d", year, month, sequence);
    }
}
```

### 3.2 提案番号の検証ロジック

```java
public static boolean isValidProposalNumber(String proposalNumber) {
    if (proposalNumber == null || proposalNumber.isEmpty()) {
        return false;
    }
    
    // 形式チェック: PRO-YYYYMM-NNNN
    Pattern pattern = Pattern.compile("PRO-(\\d{6})-(\\d{4})");
    Matcher matcher = pattern.matcher(proposalNumber);
    
    if (!matcher.matches()) {
        return false;
    }
    
    // 年月部分の検証
    String yearMonth = matcher.group(1);
    int year = Integer.parseInt(yearMonth.substring(0, 4));
    int month = Integer.parseInt(yearMonth.substring(4, 6));
    
    // 年月の範囲チェック
    if (year < 2020 || year > 2100 || month < 1 || month > 12) {
        return false;
    }
    
    return true;
}
```

## 4. 提案書ドキュメント管理

### 4.1 提案書テンプレート

提案書は標準テンプレートに基づいて生成されます。テンプレートはプロジェクトタイプごとにカスタマイズ可能です。

```java
@Entity
@Table(name = "proposal_templates")
public class ProposalTemplate {
    
    @Id
    private UUID id;
    
    @Column(name = "template_name", nullable = false)
    private String templateName;
    
    @Column(name = "project_type")
    private String projectType;
    
    @Column(name = "template_content", columnDefinition = "TEXT", nullable = false)
    private String templateContent;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;
    
    @Column(name = "is_active", nullable = false)
    private boolean active;
    
    // ゲッター・セッター
}
```

### 4.2 提案書生成サービス

```java
@Service
public class ProposalDocumentService {
    
    private final ProposalRepository proposalRepository;
    private final ProjectService projectService;
    private final EngineerService engineerService;
    private final TemplateService templateService;
    private final DocumentStorageService documentStorageService;
    
    @Autowired
    public ProposalDocumentService(ProposalRepository proposalRepository,
                                  ProjectService projectService,
                                  EngineerService engineerService,
                                  TemplateService templateService,
                                  DocumentStorageService documentStorageService) {
        this.proposalRepository = proposalRepository;
        this.projectService = projectService;
        this.engineerService = engineerService;
        this.templateService = templateService;
        this.documentStorageService = documentStorageService;
    }
    
    /**
     * 提案に対する提案書を生成する
     * @param proposalId 提案ID
     * @return 生成された提案書のドキュメントID
     */
    @Transactional
    public UUID generateProposalDocument(UUID proposalId) {
        // 提案情報の取得
        Proposal proposal = proposalRepository.findById(proposalId)
            .orElseThrow(() -> new EntityNotFoundException("Proposal not found: " + proposalId));
        
        // 案件情報の取得
        ProjectDTO project = projectService.getProjectById(proposal.getProjectId());
        
        // 技術者情報の取得
        EngineerDTO engineer = engineerService.getEngineerById(proposal.getEngineerId());
        
        // プロジェクトタイプに合わせたテンプレートの取得
        String templateContent = templateService.getTemplateForProjectType(project.getProjectType());
        
        // テンプレート変数の置換
        Map<String, Object> variables = new HashMap<>();
        variables.put("proposal", proposal);
        variables.put("project", project);
        variables.put("engineer", engineer);
        variables.put("currentDate", LocalDate.now());
        
        String documentContent = templateService.processTemplate(templateContent, variables);
        
        // PDFドキュメントの生成と保存
        String fileName = "提案書_" + proposal.getProposalNumber() + ".pdf";
        byte[] pdfContent = generatePdf(documentContent);
        
        UUID documentId = documentStorageService.storeDocument(pdfContent, fileName, "application/pdf");
        
        // 提案にドキュメントIDを関連付け
        proposal.setProposalDocumentId(documentId);
        proposalRepository.save(proposal);
        
        return documentId;
    }
    
    private byte[] generatePdf(String content) {
        // HTMLからPDFを生成するロジック
        // 例: iTextやOpenHTMLtoPDFなどのライブラリを使用
        // ...
        
        return null; // 実装詳細は省略
    }
}
```

### 4.3 提案書バージョン管理

提案書のバージョン管理を行い、履歴を追跡します。

```java
@Entity
@Table(name = "proposal_document_versions")
public class ProposalDocumentVersion {
    
    @Id
    private UUID id;
    
    @Column(name = "proposal_id", nullable = false)
    private UUID proposalId;
    
    @Column(name = "document_id", nullable = false)
    private UUID documentId;
    
    @Column(name = "version_number", nullable = false)
    private int versionNumber;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "created_by", nullable = false)
    private String createdBy;
    
    @Column(name = "comment")
    private String comment;
    
    // ゲッター・セッター
}
```

## 5. 提案フィードバック管理

### 5.1 フィードバックエンティティ

顧客や関係者からのフィードバックを記録します。

```java
@Entity
@Table(name = "proposal_feedbacks")
public class ProposalFeedback {
    
    @Id
    private UUID id;
    
    @Column(name = "proposal_id", nullable = false)
    private UUID proposalId;
    
    @Column(name = "feedback_type", nullable = false)
    @Enumerated(EnumType.STRING)
    private FeedbackType type;
    
    @Column(name = "content", nullable = false)
    private String content;
    
    @Column(name = "feedback_date", nullable = false)
    private LocalDateTime feedbackDate;
    
    @Column(name = "provided_by")
    private String providedBy;
    
    @Column(name = "recorded_by", nullable = false)
    private String recordedBy;
    
    @Column(name = "is_confidential")
    private boolean confidential;
    
    public enum FeedbackType {
        CUSTOMER("顧客"),
        INTERNAL("内部"),
        TECHNICAL("技術"),
        COMMERCIAL("商務");
        
        private final String displayName;
        
        FeedbackType(String displayName) {
            this.displayName = displayName;
        }
        
        public String getDisplayName() {
            return displayName;
        }
    }
    
    // ゲッター・セッター
}
```

### 5.2 フィードバック管理サービス

```java
@Service
public class ProposalFeedbackService {
    
    private final ProposalRepository proposalRepository;
    private final ProposalFeedbackRepository feedbackRepository;
    
    @Autowired
    public ProposalFeedbackService(ProposalRepository proposalRepository,
                                  ProposalFeedbackRepository feedbackRepository) {
        this.proposalRepository = proposalRepository;
        this.feedbackRepository = feedbackRepository;
    }
    
    /**
     * 提案にフィードバックを追加する
     * @param proposalId 提案ID
     * @param feedbackDTO フィードバック情報
     * @return 作成されたフィードバックID
     */
    @Transactional
    public UUID addFeedback(UUID proposalId, ProposalFeedbackDTO feedbackDTO) {
        // 提案の存在確認
        if (!proposalRepository.existsById(proposalId)) {
            throw new EntityNotFoundException("Proposal not found: " + proposalId);
        }
        
        // 現在のユーザー情報を取得
        String currentUser = SecurityContextHolder.getContext().getAuthentication().getName();
        
        // フィードバックエンティティの作成
        ProposalFeedback feedback = new ProposalFeedback();
        feedback.setId(UUID.randomUUID());
        feedback.setProposalId(proposalId);
        feedback.setType(ProposalFeedback.FeedbackType.valueOf(feedbackDTO.getType()));
        feedback.setContent(feedbackDTO.getContent());
        feedback.setFeedbackDate(LocalDateTime.now());
        feedback.setProvidedBy(feedbackDTO.getProvidedBy());
        feedback.setRecordedBy(currentUser);
        feedback.setConfidential(feedbackDTO.isConfidential());
        
        // フィードバックの保存
        ProposalFeedback savedFeedback = feedbackRepository.save(feedback);
        
        // 提案の最新フィードバックメモを更新
        Proposal proposal = proposalRepository.findById(proposalId).get();
        proposal.setFeedbackNotes(feedback.getContent());
        proposal.setUpdatedAt(LocalDateTime.now());
        proposalRepository.save(proposal);
        
        return savedFeedback.getId();
    }
    
    /**
     * 提案に関連するフィードバック一覧を取得する
     * @param proposalId 提案ID
     * @return フィードバック一覧
     */
    public List<ProposalFeedbackDTO> getFeedbacksForProposal(UUID proposalId) {
        List<ProposalFeedback> feedbacks = feedbackRepository.findByProposalIdOrderByFeedbackDateDesc(proposalId);
        
        // 機密フィードバックをフィルタリング（権限によって）
        boolean canViewConfidential = hasPermissionToViewConfidential();
        
        return feedbacks.stream()
            .filter(f -> canViewConfidential || !f.isConfidential())
            .map(this::mapToDto)
            .collect(Collectors.toList());
    }
    
    private boolean hasPermissionToViewConfidential() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        return auth != null && auth.getAuthorities().stream()
            .anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN") || 
                          a.getAuthority().equals("ROLE_SALES_MANAGER"));
    }
    
    private ProposalFeedbackDTO mapToDto(ProposalFeedback feedback) {
        ProposalFeedbackDTO dto = new ProposalFeedbackDTO();
        dto.setId(feedback.getId());
        dto.setProposalId(feedback.getProposalId());
        dto.setType(feedback.getType().name());
        dto.setTypeDisplayName(feedback.getType().getDisplayName());
        dto.setContent(feedback.getContent());
        dto.setFeedbackDate(feedback.getFeedbackDate());
        dto.setProvidedBy(feedback.getProvidedBy());
        dto.setRecordedBy(feedback.getRecordedBy());
        dto.setConfidential(feedback.isConfidential());
        return dto;
    }
}
```

## 6. 提案承認/却下管理

### 6.1 承認ワークフロー

提案の承認/却下プロセスを管理するワークフローです。

```java
@Service
public class ProposalApprovalService {
    
    private final ProposalRepository proposalRepository;
    private final ProposalStatusHistoryRepository historyRepository;
    private final NotificationService notificationService;
    private final ContractService contractService;
    
    @Autowired
    public ProposalApprovalService(ProposalRepository proposalRepository,
                                  ProposalStatusHistoryRepository historyRepository,
                                  NotificationService notificationService,
                                  ContractService contractService) {
        this.proposalRepository = proposalRepository;
        this.historyRepository = historyRepository;
        this.notificationService = notificationService;
        this.contractService = contractService;
    }
    
    /**
     * 提案を承認する
     * @param proposalId 提案ID
     * @param approvalDTO 承認情報
     * @return 更新された提案
     */
    @Transactional
    public ProposalDTO approveProposal(UUID proposalId, ProposalApprovalDTO approvalDTO) {
        // 提案の取得
        Proposal proposal = proposalRepository.findById(proposalId)
            .orElseThrow(() -> new EntityNotFoundException("Proposal not found: " + proposalId));
        
        // 状態遷移可能かチェック
        if (!proposal.canTransitionTo(ProposalStatus.ACCEPTED)) {
            throw new IllegalStateException(
                "Cannot approve proposal in current status: " + proposal.getStatus());
        }
        
        // 承認情報の設定
        proposal.setApprovalComments(approvalDTO.getComments());
        proposal.setApprovalDate(LocalDate.now());
        proposal.setApprovedBy(SecurityContextHolder.getContext().getAuthentication().getName());
        
        // 状態の更新
        proposal.updateStatus(ProposalStatus.ACCEPTED, approvalDTO.getComments());
        Proposal savedProposal = proposalRepository.save(proposal);
        
        // 契約モジュールへの連携（承認された場合）
        if (approvalDTO.isCreateContract()) {
            contractService.initiateContractFromProposal(proposalId);
        }
        
        // 通知の送信
        notificationService.sendProposalApprovedNotification(proposal);
        
        return mapToDto(savedProposal);
    }
    
    /**
     * 提案を却下する
     * @param proposalId 提案ID
     * @param rejectionDTO 却下情報
     * @return 更新された提案
     */
    @Transactional
    public ProposalDTO rejectProposal(UUID proposalId, ProposalRejectionDTO rejectionDTO) {
        // 提案の取得
        Proposal proposal = proposalRepository.findById(proposalId)
            .orElseThrow(() -> new EntityNotFoundException("Proposal not found: " + proposalId));
        
        // 状態遷移可能かチェック
        if (!proposal.canTransitionTo(ProposalStatus.REJECTED)) {
            throw new IllegalStateException(
                "Cannot reject proposal in current status: " + proposal.getStatus());
        }
        
        // 却下理由の設定
        proposal.setRejectionReason(rejectionDTO.getReason());
        proposal.setRejectionDetail(rejectionDTO.getDetail());
        proposal.setRejectionDate(LocalDate.now());
        proposal.setRejectedBy(SecurityContextHolder.getContext().getAuthentication().getName());
        
        // 状態の更新
        proposal.updateStatus(ProposalStatus.REJECTED, rejectionDTO.getReason());
        Proposal savedProposal = proposalRepository.save(proposal);
        
        // 通知の送信
        notificationService.sendProposalRejectedNotification(proposal);
        
        return mapToDto(savedProposal);
    }
    
    // DTOへの変換メソッド（省略）
    private ProposalDTO mapToDto(Proposal proposal) {
        // エンティティからDTOへの変換ロジック
        // ...
        return null;
    }
}
```

### 6.2 承認権限管理

提案の承認/却下に関する権限を管理します。

```java
@Component
public class ProposalAuthorizationService {
    
    /**
     * 提案を承認する権限があるかチェックする
     * @param proposalId 提案ID
     * @return 承認権限がある場合はtrue
     */
    public boolean canApproveProposal(UUID proposalId) {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        
        // 管理者または営業管理者は常に承認可能
        if (hasAdminRole(auth) || hasSalesManagerRole(auth)) {
            return true;
        }
        
        // 特定の条件下での承認権限
        // たとえば、特定金額以下は営業担当者も承認可能など
        // ...
        
        return false;
    }
    
    /**
     * 提案を却下する権限があるかチェックする
     * @param proposalId 提案ID
     * @return 却下権限がある場合はtrue
     */
    public boolean canRejectProposal(UUID proposalId) {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        
        // 管理者または営業管理者は常に却下可能
        if (hasAdminRole(auth) || hasSalesManagerRole(auth)) {
            return true;
        }
        
        // 営業担当者は自分が作成した提案のみ却下可能
        if (hasSalesRole(auth)) {
            String username = auth.getName();
            return isProposalCreatedBy(proposalId, username);
        }
        
        return false;
    }
    
    private boolean hasAdminRole(Authentication auth) {
        return auth != null && auth.getAuthorities().stream()
            .anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN"));
    }
    
    private boolean hasSalesManagerRole(Authentication auth) {
        return auth != null && auth.getAuthorities().stream()
            .anyMatch(a -> a.getAuthority().equals("ROLE_SALES_MANAGER"));
    }
    
    private boolean hasSalesRole(Authentication auth) {
        return auth != null && auth.getAuthorities().stream()
            .anyMatch(a -> a.getAuthority().equals("ROLE_SALES"));
    }
    
    private boolean isProposalCreatedBy(UUID proposalId, String username) {
        // 提案の作成者をチェックするロジック
        // ...
        return false;
    }
}
```

## 7. 提案レポートと分析

### 7.1 提案分析レポート

提案の成約率や状態遷移を分析するレポート機能です。

```java
@Service
public class ProposalAnalyticsService {
    
    private final ProposalRepository proposalRepository;
    private final JdbcTemplate jdbcTemplate;
    
    @Autowired
    public ProposalAnalyticsService(ProposalRepository proposalRepository, JdbcTemplate jdbcTemplate) {
        this.proposalRepository = proposalRepository;
        this.jdbcTemplate = jdbcTemplate;
    }
    
    /**
     * 期間内の提案成約率を計算する
     * @param from 開始日
     * @param to 終了日
     * @return 成約率分析結果
     */
    public ProposalAcceptanceRateDTO calculateAcceptanceRate(LocalDate from, LocalDate to) {
        // 期間内の提案総数
        long totalProposals = proposalRepository.countByProposalDateBetween(from, to);
        
        // 期間内の承認済み提案数
        long acceptedProposals = proposalRepository.countByStatusAndProposalDateBetween(
            ProposalStatus.ACCEPTED, from, to);
        
        // 期間内の却下済み提案数
        long rejectedProposals = proposalRepository.countByStatusAndProposalDateBetween(
            ProposalStatus.REJECTED, from, to);
        
        // 期間内の取消提案数
        long canceledProposals = proposalRepository.countByStatusAndProposalDateBetween(
            ProposalStatus.CANCELED, from, to);
        
        // 期間内の未決定提案数（下書き、提出済、検討中）
        long pendingProposals = totalProposals - acceptedProposals - rejectedProposals - canceledProposals;
        
        // 成約率の計算（未決定を除く）
        double acceptanceRate = 0.0;
        long decidedProposals = acceptedProposals + rejectedProposals;
        if (decidedProposals > 0) {
            acceptanceRate = (double) acceptedProposals / decidedProposals * 100.0;
        }
        
        // 結果DTOの作成
        ProposalAcceptanceRateDTO result = new ProposalAcceptanceRateDTO();
        result.setFromDate(from);
        result.setToDate(to);
        result.setTotalProposals(totalProposals);
        result.setAcceptedProposals(acceptedProposals);
        result.setRejectedProposals(rejectedProposals);
        result.setCanceledProposals(canceledProposals);
        result.setPendingProposals(pendingProposals);
        result.setAcceptanceRate(acceptanceRate);
        
        return result;
    }
    
    /**
     * 案件種別ごとの提案成約率を計算する
     * @param from 開始日
     * @param to 終了日
     * @return 案件種別ごとの成約率
     */
    public List<ProjectTypeAcceptanceRateDTO> calculateAcceptanceRateByProjectType(LocalDate from, LocalDate to) {
        // 案件種別ごとの集計クエリ
        String sql = """
            SELECT p.project_type, 
                   COUNT(*) as total_count,
                   SUM(CASE WHEN pr.status = 'ACCEPTED' THEN 1 ELSE 0 END) as accepted_count,
                   SUM(CASE WHEN pr.status = 'REJECTED' THEN 1 ELSE 0 END) as rejected_count
            FROM proposals pr
            JOIN projects p ON pr.project_id = p.id
            WHERE pr.proposal_date BETWEEN ? AND ?
            GROUP BY p.project_type
            """;
        
        return jdbcTemplate.query(
            sql, 
            (rs, rowNum) -> {
                String projectType = rs.getString("project_type");
                int totalCount = rs.getInt("total_count");
                int acceptedCount = rs.getInt("accepted_count");
                int rejectedCount = rs.getInt("rejected_count");
                
                double acceptanceRate = 0.0;
                int decidedCount = acceptedCount + rejectedCount;
                if (decidedCount > 0) {
                    acceptanceRate = (double) acceptedCount / decidedCount * 100.0;
                }
                
                ProjectTypeAcceptanceRateDTO dto = new ProjectTypeAcceptanceRateDTO();
                dto.setProjectType(projectType);
                dto.setTotalProposals(totalCount);
                dto.setAcceptedProposals(acceptedCount);
                dto.setRejectedProposals(rejectedCount);
                dto.setAcceptanceRate(acceptanceRate);
                
                return dto;
            },
            from, to
        );
    }
    
    /**
     * 提案の平均処理時間を計算する
     * @param from 開始日
     * @param to 終了日
     * @return 提案処理時間分析
     */
    public ProposalProcessingTimeDTO calculateProcessingTime(LocalDate from, LocalDate to) {
        String sql = """
            SELECT 
                AVG(EXTRACT(EPOCH FROM (h_submit.changed_at - p.created_at)) / 86400) as avg_draft_days,
                AVG(EXTRACT(EPOCH FROM (h_review.changed_at - h_submit.changed_at)) / 86400) as avg_submission_days,
                AVG(EXTRACT(EPOCH FROM (h_final.changed_at - h_review.changed_at)) / 86400) as avg_review_days,
                AVG(EXTRACT(EPOCH FROM (h_final.changed_at - p.created_at)) / 86400) as avg_total_days
            FROM proposals p
            JOIN proposal_status_history h_submit ON p.id = h_submit.proposal_id AND h_submit.new_status = 'SUBMITTED'
            JOIN proposal_status_history h_review ON p.id = h_review.proposal_id AND h_review.new_status = 'IN_REVIEW'
            JOIN proposal_status_history h_final ON p.id = h_final.proposal_id 
                AND (h_final.new_status = 'ACCEPTED' OR h_final.new_status = 'REJECTED')
            WHERE p.proposal_date BETWEEN ? AND ?
            """;
        
        return jdbcTemplate.queryForObject(
            sql,
            (rs, rowNum) -> {
                ProposalProcessingTimeDTO dto = new ProposalProcessingTimeDTO();
                dto.setAverageDraftDays(rs.getDouble("avg_draft_days"));
                dto.setAverageSubmissionDays(rs.getDouble("avg_submission_days"));
                dto.setAverageReviewDays(rs.getDouble("avg_review_days"));
                dto.setAverageTotalDays(rs.getDouble("avg_total_days"));
                return dto;
            },
            from, to
        );
    }
}
```

### 7.2 提案レポートDTO

提案分析結果を表すDTOクラスです。

```java
public class ProposalAcceptanceRateDTO {
    private LocalDate fromDate;
    private LocalDate toDate;
    private long totalProposals;
    private long acceptedProposals;
    private long rejectedProposals;
    private long canceledProposals;
    private long pendingProposals;
    private double acceptanceRate;
    
    // ゲッター・セッター
}

public class ProjectTypeAcceptanceRateDTO {
    private String projectType;
    private int totalProposals;
    private int acceptedProposals;
    private int rejectedProposals;
    private double acceptanceRate;
    
    // ゲッター・セッター
}

public class ProposalProcessingTimeDTO {
    private double averageDraftDays;
    private double averageSubmissionDays;
    private double averageReviewDays;
    private double averageTotalDays;
    
    // ゲッター・セッター
}
```

## 8. 提案と契約モジュールの連携

### 8.1 契約連携サービス

承認された提案から契約モジュールへデータを連携するサービスです。

```java
@Service
public class ProposalContractIntegrationService {
    
    private final ProposalRepository proposalRepository;
    private final ContractService contractService;
    private final EngineerService engineerService;
    private final ProjectService projectService;
    
    @Autowired
    public ProposalContractIntegrationService(ProposalRepository proposalRepository,
                                             ContractService contractService,
                                             EngineerService engineerService,
                                             ProjectService projectService) {
        this.proposalRepository = proposalRepository;
        this.contractService = contractService;
        this.engineerService = engineerService;
        this.projectService = projectService;
    }
    
    /**
     * 承認された提案から契約を作成する
     * @param proposalId 提案ID
     * @return 作成された契約ID
     */
    @Transactional
    public UUID createContractFromProposal(UUID proposalId) {
        // 提案の取得
        Proposal proposal = proposalRepository.findById(proposalId)
            .orElseThrow(() -> new EntityNotFoundException("Proposal not found: " + proposalId));
        
        // 提案が承認状態かチェック
        if (proposal.getStatus() != ProposalStatus.ACCEPTED) {
            throw new IllegalStateException(
                "Cannot create contract from non-accepted proposal: " + proposal.getStatus());
        }
        
        // 案件情報の取得
        ProjectDTO project = projectService.getProjectById(proposal.getProjectId());
        
        // 技術者情報の取得
        EngineerDTO engineer = engineerService.getEngineerById(proposal.getEngineerId());
        
        // 契約初期データの作成
        ContractInitiationDTO contractData = new ContractInitiationDTO();
        contractData.setProposalId(proposalId);
        contractData.setProjectId(proposal.getProjectId());
        contractData.setEngineerId(proposal.getEngineerId());
        contractData.setContractStartDate(project.getStartDate());
        contractData.setContractEndDate(project.getEndDate());
        contractData.setRate(project.getProposedRate());
        contractData.setRateType(project.getRateType());
        contractData.setContractType(deriveContractType(project, engineer));
        
        // 契約モジュールに契約作成を依頼
        UUID contractId = contractService.initiateContract(contractData);
        
        // 提案に契約IDを関連付け
        proposal.setContractId(contractId);
        proposalRepository.save(proposal);
        
        return contractId;
    }
    
    /**
     * 案件と技術者情報から適切な契約種別を判断する
     */
    private String deriveContractType(ProjectDTO project, EngineerDTO engineer) {
        // 契約種別判断ロジック
        // ...
        
        return "STANDARD"; // デフォルト値
    }
}
```

### 8.2 契約モジュール連携用DTO

```java
public class ContractInitiationDTO {
    private UUID proposalId;
    private UUID projectId;
    private UUID engineerId;
    private LocalDate contractStartDate;
    private LocalDate contractEndDate;
    private BigDecimal rate;
    private String rateType;
    private String contractType;
    
    // ゲッター・セッター
}
```

## 9. 通知システム連携

### 9.1 提案関連通知サービス

提案状態の変更に関する通知を送信するサービスです。

```java
@Service
public class ProposalNotificationService {
    
    private final NotificationService notificationService;
    private final UserService userService;
    
    @Autowired
    public ProposalNotificationService(NotificationService notificationService,
                                      UserService userService) {
        this.notificationService = notificationService;
        this.userService = userService;
    }
    
    /**
     * 提案作成時の通知を送信する
     * @param proposal 作成された提案
     */
    public void sendProposalCreatedNotification(Proposal proposal) {
        // 提案担当者への通知
        NotificationDTO notification = new NotificationDTO();
        notification.setSubject("提案が作成されました");
        notification.setContent("提案番号: " + proposal.getProposalNumber() + "が作成されました。");
        notification.setType("PROPOSAL_CREATED");
        notification.setTargetUserId(proposal.getSalesPersonId());
        notification.setTargetUrl("/proposals/" + proposal.getId());
        notification.setPriority("NORMAL");
        
        notificationService.sendNotification(notification);
        
        // 承認者への通知
        List<UUID> approverIds = userService.findUsersByRole("ROLE_SALES_MANAGER");
        for (UUID approverId : approverIds) {
            NotificationDTO approverNotification = new NotificationDTO();
            approverNotification.setSubject("新しい提案が提出されました");
            approverNotification.setContent("提案番号: " + proposal.getProposalNumber() + "が作成され、レビューが必要です。");
            approverNotification.setType("PROPOSAL_REVIEW_NEEDED");
            approverNotification.setTargetUserId(approverId);
            approverNotification.setTargetUrl("/proposals/" + proposal.getId());
            approverNotification.setPriority("NORMAL");
            
            notificationService.sendNotification(approverNotification);
        }
    }
    
    /**
     * 提案状態変更時の通知を送信する
     * @param proposal 状態が変更された提案
     * @param oldStatus 旧状態
     * @param newStatus 新状態
     */
    public void sendProposalStatusChangedNotification(Proposal proposal, 
                                                    ProposalStatus oldStatus,
                                                    ProposalStatus newStatus) {
        // 状態変更内容に基づく通知設定
        String subject = "提案の状態が更新されました";
        String content = "提案番号: " + proposal.getProposalNumber() + "の状態が" + 
                         oldStatus.getDisplayName() + "から" + newStatus.getDisplayName() + "に変更されました。";
        String type = "PROPOSAL_STATUS_CHANGED";
        String priority = "NORMAL";
        
        // 承認/却下の場合は特別な通知
        if (newStatus == ProposalStatus.ACCEPTED) {
            subject = "提案が承認されました";
            content = "提案番号: " + proposal.getProposalNumber() + "が承認されました。";
            type = "PROPOSAL_ACCEPTED";
            priority = "HIGH";
        } else if (newStatus == ProposalStatus.REJECTED) {
            subject = "提案が却下されました";
            content = "提案番号: " + proposal.getProposalNumber() + "が却下されました。";
            type = "PROPOSAL_REJECTED";
            priority = "HIGH";
        }
        
        // 提案担当者への通知
        NotificationDTO notification = new NotificationDTO();
        notification.setSubject(subject);
        notification.setContent(content);
        notification.setType(type);
        notification.setTargetUserId(proposal.getSalesPersonId());
        notification.setTargetUrl("/proposals/" + proposal.getId());
        notification.setPriority(priority);
        
        notificationService.sendNotification(notification);
    }
    
    /**
     * 提案期限切れの通知を送信する
     * @param proposal 期限切れの提案
     */
    public void sendProposalDeadlineNotification(Proposal proposal) {
        // 提案担当者への通知
        NotificationDTO notification = new NotificationDTO();
        notification.setSubject("提案の回答期限が近づいています");
        notification.setContent("提案番号: " + proposal.getProposalNumber() + "の回答期限が近づいています。");
        notification.setType("PROPOSAL_DEADLINE_APPROACHING");
        notification.setTargetUserId(proposal.getSalesPersonId());
        notification.setTargetUrl("/proposals/" + proposal.getId());
        notification.setPriority("HIGH");
        
        notificationService.sendNotification(notification);
    }
}
```

## 10. スケジュールされたタスク

### 10.1 提案モニタリングタスク

提案の期限監視や状態監視を行うスケジュールタスクです。

```java
@Component
public class ProposalMonitoringTasks {
    
    private final ProposalRepository proposalRepository;
    private final ProposalNotificationService notificationService;
    private final Logger logger = LoggerFactory.getLogger(ProposalMonitoringTasks.class);
    
    @Autowired
    public ProposalMonitoringTasks(ProposalRepository proposalRepository,
                                  ProposalNotificationService notificationService) {
        this.proposalRepository = proposalRepository;
        this.notificationService = notificationService;
    }
    
    /**
     * 提案期限切れチェックを毎日午前9時に実行
     */
    @Scheduled(cron = "0 0 9 * * ?")
    public void checkProposalDeadlines() {
        logger.info("Starting scheduled proposal deadline check");
        
        // 明日が期限の提案を取得
        LocalDate tomorrow = LocalDate.now().plusDays(1);
        List<Proposal> expiringProposals = proposalRepository.findByStatusInAndResponseDeadline(
            Arrays.asList(ProposalStatus.SUBMITTED, ProposalStatus.IN_REVIEW),
            tomorrow
        );
        
        logger.info("Found {} proposals with deadline tomorrow", expiringProposals.size());
        
        // 期限切れ通知の送信
        for (Proposal proposal : expiringProposals) {
            try {
                notificationService.sendProposalDeadlineNotification(proposal);
                logger.info("Sent deadline notification for proposal: {}", proposal.getProposalNumber());
            } catch (Exception e) {
                logger.error("Error sending deadline notification for proposal {}: {}", 
                            proposal.getId(), e.getMessage(), e);
            }
        }
        
        logger.info("Completed scheduled proposal deadline check");
    }
    
    /**
     * 長期未応答提案チェックを毎週月曜日午前10時に実行
     */
    @Scheduled(cron = "0 0 10 ? * MON")
    public void checkLongPendingProposals() {
        logger.info("Starting scheduled long pending proposal check");
        
        // 2週間以上応答のない提案を取得
        LocalDate twoWeeksAgo = LocalDate.now().minusWeeks(2);
        List<Proposal> pendingProposals = proposalRepository.findLongPendingProposals(
            Arrays.asList(ProposalStatus.SUBMITTED, ProposalStatus.IN_REVIEW),
            twoWeeksAgo
        );
        
        logger.info("Found {} proposals pending for more than 2 weeks", pendingProposals.size());
        
        // 長期未応答通知の送信
        for (Proposal proposal : pendingProposals) {
            try {
                // 提案担当者への通知
                NotificationDTO notification = new NotificationDTO();
                notification.setSubject("提案が長期未応答です");
                notification.setContent("提案番号: " + proposal.getProposalNumber() + 
                                       "が2週間以上応答がありません。フォローアップをご検討ください。");
                notification.setType("PROPOSAL_LONG_PENDING");
                notification.setTargetUserId(proposal.getSalesPersonId());
                notification.setTargetUrl("/proposals/" + proposal.getId());
                notification.setPriority("HIGH");
                
                notificationService.sendNotification(notification);
                logger.info("Sent long pending notification for proposal: {}", proposal.getProposalNumber());
            } catch (Exception e) {
                logger.error("Error sending long pending notification for proposal {}: {}", 
                            proposal.getId(), e.getMessage(), e);
            }
        }
        
        logger.info("Completed scheduled long pending proposal check");
    }
}
```

## 11. アーカイブ管理

### 11.1 提案アーカイブサービス

古い提案や終了した提案をアーカイブ管理するサービスです。

```java
@Service
public class ProposalArchiveService {
    
    private final ProposalRepository proposalRepository;
    private final ProposalArchiveRepository archiveRepository;
    private final DocumentStorageService documentStorageService;
    
    @Autowired
    public ProposalArchiveService(ProposalRepository proposalRepository,
                                 ProposalArchiveRepository archiveRepository,
                                 DocumentStorageService documentStorageService) {
        this.proposalRepository = proposalRepository;
        this.archiveRepository = archiveRepository;
        this.documentStorageService = documentStorageService;
    }
    
    /**
     * 終了状態の古い提案をアーカイブ化する
     * @param minAge アーカイブ化する最小経過月数
     * @return アーカイブ化した提案の数
     */
    @Transactional
    public int archiveOldProposals(int minAge) {
        // アーカイブ化対象日以前の日付を計算
        LocalDate cutoffDate = LocalDate.now().minusMonths(minAge);
        
        // アーカイブ化対象の提案を取得（終了状態かつ古いもの）
        List<Proposal> proposalsToArchive = proposalRepository.findByStatusInAndProposalDateBefore(
            Arrays.asList(ProposalStatus.ACCEPTED, ProposalStatus.REJECTED, ProposalStatus.CANCELED),
            cutoffDate
        );
        
        int archivedCount = 0;
        for (Proposal proposal : proposalsToArchive) {
            try {
                // 提案をアーカイブデータとして保存
                ProposalArchive archive = createArchiveFromProposal(proposal);
                archiveRepository.save(archive);
                
                // 提案書ドキュメントもアーカイブにコピー
                if (proposal.getProposalDocumentId() != null) {
                    documentStorageService.copyToArchive(proposal.getProposalDocumentId());
                }
                
                // 既存の提案を削除
                proposalRepository.delete(proposal);
                
                archivedCount++;
            } catch (Exception e) {
                // エラーログ
            }
        }
        
        return archivedCount;
    }
    
    private ProposalArchive createArchiveFromProposal(Proposal proposal) {
        ProposalArchive archive = new ProposalArchive();
        
        // 提案データをアーカイブにコピー
        archive.setId(UUID.randomUUID());
        archive.setOriginalId(proposal.getId());
        archive.setProposalNumber(proposal.getProposalNumber());
        archive.setProjectId(proposal.getProjectId());
        archive.setEngineerId(proposal.getEngineerId());
        archive.setStatus(proposal.getStatus());
        archive.setProposalDate(proposal.getProposalDate());
        archive.setProposalDocumentId(proposal.getProposalDocumentId());
        archive.setSalesPersonId(proposal.getSalesPersonId());
        archive.setFeedbackNotes(proposal.getFeedbackNotes());
        archive.setResponseDeadline(proposal.getResponseDeadline());
        archive.setCreatedAt(proposal.getCreatedAt());
        archive.setUpdatedAt(proposal.getUpdatedAt());
        archive.setArchivedAt(LocalDateTime.now());
        
        return archive;
    }
    
    /**
     * アーカイブから提案情報を検索する
     * @param searchDTO 検索条件
     * @param pageable ページング情報
     * @return アーカイブ提案の検索結果
     */
    public Page<ProposalArchiveDTO> searchArchivedProposals(ProposalArchiveSearchDTO searchDTO, Pageable pageable) {
        Page<ProposalArchive> archives = archiveRepository.findBySearchCriteria(
            searchDTO.getProposalNumber(),
            searchDTO.getProjectId(),
            searchDTO.getEngineerId(),
            searchDTO.getStatus(),
            searchDTO.getFromDate(),
            searchDTO.getToDate(),
            pageable
        );
        
        return archives.map(this::mapToDto);
    }
    
    private ProposalArchiveDTO mapToDto(ProposalArchive archive) {
        // アーカイブエンティティからDTOへの変換
        // ...
        return null;
    }
}
```