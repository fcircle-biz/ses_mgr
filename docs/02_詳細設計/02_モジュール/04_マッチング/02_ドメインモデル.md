# マッチング機能モジュール - ドメインモデル

## 1. ドメインモデル概要

マッチング機能モジュールは、案件と技術者のマッチングを実現するための複数のドメインオブジェクトを定義します。主要なエンティティとして「マッチング結果」と「提案」があり、これらを中心としたドメインモデルを構築します。

### 1.1 ドメインモデル関連図

```
+------------------+       +------------------+
| MatchingResult   |       | Project          |
|------------------|       | (案件管理モジュール) |
| id               |------>| id               |
| projectId        |       +------------------+
| engineerId       |
| matchingScore    |       +------------------+
| scoreDetails     |       | Engineer         |
| calculatedAt     |------>| (技術者管理モジュール) |
| algorithm        |       | id               |
| calculatedBy     |       +------------------+
| favorite         |
| memo             |
+------------------+
        |
        | 1..0
        v
+------------------+
| Proposal         |
|------------------|
| id               |
| proposalNumber   |
| projectId        |
| engineerId       |
| status           |<----+
| proposalDate     |     |
| documentId       |     |
| salesPersonId    |     |
| feedbackNotes    |     |
| responseDeadline |     |
| createdAt        |     |
| updatedAt        |     |
+------------------+     |
                         |
              +------------------+
              | ProposalStatus   |
              |------------------|
              | DRAFT            |
              | SUBMITTED        |
              | IN_REVIEW        |
              | ACCEPTED         |
              | REJECTED         |
              | CANCELED         |
              +------------------+
```

## 2. エンティティ定義

### 2.1 MatchingResult（マッチング結果）エンティティ

マッチング結果エンティティは、案件と技術者の組み合わせに対して算出されたマッチングスコアとその詳細を保持します。

#### 属性

| 属性名 | 型 | 説明 | 制約 |
|--------|------|------|------|
| id | UUID | マッチング結果ID | PK |
| projectId | UUID | 案件ID | FK, NOT NULL |
| engineerId | UUID | 技術者ID | FK, NOT NULL |
| matchingScore | double | マッチングスコア | 0-100の範囲, NOT NULL |
| scoreDetails | Map<String, Double> | スコア詳細（カテゴリ別） | JSONBとして格納 |
| calculatedAt | LocalDateTime | 計算日時 | NOT NULL |
| algorithm | String | 使用アルゴリズム | |
| calculatedBy | UUID | 計算実行ユーザーID | FK |
| favorite | boolean | お気に入りフラグ | デフォルトはfalse |
| memo | String | メモ | |

#### 実装

```java
public class MatchingResult {
    private UUID id;
    private UUID projectId;
    private UUID engineerId;
    private double matchingScore;
    private Map<String, Double> scoreDetails;
    private LocalDateTime calculatedAt;
    private String algorithm;
    private UUID calculatedBy;
    private boolean favorite;
    private String memo;
    
    // コンストラクタ
    public MatchingResult() {
    }
    
    public MatchingResult(UUID projectId, UUID engineerId, double matchingScore,
                         Map<String, Double> scoreDetails, String algorithm) {
        this.id = UUID.randomUUID();
        this.projectId = projectId;
        this.engineerId = engineerId;
        this.matchingScore = matchingScore;
        this.scoreDetails = new HashMap<>(scoreDetails);
        this.calculatedAt = LocalDateTime.now();
        this.algorithm = algorithm;
        this.favorite = false;
    }
    
    // ビジネスメソッド
    public void toggleFavorite() {
        this.favorite = !this.favorite;
    }
    
    public boolean isScoreAboveThreshold(double threshold) {
        return this.matchingScore >= threshold;
    }
    
    public Map<String, Double> getScoreDetails() {
        return Collections.unmodifiableMap(this.scoreDetails);
    }
    
    public double getCategoryScore(String category) {
        return this.scoreDetails.getOrDefault(category, 0.0);
    }
    
    public String getLowestScoreCategory() {
        if (this.scoreDetails == null || this.scoreDetails.isEmpty()) {
            return null;
        }
        
        return this.scoreDetails.entrySet().stream()
            .min(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(null);
    }
    
    // ゲッター・セッター（省略）
}
```

### 2.2 Proposal（提案）エンティティ

提案エンティティは、マッチング結果に基づいて作成される具体的な提案情報を管理します。提案状態の遷移ルールも含みます。

#### 属性

| 属性名 | 型 | 説明 | 制約 |
|--------|------|------|------|
| id | UUID | 提案ID | PK |
| proposalNumber | String | 提案番号 | UK, NOT NULL |
| projectId | UUID | 案件ID | FK, NOT NULL |
| engineerId | UUID | 技術者ID | FK, NOT NULL |
| status | ProposalStatus | 提案状態 | NOT NULL |
| proposalDate | LocalDate | 提案日 | NOT NULL |
| proposalDocumentId | UUID | 提案書ドキュメントID | FK |
| salesPersonId | UUID | 提案担当者ID | FK, NOT NULL |
| feedbackNotes | String | フィードバックメモ | |
| responseDeadline | LocalDate | 回答期限 | |
| createdAt | LocalDateTime | 作成日時 | NOT NULL |
| updatedAt | LocalDateTime | 更新日時 | NOT NULL |

#### 実装

```java
public class Proposal {
    private UUID id;
    private String proposalNumber;
    private UUID projectId;
    private UUID engineerId;
    private ProposalStatus status;
    private LocalDate proposalDate;
    private UUID proposalDocumentId;
    private UUID salesPersonId;
    private String feedbackNotes;
    private LocalDate responseDeadline;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // コンストラクタ
    public Proposal() {
    }
    
    public Proposal(String proposalNumber, UUID projectId, UUID engineerId, UUID salesPersonId) {
        this.id = UUID.randomUUID();
        this.proposalNumber = proposalNumber;
        this.projectId = projectId;
        this.engineerId = engineerId;
        this.status = ProposalStatus.DRAFT;
        this.proposalDate = LocalDate.now();
        this.salesPersonId = salesPersonId;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    // ビジネスメソッド
    public boolean canTransitionTo(ProposalStatus newStatus) {
        switch (this.status) {
            case DRAFT:
                // 下書きからは提出済か取消のみ可能
                return newStatus == ProposalStatus.SUBMITTED || 
                       newStatus == ProposalStatus.CANCELED;
                       
            case SUBMITTED:
                // 提出済からは検討中、取消が可能
                return newStatus == ProposalStatus.IN_REVIEW || 
                       newStatus == ProposalStatus.CANCELED;
                       
            case IN_REVIEW:
                // 検討中からは承認、却下、取消が可能
                return newStatus == ProposalStatus.ACCEPTED || 
                       newStatus == ProposalStatus.REJECTED || 
                       newStatus == ProposalStatus.CANCELED;
                       
            case ACCEPTED:
            case REJECTED:
                // 承認、却下からの変更は不可
                return false;
                
            case CANCELED:
                // 取消からの変更は不可
                return false;
                
            default:
                return false;
        }
    }
    
    public void updateStatus(ProposalStatus newStatus) {
        if (!canTransitionTo(newStatus)) {
            throw new IllegalStateException(
                String.format("Cannot transition from %s to %s", this.status, newStatus));
        }
        this.status = newStatus;
        this.updatedAt = LocalDateTime.now();
    }
    
    public boolean isFinalized() {
        return this.status == ProposalStatus.ACCEPTED ||
               this.status == ProposalStatus.REJECTED ||
               this.status == ProposalStatus.CANCELED;
    }
    
    public boolean isExpired() {
        return this.responseDeadline != null && 
               LocalDate.now().isAfter(this.responseDeadline);
    }
    
    // ゲッター・セッター（省略）
}
```

### 2.3 ProposalStatus（提案状態）列挙型

提案の現在のステータスを表す列挙型です。

```java
public enum ProposalStatus {
    DRAFT("下書き"),
    SUBMITTED("提出済"),
    IN_REVIEW("検討中"),
    ACCEPTED("承認"),
    REJECTED("却下"),
    CANCELED("取消");
    
    private final String displayName;
    
    ProposalStatus(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
    
    public boolean isActive() {
        return this == SUBMITTED || this == IN_REVIEW;
    }
    
    public boolean isTerminal() {
        return this == ACCEPTED || this == REJECTED || this == CANCELED;
    }
}
```

### 2.4 MatchingScore（マッチングスコア）値オブジェクト

マッチングスコアの計算結果を表す値オブジェクトです。総合スコアと各カテゴリのスコアを不変オブジェクトとして保持します。

```java
public class MatchingScore {
    private final double totalScore;
    private final Map<String, Double> categoryScores;
    
    public MatchingScore(double totalScore, Map<String, Double> categoryScores) {
        this.totalScore = totalScore;
        this.categoryScores = Collections.unmodifiableMap(new HashMap<>(categoryScores));
    }
    
    public double getTotalScore() {
        return totalScore;
    }
    
    public Map<String, Double> getCategoryScores() {
        return categoryScores;
    }
    
    public double getCategoryScore(String category) {
        return categoryScores.getOrDefault(category, 0.0);
    }
    
    public String getLowestScoreCategory() {
        if (categoryScores.isEmpty()) {
            return null;
        }
        
        return categoryScores.entrySet().stream()
            .min(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(null);
    }
    
    public String getHighestScoreCategory() {
        if (categoryScores.isEmpty()) {
            return null;
        }
        
        return categoryScores.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(null);
    }
    
    public boolean isGoodMatch() {
        return totalScore >= 70.0;
    }
}
```

## 3. リポジトリインターフェース

### 3.1 MatchingResultRepository

マッチング結果エンティティを永続化するためのリポジトリインターフェースです。

```java
public interface MatchingResultRepository {
    MatchingResult save(MatchingResult matchingResult);
    Optional<MatchingResult> findById(UUID id);
    List<MatchingResult> findByProjectId(UUID projectId);
    List<MatchingResult> findByEngineerId(UUID engineerId);
    Optional<MatchingResult> findByProjectIdAndEngineerId(UUID projectId, UUID engineerId);
    
    Page<MatchingResult> findByProjectIdAndSkillCriteria(
        UUID projectId,
        Double minimumScore,
        Set<UUID> skillIds,
        Integer experienceYears,
        Pageable pageable);
        
    Page<MatchingResult> findByEngineerIdAndProjectCriteria(
        UUID engineerId,
        Double minimumScore,
        String location,
        Set<String> projectTypes,
        Pageable pageable);
        
    Page<MatchingResult> findByBasicCriteria(
        Double minimumScore,
        Boolean favoriteOnly,
        Pageable pageable);
        
    void delete(MatchingResult matchingResult);
    void deleteById(UUID id);
    long count();
}
```

### 3.2 ProposalRepository

提案エンティティを永続化するためのリポジトリインターフェースです。

```java
public interface ProposalRepository {
    Proposal save(Proposal proposal);
    Optional<Proposal> findById(UUID id);
    Optional<Proposal> findByProposalNumber(String proposalNumber);
    List<Proposal> findByProjectId(UUID projectId);
    List<Proposal> findByEngineerId(UUID engineerId);
    List<Proposal> findBySalesPersonId(UUID salesPersonId);
    Page<Proposal> findByStatus(ProposalStatus status, Pageable pageable);
    
    Page<Proposal> findBySearchCriteria(
        ProposalStatus status,
        LocalDate fromDate,
        LocalDate toDate,
        UUID projectId,
        UUID engineerId,
        Pageable pageable);
        
    int countByYearAndMonth(int year, int month);
    List<Proposal> findExpired(LocalDate referenceDate);
    
    void delete(Proposal proposal);
    void deleteById(UUID id);
    long count();
}
```

## 4. データベース設計

### 4.1 テーブル定義

#### matching_results テーブル

マッチング結果エンティティを格納するテーブルです。

| カラム名 | データ型 | 制約 | 説明 |
|---------|---------|------|------|
| id | UUID | PK | マッチング結果ID |
| project_id | UUID | FK, NOT NULL | 案件ID |
| engineer_id | UUID | FK, NOT NULL | 技術者ID |
| matching_score | DOUBLE PRECISION | NOT NULL | マッチングスコア |
| score_details | JSONB | | スコア詳細 |
| calculated_at | TIMESTAMP | NOT NULL | 計算日時 |
| algorithm | VARCHAR(100) | | 使用アルゴリズム |
| calculated_by | UUID | FK | 計算実行ユーザーID |
| favorite | BOOLEAN | DEFAULT FALSE | お気に入りフラグ |
| memo | TEXT | | メモ |
| created_at | TIMESTAMP | NOT NULL | 作成日時 |
| updated_at | TIMESTAMP | NOT NULL | 更新日時 |

#### proposals テーブル

提案エンティティを格納するテーブルです。

| カラム名 | データ型 | 制約 | 説明 |
|---------|---------|------|------|
| id | UUID | PK | 提案ID |
| proposal_number | VARCHAR(50) | UK, NOT NULL | 提案番号 |
| project_id | UUID | FK, NOT NULL | 案件ID |
| engineer_id | UUID | FK, NOT NULL | 技術者ID |
| status | VARCHAR(50) | NOT NULL | 提案状態 |
| proposal_date | DATE | NOT NULL | 提案日 |
| proposal_document_id | UUID | FK | 提案書ドキュメントID |
| sales_person_id | UUID | FK, NOT NULL | 提案担当者ID |
| feedback_notes | TEXT | | フィードバックメモ |
| response_deadline | DATE | | 回答期限 |
| created_at | TIMESTAMP | NOT NULL | 作成日時 |
| updated_at | TIMESTAMP | NOT NULL | 更新日時 |

### 4.2 インデックス

#### matching_results テーブルのインデックス

| インデックス名 | カラム | 種類 | 説明 |
|--------------|-------|------|------|
| idx_matching_results_project_id | project_id | BTREE | 案件IDによる検索用 |
| idx_matching_results_engineer_id | engineer_id | BTREE | 技術者IDによる検索用 |
| idx_matching_results_score | matching_score | BTREE | スコアによるソート用 |
| idx_matching_results_calculated_at | calculated_at | BTREE | 計算日時による検索用 |
| idx_matching_results_favorite | favorite | BTREE | お気に入りフラグによる検索用 |
| idx_matching_results_composite | (project_id, engineer_id) | BTREE | 案件と技術者の組み合わせによる検索用 |

#### proposals テーブルのインデックス

| インデックス名 | カラム | 種類 | 説明 |
|--------------|-------|------|------|
| idx_proposals_proposal_number | proposal_number | BTREE | 提案番号による検索用 |
| idx_proposals_project_id | project_id | BTREE | 案件IDによる検索用 |
| idx_proposals_engineer_id | engineer_id | BTREE | 技術者IDによる検索用 |
| idx_proposals_status | status | BTREE | 提案状態による検索用 |
| idx_proposals_proposal_date | proposal_date | BTREE | 提案日による検索用 |
| idx_proposals_sales_person_id | sales_person_id | BTREE | 提案担当者IDによる検索用 |
| idx_proposals_response_deadline | response_deadline | BTREE | 回答期限による検索用 |

### 4.3 制約

#### matching_results テーブルの制約

| 制約名 | 種類 | カラム | 説明 |
|--------|------|-------|------|
| pk_matching_results | PRIMARY KEY | id | 主キー制約 |
| fk_matching_results_project | FOREIGN KEY | project_id | projects テーブルへの外部キー |
| fk_matching_results_engineer | FOREIGN KEY | engineer_id | engineers テーブルへの外部キー |
| fk_matching_results_user | FOREIGN KEY | calculated_by | users テーブルへの外部キー |
| uq_matching_results_project_engineer | UNIQUE | (project_id, engineer_id) | 案件と技術者の組み合わせの一意性 |
| chk_matching_results_score | CHECK | matching_score | スコアの範囲チェック（0-100） |

#### proposals テーブルの制約

| 制約名 | 種類 | カラム | 説明 |
|--------|------|-------|------|
| pk_proposals | PRIMARY KEY | id | 主キー制約 |
| uq_proposals_proposal_number | UNIQUE | proposal_number | 提案番号の一意性 |
| fk_proposals_project | FOREIGN KEY | project_id | projects テーブルへの外部キー |
| fk_proposals_engineer | FOREIGN KEY | engineer_id | engineers テーブルへの外部キー |
| fk_proposals_document | FOREIGN KEY | proposal_document_id | documents テーブルへの外部キー |
| fk_proposals_sales_person | FOREIGN KEY | sales_person_id | users テーブルへの外部キー |
| chk_proposals_status | CHECK | status | 提案状態の値チェック |

### 4.4 DDL

```sql
-- matching_results テーブル
CREATE TABLE matching_results (
    id UUID PRIMARY KEY,
    project_id UUID NOT NULL,
    engineer_id UUID NOT NULL,
    matching_score DOUBLE PRECISION NOT NULL,
    score_details JSONB,
    calculated_at TIMESTAMP NOT NULL,
    algorithm VARCHAR(100),
    calculated_by UUID,
    favorite BOOLEAN DEFAULT FALSE,
    memo TEXT,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    CONSTRAINT uq_matching_results_project_engineer UNIQUE (project_id, engineer_id),
    CONSTRAINT fk_matching_results_project FOREIGN KEY (project_id) REFERENCES projects (id),
    CONSTRAINT fk_matching_results_engineer FOREIGN KEY (engineer_id) REFERENCES engineers (id),
    CONSTRAINT fk_matching_results_user FOREIGN KEY (calculated_by) REFERENCES users (id),
    CONSTRAINT chk_matching_results_score CHECK (matching_score >= 0 AND matching_score <= 100)
);

CREATE INDEX idx_matching_results_project_id ON matching_results (project_id);
CREATE INDEX idx_matching_results_engineer_id ON matching_results (engineer_id);
CREATE INDEX idx_matching_results_score ON matching_results (matching_score);
CREATE INDEX idx_matching_results_calculated_at ON matching_results (calculated_at);
CREATE INDEX idx_matching_results_favorite ON matching_results (favorite);

-- proposals テーブル
CREATE TABLE proposals (
    id UUID PRIMARY KEY,
    proposal_number VARCHAR(50) NOT NULL,
    project_id UUID NOT NULL,
    engineer_id UUID NOT NULL,
    status VARCHAR(50) NOT NULL,
    proposal_date DATE NOT NULL,
    proposal_document_id UUID,
    sales_person_id UUID NOT NULL,
    feedback_notes TEXT,
    response_deadline DATE,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    CONSTRAINT uq_proposals_proposal_number UNIQUE (proposal_number),
    CONSTRAINT fk_proposals_project FOREIGN KEY (project_id) REFERENCES projects (id),
    CONSTRAINT fk_proposals_engineer FOREIGN KEY (engineer_id) REFERENCES engineers (id),
    CONSTRAINT fk_proposals_document FOREIGN KEY (proposal_document_id) REFERENCES documents (id),
    CONSTRAINT fk_proposals_sales_person FOREIGN KEY (sales_person_id) REFERENCES users (id),
    CONSTRAINT chk_proposals_status CHECK (status IN ('DRAFT', 'SUBMITTED', 'IN_REVIEW', 'ACCEPTED', 'REJECTED', 'CANCELED'))
);

CREATE INDEX idx_proposals_proposal_number ON proposals (proposal_number);
CREATE INDEX idx_proposals_project_id ON proposals (project_id);
CREATE INDEX idx_proposals_engineer_id ON proposals (engineer_id);
CREATE INDEX idx_proposals_status ON proposals (status);
CREATE INDEX idx_proposals_proposal_date ON proposals (proposal_date);
CREATE INDEX idx_proposals_sales_person_id ON proposals (sales_person_id);
CREATE INDEX idx_proposals_response_deadline ON proposals (response_deadline);
```

## 5. DTOクラス

### 5.1 MatchingSearchDTO

マッチング検索条件を表すDTOクラスです。

```java
public class MatchingSearchDTO {
    private UUID projectId;
    private UUID engineerId;
    private Double minimumScore;
    private Set<UUID> skillIds;
    private Integer experienceYears;
    private String location;
    private Set<String> projectTypes;
    private Boolean favoriteOnly;
    
    // コンストラクタ、ゲッター、セッター
}
```

### 5.2 MatchingResultDTO

マッチング結果をプレゼンテーション層に提供するDTOクラスです。

```java
public class MatchingResultDTO {
    private UUID id;
    private UUID projectId;
    private String projectName;
    private UUID engineerId;
    private String engineerName;
    private double matchingScore;
    private Map<String, Double> scoreDetails;
    private LocalDateTime calculatedAt;
    private boolean favorite;
    private String memo;
    
    // コンストラクタ、ゲッター、セッター
}
```

### 5.3 ProposalDTO

提案をプレゼンテーション層に提供するDTOクラスです。

```java
public class ProposalDTO {
    private UUID id;
    private String proposalNumber;
    private UUID projectId;
    private String projectName;
    private UUID engineerId;
    private String engineerName;
    private String status;
    private String statusDisplayName;
    private LocalDate proposalDate;
    private UUID proposalDocumentId;
    private UUID salesPersonId;
    private String salesPersonName;
    private String feedbackNotes;
    private LocalDate responseDeadline;
    private boolean expired;
    
    // コンストラクタ、ゲッター、セッター
}
```

## 6. マッパークラス

### 6.1 MatchingMapper

マッチング結果エンティティとDTOの相互変換を行うマッパークラスです。

```java
@Component
public class MatchingMapper {
    private final ProjectService projectService;
    private final EngineerService engineerService;
    
    @Autowired
    public MatchingMapper(ProjectService projectService, EngineerService engineerService) {
        this.projectService = projectService;
        this.engineerService = engineerService;
    }
    
    public MatchingResultDTO toDto(MatchingResult entity) {
        if (entity == null) {
            return null;
        }
        
        MatchingResultDTO dto = new MatchingResultDTO();
        dto.setId(entity.getId());
        dto.setProjectId(entity.getProjectId());
        dto.setEngineerId(entity.getEngineerId());
        dto.setMatchingScore(entity.getMatchingScore());
        dto.setScoreDetails(entity.getScoreDetails());
        dto.setCalculatedAt(entity.getCalculatedAt());
        dto.setFavorite(entity.isFavorite());
        dto.setMemo(entity.getMemo());
        
        // 関連エンティティ情報の取得と設定
        try {
            ProjectDTO project = projectService.getProjectById(entity.getProjectId());
            if (project != null) {
                dto.setProjectName(project.getProjectName());
            }
        } catch (Exception e) {
            // ログ出力
        }
        
        try {
            EngineerDTO engineer = engineerService.getEngineerById(entity.getEngineerId());
            if (engineer != null) {
                dto.setEngineerName(engineer.getFullName());
            }
        } catch (Exception e) {
            // ログ出力
        }
        
        return dto;
    }
    
    public MatchingResult toEntity(MatchingResultDTO dto) {
        if (dto == null) {
            return null;
        }
        
        MatchingResult entity = new MatchingResult();
        entity.setId(dto.getId());
        entity.setProjectId(dto.getProjectId());
        entity.setEngineerId(dto.getEngineerId());
        entity.setMatchingScore(dto.getMatchingScore());
        entity.setScoreDetails(dto.getScoreDetails());
        entity.setCalculatedAt(dto.getCalculatedAt());
        entity.setFavorite(dto.isFavorite());
        entity.setMemo(dto.getMemo());
        
        return entity;
    }
}
```

### 6.2 ProposalMapper

提案エンティティとDTOの相互変換を行うマッパークラスです。

```java
@Component
public class ProposalMapper {
    private final ProjectService projectService;
    private final EngineerService engineerService;
    private final UserService userService;
    
    @Autowired
    public ProposalMapper(ProjectService projectService, EngineerService engineerService, 
                         UserService userService) {
        this.projectService = projectService;
        this.engineerService = engineerService;
        this.userService = userService;
    }
    
    public ProposalDTO toDto(Proposal entity) {
        if (entity == null) {
            return null;
        }
        
        ProposalDTO dto = new ProposalDTO();
        dto.setId(entity.getId());
        dto.setProposalNumber(entity.getProposalNumber());
        dto.setProjectId(entity.getProjectId());
        dto.setEngineerId(entity.getEngineerId());
        dto.setStatus(entity.getStatus().name());
        dto.setStatusDisplayName(entity.getStatus().getDisplayName());
        dto.setProposalDate(entity.getProposalDate());
        dto.setProposalDocumentId(entity.getProposalDocumentId());
        dto.setSalesPersonId(entity.getSalesPersonId());
        dto.setFeedbackNotes(entity.getFeedbackNotes());
        dto.setResponseDeadline(entity.getResponseDeadline());
        dto.setExpired(entity.isExpired());
        
        // 関連エンティティ情報の取得と設定
        try {
            ProjectDTO project = projectService.getProjectById(entity.getProjectId());
            if (project != null) {
                dto.setProjectName(project.getProjectName());
            }
        } catch (Exception e) {
            // ログ出力
        }
        
        try {
            EngineerDTO engineer = engineerService.getEngineerById(entity.getEngineerId());
            if (engineer != null) {
                dto.setEngineerName(engineer.getFullName());
            }
        } catch (Exception e) {
            // ログ出力
        }
        
        try {
            UserDTO salesPerson = userService.getUserById(entity.getSalesPersonId());
            if (salesPerson != null) {
                dto.setSalesPersonName(salesPerson.getFullName());
            }
        } catch (Exception e) {
            // ログ出力
        }
        
        return dto;
    }
    
    public Proposal toEntity(ProposalDTO dto) {
        if (dto == null) {
            return null;
        }
        
        Proposal entity = new Proposal();
        entity.setId(dto.getId());
        entity.setProposalNumber(dto.getProposalNumber());
        entity.setProjectId(dto.getProjectId());
        entity.setEngineerId(dto.getEngineerId());
        entity.setStatus(ProposalStatus.valueOf(dto.getStatus()));
        entity.setProposalDate(dto.getProposalDate());
        entity.setProposalDocumentId(dto.getProposalDocumentId());
        entity.setSalesPersonId(dto.getSalesPersonId());
        entity.setFeedbackNotes(dto.getFeedbackNotes());
        entity.setResponseDeadline(dto.getResponseDeadline());
        
        return entity;
    }
}
```