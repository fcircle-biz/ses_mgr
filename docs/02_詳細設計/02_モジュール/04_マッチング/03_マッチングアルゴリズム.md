# マッチング機能モジュール - マッチングアルゴリズム

## 1. マッチングアルゴリズム概要

マッチングアルゴリズムは、案件と技術者の適合度を客観的に評価するための計算ロジックを提供します。複数の評価軸（スキル、経験年数、稼働状況、勤務地など）に基づいて、0〜100点のスコアを算出します。

### 1.1 アルゴリズムの基本設計方針

- 複数評価軸の重み付け平均によるスコア算出
- カテゴリ別スコアの可視化による説明可能性の確保
- パラメータの柔軟な調整による最適化
- 案件特性に応じた重み付けの変動
- 拡張性を考慮した設計

### 1.2 評価カテゴリと重み付け

標準的な評価カテゴリとその重み付けは以下の通りです。これらは案件タイプや要件に応じて変動します。

| カテゴリ | 説明 | 標準重み |
|---------|------|---------|
| skills | スキル適合度 | 0.5 (50%) |
| experience | 経験年数 | 0.25 (25%) |
| availability | 稼働状況 | 0.15 (15%) |
| location | 勤務地 | 0.10 (10%) |

## 2. アルゴリズム実装

### 2.1 MatchingAlgorithmService クラス

マッチングアルゴリズムのコア機能を提供するドメインサービスです。

```java
@Service
public class MatchingAlgorithmService {

    // カテゴリ別の重み付け設定
    private static final Map<String, Double> CATEGORY_WEIGHTS = Map.of(
        "skills", 0.5,            // スキル適合度
        "experience", 0.25,       // 経験年数
        "availability", 0.15,     // 稼働状況
        "location", 0.10          // 勤務地
    );
    
    private final AlgorithmParameterRepository parameterRepository;
    
    @Autowired
    public MatchingAlgorithmService(AlgorithmParameterRepository parameterRepository) {
        this.parameterRepository = parameterRepository;
    }

    /**
     * マッチングスコアを計算する
     * @param project 案件情報
     * @param engineer 技術者情報
     * @return マッチングスコア
     */
    public MatchingScore calculateMatchingScore(ProjectDTO project, EngineerDTO engineer) {
        Map<String, Double> categoryScores = new HashMap<>();
        
        // 案件タイプに応じた重み付け取得
        Map<String, Double> weights = getWeightsForProjectType(project.getProjectType());
        
        // 1. スキルマッチング（0-100点）
        double skillScore = calculateSkillScore(project.getRequiredSkillIds(), engineer.getSkills());
        categoryScores.put("skills", skillScore);
        
        // 2. 経験年数評価（0-100点）
        double experienceScore = calculateExperienceScore(project, engineer);
        categoryScores.put("experience", experienceScore);
        
        // 3. 稼働状況評価（0-100点）
        double availabilityScore = calculateAvailabilityScore(project.getStartDate(), engineer.getAvailability());
        categoryScores.put("availability", availabilityScore);
        
        // 4. 勤務地評価（0-100点）
        double locationScore = calculateLocationScore(project.getLocation(), engineer.getPreferredLocations());
        categoryScores.put("location", locationScore);
        
        // 総合スコア計算（重み付け平均）
        double totalScore = calculateWeightedScore(categoryScores, weights);
        
        return new MatchingScore(totalScore, categoryScores);
    }
    
    // 案件タイプに応じた重み付け取得
    private Map<String, Double> getWeightsForProjectType(String projectType) {
        // パラメータリポジトリから案件タイプ別の重み付け設定を取得
        Optional<AlgorithmParameter> parameters = parameterRepository.findByProjectType(projectType);
        
        // 設定が存在すれば使用、なければデフォルト値を使用
        return parameters.map(AlgorithmParameter::getWeights)
                        .orElse(CATEGORY_WEIGHTS);
    }

    // スキルスコア計算（必須スキルの網羅度と習熟度で評価）
    private double calculateSkillScore(Set<UUID> requiredSkillIds, List<EngineerSkillDTO> engineerSkills) {
        if (requiredSkillIds.isEmpty()) {
            return 100.0; // スキル要件なしの場合は満点
        }
        
        // 技術者のスキルIDと習熟度のマップを作成
        Map<UUID, Integer> engineerSkillMap = engineerSkills.stream()
            .collect(Collectors.toMap(EngineerSkillDTO::getSkillId, EngineerSkillDTO::getLevel));
            
        // 必須スキル一致度と習熟度を評価
        double coveredSkillsScore = 0.0;
        double skillLevelScore = 0.0;
        
        int coveredSkillCount = 0;
        double totalSkillLevel = 0.0;
        
        for (UUID skillId : requiredSkillIds) {
            if (engineerSkillMap.containsKey(skillId)) {
                // スキルカバレッジスコア
                coveredSkillCount++;
                
                // スキル習熟度（1-5）を20点刻みのスコアに変換
                int level = engineerSkillMap.get(skillId);
                totalSkillLevel += level * 20.0;
            }
        }
        
        // スキルカバレッジスコア（最大50点）
        coveredSkillsScore = 50.0 * ((double) coveredSkillCount / requiredSkillIds.size());
        
        // スキル習熟度スコア（最大50点）
        if (coveredSkillCount > 0) {
            skillLevelScore = totalSkillLevel / requiredSkillIds.size() / 2.0;
        }
        
        // 総合スキルスコア（最大100点）
        return coveredSkillsScore + skillLevelScore;
    }
    
    // 経験年数スコア計算
    private double calculateExperienceScore(ProjectDTO project, EngineerDTO engineer) {
        // プロジェクトが指定する最低経験年数と技術者の経験年数の比較
        int requiredYears = project.getRequiredExperienceYears() != null ? project.getRequiredExperienceYears() : 0;
        int engineerYears = engineer.getTotalExperienceYears();
        
        if (engineerYears >= requiredYears) {
            // 最低要件を満たす場合
            if (requiredYears == 0) {
                return 100.0; // 経験年数要件なしの場合は満点
            }
            
            // 要件以上の場合はボーナススコア（最大100点）
            return Math.min(100.0, 80.0 + 20.0 * (engineerYears - requiredYears) / 5.0);
        } else {
            // 最低要件を満たさない場合（要件に近いほど高スコア）
            return 60.0 * engineerYears / requiredYears;
        }
    }
    
    // 稼働状況スコア計算
    private double calculateAvailabilityScore(LocalDate projectStartDate, EngineerAvailabilityDTO availability) {
        if (projectStartDate == null || availability == null) {
            return 50.0; // データ不足の場合は中立的なスコア
        }
        
        // プロジェクト開始日における技術者の稼働状況を評価
        LocalDate availableDate = availability.getNextAvailableDate();
        
        if (availableDate == null) {
            return 0.0; // 稼働予定なしの場合は0点
        }
        
        if (availableDate.isBefore(projectStartDate) || availableDate.isEqual(projectStartDate)) {
            return 100.0; // プロジェクト開始日に稼働可能なら満点
        }
        
        // 遅れ日数に応じたスコア減少（1ヶ月で40点減）
        long daysLate = ChronoUnit.DAYS.between(projectStartDate, availableDate);
        return Math.max(0.0, 100.0 - (daysLate / 30.0) * 40.0);
    }
    
    // 勤務地スコア計算
    private double calculateLocationScore(String projectLocation, List<String> preferredLocations) {
        if (projectLocation == null || preferredLocations == null || preferredLocations.isEmpty()) {
            return 50.0; // データ不足の場合は中立的なスコア
        }
        
        // 完全一致
        if (preferredLocations.contains(projectLocation)) {
            return 100.0;
        }
        
        // 都道府県レベルで一致（例: "東京都新宿区" と "東京都" でマッチ）
        String projectPrefecture = extractPrefecture(projectLocation);
        for (String location : preferredLocations) {
            String preferredPrefecture = extractPrefecture(location);
            if (projectPrefecture.equals(preferredPrefecture)) {
                return 80.0;
            }
        }
        
        // 地域レベルで一致（例: "東京都" と "関東" でマッチ）
        String projectRegion = getPrefectureRegion(projectPrefecture);
        for (String location : preferredLocations) {
            String preferredPrefecture = extractPrefecture(location);
            String preferredRegion = getPrefectureRegion(preferredPrefecture);
            
            if (projectRegion.equals(preferredRegion)) {
                return 60.0;
            }
        }
        
        // リモートワーク許容
        if (preferredLocations.contains("リモート") || preferredLocations.contains("在宅")) {
            return 70.0; // リモート可能なら一定スコア
        }
        
        return 30.0; // マッチしない場合は低スコア
    }
    
    // 住所から都道府県を抽出
    private String extractPrefecture(String location) {
        if (location == null || location.isEmpty()) {
            return "";
        }
        
        // 都道府県の抽出ロジック
        // 例: "東京都新宿区" -> "東京都"
        String[] parts = location.split("[都道府県]", 2);
        if (parts.length > 0) {
            return parts[0] + getPrefectureSuffix(parts[0]);
        }
        return location;
    }
    
    // 都道府県の接尾辞を取得
    private String getPrefectureSuffix(String prefecture) {
        // 北海道は特殊ケース
        if ("北海".equals(prefecture)) {
            return "道";
        }
        
        // 東京都、京都府、大阪府は「都府」
        if ("東京".equals(prefecture) || "京".equals(prefecture)) {
            return "都";
        }
        if ("大阪".equals(prefecture) || "京".equals(prefecture)) {
            return "府";
        }
        
        // それ以外は県
        return "県";
    }
    
    // 都道府県から地域を取得
    private String getPrefectureRegion(String prefecture) {
        // 地域区分マップ
        Map<String, List<String>> regionMap = Map.of(
            "北海道・東北", List.of("北海道", "青森県", "岩手県", "宮城県", "秋田県", "山形県", "福島県"),
            "関東", List.of("茨城県", "栃木県", "群馬県", "埼玉県", "千葉県", "東京都", "神奈川県"),
            "中部", List.of("新潟県", "富山県", "石川県", "福井県", "山梨県", "長野県", "岐阜県", "静岡県", "愛知県"),
            "近畿", List.of("三重県", "滋賀県", "京都府", "大阪府", "兵庫県", "奈良県", "和歌山県"),
            "中国・四国", List.of("鳥取県", "島根県", "岡山県", "広島県", "山口県", "徳島県", "香川県", "愛媛県", "高知県"),
            "九州・沖縄", List.of("福岡県", "佐賀県", "長崎県", "熊本県", "大分県", "宮崎県", "鹿児島県", "沖縄県")
        );
        
        // 都道府県から地域を検索
        for (Map.Entry<String, List<String>> entry : regionMap.entrySet()) {
            if (entry.getValue().contains(prefecture)) {
                return entry.getKey();
            }
        }
        
        return "その他";
    }
    
    // 重み付け平均スコア計算
    private double calculateWeightedScore(Map<String, Double> categoryScores, Map<String, Double> weights) {
        double totalWeightedScore = 0.0;
        double totalWeight = 0.0;
        
        for (Map.Entry<String, Double> entry : categoryScores.entrySet()) {
            String category = entry.getKey();
            Double score = entry.getValue();
            Double weight = weights.getOrDefault(category, 0.0);
            
            totalWeightedScore += score * weight;
            totalWeight += weight;
        }
        
        return totalWeight > 0 ? totalWeightedScore / totalWeight : 0.0;
    }
}
```

### 2.2 MatchingScore 値オブジェクト

マッチングスコアの計算結果を不変オブジェクトとして表現します。

```java
public class MatchingScore {
    private final double totalScore;
    private final Map<String, Double> categoryScores;
    
    public MatchingScore(double totalScore, Map<String, Double> categoryScores) {
        this.totalScore = totalScore;
        this.categoryScores = Collections.unmodifiableMap(new HashMap<>(categoryScores));
    }
    
    public double getTotalScore() {
        return totalScore;
    }
    
    public Map<String, Double> getCategoryScores() {
        return categoryScores;
    }
    
    public double getCategoryScore(String category) {
        return categoryScores.getOrDefault(category, 0.0);
    }
    
    // スコアの解釈メソッド
    public MatchingLevel getMatchingLevel() {
        if (totalScore >= 90.0) {
            return MatchingLevel.EXCELLENT;
        } else if (totalScore >= 70.0) {
            return MatchingLevel.GOOD;
        } else if (totalScore >= 50.0) {
            return MatchingLevel.AVERAGE;
        } else {
            return MatchingLevel.POOR;
        }
    }
    
    // マッチングレベル列挙型
    public enum MatchingLevel {
        EXCELLENT("最適", "緑"),
        GOOD("良好", "青"),
        AVERAGE("普通", "黄"),
        POOR("不適", "赤");
        
        private final String displayName;
        private final String colorCode;
        
        MatchingLevel(String displayName, String colorCode) {
            this.displayName = displayName;
            this.colorCode = colorCode;
        }
        
        public String getDisplayName() {
            return displayName;
        }
        
        public String getColorCode() {
            return colorCode;
        }
    }
    
    public String getLowestScoreCategory() {
        if (categoryScores.isEmpty()) {
            return null;
        }
        
        return categoryScores.entrySet().stream()
            .min(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(null);
    }
    
    public String getHighestScoreCategory() {
        if (categoryScores.isEmpty()) {
            return null;
        }
        
        return categoryScores.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(null);
    }
}
```

### 2.3 AlgorithmParameter エンティティ

マッチングアルゴリズムのパラメータを管理するエンティティです。案件タイプごとにカスタマイズ可能な重み付けを格納します。

```java
public class AlgorithmParameter {
    private UUID id;
    private String projectType;
    private Map<String, Double> weights;
    private String description;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // コンストラクタ、ゲッター、セッター
    
    public Map<String, Double> getWeights() {
        return Collections.unmodifiableMap(weights);
    }
}
```

## 3. スキルマッチングアルゴリズム詳細

スキルマッチングは、全体スコアの50%を占める最も重要な評価軸です。複数の観点からスキルマッチングを評価します。

### 3.1 スキルカバレッジ評価

必須スキルがどれだけカバーされているかを評価します。

```
スキルカバレッジスコア = 50.0 * (一致スキル数 / 必須スキル数)
```

例：
- 案件の必須スキル: Java, Spring Boot, AWS, PostgreSQL, React
- 技術者のスキル: Java, Spring Boot, PostgreSQL
- スキルカバレッジ: 3/5 = 0.6
- スキルカバレッジスコア: 50 * 0.6 = 30点

### 3.2 スキル習熟度評価

一致したスキルの習熟度を評価します。スキルレベルは1〜5で表現し、以下のように変換します。

```
スキルレベル変換:
レベル1 = 20点
レベル2 = 40点
レベル3 = 60点
レベル4 = 80点
レベル5 = 100点

スキル習熟度スコア = Σ(スキルレベル変換値) / 必須スキル数 / 2
```

例：
- 一致スキル: Java(レベル4), Spring Boot(レベル3), PostgreSQL(レベル2)
- スキルレベル合計: 80 + 60 + 40 = 180
- スキル習熟度スコア: 180 / 5 / 2 = 18点

### 3.3 総合スキルスコア

カバレッジと習熟度を合算した総合スコアを計算します。

```
総合スキルスコア = スキルカバレッジスコア + スキル習熟度スコア
```

例：
- 総合スキルスコア = 30 + 18 = 48点

## 4. 経験年数評価アルゴリズム詳細

経験年数評価は、案件が要求する経験年数と技術者の実際の経験年数を比較します。

### 4.1 要件充足評価

```
if (技術者経験年数 >= 要求経験年数) {
    if (要求経験年数 == 0) {
        return 100.0; // 経験年数要件なしの場合は満点
    }
    
    // 要件以上の場合はボーナススコア（最大100点）
    return min(100.0, 80.0 + 20.0 * (技術者経験年数 - 要求経験年数) / 5.0);
} else {
    // 要件未満の場合は比例配分
    return 60.0 * 技術者経験年数 / 要求経験年数;
}
```

例：
- 案件要求経験年数: 5年
- ケース1: 技術者経験年数7年
  - スコア = 80 + 20 * (7-5)/5 = 80 + 8 = 88点
- ケース2: 技術者経験年数3年
  - スコア = 60 * 3/5 = 36点

## 5. 稼働状況評価アルゴリズム詳細

稼働状況評価は、案件開始日と技術者の次回稼働可能日を比較します。

### 5.1 稼働タイミング評価

```
if (稼働可能日 == null) {
    return 0.0; // 稼働予定なしの場合は0点
}

if (稼働可能日 <= プロジェクト開始日) {
    return 100.0; // プロジェクト開始日に稼働可能なら満点
}

// 遅れ日数に応じたスコア減少（1ヶ月で40点減）
遅れ日数 = 稼働可能日 - プロジェクト開始日;
return max(0.0, 100.0 - (遅れ日数 / 30.0) * 40.0);
```

例：
- 案件開始日: 2025-06-01
- ケース1: 技術者稼働可能日 2025-05-15 
  - スコア = 100点（開始日前に稼働可能）
- ケース2: 技術者稼働可能日 2025-07-01
  - 遅れ日数 = 30日
  - スコア = 100 - (30/30) * 40 = 60点

## 6. 勤務地評価アルゴリズム詳細

勤務地評価は、案件の勤務地と技術者の希望勤務地のマッチング度を評価します。

### 6.1 地理的マッチング評価

```
// 完全一致
if (希望勤務地リストに案件勤務地が含まれる) {
    return 100.0;
}

// 都道府県レベルで一致
if (希望勤務地リスト内の都道府県と案件勤務地の都道府県が一致) {
    return 80.0;
}

// 地域レベルで一致
if (希望勤務地リスト内の地域と案件勤務地の地域が一致) {
    return 60.0;
}

// リモートワーク許容
if (希望勤務地リストに"リモート"や"在宅"が含まれる) {
    return 70.0;
}

// マッチしない
return 30.0;
```

例：
- 案件勤務地: "東京都新宿区"
- ケース1: 希望勤務地リスト ["東京都新宿区", "東京都渋谷区"]
  - スコア = 100点（完全一致）
- ケース2: 希望勤務地リスト ["東京都", "神奈川県"]
  - スコア = 80点（都道府県レベルで一致）
- ケース3: 希望勤務地リスト ["大阪府", "リモート"]
  - スコア = 70点（リモート希望）

## 7. アルゴリズム拡張性

マッチングアルゴリズムは、将来的な拡張や最適化に対応できる柔軟な設計です。

### 7.1 追加可能な評価軸

将来的に追加可能な評価軸の例：

1. **単価適合度**
   - 案件予算と技術者希望単価の近接度評価
   - 予算オーバー度合いに応じたスコア減算

2. **業種経験**
   - 案件の業種と技術者の業種経験の一致度
   - 金融、製造、小売など業種別の経験評価

3. **プロジェクト規模適合度**
   - 技術者の経験プロジェクト規模と案件規模の一致度
   - 大規模/中規模/小規模プロジェクト経験の評価

4. **言語適合度**
   - 案件で使用される言語（日本語/英語レベル等）と技術者の言語スキル

### 7.2 アルゴリズムのバージョン管理

アルゴリズムは継続的に改善され、バージョン管理されます。新バージョンのアルゴリズムをリリースする際のステップ：

1. 新アルゴリズムの開発とテスト
2. 既存データを用いた新旧アルゴリズムの結果比較
3. 影響度分析と調整
4. A/Bテストによる有効性検証
5. 段階的なロールアウト

## 8. アルゴリズムパラメータ管理

### 8.1 パラメータ設定テーブル

アルゴリズムパラメータはデータベースで管理し、管理者が調整可能にします。

**algorithm_parameters テーブル**

| カラム名 | データ型 | 制約 | 説明 |
|---------|---------|------|------|
| id | UUID | PK | パラメータID |
| project_type | VARCHAR(50) | UK, NOT NULL | 案件タイプ |
| weights | JSONB | NOT NULL | カテゴリ別重み設定 |
| description | TEXT | | 説明 |
| created_at | TIMESTAMP | NOT NULL | 作成日時 |
| updated_at | TIMESTAMP | NOT NULL | 更新日時 |

### 8.2 パラメータの調整機能

管理者向けにパラメータ調整UIを提供します。

- カテゴリ別重み付けのスライダー設定
- 案件タイプごとのプリセット管理
- パラメータ変更履歴のトラッキング
- A/Bテスト機能（新旧パラメータの比較）

## 9. バッチ処理によるマッチング計算

大量のマッチング計算を効率的に実行するためのバッチ処理機能を提供します。

### 9.1 BatchMatchingService

```java
@Service
public class BatchMatchingService {

    private final MatchingAlgorithmService algorithmService;
    private final MatchingResultRepository resultRepository;
    private final ProjectService projectService;
    private final EngineerService engineerService;
    private final ExecutorService executorService;
    
    public BatchMatchingService() {
        // スレッドプールの初期化（プロセッサ数に合わせる）
        this.executorService = Executors.newFixedThreadPool(
            Runtime.getRuntime().availableProcessors()
        );
    }
    
    /**
     * 指定された案件に対して一括マッチング計算を実行する
     * @param projectId 案件ID
     * @return マッチング結果のリスト
     */
    public CompletableFuture<List<MatchingResult>> calculateBatchMatching(UUID projectId) {
        ProjectDTO project = projectService.getProjectById(projectId);
        
        // 案件要件に基づいて候補技術者検索
        List<EngineerDTO> candidateEngineers = engineerService.findEngineersBySkillRequirements(
            project.getRequiredSkillIds(),
            project.getRequiredExperienceYears()
        );
        
        // 並列処理でマッチング計算
        List<CompletableFuture<MatchingResult>> futures = candidateEngineers.stream()
            .map(engineer -> CompletableFuture.supplyAsync(() -> {
                MatchingScore score = algorithmService.calculateMatchingScore(project, engineer);
                
                MatchingResult result = new MatchingResult();
                result.setProjectId(projectId);
                result.setEngineerId(engineer.getId());
                result.setMatchingScore(score.getTotalScore());
                result.setScoreDetails(score.getCategoryScores());
                result.setCalculatedAt(LocalDateTime.now());
                result.setAlgorithm("BatchMatching-v1");
                
                return resultRepository.save(result);
            }, executorService))
            .toList();
        
        // 全ての計算が終わるのを待つ
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> futures.stream()
                .map(CompletableFuture::join)
                .collect(Collectors.toList()));
    }
    
    /**
     * 指定された技術者に対して一括マッチング計算を実行する
     * @param engineerId 技術者ID
     * @return マッチング結果のリスト
     */
    public CompletableFuture<List<MatchingResult>> calculateBatchMatchingForEngineer(UUID engineerId) {
        EngineerDTO engineer = engineerService.getEngineerById(engineerId);
        
        // 技術者のスキルに基づいて候補案件検索
        List<ProjectDTO> candidateProjects = projectService.findProjectsByEngineerSkills(
            engineer.getSkillIds()
        );
        
        // 並列処理でマッチング計算
        List<CompletableFuture<MatchingResult>> futures = candidateProjects.stream()
            .map(project -> CompletableFuture.supplyAsync(() -> {
                MatchingScore score = algorithmService.calculateMatchingScore(project, engineer);
                
                MatchingResult result = new MatchingResult();
                result.setProjectId(project.getId());
                result.setEngineerId(engineerId);
                result.setMatchingScore(score.getTotalScore());
                result.setScoreDetails(score.getCategoryScores());
                result.setCalculatedAt(LocalDateTime.now());
                result.setAlgorithm("BatchMatching-v1");
                
                return resultRepository.save(result);
            }, executorService))
            .toList();
        
        // 全ての計算が終わるのを待つ
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> futures.stream()
                .map(CompletableFuture::join)
                .collect(Collectors.toList()));
    }
}
```

### 9.2 スケジュールされたバッチ処理

```java
@Component
public class ScheduledMatchingTasks {

    private final BatchMatchingService batchMatchingService;
    private final ProjectService projectService;
    private final EngineerService engineerService;
    private final Logger logger = LoggerFactory.getLogger(ScheduledMatchingTasks.class);
    
    @Autowired
    public ScheduledMatchingTasks(BatchMatchingService batchMatchingService,
                                 ProjectService projectService,
                                 EngineerService engineerService) {
        this.batchMatchingService = batchMatchingService;
        this.projectService = projectService;
        this.engineerService = engineerService;
    }
    
    /**
     * 新規案件の一括マッチング計算を毎日午前3時に実行
     */
    @Scheduled(cron = "0 0 3 * * ?")
    public void calculateMatchingForNewProjects() {
        logger.info("Starting scheduled matching calculation for new projects");
        
        // 過去24時間以内に登録された案件を取得
        LocalDateTime yesterday = LocalDateTime.now().minusDays(1);
        List<ProjectDTO> newProjects = projectService.findProjectsCreatedAfter(yesterday);
        
        logger.info("Found {} new projects for matching calculation", newProjects.size());
        
        // 各案件に対してバッチマッチング実行
        for (ProjectDTO project : newProjects) {
            try {
                batchMatchingService.calculateBatchMatching(project.getId())
                    .thenAccept(results -> 
                        logger.info("Completed matching calculation for project {}, {} results", 
                                   project.getId(), results.size()));
            } catch (Exception e) {
                logger.error("Error during matching calculation for project {}: {}", 
                            project.getId(), e.getMessage(), e);
            }
        }
        
        logger.info("Completed scheduled matching calculation for new projects");
    }
    
    /**
     * 更新された技術者のマッチング再計算を毎週月曜日午前4時に実行
     */
    @Scheduled(cron = "0 0 4 ? * MON")
    public void recalculateMatchingForUpdatedEngineers() {
        logger.info("Starting scheduled matching recalculation for updated engineers");
        
        // 過去7日間に更新された技術者を取得
        LocalDateTime lastWeek = LocalDateTime.now().minusWeeks(1);
        List<EngineerDTO> updatedEngineers = engineerService.findEngineersUpdatedAfter(lastWeek);
        
        logger.info("Found {} updated engineers for matching recalculation", updatedEngineers.size());
        
        // 各技術者に対してバッチマッチング実行
        for (EngineerDTO engineer : updatedEngineers) {
            try {
                batchMatchingService.calculateBatchMatchingForEngineer(engineer.getId())
                    .thenAccept(results -> 
                        logger.info("Completed matching recalculation for engineer {}, {} results", 
                                   engineer.getId(), results.size()));
            } catch (Exception e) {
                logger.error("Error during matching recalculation for engineer {}: {}", 
                            engineer.getId(), e.getMessage(), e);
            }
        }
        
        logger.info("Completed scheduled matching recalculation for updated engineers");
    }
}
```

## 10. パフォーマンス最適化

### 10.1 マッチング結果キャッシュ

マッチング計算は比較的コストの高い処理のため、結果をキャッシュして再利用します。

```java
@Service
public class MatchingCacheService {
    private final Cache<UUID, MatchingResult> matchingCache;
    
    public MatchingCacheService() {
        // 有効期限1時間、最大10000エントリのキャッシュ
        this.matchingCache = Caffeine.newBuilder()
            .expireAfterWrite(1, TimeUnit.HOURS)
            .maximumSize(10000)
            .build();
    }
    
    public Optional<MatchingResult> getCachedResult(UUID projectId, UUID engineerId) {
        // プロジェクトID + エンジニアIDの複合キー
        UUID cacheKey = generateCacheKey(projectId, engineerId);
        return Optional.ofNullable(matchingCache.getIfPresent(cacheKey));
    }
    
    public void cacheResult(MatchingResult result) {
        UUID cacheKey = generateCacheKey(result.getProjectId(), result.getEngineerId());
        matchingCache.put(cacheKey, result);
    }
    
    public void invalidateCache(UUID projectId, UUID engineerId) {
        UUID cacheKey = generateCacheKey(projectId, engineerId);
        matchingCache.invalidate(cacheKey);
    }
    
    private UUID generateCacheKey(UUID projectId, UUID engineerId) {
        return UUID.nameUUIDFromBytes(
            (projectId.toString() + ":" + engineerId.toString()).getBytes()
        );
    }
}
```

### 10.2 最適化戦略

マッチングアルゴリズムの性能最適化のために採用している戦略：

1. **処理の分割と並列化**
   - 独立したマッチング計算を並列スレッドで実行
   - CompletableFuture による非同期処理

2. **事前フィルタリング**
   - データベースレベルでの候補絞り込み
   - 明らかにマッチしない組み合わせを除外

3. **インデックス最適化**
   - 検索クエリに対応したインデックスの設定
   - 複合インデックスの活用

4. **キャッシング戦略**
   - 計算コストの高い処理結果をキャッシュ
   - 適切なキャッシュ有効期限の設定

5. **バッチ処理の最適化**
   - 一度に処理する件数の制限
   - スケジュール調整による負荷分散

## 11. 将来的な拡張計画

### 11.1 機械学習モデルの統合

将来的には、過去のマッチングデータを学習した機械学習モデルの統合を検討します。

1. **教師データの準備**
   - 過去の成約/不成約データをラベル付け
   - 特徴量エンジニアリング

2. **モデル選定と学習**
   - 勾配ブースティング（XGBoost, LightGBM）
   - ランキング学習アルゴリズム
   - ディープラーニングモデル

3. **ハイブリッドアプローチ**
   - ルールベースアルゴリズムと機械学習モデルの組み合わせ
   - 説明可能性と予測精度のバランス

### 11.2 リアルタイムフィードバック

ユーザーのフィードバックをリアルタイムで取り入れる仕組みを導入します。

1. **フィードバックループ**
   - マッチング結果に対するフィードバック収集
   - フィードバックに基づくパラメータ自動調整

2. **パーソナライズ**
   - ユーザー（マッチング担当者）ごとの重み付け設定
   - 個人の傾向を学習した推奨

### 11.3 アルゴリズムバージョン管理

アルゴリズムの進化を管理するためのバージョン管理システムを導入します。

1. **バージョン管理**
   - アルゴリズムのバージョニング
   - 前のバージョンとの比較分析

2. **A/Bテスト基盤**
   - 複数アルゴリズムの同時運用
   - パフォーマンス評価システム