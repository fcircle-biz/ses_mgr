# 国際化機能 - フォーマット機能

## 1. 機能概要

フォーマット機能は、日付・時刻・数値・通貨などのデータをユーザーのロケール（言語と地域の組み合わせ）に応じた形式で表示するための機能です。異なる地域や言語環境でも自然な形式でデータを表示するために重要な役割を果たします。

主な責務は以下の通りです：

- ロケールに応じた日付・時刻のフォーマット
- ロケールに応じた数値・通貨のフォーマット
- カスタムフォーマットパターンの管理
- 文字列からのロケール対応パース機能
- フォーマットコンポーネントの提供

## 2. 日付・時刻フォーマット

### 2.1 フォーマットパターン定義

ロケールごとの日付・時刻フォーマットパターン：

| フォーマットタイプ | パターンID | ja-JP | en-US | en-GB |
|-----------------|------------|-------|-------|-------|
| 日付（標準） | date.default | yyyy/MM/dd | MM/dd/yyyy | dd/MM/yyyy |
| 日付（短） | date.short | yy/MM/dd | M/d/yy | dd/MM/yy |
| 日付（長） | date.long | yyyy年M月d日 | MMMM d, yyyy | d MMMM yyyy |
| 日付（曜日） | date.weekday | yyyy年M月d日(E) | EEEE, MMMM d, yyyy | EEEE, d MMMM yyyy |
| 時刻（標準） | time.default | HH:mm | h:mm a | HH:mm |
| 時刻（秒） | time.seconds | HH:mm:ss | h:mm:ss a | HH:mm:ss |
| 日時（標準） | datetime.default | yyyy/MM/dd HH:mm | MM/dd/yyyy h:mm a | dd/MM/yyyy HH:mm |
| 日時（長） | datetime.long | yyyy年M月d日 HH時mm分 | MMMM d, yyyy h:mm a | d MMMM yyyy HH:mm |
| 月年 | month.year | yyyy年M月 | MMMM yyyy | MMMM yyyy |

### 2.2 日付フォーマットの実装

#### バックエンド実装（Java）

```java
@Service
public class DateTimeFormatServiceImpl implements DateTimeFormatService {
    
    private final MessageSourceService messageSourceService;
    private final LocaleService localeService;
    private final CacheService cacheService;
    
    private static final String PATTERN_PREFIX = "format.";
    private static final String CACHE_NAME = "dateTimePatterns";
    
    @Autowired
    public DateTimeFormatServiceImpl(
            MessageSourceService messageSourceService,
            LocaleService localeService,
            CacheService cacheService) {
        this.messageSourceService = messageSourceService;
        this.localeService = localeService;
        this.cacheService = cacheService;
    }
    
    @Override
    public String formatDate(LocalDate date, String formatType, Locale locale) {
        if (date == null) {
            return "";
        }
        
        if (locale == null) {
            locale = localeService.getCurrentLocale();
        }
        
        String pattern = getFormatPattern(formatType, locale);
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern, locale);
        return date.format(formatter);
    }
    
    @Override
    public String formatTime(LocalTime time, String formatType, Locale locale) {
        if (time == null) {
            return "";
        }
        
        if (locale == null) {
            locale = localeService.getCurrentLocale();
        }
        
        String pattern = getFormatPattern(formatType, locale);
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern, locale);
        return time.format(formatter);
    }
    
    @Override
    public String formatDateTime(LocalDateTime dateTime, String formatType, Locale locale) {
        if (dateTime == null) {
            return "";
        }
        
        if (locale == null) {
            locale = localeService.getCurrentLocale();
        }
        
        String pattern = getFormatPattern(formatType, locale);
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern, locale);
        return dateTime.format(formatter);
    }
    
    @Override
    public String formatWithPattern(TemporalAccessor temporal, String pattern, Locale locale) {
        if (temporal == null) {
            return "";
        }
        
        if (locale == null) {
            locale = localeService.getCurrentLocale();
        }
        
        try {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern, locale);
            return formatter.format(temporal);
        } catch (DateTimeException e) {
            throw new IllegalPatternException("Invalid date time pattern: " + pattern, e);
        }
    }
    
    @Override
    public String getFormatPattern(String formatType, Locale locale) {
        if (locale == null) {
            locale = localeService.getCurrentLocale();
        }
        
        // キャッシュからパターンを取得
        String cacheKey = formatType + "_" + locale.toString();
        String cachedPattern = (String) cacheService.get(CACHE_NAME, cacheKey);
        
        if (cachedPattern != null) {
            return cachedPattern;
        }
        
        // メッセージリソースからパターンを取得
        String patternKey = PATTERN_PREFIX + formatType;
        String pattern = messageSourceService.getMessage(patternKey, null, locale);
        
        // キャッシュに格納
        cacheService.put(CACHE_NAME, cacheKey, pattern);
        
        return pattern;
    }
}
```

#### フロントエンド実装（TypeScript）

```typescript
// src/utils/DateTimeFormatter.ts
import { format, parse } from 'date-fns';
import { ja, enUS, enGB } from 'date-fns/locale';
import { useI18n } from '../i18n/useI18n';

type FormatType = 
  | 'date.default' 
  | 'date.short' 
  | 'date.long' 
  | 'date.weekday' 
  | 'time.default' 
  | 'time.seconds' 
  | 'datetime.default' 
  | 'datetime.long' 
  | 'month.year';

// ロケールに対応するdate-fnsロケール
const localeMap: Record<string, Locale> = {
  'ja-JP': ja,
  'en-US': enUS,
  'en-GB': enGB,
};

// パターンのマッピング
const patternMap: Record<string, Record<FormatType, string>> = {
  'ja-JP': {
    'date.default': 'yyyy/MM/dd',
    'date.short': 'yy/MM/dd',
    'date.long': 'yyyy年M月d日',
    'date.weekday': 'yyyy年M月d日(EEEE)',
    'time.default': 'HH:mm',
    'time.seconds': 'HH:mm:ss',
    'datetime.default': 'yyyy/MM/dd HH:mm',
    'datetime.long': 'yyyy年M月d日 HH時mm分',
    'month.year': 'yyyy年M月',
  },
  'en-US': {
    'date.default': 'MM/dd/yyyy',
    'date.short': 'M/d/yy',
    'date.long': 'MMMM d, yyyy',
    'date.weekday': 'EEEE, MMMM d, yyyy',
    'time.default': 'h:mm a',
    'time.seconds': 'h:mm:ss a',
    'datetime.default': 'MM/dd/yyyy h:mm a',
    'datetime.long': 'MMMM d, yyyy h:mm a',
    'month.year': 'MMMM yyyy',
  },
  'en-GB': {
    'date.default': 'dd/MM/yyyy',
    'date.short': 'dd/MM/yy',
    'date.long': 'd MMMM yyyy',
    'date.weekday': 'EEEE, d MMMM yyyy',
    'time.default': 'HH:mm',
    'time.seconds': 'HH:mm:ss',
    'datetime.default': 'dd/MM/yyyy HH:mm',
    'datetime.long': 'd MMMM yyyy HH:mm',
    'month.year': 'MMMM yyyy',
  },
};

export const useDateTimeFormatter = () => {
  const { getCurrentLanguage } = useI18n();
  const currentLocale = getCurrentLanguage();
  
  // ロケールに対応するdate-fnsロケール
  const getDateFnsLocale = (locale: string) => {
    return localeMap[locale] || localeMap['ja-JP'];
  };
  
  // フォーマットパターンを取得
  const getPattern = (formatType: FormatType, locale?: string) => {
    const targetLocale = locale || currentLocale;
    return patternMap[targetLocale]?.[formatType] || patternMap['ja-JP'][formatType];
  };
  
  // 日付のフォーマット
  const formatDate = (date: Date | string | null | undefined, formatType: FormatType) => {
    if (!date) return '';
    
    const dateObj = typeof date === 'string' ? new Date(date) : date;
    const pattern = getPattern(formatType);
    const locale = getDateFnsLocale(currentLocale);
    
    return format(dateObj, pattern, { locale });
  };
  
  // 文字列から日付へのパース
  const parseDate = (dateString: string, formatType: FormatType) => {
    const pattern = getPattern(formatType);
    const locale = getDateFnsLocale(currentLocale);
    
    return parse(dateString, pattern, new Date(), { locale });
  };
  
  return {
    formatDate,
    parseDate,
    getPattern,
  };
};
```

### 2.3 フォーマットコンポーネント

日付フォーマットコンポーネントの例：

```tsx
// src/components/DateFormatter.tsx
import React from 'react';
import { useDateTimeFormatter } from '../utils/DateTimeFormatter';

type DateFormatterProps = {
  value: Date | string | null | undefined;
  format?: 'default' | 'short' | 'long' | 'weekday';
  showTime?: boolean;
};

export const DateFormatter: React.FC<DateFormatterProps> = ({
  value,
  format = 'default',
  showTime = false,
}) => {
  const { formatDate } = useDateTimeFormatter();
  
  if (!value) {
    return null;
  }
  
  const formatType = showTime 
    ? `datetime.${format}` as const
    : `date.${format}` as const;
  
  return <span>{formatDate(value, formatType)}</span>;
};
```

## 3. 数値・通貨フォーマット

### 3.1 フォーマットパターン定義

ロケールごとの数値・通貨フォーマットパターン：

| フォーマットタイプ | パターンID | ja-JP | en-US | en-GB |
|-----------------|------------|-------|-------|-------|
| 整数（標準） | number.integer | #,##0 | #,##0 | #,##0 |
| 小数（標準） | number.decimal | #,##0.00 | #,##0.00 | #,##0.00 |
| 小数（最大2桁） | number.decimal2 | #,##0.## | #,##0.## | #,##0.## |
| 割合 | number.percent | #,##0% | #,##0% | #,##0% |
| 割合（小数点） | number.percentDecimal | #,##0.00% | #,##0.00% | #,##0.00% |
| 通貨（標準） | currency.default | ¤#,##0 | ¤#,##0.00 | ¤#,##0.00 |
| 通貨（千単位） | currency.thousands | ¤#,##0K | ¤#,##0.00K | ¤#,##0.00K |
| 通貨（百万単位） | currency.millions | ¤#,##0M | ¤#,##0.00M | ¤#,##0.00M |

### 3.2 数値フォーマットの実装

#### バックエンド実装（Java）

```java
@Service
public class NumberFormatServiceImpl implements NumberFormatService {
    
    private final MessageSourceService messageSourceService;
    private final LocaleService localeService;
    private final CacheService cacheService;
    
    private static final String PATTERN_PREFIX = "format.";
    private static final String CACHE_NAME = "numberPatterns";
    
    @Autowired
    public NumberFormatServiceImpl(
            MessageSourceService messageSourceService,
            LocaleService localeService,
            CacheService cacheService) {
        this.messageSourceService = messageSourceService;
        this.localeService = localeService;
        this.cacheService = cacheService;
    }
    
    @Override
    public String formatNumber(Number number, String formatType, Locale locale) {
        if (number == null) {
            return "";
        }
        
        if (locale == null) {
            locale = localeService.getCurrentLocale();
        }
        
        String pattern = getFormatPattern(formatType, locale);
        DecimalFormat formatter = (DecimalFormat) NumberFormat.getInstance(locale);
        formatter.applyPattern(pattern);
        
        return formatter.format(number);
    }
    
    @Override
    public String formatCurrency(Number amount, String formatType, String currencyCode, Locale locale) {
        if (amount == null) {
            return "";
        }
        
        if (locale == null) {
            locale = localeService.getCurrentLocale();
        }
        
        // 通貨単位の取得（省略時はロケールのデフォルト通貨）
        Currency currency;
        if (currencyCode != null && !currencyCode.isEmpty()) {
            try {
                currency = Currency.getInstance(currencyCode);
            } catch (IllegalArgumentException e) {
                currency = Currency.getInstance(locale);
            }
        } else {
            currency = Currency.getInstance(locale);
        }
        
        // 特殊単位（千、百万）の処理
        double scaledAmount = amount.doubleValue();
        String suffix = "";
        
        if ("currency.thousands".equals(formatType)) {
            scaledAmount /= 1000.0;
            suffix = "K";
        } else if ("currency.millions".equals(formatType)) {
            scaledAmount /= 1000000.0;
            suffix = "M";
        }
        
        // 通貨フォーマットの作成
        DecimalFormat formatter = (DecimalFormat) NumberFormat.getCurrencyInstance(locale);
        formatter.setCurrency(currency);
        
        String pattern = getFormatPattern(formatType, locale);
        formatter.applyPattern(pattern.replace("¤", formatter.getCurrency().getSymbol(locale)));
        
        return formatter.format(scaledAmount) + suffix;
    }
    
    @Override
    public String formatPercent(Number value, Locale locale) {
        if (value == null) {
            return "";
        }
        
        if (locale == null) {
            locale = localeService.getCurrentLocale();
        }
        
        String pattern = getFormatPattern("number.percent", locale);
        DecimalFormat formatter = (DecimalFormat) NumberFormat.getPercentInstance(locale);
        formatter.applyPattern(pattern);
        
        return formatter.format(value);
    }
    
    @Override
    public Number parseNumber(String text, Locale locale) throws ParseException {
        if (text == null || text.trim().isEmpty()) {
            return null;
        }
        
        if (locale == null) {
            locale = localeService.getCurrentLocale();
        }
        
        NumberFormat parser = NumberFormat.getInstance(locale);
        return parser.parse(text);
    }
    
    @Override
    public String getCurrencySymbol(String currencyCode, Locale locale) {
        if (locale == null) {
            locale = localeService.getCurrentLocale();
        }
        
        Currency currency;
        if (currencyCode != null && !currencyCode.isEmpty()) {
            try {
                currency = Currency.getInstance(currencyCode);
            } catch (IllegalArgumentException e) {
                currency = Currency.getInstance(locale);
            }
        } else {
            currency = Currency.getInstance(locale);
        }
        
        return currency.getSymbol(locale);
    }
    
    @Override
    public String getFormatPattern(String formatType, Locale locale) {
        if (locale == null) {
            locale = localeService.getCurrentLocale();
        }
        
        // キャッシュからパターンを取得
        String cacheKey = formatType + "_" + locale.toString();
        String cachedPattern = (String) cacheService.get(CACHE_NAME, cacheKey);
        
        if (cachedPattern != null) {
            return cachedPattern;
        }
        
        // メッセージリソースからパターンを取得
        String patternKey = PATTERN_PREFIX + formatType;
        String pattern = messageSourceService.getMessage(patternKey, null, locale);
        
        // キャッシュに格納
        cacheService.put(CACHE_NAME, cacheKey, pattern);
        
        return pattern;
    }
}
```

#### フロントエンド実装（TypeScript）

```typescript
// src/utils/NumberFormatter.ts
import { useI18n } from '../i18n/useI18n';

// パターンのマッピング（Intl.NumberFormatで使用するためのオプション）
const formatOptionsMap: Record<string, Record<string, Intl.NumberFormatOptions>> = {
  'ja-JP': {
    'number.integer': { style: 'decimal', maximumFractionDigits: 0 },
    'number.decimal': { style: 'decimal', minimumFractionDigits: 2, maximumFractionDigits: 2 },
    'number.decimal2': { style: 'decimal', maximumFractionDigits: 2 },
    'number.percent': { style: 'percent', maximumFractionDigits: 0 },
    'number.percentDecimal': { style: 'percent', minimumFractionDigits: 2, maximumFractionDigits: 2 },
    'currency.default': { style: 'currency', currency: 'JPY', currencyDisplay: 'symbol' },
    'currency.thousands': { style: 'currency', currency: 'JPY', currencyDisplay: 'symbol', maximumFractionDigits: 0 },
    'currency.millions': { style: 'currency', currency: 'JPY', currencyDisplay: 'symbol', maximumFractionDigits: 0 },
  },
  'en-US': {
    'number.integer': { style: 'decimal', maximumFractionDigits: 0 },
    'number.decimal': { style: 'decimal', minimumFractionDigits: 2, maximumFractionDigits: 2 },
    'number.decimal2': { style: 'decimal', maximumFractionDigits: 2 },
    'number.percent': { style: 'percent', maximumFractionDigits: 0 },
    'number.percentDecimal': { style: 'percent', minimumFractionDigits: 2, maximumFractionDigits: 2 },
    'currency.default': { style: 'currency', currency: 'USD', currencyDisplay: 'symbol' },
    'currency.thousands': { style: 'currency', currency: 'USD', currencyDisplay: 'symbol', maximumFractionDigits: 2 },
    'currency.millions': { style: 'currency', currency: 'USD', currencyDisplay: 'symbol', maximumFractionDigits: 2 },
  },
  'en-GB': {
    'number.integer': { style: 'decimal', maximumFractionDigits: 0 },
    'number.decimal': { style: 'decimal', minimumFractionDigits: 2, maximumFractionDigits: 2 },
    'number.decimal2': { style: 'decimal', maximumFractionDigits: 2 },
    'number.percent': { style: 'percent', maximumFractionDigits: 0 },
    'number.percentDecimal': { style: 'percent', minimumFractionDigits: 2, maximumFractionDigits: 2 },
    'currency.default': { style: 'currency', currency: 'GBP', currencyDisplay: 'symbol' },
    'currency.thousands': { style: 'currency', currency: 'GBP', currencyDisplay: 'symbol', maximumFractionDigits: 2 },
    'currency.millions': { style: 'currency', currency: 'GBP', currencyDisplay: 'symbol', maximumFractionDigits: 2 },
  },
};

export const useNumberFormatter = () => {
  const { getCurrentLanguage } = useI18n();
  const currentLocale = getCurrentLanguage();
  
  // フォーマットオプションを取得
  const getFormatOptions = (formatType: string, locale?: string) => {
    const targetLocale = locale || currentLocale;
    return formatOptionsMap[targetLocale]?.[formatType] || formatOptionsMap['ja-JP'][formatType];
  };
  
  // 数値のフォーマット
  const formatNumber = (value: number | null | undefined, formatType: string, locale?: string) => {
    if (value === null || value === undefined) return '';
    
    const options = getFormatOptions(formatType, locale);
    const localeName = locale || currentLocale;
    
    // 特殊単位（千、百万）の処理
    let scaledValue = value;
    let suffix = '';
    
    if (formatType === 'currency.thousands') {
      scaledValue = value / 1000;
      suffix = 'K';
    } else if (formatType === 'currency.millions') {
      scaledValue = value / 1000000;
      suffix = 'M';
    }
    
    return new Intl.NumberFormat(localeName, options).format(scaledValue) + suffix;
  };
  
  // 通貨のフォーマット
  const formatCurrency = (
    value: number | null | undefined, 
    formatType: string = 'currency.default', 
    currencyCode?: string,
    locale?: string
  ) => {
    if (value === null || value === undefined) return '';
    
    const options = { ...getFormatOptions(formatType, locale) };
    const localeName = locale || currentLocale;
    
    // 通貨コードの上書き
    if (currencyCode) {
      options.currency = currencyCode;
    }
    
    // 特殊単位（千、百万）の処理
    let scaledValue = value;
    let suffix = '';
    
    if (formatType === 'currency.thousands') {
      scaledValue = value / 1000;
      suffix = 'K';
    } else if (formatType === 'currency.millions') {
      scaledValue = value / 1000000;
      suffix = 'M';
    }
    
    return new Intl.NumberFormat(localeName, options).format(scaledValue) + suffix;
  };
  
  // パーセントのフォーマット
  const formatPercent = (value: number | null | undefined, decimal: boolean = false, locale?: string) => {
    if (value === null || value === undefined) return '';
    
    const formatType = decimal ? 'number.percentDecimal' : 'number.percent';
    const options = getFormatOptions(formatType, locale);
    const localeName = locale || currentLocale;
    
    return new Intl.NumberFormat(localeName, options).format(value);
  };
  
  // 文字列から数値へのパース
  const parseNumber = (text: string, locale?: string) => {
    if (!text) return null;
    
    // 通貨記号と桁区切りを除去してパース
    const localeName = locale || currentLocale;
    const parts = new Intl.NumberFormat(localeName).formatToParts(1234.5);
    let group = ',';
    let decimal = '.';
    
    for (const part of parts) {
      if (part.type === 'group') {
        group = part.value;
      } else if (part.type === 'decimal') {
        decimal = part.value;
      }
    }
    
    // 通貨記号、単位記号などを除去
    const cleanText = text.replace(/[^\d\-+.,]/g, '')
      .replace(new RegExp('\\' + group, 'g'), '')
      .replace(new RegExp('\\' + decimal), '.');
    
    return parseFloat(cleanText);
  };
  
  return {
    formatNumber,
    formatCurrency,
    formatPercent,
    parseNumber,
  };
};
```

### 3.3 フォーマットコンポーネント

数値・通貨フォーマットコンポーネントの例：

```tsx
// src/components/CurrencyFormatter.tsx
import React from 'react';
import { useNumberFormatter } from '../utils/NumberFormatter';

type CurrencyFormatterProps = {
  value: number | null | undefined;
  format?: 'default' | 'thousands' | 'millions';
  currency?: string;
};

export const CurrencyFormatter: React.FC<CurrencyFormatterProps> = ({
  value,
  format = 'default',
  currency,
}) => {
  const { formatCurrency } = useNumberFormatter();
  
  if (value === null || value === undefined) {
    return null;
  }
  
  const formatType = `currency.${format}` as const;
  
  return <span>{formatCurrency(value, formatType, currency)}</span>;
};

// src/components/NumberFormatter.tsx
import React from 'react';
import { useNumberFormatter } from '../utils/NumberFormatter';

type NumberFormatterProps = {
  value: number | null | undefined;
  format?: 'integer' | 'decimal' | 'decimal2';
};

export const NumberFormatter: React.FC<NumberFormatterProps> = ({
  value,
  format = 'decimal',
}) => {
  const { formatNumber } = useNumberFormatter();
  
  if (value === null || value === undefined) {
    return null;
  }
  
  const formatType = `number.${format}` as const;
  
  return <span>{formatNumber(value, formatType)}</span>;
};

// src/components/PercentFormatter.tsx
import React from 'react';
import { useNumberFormatter } from '../utils/NumberFormatter';

type PercentFormatterProps = {
  value: number | null | undefined;
  decimal?: boolean;
};

export const PercentFormatter: React.FC<PercentFormatterProps> = ({
  value,
  decimal = false,
}) => {
  const { formatPercent } = useNumberFormatter();
  
  if (value === null || value === undefined) {
    return null;
  }
  
  return <span>{formatPercent(value, decimal)}</span>;
};
```

## 4. 入力コンポーネント

### 4.1 日付入力コンポーネント

ロケール対応の日付入力コンポーネント：

```tsx
// src/components/DateInput.tsx
import React, { useState, useEffect } from 'react';
import { useDateTimeFormatter } from '../utils/DateTimeFormatter';
import { useI18n } from '../i18n/useI18n';

type DateInputProps = {
  value: Date | string | null | undefined;
  onChange: (date: Date | null) => void;
  format?: 'default' | 'short';
  placeholder?: string;
  disabled?: boolean;
  required?: boolean;
  min?: Date | string;
  max?: Date | string;
};

export const DateInput: React.FC<DateInputProps> = ({
  value,
  onChange,
  format = 'default',
  placeholder,
  disabled = false,
  required = false,
  min,
  max,
}) => {
  const { formatDate, parseDate, getPattern } = useDateTimeFormatter();
  const { t } = useI18n();
  const [inputValue, setInputValue] = useState('');
  const [error, setError] = useState('');
  
  // 入力値のフォーマット
  const formatInputValue = (date: Date | string | null | undefined) => {
    if (!date) return '';
    return formatDate(date, `date.${format}` as const);
  };
  
  // 初期値設定
  useEffect(() => {
    setInputValue(formatInputValue(value));
  }, [value, format]);
  
  // プレースホルダーテキスト
  const placeholderText = placeholder || getPattern(`date.${format}` as const);
  
  // 変更ハンドラ
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;
    setInputValue(newValue);
    
    if (!newValue) {
      onChange(null);
      setError('');
      return;
    }
    
    try {
      // 入力値を日付に変換
      const date = parseDate(newValue, `date.${format}` as const);
      
      // 日付の範囲チェック
      if (min && date < new Date(min)) {
        setError(t('validation.date.min', { min: formatInputValue(min) }));
        return;
      }
      
      if (max && date > new Date(max)) {
        setError(t('validation.date.max', { max: formatInputValue(max) }));
        return;
      }
      
      setError('');
      onChange(date);
    } catch (err) {
      setError(t('validation.date.invalid'));
    }
  };
  
  return (
    <div className="date-input">
      <input
        type="text"
        value={inputValue}
        onChange={handleChange}
        placeholder={placeholderText}
        disabled={disabled}
        required={required}
        aria-invalid={!!error}
        aria-describedby={error ? 'date-input-error' : undefined}
      />
      {error && (
        <div id="date-input-error" className="input-error">
          {error}
        </div>
      )}
    </div>
  );
};
```

### 4.2 数値入力コンポーネント

ロケール対応の数値入力コンポーネント：

```tsx
// src/components/NumberInput.tsx
import React, { useState, useEffect } from 'react';
import { useNumberFormatter } from '../utils/NumberFormatter';
import { useI18n } from '../i18n/useI18n';

type NumberInputProps = {
  value: number | null | undefined;
  onChange: (value: number | null) => void;
  format?: 'integer' | 'decimal' | 'decimal2';
  placeholder?: string;
  disabled?: boolean;
  required?: boolean;
  min?: number;
  max?: number;
  step?: number;
};

export const NumberInput: React.FC<NumberInputProps> = ({
  value,
  onChange,
  format = 'decimal',
  placeholder,
  disabled = false,
  required = false,
  min,
  max,
  step,
}) => {
  const { formatNumber, parseNumber } = useNumberFormatter();
  const { t } = useI18n();
  const [inputValue, setInputValue] = useState('');
  const [error, setError] = useState('');
  
  // 入力値のフォーマット
  const formatInputValue = (num: number | null | undefined) => {
    if (num === null || num === undefined) return '';
    return formatNumber(num, `number.${format}` as const);
  };
  
  // 初期値設定
  useEffect(() => {
    setInputValue(formatInputValue(value));
  }, [value, format]);
  
  // 変更ハンドラ
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;
    setInputValue(newValue);
    
    if (!newValue) {
      onChange(null);
      setError('');
      return;
    }
    
    try {
      // 入力値を数値に変換
      const number = parseNumber(newValue);
      
      if (number === null) {
        setError(t('validation.number.invalid'));
        return;
      }
      
      // 数値の範囲チェック
      if (min !== undefined && number < min) {
        setError(t('validation.number.min', { min }));
        return;
      }
      
      if (max !== undefined && number > max) {
        setError(t('validation.number.max', { max }));
        return;
      }
      
      setError('');
      onChange(number);
    } catch (err) {
      setError(t('validation.number.invalid'));
    }
  };
  
  // フォーカスを失ったときに再フォーマット
  const handleBlur = () => {
    if (value !== null && value !== undefined) {
      setInputValue(formatInputValue(value));
    }
  };
  
  return (
    <div className="number-input">
      <input
        type="text"
        inputMode="decimal"
        value={inputValue}
        onChange={handleChange}
        onBlur={handleBlur}
        placeholder={placeholder}
        disabled={disabled}
        required={required}
        step={step}
        aria-invalid={!!error}
        aria-describedby={error ? 'number-input-error' : undefined}
      />
      {error && (
        <div id="number-input-error" className="input-error">
          {error}
        </div>
      )}
    </div>
  );
};
```

## 5. フォーマット実装の最適化

### 5.1 パフォーマンス最適化

フォーマット処理のパフォーマンス最適化：

1. **パターンキャッシング**
   - フォーマットパターンのキャッシュ
   - フォーマッタインスタンスの再利用
   - メモ化によるフォーマット結果のキャッシュ

2. **遅延ロード**
   - 必要なロケールデータのみ動的ロード
   - 使用頻度の低いフォーマットは必要時にのみロード

3. **バッチ処理**
   - 複数のフォーマット処理をまとめて実行
   - レンダリングの最適化（メモ化コンポーネント）

### 5.2 メモリ使用量の最適化

メモリ使用量の最適化：

1. **リソース共有**
   - ロケールデータの共有
   - フォーマッタインスタンスの共有

2. **部分ロード**
   - 必要な部分のみをロード（例：すべてのロケールではなく使用中のロケールのみ）
   - フォーマットパターンの分割ロード

3. **キャッシュサイズ制限**
   - キャッシュサイズの上限設定
   - LRU（Least Recently Used）ポリシーの採用

### 5.3 フォールバック戦略

フォーマット処理のフォールバック戦略：

1. **ロケールフォールバック**
   - 指定されたロケールが使用できない場合、言語のみのロケールにフォールバック
   - 言語のみのロケールも使用できない場合、デフォルトロケール（ja-JP）にフォールバック

2. **パターンフォールバック**
   - 指定されたパターンが使用できない場合、デフォルトパターンにフォールバック
   - パターン解析エラーの場合、基本フォーマットを使用

3. **入力値フォールバック**
   - 無効または変換不可能な入力値の場合、デフォルト値または空文字列を表示
   - 例外のスローではなく、エラー状態として取り扱い

## 6. テストと検証

### 6.1 単体テスト

フォーマット機能の単体テスト：

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class DateTimeFormatServiceTest {
    
    @Autowired
    private DateTimeFormatService formatService;
    
    @Test
    public void testJapaneseDateFormat() {
        LocalDate date = LocalDate.of(2025, 5, 10);
        Locale jaLocale = Locale.JAPANESE;
        
        assertEquals("2025/05/10", formatService.formatDate(date, "date.default", jaLocale));
        assertEquals("2025年5月10日", formatService.formatDate(date, "date.long", jaLocale));
    }
    
    @Test
    public void testAmericanDateFormat() {
        LocalDate date = LocalDate.of(2025, 5, 10);
        Locale usLocale = Locale.US;
        
        assertEquals("05/10/2025", formatService.formatDate(date, "date.default", usLocale));
        assertEquals("May 10, 2025", formatService.formatDate(date, "date.long", usLocale));
    }
    
    @Test
    public void testJapaneseNumberFormat() {
        BigDecimal number = new BigDecimal("1234.56");
        Locale jaLocale = Locale.JAPANESE;
        
        assertEquals("1,235", formatService.formatNumber(number, "number.integer", jaLocale));
        assertEquals("1,234.56", formatService.formatNumber(number, "number.decimal", jaLocale));
    }
    
    @Test
    public void testJapaneseCurrencyFormat() {
        BigDecimal amount = new BigDecimal("1234.56");
        Locale jaLocale = Locale.JAPANESE;
        
        assertEquals("¥1,235", formatService.formatCurrency(amount, "currency.default", "JPY", jaLocale));
        assertEquals("$1,234.56", formatService.formatCurrency(amount, "currency.default", "USD", jaLocale));
    }
}
```

### 6.2 統合テスト

フォーマット機能の統合テスト：

```java
@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
public class FormatIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Test
    public void testJapaneseLocaleFormat() throws Exception {
        mockMvc.perform(get("/api/v1/format/date")
                .param("date", "2025-05-10")
                .param("type", "default")
                .header("Accept-Language", "ja-JP"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.formatted").value("2025/05/10"));
    }
    
    @Test
    public void testAmericanLocaleFormat() throws Exception {
        mockMvc.perform(get("/api/v1/format/date")
                .param("date", "2025-05-10")
                .param("type", "default")
                .header("Accept-Language", "en-US"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.formatted").value("05/10/2025"));
    }
    
    @Test
    public void testJapaneseLocaleNumber() throws Exception {
        mockMvc.perform(get("/api/v1/format/number")
                .param("value", "1234.56")
                .param("type", "currency.default")
                .header("Accept-Language", "ja-JP"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.formatted").value("¥1,235"));
    }
}
```

### 6.3 クロスブラウザテスト

フォーマット機能のクロスブラウザテスト：

```javascript
describe('Format Component Tests', () => {
  beforeEach(() => {
    // 言語設定を日本語にリセット
    i18n.changeLanguage('ja-JP');
  });
  
  it('should format dates correctly in Japanese locale', () => {
    const { getByText } = render(
      <DateFormatter value={new Date('2025-05-10')} format="default" />
    );
    
    expect(getByText('2025/05/10')).toBeInTheDocument();
  });
  
  it('should format dates correctly in US locale', () => {
    i18n.changeLanguage('en-US');
    
    const { getByText } = render(
      <DateFormatter value={new Date('2025-05-10')} format="default" />
    );
    
    expect(getByText('05/10/2025')).toBeInTheDocument();
  });
  
  it('should format currency correctly in Japanese locale', () => {
    const { getByText } = render(
      <CurrencyFormatter value={1234.56} format="default" />
    );
    
    expect(getByText('¥1,235')).toBeInTheDocument();
  });
  
  it('should format currency correctly in US locale', () => {
    i18n.changeLanguage('en-US');
    
    const { getByText } = render(
      <CurrencyFormatter value={1234.56} format="default" />
    );
    
    expect(getByText('$1,234.56')).toBeInTheDocument();
  });
});