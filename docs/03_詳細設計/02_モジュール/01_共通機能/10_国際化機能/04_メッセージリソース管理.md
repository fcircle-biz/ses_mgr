# 国際化機能 - メッセージリソース管理

## 1. 機能概要

メッセージリソース管理機能は、システム全体の多言語対応テキストを一元管理する機能です。画面表示テキスト、エラーメッセージ、ヘルプテキストなど、ユーザーに表示されるすべてのテキストを言語ごとにプロパティファイルやJSONファイルに格納し、アプリケーションコードから分離します。

主な責務は以下の通りです：

- メッセージリソースファイルの構成と管理
- メッセージキーによるメッセージの解決
- パラメータ置換機能の提供
- リソースの動的読み込みとキャッシング
- プログラムからのメッセージ参照を簡素化するAPI提供

## 2. リソースバンドル設計

### 2.1 ファイル構成

#### バックエンド用プロパティファイル構成

```
src/main/resources/
  ├── i18n/
      ├── common/
      │   ├── common_ja.properties     # 共通メッセージ（日本語）
      │   └── common_en.properties     # 共通メッセージ（英語）
      ├── validation/
      │   ├── validation_ja.properties # 検証メッセージ（日本語）
      │   └── validation_en.properties # 検証メッセージ（英語）
      ├── error/
      │   ├── error_ja.properties      # エラーメッセージ（日本語）
      │   └── error_en.properties      # エラーメッセージ（英語）
      ├── domain/
      │   ├── project/
      │   │   ├── project_ja.properties  # 案件管理メッセージ（日本語）
      │   │   └── project_en.properties  # 案件管理メッセージ（英語）
      │   ├── engineer/
      │   │   ├── engineer_ja.properties # 技術者管理メッセージ（日本語）
      │   │   └── engineer_en.properties # 技術者管理メッセージ（英語）
      │   └── ...
```

#### フロントエンド用JSONファイル構成

```
src/i18n/
  ├── locales/
  │   ├── ja/
  │   │   ├── common.json       # 共通メッセージ（日本語）
  │   │   ├── validation.json   # 検証メッセージ（日本語）
  │   │   ├── project.json      # 案件管理メッセージ（日本語）
  │   │   ├── engineer.json     # 技術者管理メッセージ（日本語）
  │   │   └── ...
  │   ├── en/
  │   │   ├── common.json       # 共通メッセージ（英語）
  │   │   ├── validation.json   # 検証メッセージ（英語）
  │   │   ├── project.json      # 案件管理メッセージ（英語）
  │   │   ├── engineer.json     # 技術者管理メッセージ（英語）
  │   │   └── ...
  ├── config.ts                 # i18n設定ファイル
  └── index.ts                  # i18n機能のエクスポート
```

### 2.2 メッセージカテゴリ

メッセージは以下のカテゴリに分類されます：

| カテゴリ     | 説明                                         | プレフィックス |
|------------|----------------------------------------------|--------------|
| 共通       | 共通のボタン名、ラベル、メニュー項目など        | common.      |
| 検証       | 入力検証エラーメッセージ                      | validation.  |
| エラー     | システムエラーメッセージ                      | error.       |
| ドメイン   | 業務ドメイン固有のメッセージ                  | {domain}.    |

### 2.3 メッセージキー命名規則

メッセージキーは階層構造を持ち、以下の規則に従って命名します：

```
[カテゴリ].[要素タイプ].[要素名].[詳細]
```

#### 命名規則の例

```
# 共通メッセージの例
common.button.save = 保存
common.button.cancel = キャンセル
common.label.id = ID
common.label.name = 名前
common.placeholder.search = 検索...

# 検証メッセージの例
validation.required = {0}は必須です
validation.maxLength = {0}は{1}文字以内で入力してください
validation.pattern.email = メールアドレスの形式が正しくありません

# エラーメッセージの例
error.notFound = {0}が見つかりません
error.alreadyExists = {0}は既に存在します
error.system = システムエラーが発生しました。管理者に連絡してください。

# ドメイン固有メッセージの例
project.label.projectName = 案件名
project.label.startDate = 開始日
project.status.active = 進行中
project.status.completed = 完了
```

## 3. メッセージ解決の実装

### 3.1 メッセージソース設定

Springのメッセージソース設定例：

```java
@Configuration
public class MessageSourceConfig {
    
    @Bean
    public MessageSource messageSource() {
        ReloadableResourceBundleMessageSource messageSource = 
            new ReloadableResourceBundleMessageSource();
        
        // リソースバンドルの基本名設定
        messageSource.setBasenames(
            "classpath:i18n/common/common",
            "classpath:i18n/validation/validation",
            "classpath:i18n/error/error",
            "classpath:i18n/domain/project/project",
            "classpath:i18n/domain/engineer/engineer"
            // 他のリソースバンドル
        );
        
        // デフォルトエンコーディング設定
        messageSource.setDefaultEncoding("UTF-8");
        
        // 開発環境ではキャッシュを無効化（本番環境では有効化）
        messageSource.setCacheSeconds(
            isDevEnvironment() ? -1 : 3600 // 1時間キャッシュ
        );
        
        // メッセージが見つからない場合はキーをそのまま返す
        messageSource.setUseCodeAsDefaultMessage(true);
        
        return messageSource;
    }
    
    @Bean
    public MessageSourceAccessor messageSourceAccessor(MessageSource messageSource) {
        return new MessageSourceAccessor(messageSource, Locale.JAPANESE);
    }
    
    @Bean
    public LocalValidatorFactoryBean validator() {
        LocalValidatorFactoryBean bean = new LocalValidatorFactoryBean();
        bean.setValidationMessageSource(messageSource());
        return bean;
    }
}
```

### 3.2 メッセージサービス実装

メッセージ解決サービスの実装例：

```java
@Service
public class MessageSourceServiceImpl implements MessageSourceService {
    
    private final MessageSource messageSource;
    private final LocaleService localeService;
    
    @Autowired
    public MessageSourceServiceImpl(MessageSource messageSource, LocaleService localeService) {
        this.messageSource = messageSource;
        this.localeService = localeService;
    }
    
    @Override
    public String getMessage(String key, Object[] args, Locale locale) {
        if (locale == null) {
            locale = localeService.getCurrentLocale();
        }
        
        try {
            return messageSource.getMessage(key, args, locale);
        } catch (NoSuchMessageException e) {
            // フォールバックロケールで再試行
            if (!locale.equals(Locale.JAPANESE)) {
                return messageSource.getMessage(key, args, Locale.JAPANESE);
            }
            throw e;
        }
    }
    
    @Override
    public String getMessage(String key, Object[] args) {
        return getMessage(key, args, null);
    }
    
    @Override
    public String getMessage(String key) {
        return getMessage(key, null, null);
    }
    
    @Override
    public Map<String, String> getAllMessages(String namespace, Locale locale) {
        if (locale == null) {
            locale = localeService.getCurrentLocale();
        }
        
        Map<String, String> messages = new HashMap<>();
        
        // プロパティファイルからメッセージを取得する処理
        // このサンプルでは簡略化しています
        
        return messages;
    }
    
    @Override
    public boolean hasMessage(String key, Locale locale) {
        if (locale == null) {
            locale = localeService.getCurrentLocale();
        }
        
        try {
            messageSource.getMessage(key, null, locale);
            return true;
        } catch (NoSuchMessageException e) {
            return false;
        }
    }
    
    @Override
    public void reloadMessages() {
        if (messageSource instanceof ReloadableResourceBundleMessageSource) {
            ((ReloadableResourceBundleMessageSource) messageSource).clearCache();
        }
    }
}
```

### 3.3 パラメータ置換

メッセージ内のパラメータ置換機能の実装例：

#### バックエンド（Spring）

```java
// プロパティファイル内の定義
project.validation.dateRange = {0}は{1}より前の日付を指定してください

// Java内での使用例
String message = messageService.getMessage(
    "project.validation.dateRange", 
    new Object[]{"開始日", "終了日"}
);
// 結果: "開始日は終了日より前の日付を指定してください"
```

#### フロントエンド（i18next）

```javascript
// JSONファイル内の定義
{
  "project": {
    "validation": {
      "dateRange": "{{startDate}}は{{endDate}}より前の日付を指定してください"
    }
  }
}

// JavaScript内での使用例
const message = t('project.validation.dateRange', {
  startDate: '開始日',
  endDate: '終了日'
});
// 結果: "開始日は終了日より前の日付を指定してください"
```

## 4. メッセージのフロントエンド統合

### 4.1 i18next設定

フロントエンドでのi18next設定例：

```typescript
// src/i18n/config.ts
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import Backend from 'i18next-http-backend';
import LanguageDetector from 'i18next-browser-languagedetector';

// 言語リソースの事前ロード
import commonJa from './locales/ja/common.json';
import commonEn from './locales/en/common.json';

// 言語リソースをまとめる
const resources = {
  ja: {
    common: commonJa,
    // 他のリソースは動的にロード
  },
  en: {
    common: commonEn,
    // 他のリソースは動的にロード
  }
};

i18n
  // HTTP通信でリソースを取得するプラグイン
  .use(Backend)
  // ブラウザの言語を検出するプラグイン
  .use(LanguageDetector)
  // Reactと統合するプラグイン
  .use(initReactI18next)
  // 初期化
  .init({
    // 事前ロードしたリソース
    resources,
    // デフォルト言語
    lng: 'ja',
    // フォールバック言語
    fallbackLng: 'ja',
    // 名前空間
    ns: ['common'],
    // デフォルト名前空間
    defaultNS: 'common',
    // プロパティへの深いアクセスを許可
    keySeparator: '.',
    // 変数補間の設定
    interpolation: {
      escapeValue: false, // Reactの場合はエスケープ不要
      formatSeparator: ',',
    },
    // バックエンドプラグインの設定
    backend: {
      // リソースを取得するURL
      loadPath: '/i18n/{{lng}}/{{ns}}.json',
    },
    // 言語検出の設定
    detection: {
      // 検出順序
      order: ['querystring', 'cookie', 'localStorage', 'navigator'],
      // クエリストリングのパラメータ名
      lookupQuerystring: 'lng',
      // Cookieの名前
      lookupCookie: 'i18n_lang',
      // LocalStorageのキー
      lookupLocalStorage: 'i18n_lang',
      // Cookieの有効期限（日数）
      cookieExpirationDate: 365,
      // キャッシュに使用する場所
      caches: ['localStorage', 'cookie'],
    },
  });

export default i18n;
```

### 4.2 i18n Hooks

フロントエンドでの翻訳フックの実装例：

```typescript
// src/i18n/useI18n.ts
import { useTranslation } from 'react-i18next';
import { useCallback } from 'react';

export const useI18n = () => {
  const { t, i18n } = useTranslation();
  
  // 翻訳関数
  const translate = useCallback((key: string, params?: Record<string, any>) => {
    return t(key, params);
  }, [t]);
  
  // 言語切り替え関数
  const changeLanguage = useCallback((language: string) => {
    return i18n.changeLanguage(language);
  }, [i18n]);
  
  // 現在の言語を取得
  const getCurrentLanguage = useCallback(() => {
    return i18n.language;
  }, [i18n]);
  
  // サポートされている言語を取得
  const getSupportedLanguages = useCallback(() => {
    return [
      { code: 'ja', name: '日本語' },
      { code: 'en', name: 'English' }
    ];
  }, []);
  
  return {
    t: translate,
    changeLanguage,
    getCurrentLanguage,
    getSupportedLanguages
  };
};
```

### 4.3 言語切り替えコンポーネント

言語切り替えドロップダウンの実装例：

```tsx
// src/components/LanguageSwitcher.tsx
import React from 'react';
import { useI18n } from '../i18n/useI18n';

export const LanguageSwitcher: React.FC = () => {
  const { t, changeLanguage, getCurrentLanguage, getSupportedLanguages } = useI18n();
  
  const handleChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    changeLanguage(e.target.value);
  };
  
  const currentLanguage = getCurrentLanguage();
  const languages = getSupportedLanguages();
  
  return (
    <div className="language-switcher">
      <select 
        value={currentLanguage} 
        onChange={handleChange} 
        aria-label={t('common.accessibility.languageSelector')}
      >
        {languages.map(lang => (
          <option key={lang.code} value={lang.code}>
            {lang.name}
          </option>
        ))}
      </select>
    </div>
  );
};
```

## 5. メッセージリソース管理の最適化

### 5.1 キャッシング戦略

メッセージリソースのキャッシング戦略：

1. **サーバーサイドキャッシング**
   - 開発環境: キャッシュなし（即時反映）
   - テスト環境: 5分間キャッシュ
   - 本番環境: 1時間キャッシュ

2. **クライアントサイドキャッシング**
   - 初回ロード時に共通リソースを事前ロード
   - 残りのリソースは必要に応じて動的ロード
   - LocalStorageでリソースをキャッシュ
   - アプリケーションバージョン変更時にキャッシュ無効化

### 5.2 リソース分割戦略

メッセージリソースの分割戦略：

1. **モジュール別分割**
   - 共通モジュール（全画面で使用）
   - ドメイン別モジュール（特定機能でのみ使用）

2. **ロード戦略**
   - 初期ロード: 共通メッセージのみロード
   - 遅延ロード: 必要なドメイン別メッセージを動的ロード
   - プリロード: ユーザーが直後に必要とするメッセージを事前ロード

### 5.3 デフォルト言語とフォールバック

デフォルト言語とフォールバック戦略：

1. **デフォルト言語**
   - システムのデフォルト言語: 日本語（ja）
   - リソースバンドルのデフォルト: 日本語（ja）

2. **フォールバック順序**
   - 要求されたロケール完全一致（例: ja_JP）
   - 言語のみ一致（例: ja）
   - デフォルト言語（ja）
   - メッセージキーそのもの

## 6. メッセージリソース管理の運用

### 6.1 リソース管理ワークフロー

メッセージリソース管理の運用ワークフロー：

1. **リソース追加**
   - 新機能開発時に、すべての対応言語でリソースを同時追加
   - プルリクエストにリソース追加を含める
   - リソースキーの命名規則遵守を確認

2. **リソース更新**
   - 文言変更時は、全言語版を同時に更新
   - 未翻訳のリソースは「TODO: Translate」などのマーカーを付与
   - 翻訳作業を別チケットとして管理

3. **品質管理**
   - 未翻訳リソースのチェック
   - 翻訳内容のレビュー
   - 使われていないリソースキーの検出と削除

### 6.2 翻訳管理ツール

翻訳管理のためのツールと手法：

1. **エクスポート・インポート機能**
   - プロパティファイル/JSONを表形式データに変換
   - 翻訳者向けに表形式データを提供
   - 翻訳完了後、表形式データからプロパティファイル/JSONに再変換

2. **リソースキー一覧生成**
   - リソースファイルからキー一覧を自動生成
   - TypeScript型定義ファイルを生成（コード補完のため）
   - 使用されていないキーの検出

3. **翻訳統計機能**
   - 言語ごとの翻訳率
   - 未翻訳リソースの一覧
   - 最近更新されたリソースの一覧

### 6.3 デバッグと開発支援

開発者向けのデバッグ機能と支援ツール：

1. **デバッグモード**
   - メッセージキーと実際の値を同時表示
   - メッセージリソースの再読み込みボタン
   - 全言語での表示切り替え

2. **開発者向けツール**
   - 使用されていないメッセージキーの検出
   - 重複するメッセージ値の検出
   - メッセージフォーマットのバリデーション