# WebAPIゲートウェイ機能 ルーティング機能

## 1. 概要

ルーティング機能は、WebAPIゲートウェイの中核となる機能で、受信したAPIリクエストを分析し、適切なバックエンドサービスに転送する役割を担います。リクエストの特性（パス、メソッド、ヘッダー等）に基づいて最適なルートを選択し、効率的かつ柔軟なAPI管理を実現します。

## 2. ルーティング機能の責務

ルーティング機能は以下の主要な責務を持ちます：

1. **リクエスト分析**: 着信したリクエストのパス、メソッド、ヘッダー、クエリパラメータ等を分析
2. **ルート選択**: 定義されたルーティングルールに基づいて最適なバックエンドサービスを選択
3. **リクエスト転送**: 選択されたバックエンドサービスにリクエストを転送
4. **設定管理**: ルーティングルールの管理と動的な更新
5. **ヘルスチェック**: バックエンドサービスの稼働状態監視と問題時の適切なルーティング

## 3. コンポーネント構成

ルーティング機能は以下のコンポーネントで構成されます：

### 3.1 RouteRegistry

登録されたすべてのルート定義を管理するレジストリです。

**主要機能**:
- ルート定義の登録・更新・削除
- 条件に基づくルート検索
- ルート定義のキャッシュ管理

```java
public interface RouteRegistry {
    void registerRoute(RouteDefinition routeDefinition);
    Optional<RouteDefinition> getRoute(String routeId);
    List<RouteDefinition> getAllRoutes();
    boolean deleteRoute(String routeId);
    Optional<RouteDefinition> findMatchingRoute(GatewayRequest request);
    void refresh();
}
```

### 3.2 RouteMatcher

リクエストとルート定義のマッチングを判定するコンポーネントです。

**主要機能**:
- パスパターンマッチング
- HTTPメソッドマッチング
- ヘッダー条件マッチング
- クエリパラメータマッチング

```java
public interface RouteMatcher {
    boolean matches(RouteDefinition route, GatewayRequest request);
    MatchResult getMatchResult(RouteDefinition route, GatewayRequest request);
}
```

### 3.3 RouteResolver

リクエストに最適なルートを解決するコンポーネントです。

**主要機能**:
- 複数のマッチするルートからの優先順位付け
- 最適なルートの選定
- ルート解決に関するメトリクス収集

```java
public interface RouteResolver {
    Optional<ResolvedRoute> resolveRoute(GatewayRequest request);
    List<RouteMatch> findAllMatches(GatewayRequest request);
}
```

### 3.4 RequestRouter

実際のリクエスト転送を行うコンポーネントです。

**主要機能**:
- リクエストの実際の転送処理
- 転送先URLの構築
- タイムアウト処理
- リトライロジック

```java
public interface RequestRouter {
    GatewayResponse route(GatewayRequest request, ResolvedRoute route);
    CompletableFuture<GatewayResponse> routeAsync(GatewayRequest request, ResolvedRoute route);
}
```

### 3.5 RouteConfigurationLoader

ルート設定を読み込み、管理するコンポーネントです。

**主要機能**:
- 設定ファイルからのルート定義読み込み
- データベースからのルート定義読み込み
- 動的設定変更の検知と適用

```java
public interface RouteConfigurationLoader {
    List<RouteDefinition> loadRouteDefinitions();
    void refreshRouteDefinitions();
    void addConfigChangeListener(ConfigChangeListener listener);
}
```

## 4. 処理フロー

### 4.1 基本的なリクエストルーティングフロー

```
1. リクエスト受信
   ↓
2. RouteResolver.resolveRoute()でルート検索
   ↓
3. すべてのRouteDefinitionに対して
   3.1 RouteMatcher.matches()でマッチング評価
   3.2 マッチしたルートを優先度順でソート
   ↓
4. 最適なResolvedRouteを選定
   ↓
5. RequestRouter.route()でバックエンドへ転送
   ↓
6. レスポンス処理
```

### 4.2 動的ルート更新フロー

```
1. 管理インターフェースからのルート更新リクエスト
   ↓
2. RouteRegistry.registerRoute()で登録／更新
   ↓
3. 永続化ストアに保存
   ↓
4. 変更通知イベント発行
   ↓
5. 必要に応じてキャッシュ更新
   ↓
6. 変更の適用完了
```

## 5. ルーティング設定設計

### 5.1 ルート定義

ルート定義は以下の要素で構成されます：

**基本属性**:
- **id**: ルートの一意識別子
- **path**: マッチするパスパターン（例: `/api/v1/engineers/**`）
- **method**: HTTPメソッド (GET, POST, PUT, DELETE等)
- **targetService**: 転送先バックエンドサービス識別子

**マッチング条件**:
- **predicates**: ルート選択のための一致条件リスト
  - パスベース: パスパターンに一致
  - ヘッダーベース: 特定のHTTPヘッダーの有無や値
  - クエリパラメータベース: 特定のクエリパラメータの有無や値
  - メソッドベース: HTTPメソッドの一致
  - 複合条件: 複数条件のAND/OR結合

**転送設定**:
- **filters**: リクエスト/レスポンス変換フィルターのリスト
- **timeout**: リクエストタイムアウト設定
- **retryConfig**: リトライ設定

**制御設定**:
- **order**: 優先順位（複数ルートがマッチした場合の選択順）
- **enabled**: 有効/無効フラグ
- **rateLimit**: このルートに対するレート制限設定

### 5.2 設定形式

ルート定義は、以下のJSON形式で表現されます（内部表現の例）：

```json
{
  "id": "api-engineers-route",
  "path": "/api/v1/engineers/**",
  "method": "GET",
  "targetService": "engineer-service",
  "predicates": [
    {
      "type": "PATH",
      "matchType": "PREFIX",
      "value": "/api/v1/engineers/"
    },
    {
      "type": "HEADER",
      "name": "Content-Type",
      "matchType": "EXACT",
      "value": "application/json"
    }
  ],
  "filters": [
    {
      "type": "REWRITE_PATH",
      "name": "rewritePath",
      "value": "/api/v1/engineers/(?<path>.*)",
      "replacement": "/engineers/${path}"
    },
    {
      "type": "ADD_HEADER",
      "name": "X-Gateway-Version",
      "value": "1.0.0"
    }
  ],
  "order": 10,
  "enabled": true,
  "metadata": {
    "description": "Engineers API route",
    "owner": "engineer-team"
  }
}
```

### 5.3 ルートの永続化

ルート定義は以下の方法で永続化されます：

1. **データベース**: 主要な保存先として、構造化されたフォーマットでデータベースに格納
2. **設定ファイル**: 初期設定やバックアップとしてYAML/JSONファイルに保存
3. **キャッシュ**: Redis等のキャッシュを使用し、高速なアクセスを実現

## 6. 主要ユースケース

### 6.1 パスベースのルーティング

最も基本的なルーティングパターンで、URLパスに基づいてバックエンドサービスを選択します。

**設定例**:
```json
{
  "id": "api-projects-route",
  "path": "/api/v1/projects/**",
  "targetService": "project-service"
}
```

**挙動**:
- `/api/v1/projects/` へのリクエスト → `project-service` へ転送
- `/api/v1/projects/123` へのリクエスト → `project-service` へ転送 （末尾のパスパラメータ付き）

### 6.2 バージョンベースのルーティング

APIバージョンに基づいて異なるバックエンドサービスにルーティングします。

**設定例**:
```json
[
  {
    "id": "api-v2-engineers-route",
    "path": "/api/v2/engineers/**",
    "targetService": "engineer-service-v2",
    "order": 10
  },
  {
    "id": "api-v1-engineers-route",
    "path": "/api/v1/engineers/**",
    "targetService": "engineer-service-v1",
    "order": 20
  }
]
```

**挙動**:
- `/api/v2/engineers/` へのリクエスト → `engineer-service-v2` へ転送
- `/api/v1/engineers/` へのリクエスト → `engineer-service-v1` へ転送

### 6.3 ヘッダーベースのルーティング

HTTPヘッダーの値に基づいてルーティングを行います。

**設定例**:
```json
[
  {
    "id": "api-beta-feature-route",
    "path": "/api/v1/features/**",
    "predicates": [
      {
        "type": "HEADER",
        "name": "X-Feature-Version",
        "matchType": "EXACT",
        "value": "beta"
      }
    ],
    "targetService": "feature-service-beta",
    "order": 10
  },
  {
    "id": "api-stable-feature-route",
    "path": "/api/v1/features/**",
    "targetService": "feature-service-stable",
    "order": 20
  }
]
```

**挙動**:
- `X-Feature-Version: beta` ヘッダー付きのリクエスト → `feature-service-beta` へ転送
- ヘッダーなしまたは他の値のリクエスト → `feature-service-stable` へ転送

### 6.4 パス書き換え

バックエンドサービスへの転送時にパスを変更します。

**設定例**:
```json
{
  "id": "api-legacy-route",
  "path": "/api/v1/legacy-reports/**",
  "targetService": "report-service",
  "filters": [
    {
      "type": "REWRITE_PATH",
      "value": "/api/v1/legacy-reports/(?<reportId>.*)",
      "replacement": "/reports/legacy/${reportId}"
    }
  ]
}
```

**挙動**:
- `/api/v1/legacy-reports/quarterly` へのリクエスト → `report-service` の `/reports/legacy/quarterly` へ転送

## 7. エラーハンドリング

ルーティング機能におけるエラーハンドリングは以下のように設計されています：

### 7.1 ルート解決エラー

- **ルート未発見**: マッチするルートがない場合は404 Not Foundエラーを返却
- **無効なルート設定**: ルート設定に問題がある場合は500 Internal Server Errorを返却
- **利用不可能なバックエンドサービス**: サーキットブレーカーにより503 Service Unavailableを返却

### 7.2 転送処理エラー

- **タイムアウト**: 設定された時間内に応答がない場合は504 Gateway Timeoutを返却
- **接続エラー**: バックエンドサービスへの接続エラー時は502 Bad Gatewayを返却
- **認証/認可エラー**: 認証・認可失敗時は各々401 Unauthorized、403 Forbiddenを返却

### 7.3 リトライメカニズム

特定条件下でのリトライを設定可能です：

- **対象エラー**: 一時的なネットワークエラー、タイムアウト等
- **リトライ回数**: デフォルト3回
- **リトライ間隔**: 指数バックオフ戦略（例: 100ms, 200ms, 400ms）
- **永続的エラー除外**: 400系エラー（クライアントエラー）はリトライしない

## 8. 監視とメトリクス

### 8.1 収集メトリクス

ルーティング機能は以下のメトリクスを収集します：

| メトリクス名 | 種類 | 説明 |
|------------|------|------|
| gateway.routes.active | ゲージ | アクティブなルート定義数 |
| gateway.route.requests | カウンター | ルート別リクエスト数 |
| gateway.route.errors | カウンター | ルート別エラー数 |
| gateway.route.latency | ヒストグラム | ルート別レイテンシー分布 |
| gateway.route.no_match | カウンター | マッチするルートがなかったリクエスト数 |
| gateway.route.resolve_time | ヒストグラム | ルート解決処理時間 |

### 8.2 アラート条件

以下の条件に基づいてアラートを発行します：

| アラート名 | 条件 | 重要度 | アクション |
|-----------|------|-------|----------|
| RouteNotFound | ルート未発見率が5%超 | 中 | 設定確認 |
| RoutingLatencyHigh | ルーティング処理時間が100ms超 | 高 | パフォーマンス調査 |
| BackendUnreachable | 特定バックエンドへの接続エラー率が20%超 | 重大 | バックエンド状態確認 |

## 9. パフォーマンス最適化

### 9.1 最適化手法

ルーティング機能のパフォーマンスを最適化するために以下の手法を採用しています：

1. **ルート定義キャッシュ**: 頻繁に参照されるルート定義をインメモリキャッシュ
2. **パスパターンマッチングの最適化**: Trie木等の効率的なデータ構造による高速マッチング
3. **非同期処理**: NIO/リアクティブプログラミングモデルによる非ブロッキング処理
4. **バルクローディング**: 起動時の効率的な設定読み込み
5. **コネクションプーリング**: バックエンドサービスへの接続再利用

### 9.2 スケーラビリティ考慮点

1. **水平スケーリング**: ステートレス設計によるインスタンス追加対応
2. **分散キャッシュ**: Redisを用いた共有キャッシュによるマルチインスタンス一貫性確保
3. **設定の動的更新**: ゼロダウンタイムでの設定更新機能
4. **グレースフルシャットダウン**: 進行中のリクエスト完了までシャットダウンを遅延

## 10. 今後の拡張性

ルーティング機能は以下の拡張性を考慮して設計されています：

1. **カスタムプレディケート**: 独自のルートマッチング条件の追加
2. **カスタムフィルター**: 独自のリクエスト/レスポンス変換処理の追加
3. **重み付けルーティング**: トラフィック分散のための確率ベースルーティング対応
4. **サービスディスカバリ統合**: 外部サービスディスカバリシステムとの連携
5. **動的バックエンド登録**: 実行時のバックエンドサービス追加/削除