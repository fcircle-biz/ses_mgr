# WebAPIゲートウェイ機能 セキュリティ機能

## 1. 概要

セキュリティ機能は、WebAPIゲートウェイを通過するすべてのAPIリクエストに対してセキュリティ上の保護を提供する機能です。認証、認可、レート制限、悪意のあるリクエストの検出と防御など、APIセキュリティに関わる様々な側面を統合的に管理します。これにより、バックエンドサービスは業務ロジックの実装に集中でき、一貫性のあるセキュリティ対策をゲートウェイレベルで実現します。

## 2. セキュリティ機能の責務

セキュリティ機能は以下の主要な責務を持ちます：

1. **認証**: クライアント/ユーザー認証の検証
2. **認可**: リソースアクセス権限の検証
3. **レート制限**: APIの過剰利用防止
4. **入力検証**: 悪意のある入力の検出と防御
5. **暗号化**: データの安全な伝送
6. **監査ログ**: セキュリティイベントの記録
7. **脅威防御**: 一般的なAPI攻撃からの保護
8. **セキュリティポリシー適用**: セキュリティルールの統一的な適用

## 3. コンポーネント構成

セキュリティ機能は以下のコンポーネントで構成されます：

### 3.1 AuthenticationHandler

クライアント/ユーザー認証を処理するコンポーネントです。

**主要機能**:
- 多様な認証方式（JWT, APIキー, OAuth 2.0等）の処理
- 認証トークンの検証
- 認証コンテキストの生成
- 認証失敗時の適切なレスポンス生成

```java
public interface AuthenticationHandler {
    AuthenticationResult authenticate(GatewayRequest request);
    boolean supportsAuthenticationMethod(String method);
    List<String> getSupportedAuthenticationMethods();
    AuthenticationPolicy getAuthenticationPolicyForRoute(String routeId);
}
```

### 3.2 AuthorizationManager

リソースアクセス権限を管理するコンポーネントです。

**主要機能**:
- ロールベースのアクセス制御（RBAC）
- スコープベースのアクセス制御（OAuth 2.0スコープ）
- 属性ベースのアクセス制御（ABAC）
- カスタムポリシーに基づくアクセス制御

```java
public interface AuthorizationManager {
    AuthorizationResult authorize(AuthenticatedRequest request, String resource, String action);
    Set<String> getRequiredRoles(String routeId, String method);
    Set<String> getRequiredScopes(String routeId, String method);
    boolean hasAccessToRoute(Principal principal, String routeId, String method);
}
```

### 3.3 RateLimiter

APIリクエストのレート制限を管理するコンポーネントです。

**主要機能**:
- リクエスト数のカウントと制限
- 様々なレート制限戦略（固定ウィンドウ、スライディングウィンドウ等）
- クライアント/ユーザーごとの制限設定
- エンドポイントごとの制限設定
- 制限超過時の適切なレスポンス生成

```java
public interface RateLimiter {
    RateLimiterResponse checkLimit(String key, RateLimitPolicy policy);
    void recordUsage(String key, RateLimitPolicy policy);
    RateLimitPolicy getRateLimitPolicyForRoute(String routeId);
    Map<String, Long> getRemainingLimits(String clientId);
}
```

### 3.4 InputValidator

悪意のある入力を検出し防御するコンポーネントです。

**主要機能**:
- 入力サニタイゼーション
- SQLインジェクション検出
- XSS攻撃検出
- コマンドインジェクション検出
- 異常なペイロードサイズの検出

```java
public interface InputValidator {
    ValidationResult validateInput(GatewayRequest request, SecurityValidationPolicy policy);
    SecurityValidationPolicy getSecurityValidationPolicyForRoute(String routeId);
}
```

### 3.5 EncryptionService

データの暗号化と復号を管理するコンポーネントです。

**主要機能**:
- 転送中データの暗号化（TLS）
- 機密フィールドの暗号化
- トークン署名と検証
- 暗号鍵の管理

```java
public interface EncryptionService {
    String encryptField(String fieldValue, EncryptionContext context);
    String decryptField(String encryptedValue, EncryptionContext context);
    boolean verifySignature(String token, String signature);
    String createSignature(String token);
}
```

### 3.6 SecurityAuditor

セキュリティイベントを記録するコンポーネントです。

**主要機能**:
- 認証イベントの記録
- 認可決定の記録
- レート制限超過の記録
- セキュリティ違反の記録
- 監査ログの保存と検索

```java
public interface SecurityAuditor {
    void logAuthenticationEvent(AuthenticationEvent event);
    void logAuthorizationEvent(AuthorizationEvent event);
    void logRateLimitEvent(RateLimitEvent event);
    void logSecurityViolationEvent(SecurityViolationEvent event);
    List<SecurityAuditLog> searchLogs(SecurityAuditLogQuery query);
}
```

### 3.7 ThreatProtector

一般的なAPI攻撃からの保護を提供するコンポーネントです。

**主要機能**:
- DDOS対策
- ボットトラフィック検出
- APIスキャニング検出
- 不審なトラフィックパターン検出
- IPベースの制限と保護

```java
public interface ThreatProtector {
    ThreatAssessment assessThreat(GatewayRequest request);
    void recordSuspiciousActivity(GatewayRequest request, ThreatType threatType);
    ThreatProtectionPolicy getThreatProtectionPolicyForRoute(String routeId);
}
```

### 3.8 SecurityPolicyProvider

セキュリティポリシー設定を管理するコンポーネントです。

**主要機能**:
- ルート別セキュリティポリシーの管理
- ポリシーのロードと適用
- ポリシーの動的更新
- 環境別ポリシー設定

```java
public interface SecurityPolicyProvider {
    SecurityPolicy getSecurityPolicyForRoute(String routeId);
    void updateSecurityPolicy(String routeId, SecurityPolicy policy);
    List<String> getRoutesWithPolicy(PolicyType policyType);
    void reloadPolicies();
}
```

## 4. 処理フロー

### 4.1 基本的なセキュリティ処理フロー

```
1. リクエスト受信
   ↓
2. ThreatProtector.assessThreat()で脅威評価
   ↓
3. 脅威と判断された場合 → 即時拒否
   ↓
4. AuthenticationHandler.authenticate()で認証
   ↓
5. 認証失敗 → 401 Unauthorizedレスポンス返却
   ↓
6. AuthorizationManager.authorize()で認可
   ↓
7. 認可失敗 → 403 Forbiddenレスポンス返却
   ↓
8. InputValidator.validateInput()で入力検証
   ↓
9. 検証失敗 → 400 Bad Requestレスポンス返却
   ↓
10. RateLimiter.checkLimit()でレート制限チェック
    ↓
11. 制限超過 → 429 Too Many Requestsレスポンス返却
    ↓
12. SecurityAuditor.logXXX()で各種セキュリティイベント記録
    ↓
13. セキュリティチェック合格 → 後続処理へ
```

### 4.2 認証フロー

```
1. AuthenticationHandler.authenticate()開始
   ↓
2. リクエストから認証情報抽出
   ↓
3. 認証方式判別 (JWT, APIキー, Basic認証, OAuth等)
   ↓
4. 認証方式ごとの検証処理実行
   - JWT: シグネチャ検証、有効期限確認、クレーム検証
   - APIキー: キー検証、権限確認
   - OAuth: トークン検証、スコープ確認
   ↓
5. 認証情報からユーザー/クライアント情報解決
   ↓
6. 認証コンテキスト生成
   ↓
7. SecurityAuditor.logAuthenticationEvent()で記録
   ↓
8. 認証結果返却
```

### 4.3 認可フロー

```
1. AuthorizationManager.authorize()開始
   ↓
2. リクエストからルートID、HTTP Methodを特定
   ↓
3. リソースに必要なロール/スコープを取得
   ↓
4. 認証コンテキストからユーザーロール/スコープを取得
   ↓
5. ロール/スコープの一致確認
   ↓
6. 詳細なアクセス制御ポリシーの評価
   - リソース所有権
   - 時間ベースの制限
   - IP制限
   - カスタムルール
   ↓
7. SecurityAuditor.logAuthorizationEvent()で記録
   ↓
8. 認可結果返却
```

## 5. セキュリティポリシー設計

### 5.1 認証ポリシー

認証ポリシーは以下の要素で構成されます：

**認証方式設定**:
- **authMethods**: サポートする認証方式のリスト（JWT, APIKEY, OAUTH2等）
- **primaryMethod**: 優先的に使用する認証方式
- **fallbackMethods**: 主要方式が利用できない場合の代替方式

**JWT設定**:
- **issuer**: 発行者の検証設定
- **audience**: 想定受信者設定
- **tokenLocation**: トークンの格納場所（Authorization ヘッダー等）
- **signingKey**: 署名検証キー情報
- **expiration**: 有効期限検証設定

**APIキー設定**:
- **keyLocation**: APIキーの格納場所（ヘッダー、クエリ等）
- **keyNames**: 使用されるキー名のリスト

**認証例外**:
- **publicPaths**: 認証不要の公開パス
- **authOptionalPaths**: 認証が任意のパス

### 5.2 認可ポリシー

認可ポリシーは以下の要素で構成されます：

**ロール設定**:
- **roleMapping**: エンドポイントとHTTPメソッドに必要なロールのマッピング
- **roleHierarchy**: ロール階層関係の定義

**スコープ設定**:
- **scopeMapping**: エンドポイントとHTTPメソッドに必要なスコープのマッピング
- **scopeRelationships**: スコープ間の関係性定義

**リソース所有権**:
- **ownershipRules**: リソース所有者のみアクセス可能なルール定義
- **ownershipIdentifiers**: 所有者識別方法の定義

**IP制限**:
- **allowedIPs**: 許可IPアドレスリスト
- **deniedIPs**: 拒否IPアドレスリスト
- **ipRules**: 特定のリソースに対するIP制限ルール

### 5.3 レート制限ポリシー

レート制限ポリシーは以下の要素で構成されます：

**クライアント別制限**:
- **defaultLimit**: デフォルトのリクエスト上限
- **clientLimits**: クライアントごとのカスタム制限
- **userLimits**: ユーザーごとのカスタム制限

**リソース別制限**:
- **resourceLimits**: リソース（エンドポイント）ごとの制限設定
- **methodLimits**: HTTPメソッドごとの制限設定

**制限戦略**:
- **limitType**: 制限戦略タイプ（固定ウィンドウ、スライディングウィンドウ等）
- **timeWindow**: 時間枠設定（秒単位）
- **burstCapacity**: 一時的なトラフィックスパイク許容量

**応答設定**:
- **errorResponseType**: 制限超過時のレスポンスタイプ
- **includeHeaders**: X-RateLimit関連ヘッダーの含め方

### 5.4 入力検証ポリシー

入力検証ポリシーは以下の要素で構成されます：

**コンテンツ検証**:
- **maxRequestSize**: 最大リクエストサイズ
- **maxFieldLength**: フィールドごとの最大長
- **maxArraySize**: 配列の最大要素数

**脆弱性対策**:
- **sqlInjection**: SQLインジェクション対策設定
- **xssProtection**: XSS対策設定
- **commandInjection**: コマンドインジェクション対策設定

**サニタイゼーション**:
- **htmlSanitization**: HTML入力のサニタイズ方法
- **jsonSanitization**: JSONの安全性検証設定
- **charsetValidation**: 文字セット検証設定

**バリデーション例外**:
- **excludedPaths**: 検証を省略するパス
- **customValidationRules**: カスタム検証ルール

### 5.5 脅威保護ポリシー

脅威保護ポリシーは以下の要素で構成されます：

**DDOS対策**:
- **burstThreshold**: トラフィックスパイク閾値
- **burstAction**: スパイク発生時のアクション

**ボット対策**:
- **botDetection**: ボット検出設定
- **captchaIntegration**: CAPTCHA利用設定
- **legitimateBotsAllowlist**: 許可される正当なボットリスト

**スキャニング対策**:
- **scanPatterns**: スキャンパターン定義
- **scanThreshold**: スキャン検出閾値
- **scanAction**: スキャン検出時のアクション

**ブロックリスト**:
- **ipBlocklist**: ブロックIPリスト
- **userAgentBlocklist**: ブロックUserAgentリスト
- **blockDuration**: ブロック期間設定

## 6. 主要ユースケース

### 6.1 JWTベースの認証

APIリクエストのJWTベース認証を処理します。

**リクエスト例**:
```
GET /api/v1/engineers HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjE1MTYyMzkwMjIsInJvbGVzIjpbIkFETUlOIl0sInNjb3BlcyI6WyJyZWFkOmVuZ2luZWVycyJdfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
Accept: application/json
```

**認証ポリシー設定**:
```json
{
  "routeId": "api-engineers-list",
  "authenticationPolicy": {
    "authMethods": ["JWT"],
    "jwt": {
      "tokenLocation": "HEADER",
      "headerName": "Authorization",
      "headerPattern": "Bearer\\s+(.+)",
      "issuer": "auth.example.com",
      "audience": "api.example.com",
      "requiredClaims": ["sub", "roles", "scopes"]
    }
  }
}
```

**認証処理**:
1. JWTトークンを`Authorization`ヘッダーから抽出
2. トークンの署名を検証
3. 有効期限を確認
4. 必須クレームの存在確認
5. 発行者と受信者の検証
6. ユーザー情報とロール/スコープの抽出

**認証結果**:
```json
{
  "authenticated": true,
  "principal": {
    "userId": "1234567890",
    "name": "John Doe",
    "roles": ["ADMIN"],
    "scopes": ["read:engineers"]
  },
  "tokenMetadata": {
    "issuedAt": "2018-01-18T01:30:22Z",
    "expiresAt": "2018-01-18T02:30:22Z",
    "issuer": "auth.example.com"
  }
}
```

### 6.2 ロールベースのアクセス制御

リソースに対するロールベースのアクセス権限を検証します。

**認証済みユーザー情報**:
```json
{
  "userId": "1234567890",
  "name": "John Doe",
  "roles": ["PROJECT_MANAGER"],
  "scopes": ["read:projects", "write:projects", "read:engineers"]
}
```

**認可ポリシー設定**:
```json
{
  "routeId": "api-projects-update",
  "authorizationPolicy": {
    "roleRules": {
      "GET": ["PROJECT_VIEWER", "PROJECT_MANAGER", "ADMIN"],
      "POST": ["PROJECT_MANAGER", "ADMIN"],
      "PUT": ["PROJECT_MANAGER", "ADMIN"],
      "DELETE": ["ADMIN"]
    },
    "scopeRules": {
      "GET": ["read:projects"],
      "POST": ["write:projects"],
      "PUT": ["write:projects"],
      "DELETE": ["admin:projects"]
    }
  }
}
```

**認可処理**:
1. リクエストからHTTPメソッド（PUT）を特定
2. 必要なロール/スコープを取得（`["PROJECT_MANAGER", "ADMIN"]`と`["write:projects"]`）
3. ユーザーが必要なロール/スコープを持っているか確認
4. アクセス許可判定

**認可結果**:
```json
{
  "authorized": true,
  "matchedRoles": ["PROJECT_MANAGER"],
  "matchedScopes": ["write:projects"],
  "resource": "api-projects-update",
  "action": "PUT"
}
```

### 6.3 リソース所有者チェック

リソース所有者のみアクセスを許可するポリシーを適用します。

**リクエスト**:
```
PUT /api/v1/contracts/123 HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Type: application/json

{
  "title": "更新された契約タイトル",
  "description": "契約内容の更新"
}
```

**認可ポリシー設定**:
```json
{
  "routeId": "api-contracts-update",
  "authorizationPolicy": {
    "roleRules": {
      "PUT": ["CONTRACT_MANAGER", "ADMIN"]
    },
    "ownershipRules": {
      "enabled": true,
      "pathVariable": "contractId",
      "ownerField": "createdBy"
    },
    "ownershipExemptRoles": ["ADMIN"]
  }
}
```

**認可処理**:
1. 基本的なロールチェック
2. リソース所有権チェックの有効確認
3. パスからリソースID（`123`）を抽出
4. バックエンドAPIから契約の所有者情報を取得
5. ユーザーIDと所有者IDを比較
6. 例外ロール（ADMIN）の確認
7. アクセス許可判定

**認可結果**:
```json
{
  "authorized": true,
  "reason": "RESOURCE_OWNER",
  "resource": "api-contracts-update",
  "resourceId": "123",
  "action": "PUT"
}
```

### 6.4 レート制限

APIリクエストのレート制限を適用します。

**レート制限ポリシー設定**:
```json
{
  "routeId": "api-engineers-search",
  "rateLimitPolicy": {
    "enabled": true,
    "limitType": "SLIDING_WINDOW",
    "defaultLimits": {
      "ANONYMOUS": {
        "requestLimit": 10,
        "timeWindow": 60
      },
      "AUTHENTICATED": {
        "requestLimit": 100,
        "timeWindow": 60
      }
    },
    "roleLimits": {
      "ADMIN": {
        "requestLimit": 500,
        "timeWindow": 60
      }
    },
    "clientLimits": {
      "client-123": {
        "requestLimit": 300,
        "timeWindow": 60
      }
    },
    "includeHeaders": true
  }
}
```

**レート制限処理**:
1. クライアントの識別子（APIキーまたはユーザーID）を特定
2. ロールベースの制限値取得
3. クライアント固有の制限値取得（存在する場合）
4. 過去のリクエスト履歴の確認
5. リクエスト数が制限を超えているか確認
6. リクエストカウント更新
7. 制限情報をレスポンスヘッダーに追加

**レスポンスヘッダー**:
```
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 95
X-RateLimit-Reset: 1620000000
```

**制限超過時のレスポンス**:
```
HTTP/1.1 429 Too Many Requests
Content-Type: application/json
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1620000000
Retry-After: 30

{
  "error": {
    "code": "RATE_LIMIT_EXCEEDED",
    "message": "APIリクエスト数の上限に達しました。30秒後に再試行してください。",
    "requestId": "req-1234567890abcdef",
    "timestamp": "2025-05-11T15:30:45.123+0900"
  }
}
```

## 7. エラーハンドリング

セキュリティ機能におけるエラーハンドリングは以下のように設計されています：

### 7.1 認証エラー

- **トークン欠落**: `Authorization`ヘッダーが存在しない場合、401 Unauthorizedを返却
- **トークン無効**: JWT/APIキーが検証できない場合、401 Unauthorizedを返却
- **トークン期限切れ**: JWTの有効期限が切れている場合、401 Unauthorizedとともに`WWW-Authenticate`ヘッダーで理由を通知
- **トークン改ざん**: 署名検証に失敗した場合、401 Unauthorizedを返却

### 7.2 認可エラー

- **権限不足**: 必要なロール/スコープを持たない場合、403 Forbiddenを返却
- **リソース所有権違反**: 所有者でないリソースへのアクセス時、403 Forbiddenを返却
- **IPアドレス制限**: 許可されていないIPからのアクセス時、403 Forbiddenを返却
- **時間帯制限**: 許可されていない時間帯のアクセス時、403 Forbiddenを返却

### 7.3 レート制限エラー

- **制限超過**: レート制限を超えた場合、429 Too Many Requestsとともに`Retry-After`ヘッダーで再試行時間を通知
- **アカウント停止**: 継続的な制限超過によりアカウントが一時停止された場合、403 Forbiddenを返却

### 7.4 入力検証エラー

- **悪意のある入力検出**: SQLインジェクション等の攻撃パターン検出時、400 Bad Requestを返却
- **サイズ制限違反**: リクエストサイズ超過時、413 Payload Too Largeを返却
- **不正なコンテンツタイプ**: サポートされていないContent-Type時、415 Unsupported Media Typeを返却

### 7.5 脅威検出エラー

- **ボット検出**: 自動化されたボットと判断された場合、403 Forbiddenを返却
- **スキャン検出**: APIスキャンと判断された場合、403 Forbiddenを返却
- **DOS攻撃検出**: DOS攻撃パターンの検出時、429 Too Many Requestsを返却

### 7.6 セキュリティイベント通知

重大なセキュリティイベント発生時は以下の通知を行います：

- 管理者への即時アラート（メール/Slack等）
- 監視システムへのアラート通知
- セキュリティログへの詳細記録
- インシデント管理システムへの自動チケット作成

## 8. 監視とメトリクス

### 8.1 収集メトリクス

セキュリティ機能は以下のメトリクスを収集します：

| メトリクス名 | 種類 | 説明 |
|------------|------|------|
| gateway.security.auth.attempts | カウンター | 認証試行回数 |
| gateway.security.auth.failures | カウンター | 認証失敗回数 |
| gateway.security.auth.methods | カウンター | 認証方式別の使用回数 |
| gateway.security.authz.checks | カウンター | 認可チェック回数 |
| gateway.security.authz.denials | カウンター | 認可拒否回数 |
| gateway.security.rate.limited | カウンター | レート制限適用回数 |
| gateway.security.threats.detected | カウンター | 脅威検出回数 |
| gateway.security.validation.failures | カウンター | 入力検証失敗回数 |
| gateway.security.audit.events | カウンター | セキュリティ監査イベント数 |
| gateway.security.ip.blocked | ゲージ | 現在ブロック中のIPアドレス数 |

### 8.2 アラート条件

以下の条件に基づいてアラートを発行します：

| アラート名 | 条件 | 重要度 | アクション |
|-----------|------|-------|----------|
| HighAuthFailureRate | 認証失敗率が20%超 | 高 | 不正アクセス調査 |
| RateLimitExceeded | 特定クライアントが5分間で連続してレート制限超過 | 中 | クライアント利用パターン確認 |
| ThreatDetectionSpike | 脅威検出が通常の3倍 | 重大 | セキュリティ監視強化 |
| APIKeyCompromised | 同一APIキーが異なるIP/パターンで使用 | 重大 | APIキー無効化検討 |
| UnauthorizedAdminAccess | 管理者機能への未認可アクセス試行 | 重大 | セキュリティインシデント調査 |

## 9. パフォーマンス最適化

### 9.1 キャッシュ戦略

セキュリティ処理のパフォーマンスを最適化するために以下のキャッシュ戦略を採用しています：

1. **認証情報キャッシュ**: JWT/APIキーの検証結果をキャッシュ（有効期限を考慮）
2. **認可決定キャッシュ**: 認可決定結果の短期キャッシュ（ロール変更を考慮）
3. **セキュリティポリシーキャッシュ**: ポリシー定義のインメモリキャッシュ
4. **レート制限状態キャッシュ**: 分散キャッシュによるレート制限状態管理

### 9.2 効率的な処理

1. **早期拒否**: 明らかに不正なリクエストの早期検出と拒否
2. **並列検証**: 独立した検証の並列実行
3. **段階的検証**: 軽量な検証から重い検証への段階的実行
4. **セキュリティフィルターの最適順序**: 効率を考慮したフィルター実行順序

### 9.3 リソース使用最適化

1. **バックオフ戦略**: 連続的な失敗に対する処理遅延
2. **リソース制限**: クライアントごとのCPU/メモリ使用制限
3. **有効期限設定**: キャッシュや一時的なブロックの適切な有効期限設定

## 10. 今後の拡張性

セキュリティ機能は以下の拡張性を考慮して設計されています：

1. **認証方式の拡張**: 新しい認証プロトコルやメカニズムの追加サポート
2. **高度な認可モデル**: より細かい粒度の認可モデルやアトリビュートベースの認可
3. **機械学習統合**: 異常検出や動的脅威分析のための機械学習モデル統合
4. **セキュリティポリシーの動的更新**: 実行中のサービスへのポリシー動的適用
5. **コンプライアンスフレームワーク**: 特定の規制やコンプライアンス要件への適応
6. **カスタムセキュリティルール**: ビジネス固有のセキュリティ要件への対応