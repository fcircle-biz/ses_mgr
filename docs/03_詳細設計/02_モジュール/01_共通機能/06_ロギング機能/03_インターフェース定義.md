# ロギング機能 インターフェース定義

## 1. インターフェース概要

ロギング機能は、アプリケーション全体に対して一貫したロギングサービスを提供します。このドキュメントでは、ロギング機能が提供するインターフェースと他のモジュールから要求するインターフェースを定義します。

### 1.1 設計方針

- Spring標準のロギング機能（SLF4J + Logback）を中心に据えた設計
- Spring AOPを活用した宣言的ロギング
- Spring Boot Actuatorとの統合によるメトリクス収集
- Micrometer Tracingを活用した分散トレーシング

### 1.2 パッケージ構成

```
jp.co.sesmanager.common.logging
  ├── aop           // アスペクト関連
  ├── audit         // 監査ログ関連
  ├── config        // 設定クラス
  ├── domain        // ドメインモデル
  ├── metrics       // メトリクス関連
  ├── trace         // 分散トレーシング関連
  └── util          // ユーティリティ
```

## 2. 提供インターフェース

### 2.1 SLF4Jロガー

**目的**: Spring標準のSLF4Jを使用したログ出力

**責務**:
- 各種ログレベル（ERROR, WARN, INFO, DEBUG, TRACE）でのログ出力
- 例外情報を含むログ出力
- ログレベル有効性の確認
- MDC（Mapped Diagnostic Context）の操作
- マーカーによるログ出力の分類

#### 使用例

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

public class CustomerService {
    // SLF4Jロガーの取得
    private static final Logger logger = LoggerFactory.getLogger(CustomerService.class);
    
    public void processCustomer(Customer customer) {
        try {
            // MDCに情報を追加
            MDC.put("customerId", customer.getId());
            
            // INFOレベルでログ出力
            logger.info("顧客処理を開始しました: {}", customer.getName());
            
            // 実際の処理
            // ...
            
            // DEBUGレベルでログ出力（条件付き）
            if (logger.isDebugEnabled()) {
                logger.debug("顧客処理の詳細: {}", getDetailedInfo(customer));
            }
            
        } catch (Exception e) {
            // 例外のログ出力
            logger.error("顧客処理中にエラーが発生しました: {}", customer.getId(), e);
            throw e;
        } finally {
            // MDCのクリーンアップ
            MDC.remove("customerId");
        }
    }
}
```

### 2.2 AuditEventPublisher

**目的**: 監査イベントを発行するためのインターフェース

**責務**:
- 監査イベントの発行と記録
- Spring ApplicationEventPublisherとの統合
- 監査情報の標準化

#### メソッド一覧

**publishAuditEvent**
- **目的**: 監査イベントを発行する
- **引数**: AuditEvent（監査イベント）
- **戻り値**: なし

### 2.3 AuditLog アノテーション

**目的**: Spring AOPを活用した宣言的な監査ログ記録

**責務**:
- メソッド実行時の監査ログ自動記録
- 監査情報のメソッドパラメータからの抽出
- SpEL式による柔軟な値解決

#### 属性

**action**
- **目的**: 実行される操作
- **型**: String
- **例**: "CREATE", "READ", "UPDATE", "DELETE", "LOGIN"

**targetType**
- **目的**: 操作対象の種類
- **型**: String
- **例**: "USER", "CONTRACT", "PAYMENT"

**targetIdExpression**
- **目的**: 操作対象IDを取得するためのSpEL式
- **型**: String
- **デフォルト値**: 空文字（メソッドの戻り値から取得を試みる）

**detailsExpression**
- **目的**: 詳細情報を取得するためのSpEL式
- **型**: String
- **デフォルト値**: 空文字

### 2.4 Timed アノテーション (Micrometer)

**目的**: Spring Boot Actuatorとの連携によるメソッドの実行時間測定

**責務**:
- メソッド実行時間の自動計測と記録
- Micrometerメトリクスへの登録
- パフォーマンスモニタリングとの連携

#### 属性

**value**
- **目的**: メトリクス名
- **型**: String
- **例**: "process.customer", "generate.invoice"

**percentiles**
- **目的**: 計測するパーセンタイル値
- **型**: double[]
- **例**: {0.5, 0.95, 0.99}
- **デフォルト値**: {}

**extraTags**
- **目的**: 追加タグ情報
- **型**: String[]
- **例**: {"region=tokyo", "env=production"}
- **デフォルト値**: {}

### 2.5 Observed アノテーション (Micrometer)

**目的**: メソッド呼び出しの監視とトレース情報の記録

**責務**:
- メソッド実行の観測
- トレース情報の自動記録
- メトリクスとトレースの統合

#### 属性

**name**
- **目的**: 観測名
- **型**: String
- **例**: "http.server.requests", "service.method"

## 3. 要求インターフェース

### 3.1 UserContextProvider

**目的**: ログの出力時にユーザー情報を取得するために必要なインターフェース

**提供モジュール**: 認証認可機能

**責務**:
- 現在のユーザー情報の取得
- クライアント情報の取得
- セッション情報の取得

#### メソッド一覧

**getUserContext**
- **目的**: 現在認証されているユーザーコンテキストを取得
- **戻り値**: UserContext

**getClientIpAddress**
- **目的**: 現在のリクエストからクライアントIPアドレスを取得
- **戻り値**: クライアントIPアドレス

**getSessionId**
- **目的**: 現在のセッションIDを取得
- **戻り値**: セッションID

### 3.2 ErrorHandler

**目的**: エラーログ出力時にエラー情報を適切に変換するために必要なインターフェース

**提供モジュール**: エラー処理機能

**責務**:
- 例外情報の変換
- エラーメッセージの解決

#### メソッド一覧

**convertExceptionToErrorInfo**
- **目的**: 例外をエラー情報に変換
- **引数**: 例外オブジェクト
- **戻り値**: エラー情報

**resolveErrorMessage**
- **目的**: エラーコードからエラーメッセージを解決
- **引数**: エラーコード、メッセージパラメータ
- **戻り値**: 解決されたエラーメッセージ

## 4. データ交換モデル

### 4.1 AuditEvent

**目的**: 監査イベントを表すデータモデル

**属性**:
- **基本情報**
  - id: イベントID (String)
  - timestamp: タイムスタンプ (Instant)
  - principal: 実行者 (String)
  - action: 実行された操作 (String)
  - targetType: 操作対象の種類 (String)
  - targetId: 操作対象のID (String)
  - details: 詳細情報 (String)
  - status: 操作結果 (String: "SUCCESS", "FAILURE")
  - source: イベントソース (String)

### 4.2 MetricsConfig

**目的**: メトリクス設定を表すデータモデル

**属性**:
- **基本設定**
  - enabled: 有効/無効 (boolean)
  - prefix: メトリクス名のプレフィックス (String)
  - commonTags: 共通タグ (Map<String, String>)

- **パフォーマンス設定**
  - percentiles: パーセンタイル設定 (double[])
  - sla: SLAしきい値 (long[])
  - recordExceptions: 記録対象の例外クラス (List<String>)

### 4.3 TracingConfig

**目的**: トレース設定を表すデータモデル

**属性**:
- **基本設定**
  - enabled: 有効/無効 (boolean)
  - serviceName: サービス名 (String)
  - samplingRate: サンプリングレート (double)

- **伝播設定**
  - propagationKeys: 伝播キー (List<String>)
  - baggageKeys: バゲージキー (List<String>)
  - baggageCorrelationEnabled: バゲージ相関の有効化 (boolean)

## 5. 非機能要件

### 5.1 パフォーマンス要件

1. ロギング処理がアプリケーションパフォーマンスに与える影響を最小化するため、以下の対策を実施します：
   - Spring提供の非同期ロギング設定の活用
   - SLF4Jの条件付きログ出力（isDebugEnabled()などによる事前チェック）
   - 適切なログレベル設定によるパフォーマンス最適化

2. パフォーマンスメトリック：
   - ログエントリ1件あたりの処理オーバーヘッド: 0.1ミリ秒以下
   - 大量ログ出力時（1秒間に1000エントリ以上）のスループット低下: 5%以内
   - ディスクI/O待ちによるアプリケーションブロッキング: なし

### 5.2 トランザクション要件

1. ロギング処理とアプリケーショントランザクションの分離：
   - ロギング処理の失敗がビジネストランザクションに影響を与えない設計
   - Spring EventListenerの非同期実行オプションを活用した分離
   - 監査ログの書き込み失敗時の例外ハンドリング方針

2. 監査ログの整合性保証：
   - Spring Retryによるリトライ機構の活用
   - 一時的なバッファリングとリカバリ機構

### 5.3 スレッドセーフティ要件

1. マルチスレッド環境での安全性確保：
   - SLF4JとLogbackのスレッドセーフな実装の活用
   - ThreadLocalStorageのクリーンアップの確実な実施
   - Spring Boot ActuatorとMicrometerのスレッドセーフなメトリクス収集

### 5.4 スケーラビリティ要件

1. 大量ログ処理への対応：
   - Spring Boot提供のログローテーション設定の活用
   - バッファサイズと非同期キューの適切な設計
   - 分散環境でのログ集約処理の効率化

2. マイクロサービス環境での分散トレーシング：
   - Micrometer Tracingによるサービス間でのトレースコンテキスト伝播
   - 大規模トレースデータの効率的な収集と保存

### 5.5 セキュリティ要件

1. ログデータの保護：
   - Spring Securityによる監査ログアクセス制御
   - ログマスキングパターンの設定
   - 監査ログの改ざん防止対策

2. 認証情報と個人情報の取り扱い：
   - Spring標準のパスワードなど機密情報のマスキング機能の活用
   - 個人識別情報（PII）の適切な処理