# パフォーマンスログ機能

## 1. 機能概要

パフォーマンスログ機能は、アプリケーション内の処理時間や各種メトリクスを計測・記録し、システムのボトルネック特定や性能最適化に役立てるための機能です。Spring Boot ActuatorとMicrometerを活用して、処理時間の計測、閾値監視、リソース使用状況の記録などを行います。

### 1.1 機能の目的

- 処理時間のモニタリングと記録
- パフォーマンスボトルネックの特定と分析
- 閾値を超えた処理の検知と警告
- パフォーマンス傾向の分析と最適化
- リソース使用状況の監視

### 1.2 主要機能

- Spring Boot Actuatorによるメトリクス収集と露出
- Micrometerを活用したメソッド実行時間の自動計測
- `@Timed`アノテーションによる宣言的パフォーマンス計測
- Micrometerタイマーによる処理時間の閾値監視と警告通知
- カスタムメトリクスによる処理件数と処理速度の計測
- アプリケーションリソース使用状況のメトリクス記録
- Prometheusなどの監視システムとの連携機能

## 2. 処理フロー

### 2.1 パフォーマンス計測の基本フロー

```
1. 計測対象メソッドの呼び出し
2. Micrometer TimerによるAOPインターセプト
   a. 開始時間の記録
   b. 計測情報の初期化
   c. タグ情報の収集

3. 対象メソッドの実行

4. Micrometer Timerによる実行後処理
   a. 終了時間の記録と所要時間の計算
   b. メトリクスレジストリへの記録
   c. タイマーヒストグラムの更新

5. 例外発生時の処理
   a. 例外情報の記録
   b. エラーメトリクスの更新
```

### 2.2 パフォーマンスアラートフロー

```
1. パフォーマンス計測結果の評価
   a. SLA閾値との比較
   b. パーセンタイル閾値との比較

2. アラートレベルの決定
   a. 正常（閾値内）
   b. 警告（警告閾値超過）
   c. エラー（エラー閾値超過）

3. アラート通知
   a. Spring Boot Actuator Health Indicatorでの表示
   b. メトリクス閾値に基づく監視システムからのアラート
```

### 2.3 リソース使用状況記録フロー

```
1. Spring Boot Actuatorによるリソースメトリクス収集
   a. JVMメトリクス（メモリ、GC、スレッド）
   b. システムメトリクス（CPU、ディスク、ネットワーク）
   c. データソースメトリクス（DBコネクション、クエリ実行数）

2. Micrometerレジストリへのメトリクス登録
3. 外部システムへのメトリクスエクスポート
4. 閾値に基づくアラート処理
```

## 3. 主要コンポーネント構成

### 3.1 MeterRegistry クラス

Micrometerのコアコンポーネントで、メトリクスの収集・管理を行います。

#### 主要責務
- メトリクスの登録と管理
- タイマー、カウンター、ゲージなどのメトリクスタイプ提供
- メトリクスタグの管理
- メトリクスエクスポートの調整

#### 主要メソッド
- `timer(String name, Iterable<Tag> tags)` - 指定名とタグのタイマーを取得または作成
- `counter(String name, Iterable<Tag> tags)` - 指定名とタグのカウンターを取得または作成
- `gauge(String name, Object obj, ToDoubleFunction<Object> valueFunction)` - オブジェクトの状態を測定するゲージを作成

### 3.2 Timer クラス

処理時間を計測するMicrometerのメトリクス型です。

#### 主要責務
- 処理時間の計測
- パーセンタイル計算
- ヒストグラム生成
- 秒間リクエスト数（スループット）計算

#### 主要メソッド
- `record(Runnable runnable)` - Runnableの実行時間を計測
- `record(Supplier<T> supplier)` - Supplierの実行時間を計測して結果を返す
- `record(long amount, TimeUnit unit)` - 指定された時間を記録
- `recordCallable(Callable<T> callable)` - Callableの実行時間を計測して結果を返す

### 3.3 TimedAspect クラス

`@Timed`アノテーションを処理するAOPアスペクトです。

#### 主要責務
- @Timedアノテーション付きメソッドのインターセプト
- タイマーの取得または作成
- メソッド実行時間の計測
- 結果または例外の処理

#### 主要メソッド
- `timedMethod(ProceedingJoinPoint pjp)` - アノテーション付きメソッドの処理

### 3.4 MetricsEndpoint クラス

Spring Boot Actuatorのエンドポイントで、収集したメトリクスを公開します。

#### 主要責務
- メトリクス情報の提供
- メトリクスの検索と取得
- 特定のタグによるフィルタリング
- HTTPエンドポイントを通じたメトリクス公開

#### 主要メソッド
- `listNames()` - 利用可能なメトリクス名の一覧を返す
- `metric(String requiredMetricName, List<String> tag)` - 特定のメトリクスを返す

### 3.5 PrometheusMeterRegistry クラス

Prometheus形式でメトリクスをエクスポートするためのレジストリです。

#### 主要責務
- Micrometerメトリクスの収集
- Prometheus形式への変換
- スクレイピングエンドポイントの提供
- カスタム設定の適用

## 4. 設定詳細

### 4.1 Spring Boot Actuatorの設定

```yaml
# application.yml
management:
  endpoints:
    web:
      exposure:
        include: health, info, metrics, prometheus
      base-path: /actuator
      path-mapping:
        prometheus: metrics
  endpoint:
    health:
      show-details: when-authorized
    metrics:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true
    enable:
      all: true
      jvm: true
      tomcat: true
      process: true
      system: true
      logback: true
      jdbc: true
    distribution:
      percentiles-histogram:
        http.server.requests: true
      percentiles:
        http.server.requests: 0.5, 0.75, 0.95, 0.99
      sla:
        http.server.requests: 10ms, 100ms, 500ms
```

### 4.2 カスタムメトリクスの設定

```java
@Configuration
public class MetricsConfig {

    @Bean
    public MeterRegistryCustomizer<MeterRegistry> metricsCommonTags(
            @Value("${spring.application.name}") String applicationName,
            @Value("${spring.profiles.active:default}") String activeProfile) {
        
        return registry -> registry.config()
                .commonTags("application", applicationName)
                .commonTags("environment", activeProfile);
    }
    
    @Bean
    public TimedAspect timedAspect(MeterRegistry registry) {
        return new TimedAspect(registry);
    }
}
```

### 4.3 パフォーマンス閾値の設定

```yaml
# application.yml
sesmanager:
  metrics:
    thresholds:
      api:
        warning-ms: 500
        error-ms: 2000
      database:
        warning-ms: 200
        error-ms: 1000
      external:
        warning-ms: 2000
        error-ms: 5000
      batch:
        warning-ms: 10000
        error-ms: 30000
```

## 5. 使用例

### 5.1 @Timedアノテーションを使用した宣言的パフォーマンス計測

```java
import io.micrometer.core.annotation.Timed;
import org.springframework.stereotype.Service;

@Service
public class CustomerService {

    // 基本的なタイマー
    @Timed(value = "customer.service.findById", 
           description = "Time taken to find a customer by ID")
    public Customer findById(Long id) {
        // 顧客検索ロジック
        return customerRepository.findById(id).orElse(null);
    }
    
    // パーセンタイルとSLA付きのタイマー
    @Timed(
        value = "customer.service.createCustomer",
        description = "Time taken to create a new customer",
        percentiles = {0.5, 0.95, 0.99},
        extraTags = {"operation", "create"}
    )
    public Customer createCustomer(CustomerDto dto) {
        // 顧客作成ロジック
        Customer customer = new Customer();
        customer.setName(dto.getName());
        // 他のフィールド設定
        
        return customerRepository.save(customer);
    }
    
    // エラーケースを記録するタイマー
    @Timed(
        value = "customer.service.updateCustomer",
        longTask = true,
        extraTags = {"operation", "update"}
    )
    public Customer updateCustomer(Long id, CustomerDto dto) {
        // 顧客更新ロジック
        try {
            Customer customer = customerRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Customer not found: " + id));
            
            // フィールド更新
            customer.setName(dto.getName());
            // 他のフィールド更新
            
            return customerRepository.save(customer);
        } catch (Exception e) {
            // エラーケースはタイマーが自動的に記録
            throw e;
        }
    }
}
```

### 5.2 MeterRegistryを使用した明示的なパフォーマンス計測

```java
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Tag;
import io.micrometer.core.instrument.Timer;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.concurrent.TimeUnit;

@Service
public class ReportService {

    private final MeterRegistry meterRegistry;
    
    public ReportService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    public Report generateReport(ReportRequest request) {
        // タイマー作成
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            // レポート生成ロジック
            Report report = processReport(request);
            
            // タイマー停止と計測記録
            sample.stop(meterRegistry.timer("report.generation.time", 
                Arrays.asList(
                    Tag.of("type", request.getType()),
                    Tag.of("format", request.getFormat())
                )));
            
            return report;
        } catch (Exception e) {
            // エラー時のタイマー停止と計測記録
            sample.stop(meterRegistry.timer("report.generation.error", 
                Arrays.asList(
                    Tag.of("type", request.getType()),
                    Tag.of("format", request.getFormat()),
                    Tag.of("error", e.getClass().getSimpleName())
                )));
            throw e;
        }
    }
    
    // 特定のブロックコードだけを計測するオプション
    private void processDatabaseData(String reportType) {
        Timer timer = meterRegistry.timer("report.database.query.time", 
            Arrays.asList(Tag.of("type", reportType)));
            
        timer.record(() -> {
            // データベース処理ロジック
            // ...
        });
    }
    
    // 既知の処理時間を直接記録するオプション
    private void recordExternalServiceTime(long startTimeMillis, String serviceName) {
        long duration = System.currentTimeMillis() - startTimeMillis;
        
        meterRegistry.timer("external.service.call.time", 
            Arrays.asList(Tag.of("service", serviceName)))
            .record(duration, TimeUnit.MILLISECONDS);
    }
}
```

### 5.3 バッチ処理のパフォーマンス計測

```java
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.concurrent.TimeUnit;

@Component
public class BatchMetricsListener implements JobExecutionListener {
    
    private final MeterRegistry meterRegistry;
    private Timer.Sample jobTimerSample;
    
    public BatchMetricsListener(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    @Override
    public void beforeJob(JobExecution jobExecution) {
        jobTimerSample = Timer.start(meterRegistry);
    }
    
    @Override
    public void afterJob(JobExecution jobExecution) {
        String jobName = jobExecution.getJobInstance().getJobName();
        String status = jobExecution.getStatus().name();
        
        // 処理時間の記録
        jobTimerSample.stop(meterRegistry.timer("batch.job.duration", 
            Arrays.asList(
                Tag.of("job", jobName),
                Tag.of("status", status)
            )));
        
        // 処理件数の記録
        jobExecution.getStepExecutions().forEach(stepExecution -> {
            String stepName = stepExecution.getStepName();
            
            // 読み込み件数
            meterRegistry.gauge("batch.step.reads", 
                Arrays.asList(
                    Tag.of("job", jobName),
                    Tag.of("step", stepName)
                ), 
                stepExecution.getReadCount());
            
            // 書き込み件数
            meterRegistry.gauge("batch.step.writes", 
                Arrays.asList(
                    Tag.of("job", jobName),
                    Tag.of("step", stepName)
                ), 
                stepExecution.getWriteCount());
            
            // スキップ件数
            meterRegistry.gauge("batch.step.skips", 
                Arrays.asList(
                    Tag.of("job", jobName),
                    Tag.of("step", stepName)
                ), 
                stepExecution.getSkipCount());
        });
        
        // バッチスループット計算
        long durationMillis = jobExecution.getEndTime().getTime() - jobExecution.getStartTime().getTime();
        long totalItems = jobExecution.getStepExecutions().stream()
            .mapToLong(step -> step.getWriteCount())
            .sum();
            
        double itemsPerSecond = durationMillis > 0 
            ? (totalItems * 1000.0) / durationMillis 
            : 0;
            
        meterRegistry.gauge("batch.job.throughput", 
            Arrays.asList(
                Tag.of("job", jobName),
                Tag.of("status", status)
            ), 
            itemsPerSecond);
    }
}
```

### 5.4 HTTPクライアントのパフォーマンス計測

```java
import io.micrometer.core.instrument.MeterRegistry;
import org.springframework.boot.web.client.RestTemplateCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class RestClientConfig {

    @Bean
    public RestTemplateCustomizer restTemplateMetricCustomizer(MeterRegistry meterRegistry) {
        return restTemplate -> {
            restTemplate.getInterceptors().add(new MetricsClientHttpRequestInterceptor(meterRegistry));
        };
    }
}

public class MetricsClientHttpRequestInterceptor implements ClientHttpRequestInterceptor {

    private final MeterRegistry meterRegistry;
    
    public MetricsClientHttpRequestInterceptor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, 
                                       ClientHttpRequestExecution execution) throws IOException {
        // タイマー開始
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            // 実際のHTTPリクエスト実行
            ClientHttpResponse response = execution.execute(request, body);
            
            // タイマー停止と記録
            String host = request.getURI().getHost();
            String path = request.getURI().getPath();
            String method = request.getMethod().name();
            int status = response.getStatusCode().value();
            
            sample.stop(meterRegistry.timer("http.client.requests", 
                Arrays.asList(
                    Tag.of("method", method),
                    Tag.of("host", host),
                    Tag.of("path", path),
                    Tag.of("status", String.valueOf(status))
                )));
            
            return response;
        } catch (Exception e) {
            // エラー時のタイマー停止と記録
            String host = request.getURI().getHost();
            String path = request.getURI().getPath();
            String method = request.getMethod().name();
            
            sample.stop(meterRegistry.timer("http.client.requests", 
                Arrays.asList(
                    Tag.of("method", method),
                    Tag.of("host", host),
                    Tag.of("path", path),
                    Tag.of("status", "error"),
                    Tag.of("exception", e.getClass().getSimpleName())
                )));
            
            throw e;
        }
    }
}
```

## 6. 例外処理

### 6.1 メトリクス処理中の例外ハンドリング

メトリクス処理自体がアプリケーションの処理を妨げないように例外を処理します：

```java
@Configuration
public class MetricsErrorHandlingConfig {

    private static final Logger logger = LoggerFactory.getLogger(MetricsErrorHandlingConfig.class);
    
    @Bean
    public MeterRegistryCustomizer<MeterRegistry> metricsErrorHandler() {
        return registry -> registry.config()
            .onMeterAdded(meter -> {
                try {
                    // メトリクス処理
                } catch (Exception e) {
                    logger.warn("Failed to process metric {}: {}", 
                        meter.getId().getName(), e.getMessage());
                    // 例外を抑制し、アプリケーション処理への影響を防ぐ
                }
            });
    }
}
```

### 6.2 メトリクスエクスポート失敗のハンドリング

メトリクスエクスポートが失敗した場合の対応：

```java
@Component
public class MetricsExportErrorHandler {

    private static final Logger logger = LoggerFactory.getLogger(MetricsExportErrorHandler.class);
    
    @EventListener
    public void handleExportError(MetricsExportFailedEvent event) {
        logger.error("Failed to export metrics to {}: {}", 
            event.getExporterName(), event.getThrowable().getMessage());
        
        // エクスポート失敗のカウンター更新
        event.getRegistry().counter("metrics.export.failures", 
            "exporter", event.getExporterName())
            .increment();
    }
}
```

### 6.3 過剰なメトリクスの防止

膨大な数のメトリクスが生成されることを防ぐための対策：

```java
@Configuration
public class MetricsLimitConfig {

    @Bean
    public MeterFilter maximumAllowableTags() {
        return MeterFilter.maximumAllowableTags("http.server.requests", 100);
    }
    
    @Bean
    public MeterFilter renameFilter() {
        // 高カーディナリティタグの名前変更や除外
        return MeterFilter.replaceTagValues("path", s -> {
            if (s.startsWith("/api/users/")) {
                return "/api/users/{id}";
            }
            return s;
        });
    }
    
    @Bean
    public MeterFilter denyFilter() {
        // 特定パターンのメトリクスを除外
        return MeterFilter.denyNameStartsWith("jvm.threads");
    }
}
```

## 7. パフォーマンス考慮事項

### 7.1 メトリクス収集のオーバーヘッド最小化

メトリクス収集自体がアプリケーションのパフォーマンスに与える影響を最小限に抑えるための対策：

```java
@Configuration
public class MetricsPerformanceConfig {

    // サンプリングレートの調整
    @Bean
    public MeterFilter samplingFilter() {
        return MeterFilter.sample(registry ->
            new GaussianDistribution(0.1, 0.5, 0.95));
    }
    
    // メモリ最適化設定
    @Bean
    public MeterRegistryCustomizer<MeterRegistry> optimizeHistogram() {
        return registry -> registry.config()
            .meterRegistry(registry)
            .timerPercentilesHistogram(false)   // ヒストグラムの無効化（必要な場合のみ有効化）
            .timerMinimumExpectedValue(Duration.ofMillis(1))
            .timerMaximumExpectedValue(Duration.ofSeconds(30));
    }
}
```

### 7.2 メトリクス公開のセキュリティ

メトリクスエンドポイントへのアクセス制限：

```java
@Configuration
public class MetricsSecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        return http
            .authorizeExchange(exchanges -> exchanges
                .pathMatchers("/actuator/health/**").permitAll()
                .pathMatchers("/actuator/info").permitAll()
                .pathMatchers("/actuator/metrics/**").hasRole("MONITORING")
                .pathMatchers("/actuator/prometheus").hasRole("MONITORING")
                .anyExchange().authenticated()
            )
            .httpBasic().and()
            .build();
    }
}
```

## 8. バージョン履歴

| バージョン | 更新日     | 担当者    | 変更内容                                |
|----------|------------|---------|--------------------------------------|
| 0.1      | 2023/10/01 | 山田太郎  | 初版作成                               |
| 0.2      | 2023/11/15 | 佐藤次郎  | リソースモニタリング機能追加              |
| 0.3      | 2024/01/20 | 鈴木三郎  | バッチ処理のパフォーマンス計測機能追加     |
| 0.4      | 2024/05/10 | 一丸柴也  | 実装コードを削除し、設計情報のみに修正     |
| 0.5      | 2024/05/15 | 一丸柴也  | Spring Boot ActuatorとMicrometerを活用した設計に変更 |