# 監査ログ機能

## 1. 機能概要

監査ログ機能は、システム内の重要な操作や変更を記録し、それらの操作に関する監査証跡を提供する機能です。Spring Securityの監査機能とSpring AOPを活用し、セキュリティ監査、コンプライアンス対応、操作トレーサビリティの確保などの目的で利用されます。

### 1.1 機能の目的

- 重要な業務操作の記録と追跡
- セキュリティ関連操作の監視と証跡保持
- コンプライアンス要件への対応
- 不正操作の検出と調査
- 操作履歴の管理と監査対応

### 1.2 主要機能

- Spring Securityと連携した監査対象操作の自動記録
- Spring AOPを活用した宣言的監査ログ
- Spring Event機構による監査イベント発行と処理
- ユーザー情報、操作対象、操作結果の詳細記録
- 監査ログの長期保存と検索
- アノテーションベースの簡易監査ログ設定

## 2. 処理フロー

### 2.1 監査ログ記録の基本フロー

```
1. 監査対象メソッドの呼び出し
2. Spring AOPによるメソッド実行前処理
   a. Spring Securityからユーザーコンテキスト情報の取得
   b. 操作内容の決定
   c. 対象リソース情報の取得
   d. 監査イベント「操作試行」の作成と発行

3. 対象メソッドの実行

4. Spring AOPによるメソッド実行後処理
   a. 実行結果のステータス確認
   b. 監査イベント「操作成功」の作成と発行

5. 例外発生時の処理
   a. 例外情報の取得
   b. 監査イベント「操作失敗」の作成と発行
   c. 例外の再スロー

6. ApplicationListenerでの監査イベント処理
   a. 監査イベントのキャプチャ
   b. SLF4Jによる監査ログへの記録
   c. Spring Data Auditingによるデータベース保存（オプション）
```

### 2.2 監査ログフィルタリングフロー

```
1. 監査対象の評価
   a. 操作種別による評価
   b. リソース種別による評価
   c. ユーザーロールによる評価

2. 監査レベルの決定
   a. 詳細レベル（すべての情報を記録）
   b. 標準レベル（基本情報のみ記録）
   c. 最小レベル（操作種別と結果のみ記録）

3. フィルタリング結果に基づく記録内容の調整
```

### 2.3 監査ログ検索フロー

```
1. 検索条件の指定
   a. 期間指定
   b. ユーザー指定
   c. 操作種別指定
   d. リソース種別指定
   e. 操作結果指定

2. Elasticsearchへの検索クエリ構築
3. 検索実行
4. 結果の整形と返却
```

## 3. 主要コンポーネント構成

### 3.1 AuditEvent クラス

Spring Securityの監査イベントを表すクラスです。

#### 主要属性
- `principal` - 操作を実行したユーザー/システム
- `type` - 監査イベントの種類
- `timestamp` - イベント発生時刻
- `data` - 監査に関連する追加データ（Map形式）

#### 主要メソッド
- `getTimestamp()` - イベントのタイムスタンプを取得
- `getPrincipal()` - イベントの主体（ユーザー）を取得
- `getType()` - イベントタイプを取得
- `getData()` - イベントデータを取得

### 3.2 AuditEventRepository インターフェース

監査イベントを保存・検索するためのインターフェースです。

#### 主要メソッド
- `find(principal, after, type)` - 条件に合致する監査イベントを検索
- `add(AuditEvent)` - 新しい監査イベントを追加

#### 実装クラス
- `InMemoryAuditEventRepository` - メモリ内に監査イベントを保存（開発/テスト用）
- `JdbcAuditEventRepository` - JDBCを使用してデータベースに監査イベントを保存

### 3.3 AuditLog アノテーション

監査ログを宣言的に記録するためのSpring AOPアノテーションです。

#### 主要属性
- `action` - 実行される操作（String）
- `targetType` - 操作対象の種類（String）
- `targetIdExpression` - 対象IDを取得するSpEL式（String）
- `detailsExpression` - 詳細情報を取得するSpEL式（String）

### 3.4 AuditLogAspect クラス

`@AuditLog`アノテーションを処理するSpring AOPアスペクトクラスです。

#### 主要責務
- アノテーション付きメソッドのインターセプト
- SpEL式による動的な値解決
- 監査イベントの作成と発行

#### 主要メソッド
- `auditMethod(ProceedingJoinPoint, AuditLog)` - アノテーション処理の主メソッド
- `resolveExpression(String, EvaluationContext)` - SpEL式を評価して値を取得

### 3.5 AuditEventListener クラス

Spring ApplicationEventListenerとして監査イベントを処理するクラスです。

#### 主要責務
- 監査イベントのリスニング
- 監査ログへの記録
- 追加処理（DB保存など）の実行

#### 主要メソッド
- `onApplicationEvent(AuditApplicationEvent)` - 監査イベント処理メソッド

### 3.6 AuditLogFilter クラス

Spring Security Filterとして動作し、HTTP認証イベントを監査するクラスです。

#### 主要責務
- 認証成功/失敗イベントのキャプチャ
- 認証対象リクエストの監査ログ記録
- Spring Securityとの連携

#### 主要メソッド
- `doFilterInternal(HttpServletRequest, HttpServletResponse, FilterChain)` - フィルタ処理

## 4. 設定詳細

### 4.1 Spring Securityとの統合設定

Spring Security監査設定の例：

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public AuditEventRepository auditEventRepository() {
        return new JdbcAuditEventRepository(dataSource);
    }
    
    @Bean
    public AuditListener auditListener(AuditEventRepository auditEventRepository) {
        return new AuditListener(auditEventRepository);
    }
    
    @Bean
    public AuthenticationAuditListener authenticationAuditListener() {
        return new AuthenticationAuditListener();
    }
    
    @Bean
    public AuthorizationAuditListener authorizationAuditListener() {
        return new AuthorizationAuditListener();
    }
}
```

### 4.2 監査ログのLogback設定

監査ログ専用のLogback設定：

```xml
<!-- logback-spring.xml内の監査ログ設定 -->
<appender name="AUDIT_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>logs/audit.log</file>
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
        <fileNamePattern>logs/audit-%d{yyyy-MM-dd}.log</fileNamePattern>
        <maxHistory>730</maxHistory> <!-- 2年分 -->
        <totalSizeCap>20GB</totalSizeCap>
    </rollingPolicy>
    <encoder class="net.logstash.logback.encoder.LogstashEncoder">
        <includeMdc>true</includeMdc>
        <customFields>{"application":"${appName}","type":"audit"}</customFields>
    </encoder>
</appender>

<!-- 監査ログ専用のロガー -->
<logger name="jp.co.sesmanager.common.logging.audit" level="INFO" additivity="false">
    <appender-ref ref="AUDIT_FILE" />
</logger>
```

### 4.3 アプリケーションプロパティ設定

監査ログの設定例：

```yaml
# application.yml
sesmanager:
  audit:
    enabled: true
    log-to-file: true
    log-to-database: true
    retention-days:
      authentication: 730  # 2年
      authorization: 730   # 2年
      data-modification: 365 # 1年
      system-config: 730   # 2年
      business-operation: 90 # 3ヶ月
```

## 5. 使用例

### 5.1 アノテーションを使用した宣言的監査ログ記録

Spring AOPアノテーションを使った監査ログ記録：

```java
import jp.co.sesmanager.common.logging.audit.AuditLog;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    // ユーザー作成時に監査ログを記録
    @AuditLog(
        action = "CREATE",
        targetType = "USER",
        targetIdExpression = "result.id", // 戻り値から対象IDを取得
        detailsExpression = "'ユーザー作成: ' + #userDto.username"
    )
    public User createUser(UserDto userDto) {
        // ユーザー作成ロジック
        User user = new User();
        user.setUsername(userDto.getUsername());
        // 他のフィールド設定
        
        userRepository.save(user);
        return user;
    }

    // ユーザー更新時に監査ログを記録
    @AuditLog(
        action = "UPDATE",
        targetType = "USER",
        targetIdExpression = "#userId",
        detailsExpression = "'ユーザー更新: ' + #userId + ', 変更項目: ' + #updateDto.getChangedFields()"
    )
    public User updateUser(String userId, UserUpdateDto updateDto) {
        // ユーザー更新ロジック
        // ...
        return updatedUser;
    }
}
```

### 5.2 ApplicationEventPublisherによる明示的な監査イベント発行

Spring Eventを使った監査イベント発行：

```java
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.security.authentication.event.AbstractAuthenticationEvent;
import org.springframework.stereotype.Service;

@Service
public class ContractService {

    private final ApplicationEventPublisher eventPublisher;
    
    public ContractService(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }
    
    public Contract approveContract(String contractId, String approverComments) {
        try {
            // 監査イベント - 操作開始
            Map<String, Object> auditData = new HashMap<>();
            auditData.put("contractId", contractId);
            auditData.put("operation", "CONTRACT_APPROVAL");
            auditData.put("comments", approverComments);
            
            AuditEvent attemptEvent = new AuditEvent(
                SecurityContextHolder.getContext().getAuthentication().getName(),
                "CONTRACT_APPROVAL_ATTEMPT",
                auditData
            );
            eventPublisher.publishEvent(attemptEvent);
            
            // 契約承認処理
            Contract contract = contractRepository.findById(contractId)
                .orElseThrow(() -> new NotFoundException("契約が見つかりません: " + contractId));
            
            // ビジネスロジック
            contract.setStatus(ContractStatus.APPROVED);
            contract.setApproverComments(approverComments);
            contract.setApprovedAt(LocalDateTime.now());
            
            Contract savedContract = contractRepository.save(contract);
            
            // 監査イベント - 操作成功
            auditData.put("result", "SUCCESS");
            auditData.put("approvedAt", contract.getApprovedAt().toString());
            
            AuditEvent successEvent = new AuditEvent(
                SecurityContextHolder.getContext().getAuthentication().getName(),
                "CONTRACT_APPROVAL_SUCCESS",
                auditData
            );
            eventPublisher.publishEvent(successEvent);
            
            return savedContract;
            
        } catch (Exception e) {
            // 監査イベント - 操作失敗
            Map<String, Object> auditData = new HashMap<>();
            auditData.put("contractId", contractId);
            auditData.put("operation", "CONTRACT_APPROVAL");
            auditData.put("result", "FAILURE");
            auditData.put("reason", e.getMessage());
            
            AuditEvent failureEvent = new AuditEvent(
                SecurityContextHolder.getContext().getAuthentication().getName(),
                "CONTRACT_APPROVAL_FAILURE",
                auditData
            );
            eventPublisher.publishEvent(failureEvent);
            
            throw e;
        }
    }
}
```

### 5.3 Spring Securityの監査イベントのカスタマイズ

Spring Securityのデフォルト監査イベントのカスタマイズ例：

```java
import org.springframework.boot.actuate.security.AuthenticationAuditListener;
import org.springframework.context.event.EventListener;
import org.springframework.security.authentication.event.AbstractAuthenticationEvent;
import org.springframework.security.authentication.event.AuthenticationSuccessEvent;
import org.springframework.security.authentication.event.AuthenticationFailureBadCredentialsEvent;
import org.springframework.stereotype.Component;

@Component
public class CustomAuthenticationAuditListener extends AuthenticationAuditListener {

    private final AuditLogger auditLogger;
    
    public CustomAuthenticationAuditListener(AuditLogger auditLogger) {
        this.auditLogger = auditLogger;
    }
    
    @EventListener
    public void onAuthenticationSuccess(AuthenticationSuccessEvent event) {
        String principal = event.getAuthentication().getName();
        Map<String, Object> data = new HashMap<>();
        data.put("method", "login");
        data.put("roles", event.getAuthentication().getAuthorities().stream()
                .map(Object::toString)
                .collect(Collectors.toList()));
        
        // カスタム監査ログ出力
        auditLogger.logAuditEvent(
            "LOGIN",
            "AUTHENTICATION",
            principal,
            "ログイン成功: " + principal,
            "SUCCESS"
        );
    }
    
    @EventListener
    public void onAuthenticationFailure(AuthenticationFailureBadCredentialsEvent event) {
        String principal = event.getAuthentication().getName();
        
        // カスタム監査ログ出力
        auditLogger.logAuditEvent(
            "LOGIN",
            "AUTHENTICATION",
            principal,
            "ログイン失敗: " + principal + ", 理由: 不正な認証情報",
            "FAILURE"
        );
    }
}
```

### 5.4 バッチ処理での監査ログ記録

Spring Batchジョブでの監査ログ記録例：

```java
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;

@Component
public class BatchAuditListener implements JobExecutionListener {
    
    private final ApplicationEventPublisher eventPublisher;
    
    public BatchAuditListener(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }
    
    @Override
    public void beforeJob(JobExecution jobExecution) {
        String jobName = jobExecution.getJobInstance().getJobName();
        String jobId = String.valueOf(jobExecution.getJobId());
        
        // バッチ開始のシステム監査イベント
        Map<String, Object> auditData = new HashMap<>();
        auditData.put("jobName", jobName);
        auditData.put("jobParameters", jobExecution.getJobParameters().toString());
        
        AuditEvent auditEvent = new AuditEvent(
            "SYSTEM",
            "BATCH_JOB_START",
            auditData
        );
        
        eventPublisher.publishEvent(auditEvent);
    }
    
    @Override
    public void afterJob(JobExecution jobExecution) {
        String jobName = jobExecution.getJobInstance().getJobName();
        String jobId = String.valueOf(jobExecution.getJobId());
        
        // 実行結果の詳細情報
        Map<String, Object> auditData = new HashMap<>();
        auditData.put("jobName", jobName);
        auditData.put("status", jobExecution.getStatus().toString());
        auditData.put("startTime", jobExecution.getStartTime().toString());
        auditData.put("endTime", jobExecution.getEndTime().toString());
        auditData.put("durationMs", 
            jobExecution.getEndTime().getTime() - jobExecution.getStartTime().getTime());
        
        AuditEvent auditEvent = new AuditEvent(
            "SYSTEM",
            "BATCH_JOB_COMPLETE",
            auditData
        );
        
        eventPublisher.publishEvent(auditEvent);
    }
}
```

## 6. 例外処理

### 6.1 監査ログ記録失敗時の対応

監査ログ記録に失敗した場合の例外処理を実装します。主なポイントは以下の通りです：

```java
@Component
public class AuditEventListener {

    private static final Logger logger = LoggerFactory.getLogger(AuditEventListener.class);
    
    @EventListener
    public void handleAuditEvent(AuditEvent event) {
        try {
            // 監査ログ記録処理
            // ...
        } catch (Exception e) {
            // システムログにエラーを記録するが、アプリケーション処理は中断しない
            logger.error("監査ログの記録に失敗しました: {}", e.getMessage(), e);
            
            // 重要な監査イベントの場合は別手段で通知
            if (isHighPriorityAudit(event)) {
                sendAlertNotification(event, e);
            }
        }
    }
    
    private boolean isHighPriorityAudit(AuditEvent event) {
        // 優先度の高い監査イベント判定ロジック
        return event.getType().startsWith("SECURITY_") || 
               event.getType().startsWith("AUTH_") ||
               event.getType().contains("_ADMIN_");
    }
    
    private void sendAlertNotification(AuditEvent event, Exception error) {
        // 重要な監査イベント記録失敗時のバックアップ通知処理
        // ...
    }
}
```

### 6.2 Spring Retryによるリトライ処理

`@Retryable`アノテーションを使用した監査ログ記録のリトライ処理：

```java
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Component;

@Component
public class AuditRepository {

    private static final Logger logger = LoggerFactory.getLogger(AuditRepository.class);
    
    @Retryable(
        value = { DataAccessException.class, TransientDataAccessException.class },
        maxAttempts = 3,
        backoff = @Backoff(delay = 1000, multiplier = 2)
    )
    public void saveAuditEvent(AuditEvent event) {
        try {
            // 監査イベントをDBに保存
            jdbcTemplate.update(
                "INSERT INTO audit_events (principal, type, timestamp, data) VALUES (?, ?, ?, ?)",
                event.getPrincipal(),
                event.getType(),
                new Timestamp(event.getTimestamp().toEpochMilli()),
                serializeData(event.getData())
            );
        } catch (Exception e) {
            logger.warn("監査イベント保存に失敗しました。リトライします: {}", e.getMessage());
            throw e; // リトライのために例外を再スロー
        }
    }
}
```

## 7. セキュリティ考慮事項

### 7.1 監査ログの保護

監査ログの不正な変更や削除を防止するための対策を実装します：

```java
@Configuration
public class AuditSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .antMatcher("/api/audit/**")
            .authorizeRequests()
                .anyRequest().hasRole("AUDIT_ADMIN")
            .and()
            .httpBasic()
            .and()
            .csrf().disable();
    }
}
```

### 7.2 監査ログのマスキング処理

機密情報のマスキング処理：

```java
@Component
public class AuditDataMasker {

    private static final Pattern CREDIT_CARD_PATTERN = 
        Pattern.compile("\\b(?:\\d{4}-){3}\\d{4}\\b|\\b\\d{16}\\b");
    private static final Pattern EMAIL_PATTERN = 
        Pattern.compile("\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\b");
    
    public Map<String, Object> maskSensitiveData(Map<String, Object> data) {
        Map<String, Object> maskedData = new HashMap<>(data);
        
        // パスワードフィールドの完全除去
        maskedData.remove("password");
        maskedData.remove("secret");
        maskedData.remove("token");
        
        // クレジットカード番号のマスキング
        maskedKeys(maskedData, "card", "creditCard", "cardNumber")
            .forEach(key -> {
                Object value = maskedData.get(key);
                if (value instanceof String) {
                    maskedData.put(key, maskCreditCard((String) value));
                }
            });
        
        // メールアドレスの部分マスキング
        maskedKeys(maskedData, "email", "mail", "emailAddress")
            .forEach(key -> {
                Object value = maskedData.get(key);
                if (value instanceof String) {
                    maskedData.put(key, maskEmail((String) value));
                }
            });
        
        return maskedData;
    }
    
    private List<String> maskedKeys(Map<String, Object> data, String... patterns) {
        return data.keySet().stream()
            .filter(key -> Arrays.stream(patterns)
                .anyMatch(pattern -> key.toLowerCase().contains(pattern.toLowerCase())))
            .collect(Collectors.toList());
    }
    
    private String maskCreditCard(String value) {
        return CREDIT_CARD_PATTERN.matcher(value)
            .replaceAll(matchResult -> "************" + matchResult.group().substring(matchResult.group().length() - 4));
    }
    
    private String maskEmail(String value) {
        return EMAIL_PATTERN.matcher(value)
            .replaceAll(matchResult -> {
                String[] parts = matchResult.group().split("@");
                if (parts.length == 2) {
                    String username = parts[0];
                    return username.substring(0, Math.min(3, username.length())) + "***@" + parts[1];
                }
                return matchResult.group();
            });
    }
}
```

## 8. バージョン履歴

| バージョン | 更新日     | 担当者    | 変更内容                                |
|----------|------------|---------|--------------------------------------|
| 0.1      | 2023/10/01 | 山田太郎  | 初版作成                               |
| 0.2      | 2023/11/15 | 佐藤次郎  | セキュリティ強化対応追加                   |
| 0.3      | 2024/01/20 | 鈴木三郎  | REST API監査ログ機能追加                 |
| 0.4      | 2024/05/10 | 一丸柴也  | 実装コードを削除し、設計情報のみに修正     |
| 0.5      | 2024/05/15 | 一丸柴也  | Spring標準機能を活用した設計に変更        |