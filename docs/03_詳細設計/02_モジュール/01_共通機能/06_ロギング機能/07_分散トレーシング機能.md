# 分散トレーシング機能

## 1. 機能概要

分散トレーシング機能は、マイクロサービスアーキテクチャや複雑なシステム内で、リクエストの流れを追跡し、処理の依存関係やボトルネックを可視化するための機能です。Spring Boot 3に標準搭載されたMicrometer Tracingを活用し、トレースIDとスパンIDを使用して関連する処理を紐付け、エンドツーエンドの処理フローと実行時間の分析を可能にします。

### 1.1 機能の目的

- 複数サービスにまたがるリクエストの追跡
- エンドツーエンドの処理フローの可視化
- サービス間の依存関係やレイテンシの把握
- 障害発生時の原因特定の効率化
- システム全体のパフォーマンス分析
- マイクロサービス間の処理連携の最適化

### 1.2 主要機能

- Micrometer TracingによるトレースIDとスパンIDの生成と管理
- OpenTelemetryによる標準化されたトレースデータの収集
- Spring WebとWebFlux両方に対応したトレーシング
- Spring Cloudとの統合によるサービス間でのトレースコンテキスト伝播
- ログへのトレース情報の自動付加
- Zipkin、Jaeger、Tempo等のバックエンドシステムとの連携
- バゲージアイテムによる追加コンテキスト情報の伝播

## 2. 処理フロー

### 2.1 トレース生成と伝播の基本フロー

```
1. リクエスト受信
   a. Micrometer Tracingによるリクエスト処理のインターセプト
   b. HTTP HeaderからのトレースコンテキスとSamplingの判断
   c. 既存のコンテキストがある場合は使用、ない場合は新規作成
   d. トレースIDとルートスパンIDの生成または抽出
   e. トレースコンテキストの初期化とMDC設定

2. サービス内処理
   a. Tracer.spanBuilderによる子スパンの作成
   b. 子スパンの開始と実行
   c. スパンへのタグやイベント情報付加
   d. 子スパンの終了

3. 外部サービス呼び出し
   a. RestTemplateやWebClientの自動インストルメント
   b. W3CやB3形式によるHTTPヘッダーへのトレース情報伝播
   c. 外部サービスでのトレース継続
   d. クライアント/サーバースパンの自動作成

4. レスポンス返却
   a. ルートスパンの終了
   b. トレース情報のエクスポート
   c. MDCからのトレース情報クリア
```

### 2.2 トレース情報収集フロー

```
1. トレースデータの生成
   a. 各スパンの開始/終了時の時刻情報記録
   b. タグやイベント、ステータス情報の収集
   c. サンプリング判定に基づく処理

2. トレースデータのエクスポート
   a. 設定済みのExporterへのスパン情報送信
   b. 非同期バッチ処理によるパフォーマンス最適化
   c. エクスポートバッファとサイズ管理

3. トレースデータの保存と処理
   a. Zipkin/Jaeger/Tempoなどのバックエンドでのデータ受信
   b. トレースデータの永続化
   c. トレースデータのインデックス化と関連付け

4. トレースデータの可視化
   a. サービスグラフの生成
   b. スパンタイムラインの表示
   c. 処理時間統計の提供
   d. ボトルネック検出ロジックの適用
```

## 3. 主要コンポーネント構成

### 3.1 Tracer インターフェース

Micrometer Tracingの中核となるインターフェースです。

#### 主要責務
- 新しいスパンの作成と管理
- 現在のスパンコンテキストの取得
- トレースIDの生成と管理
- スパンのライフサイクル（開始・終了）の制御

#### 主要メソッド
- `spanBuilder(String name)` - 新しいスパンビルダーを作成
- `currentSpan()` - 現在のスパンを取得
- `withSpan(Span span, Runnable runnable)` - 特定のスパンコンテキストでコードを実行

### 3.2 Span インターフェース

個々の処理単位を表すスパンを定義するインターフェースです。

#### 主要責務
- スパンの開始と終了
- タグとイベントの記録
- スパンの状態管理
- 親子関係の維持

#### 主要メソッド
- `start()` - スパンを開始
- `end()` - スパンを終了
- `tag(String key, String value)` - タグを追加
- `event(String name)` - イベントを記録
- `error(Throwable throwable)` - エラー情報を記録

### 3.3 Propagator インターフェース

トレースコンテキストを異なるサービス間で伝播するためのインターフェースです。

#### 主要責務
- トレースコンテキストのキャリア（HTTPヘッダーなど）への注入
- キャリアからのトレースコンテキスト抽出
- 異なるプロパゲーションフォーマット間の変換

#### 主要メソッド
- `inject(Context context, C carrier, Setter<C> setter)` - コンテキストをキャリアに注入
- `extract(C carrier, Getter<C> getter)` - キャリアからコンテキストを抽出

### 3.4 SamplerFunction インターフェース

トレースのサンプリング判定を行うインターフェースです。

#### 主要責務
- トレースをサンプリングするかどうかの判定
- サンプリングレートの制御
- サンプリング決定の記録

#### 主要メソッド
- `trySample(Context context)` - サンプリング判定を行う

### 3.5 SpanExporter インターフェース

完了したスパンを外部システムにエクスポートするインターフェースです。

#### 主要責務
- 完了したスパンのバッファリング
- バックエンドシステムへのデータ送信
- エクスポート失敗時のリトライ

#### 主要メソッド
- `export(Collection<SpanData> spans)` - スパンをエクスポート
- `flush()` - バッファをフラッシュ
- `shutdown()` - エクスポーターをシャットダウン

## 4. 設定詳細

### 4.1 Spring Boot 3 Micrometer Tracing設定

Spring Bootアプリケーションの基本的なトレーシング設定：

```yaml
# application.yml
management:
  tracing:
    sampling:
      probability: 1.0  # 0.0-1.0の範囲でサンプリング確率を設定
    baggage:
      correlation:
        enabled: true  # バゲージ相関の有効化
        fields: tenant-id,customer-id  # 相関に含めるフィールド
    propagation:
      type: w3c  # W3C TraceContextフォーマットを使用

  zipkin:
    tracing:
      endpoint: http://zipkin:9411/api/v2/spans  # Zipkinバックエンド

  metrics:
    distribution:
      percentiles-histogram:
        http.server.requests: true  # HTTPリクエストのヒストグラム有効化

logging:
  pattern:
    level: "%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]"  # ログへのトレースID・スパンID追加
```

### 4.2 依存関係設定

トレーシング機能を有効化するための依存関係定義：

```groovy
// build.gradle
dependencies {
    // Spring Boot Actuator (メトリクスとトレース用)
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    
    // Micrometer Tracing
    implementation 'io.micrometer:micrometer-tracing-bridge-otel'
    
    // OpenTelemetry Instrumentation
    implementation 'io.opentelemetry:opentelemetry-api'
    implementation 'io.opentelemetry:opentelemetry-sdk'
    implementation 'io.opentelemetry:opentelemetry-exporter-zipkin'
    
    // RestTemplate/WebClient自動インストルメント
    implementation 'io.micrometer:micrometer-tracing-bridge-brave'
    implementation 'org.springframework.cloud:spring-cloud-starter-sleuth-otel'
}
```

### 4.3 カスタム設定クラス

カスタムトレーシング設定例：

```java
@Configuration
public class TracingConfig {

    @Bean
    public SamplerFunction<String> customSampler() {
        return new SamplerFunction<String>() {
            @Override
            public boolean trySample(Context context, String s) {
                // 特定のパスは必ずサンプリング
                if (s.startsWith("/api/important") || s.contains("/payment/")) {
                    return true;
                }
                // その他は50%の確率でサンプリング
                return Math.random() < 0.5;
            }
        };
    }
    
    @Bean
    public SpanCustomizer spanCustomizer() {
        return new SpanCustomizer() {
            @Override
            public SpanCustomizer tag(String key, String value) {
                // アプリケーション固有のタグをすべてのスパンに追加
                if (key.equals("sensitive-data")) {
                    // 機密データをマスク
                    return Span.current().tag(key, maskSensitiveData(value));
                }
                return Span.current().tag(key, value);
            }
            
            @Override
            public SpanCustomizer event(String value) {
                return Span.current().event(value);
            }
            
            @Override
            public SpanCustomizer name(String name) {
                return Span.current().name(name);
            }
        };
    }
}
```

## 5. 使用例

### 5.1 基本的なトレーシング

```java
import io.micrometer.observation.annotation.Observed;
import org.springframework.stereotype.Service;

@Service
public class OrderService {

    private final Tracer tracer;
    
    public OrderService(Tracer tracer) {
        this.tracer = tracer;
    }
    
    // 自動観測アノテーションによるトレーシング
    @Observed(name = "order.processing", 
              contextualName = "process-order",
              lowCardinalityKeyValues = {"service", "order-service"})
    public Order processOrder(OrderRequest request) {
        // ビジネスロジック
        return createOrder(request);
    }
    
    // 明示的なスパン作成
    public OrderSummary generateOrderSummary(String orderId) {
        // 子スパン作成
        Span span = tracer.spanBuilder("generate-order-summary")
            .setAttribute("order.id", orderId)
            .startSpan();
        
        try (Scope scope = span.makeCurrent()) {
            // データ取得
            Order order = findOrder(orderId);
            // サマリー生成
            return createSummary(order);
        } catch (Exception e) {
            span.recordException(e);
            span.setStatus(StatusCode.ERROR);
            throw e;
        } finally {
            span.end(); // スパン終了
        }
    }
    
    // ヘルパーメソッド
    private Order findOrder(String orderId) {
        // スパンイベント記録例
        Span.current().addEvent("find-order-start");
        // 実際の処理
        Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new NotFoundException("Order not found: " + orderId));
        Span.current().addEvent("find-order-end");
        return order;
    }
}
```

### 5.2 RestTemplateとWebClientの自動インストルメント

```java
@Configuration
public class HttpClientConfig {

    // RestTemplateにトレーシング機能を自動適用（Bean定義のみで有効化）
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
    
    // WebClientにトレーシング機能を自動適用（Bean定義のみで有効化）
    @Bean
    public WebClient webClient() {
        return WebClient.builder().build();
    }
    
    // 使用例
    @Service
    public class ProductService {
        private final RestTemplate restTemplate;
        private final WebClient webClient;
        
        public ProductService(RestTemplate restTemplate, WebClient webClient) {
            this.restTemplate = restTemplate;
            this.webClient = webClient;
        }
        
        // RestTemplateでの外部サービス呼び出し（トレースコンテキスト自動伝播）
        public Product getProductDetails(String productId) {
            return restTemplate.getForObject(
                "http://product-service/products/{id}", 
                Product.class, 
                productId
            );
        }
        
        // WebClientでの外部サービス呼び出し（トレースコンテキスト自動伝播）
        public Mono<Review> getProductReviews(String productId) {
            return webClient.get()
                .uri("http://review-service/reviews?productId={id}", productId)
                .retrieve()
                .bodyToMono(Review.class);
        }
    }
}
```

### 5.3 バゲージアイテムの使用

```java
@Component
public class TenantContextPropagator {

    private final BaggageManager baggageManager;
    
    public TenantContextPropagator(BaggageManager baggageManager) {
        this.baggageManager = baggageManager;
    }
    
    // テナントコンテキストをバゲージに設定
    public void setTenantContext(String tenantId) {
        BaggageField tenantField = baggageManager.getBaggageField("tenant-id");
        if (tenantField != null) {
            tenantField.updateValue(tenantId);
        }
    }
    
    // バゲージからテナントコンテキストを取得
    public String getTenantContext() {
        BaggageField tenantField = baggageManager.getBaggageField("tenant-id");
        return tenantField != null ? tenantField.getValue() : null;
    }
    
    // サービス層での使用例
    @Service
    public class MultiTenantService {
        private final TenantContextPropagator tenantContextPropagator;
        
        public MultiTenantService(TenantContextPropagator tenantContextPropagator) {
            this.tenantContextPropagator = tenantContextPropagator;
        }
        
        public void processTenantSpecificData(String tenantId, String data) {
            // バゲージにテナントIDを設定（サービス間で伝播）
            tenantContextPropagator.setTenantContext(tenantId);
            
            // この後の処理や外部サービス呼び出しでテナントコンテキストが利用可能
            processData(data);
        }
        
        private void processData(String data) {
            // バゲージからテナントIDを取得
            String currentTenant = tenantContextPropagator.getTenantContext();
            // テナント固有の処理を実行
            // ...
        }
    }
}
```

### 5.4 カスタムスパンタグとイベントの追加

```java
@Service
public class PaymentService {

    private final Tracer tracer;
    
    public PaymentService(Tracer tracer) {
        this.tracer = tracer;
    }
    
    public PaymentResult processPayment(PaymentRequest request) {
        // 現在のスパンを取得
        Span currentSpan = tracer.currentSpan();
        
        // 業務情報をスパンにタグとして追加
        currentSpan.tag("payment.amount", String.valueOf(request.getAmount()));
        currentSpan.tag("payment.method", request.getMethod().name());
        currentSpan.tag("payment.currency", request.getCurrency());
        currentSpan.tag("customer.id", request.getCustomerId());
        
        try {
            // 処理開始イベントを記録
            currentSpan.event("payment-processing-start");
            
            // 実際の支払い処理
            PaymentResult result = executePayment(request);
            
            // 結果をタグとして追加
            currentSpan.tag("payment.status", result.getStatus().name());
            currentSpan.tag("payment.transaction_id", result.getTransactionId());
            
            // 処理終了イベントを記録
            currentSpan.event("payment-processing-end");
            
            return result;
        } catch (Exception e) {
            // エラー情報をスパンに記録
            currentSpan.error(e);
            currentSpan.tag("payment.error", e.getClass().getSimpleName());
            currentSpan.tag("payment.error_message", e.getMessage());
            currentSpan.event("payment-processing-error");
            throw e;
        }
    }
}
```

### 5.5 非同期処理でのトレースコンテキスト伝播

```java
@Service
public class AsyncTaskService {

    private final Tracer tracer;
    private final TaskExecutor taskExecutor;
    
    public AsyncTaskService(Tracer tracer, TaskExecutor taskExecutor) {
        this.tracer = tracer;
        this.taskExecutor = taskExecutor;
    }
    
    // 非同期処理でのトレースコンテキスト伝播
    public CompletableFuture<ProcessingResult> processAsync(String taskId) {
        // 現在のトレースコンテキストを取得
        Span parentSpan = tracer.currentSpan();
        
        return CompletableFuture.supplyAsync(() -> {
            // 子スパンを作成し、親スパンとリンク
            Span childSpan = tracer.spanBuilder("async-processing")
                .setParent(Context.current().with(parentSpan))
                .startSpan();
            
            try (Scope scope = childSpan.makeCurrent()) {
                childSpan.tag("task.id", taskId);
                childSpan.event("async-processing-start");
                
                // 非同期処理ロジック
                ProcessingResult result = performProcessing(taskId);
                
                childSpan.tag("processing.status", result.getStatus().name());
                childSpan.event("async-processing-end");
                return result;
            } catch (Exception e) {
                childSpan.recordException(e);
                childSpan.setStatus(StatusCode.ERROR);
                throw e;
            } finally {
                childSpan.end();
            }
        }, taskExecutor);
    }
}
```

## 6. 例外処理

### 6.1 トレーシングのエラーハンドリング

トレーシング処理中の例外をハンドリングして、アプリケーションの動作に影響を与えないようにします：

```java
@Component
public class TracingErrorHandler {

    private static final Logger logger = LoggerFactory.getLogger(TracingErrorHandler.class);
    
    @EventListener
    public void handleTracingError(MicrometerTracingErrors.TracingCreateSpanError event) {
        logger.warn("Failed to create span: {}", event.getCause().getMessage());
        // エラーメトリクス更新やアラート発報
    }
    
    @EventListener
    public void handleExportError(SpanExportFailedEvent event) {
        logger.error("Failed to export spans: {}", event.getCause().getMessage());
        // バックオフやリトライ処理
    }
}
```

### 6.2 障害追跡のためのエラースパン強化

エラー発生時に詳細な情報をスパンに記録し、障害追跡を容易にします：

```java
@ControllerAdvice
public class GlobalExceptionHandler {

    private final Tracer tracer;
    
    public GlobalExceptionHandler(Tracer tracer) {
        this.tracer = tracer;
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception ex, HttpServletRequest request) {
        // 現在のスパンを取得
        Span currentSpan = tracer.currentSpan();
        
        if (currentSpan != null) {
            // エラー情報を詳細に記録
            currentSpan.error(ex);
            currentSpan.tag("error.type", ex.getClass().getName());
            currentSpan.tag("error.message", ex.getMessage());
            currentSpan.tag("error.stacktrace", getStackTraceAsString(ex));
            currentSpan.tag("http.path", request.getRequestURI());
            currentSpan.tag("http.method", request.getMethod());
            
            // エラーイベントを記録
            currentSpan.event("error-occurred");
        }
        
        // エラーレスポンスを返却
        ErrorResponse errorResponse = new ErrorResponse(
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            ex.getMessage(),
            request.getRequestURI(),
            LocalDateTime.now()
        );
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
    }
    
    private String getStackTraceAsString(Exception ex) {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        ex.printStackTrace(pw);
        return sw.toString();
    }
}
```

### 6.3 サンプリングエラーの対応

サンプリング判定中のエラーに対する対応：

```java
@Configuration
public class TracingSamplingConfig {

    private static final Logger logger = LoggerFactory.getLogger(TracingSamplingConfig.class);
    
    @Bean
    public SamplerFunction<String> robustSampler() {
        return new SamplerFunction<String>() {
            @Override
            public boolean trySample(Context context, String s) {
                try {
                    // 通常のサンプリング判定ロジック
                    return performSamplingDecision(context, s);
                } catch (Exception e) {
                    // サンプリング判定中のエラーを記録
                    logger.warn("Error in sampling decision: {}", e.getMessage());
                    // 安全策としてサンプリングしない
                    return false;
                }
            }
        };
    }
    
    private boolean performSamplingDecision(Context context, String s) {
        // 実際のサンプリング判定ロジック
        // ...
        return true;
    }
}
```

## 7. パフォーマンス考慮事項

### 7.1 適切なサンプリングレートの設定

トレーシングオーバーヘッドを制御するためのサンプリング設定：

```yaml
# application.yml (本番環境向け)
management:
  tracing:
    sampling:
      probability: 0.1  # 10%のサンプリングレート
```

### 7.2 スパンデータのバッチ処理とバッファ設定

スパンデータのエクスポート効率を最適化する設定：

```java
@Configuration
public class TracingExportConfig {

    @Bean
    public SpanExporter customizedZipkinExporter(@Value("${management.zipkin.tracing.endpoint}") String endpoint) {
        return ZipkinSpanExporter.builder()
            .setEndpoint(endpoint)
            .setBatchSize(100)  // バッチサイズの最適化
            .setMaxExportBatchSize(1000)  // 最大バッチサイズ
            .setMaxQueueSize(10000)  // キューサイズの最適化
            .setExportTimeout(Duration.ofSeconds(10))  // タイムアウト設定
            .build();
    }
}
```

### 7.3 環境別のトレーシング設定

環境に応じたトレーシング設定の最適化：

```yaml
# application.yml
spring:
  config:
    activate:
      on-profile: dev
management:
  tracing:
    sampling:
      probability: 1.0  # 開発環境では全てトレース
    propagation:
      type: w3c,b3  # 開発環境では複数フォーマットをサポート

---
spring:
  config:
    activate:
      on-profile: prod
management:
  tracing:
    sampling:
      probability: 0.1  # 本番環境では10%のみサンプリング
    propagation:
      type: w3c  # 本番環境では標準フォーマットのみ
    baggage:
      remote-fields: tenant-id  # 本番環境では必要最小限のバゲージのみ伝播
```

## 8. バージョン履歴

| バージョン | 更新日     | 担当者    | 変更内容                                |
|----------|------------|---------|--------------------------------------|
| 0.1      | 2023/10/01 | 山田太郎  | 初版作成                               |
| 0.2      | 2023/11/15 | 佐藤次郎  | メッセージキュー対応追加                   |
| 0.3      | 2024/01/20 | 鈴木三郎  | WebClient対応追加                      |
| 0.4      | 2024/05/10 | 一丸柴也  | 実装コードを削除し、設計情報のみに修正     |
| 0.5      | 2024/05/15 | 一丸柴也  | Spring Boot 3とMicrometer Tracingを活用した設計に変更 |