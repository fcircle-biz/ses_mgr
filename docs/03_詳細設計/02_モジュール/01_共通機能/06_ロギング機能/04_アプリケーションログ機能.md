# アプリケーションログ機能

## 1. 機能概要

アプリケーションログ機能は、システムの動作状況、警告、エラーなどの情報を構造化されたフォーマットで記録する機能です。Spring Frameworkの標準ロギング機能（SLF4J + Logback）を活用し、すべてのモジュールから利用される基本的なロギング機能を提供します。システムの監視、障害調査、動作検証などに活用されます。

### 1.1 機能の目的

- システム動作状況の可視化と監視
- 例外発生時のエラー情報の詳細記録
- トラブルシューティングのための情報収集
- アプリケーションの動作証跡の保持
- システムの健全性確認

### 1.2 主要機能

- Spring標準のSLF4J APIによる異なるログレベル（ERROR, WARN, INFO, DEBUG, TRACE）での出力制御
- Logback設定による構造化ログフォーマット（JSON）の出力
- MDC（Mapped Diagnostic Context）による自動コンテキスト情報付加
- 例外情報の詳細記録
- ログローテーションと保持期間管理
- 環境別ログ設定の切り替え

## 2. 処理フロー

### 2.1 ログ出力の基本フロー

```
1. アプリケーションコードから SLF4J Logger インスタンスを取得
2. 適切なログレベルでメソッドを呼び出し
3. SLF4J が呼び出しをLogback実装にルーティング
4. ログレベルのフィルタリング（無効なレベルの場合は処理終了）
5. MDC（Mapped Diagnostic Context）からコンテキスト情報を取得
6. ログメッセージの整形（logstash-logback-encoder利用時はJSON形式に変換）
7. アペンダーによるログの出力（ファイル、コンソールなど）
8. 非同期処理の場合はキューに投入
```

### 2.2 ログ初期化フロー

```
1. Spring Bootアプリケーション起動時にLogback設定ファイルを自動読み込み
2. Spring Boot Logging Autoconfigが基本設定を適用
3. 環境変数またはシステムプロパティから設定値を解決
4. アペンダーの初期化（ファイル、コンソール、その他）
5. フィルターの設定
6. デフォルトMDC値の設定
7. 非同期アペンダーの初期化（使用する場合）
8. ロガーツリーの構成
```

### 2.3 例外ログ記録フロー

```
1. try-catchブロックでの例外捕捉
2. SLF4J Logger の error メソッド呼び出し（例外オブジェクト付き）
3. Logback設定に従った例外情報の整形と記録
4. スタックトレースの整形と記録
5. エラーコードと関連情報の付加
6. 構造化フォーマットでログ出力
```

## 3. 主要コンポーネント構成

### 3.1 Spring BootのLogback自動設定

Spring Bootは、アプリケーション起動時にロギング設定を自動的に行います。以下の優先順で設定ファイルを読み込みます。

1. クラスパスルートの `logback-spring.xml`
2. クラスパスルートの `logback-spring.groovy`
3. クラスパスルートの `logback.xml`
4. クラスパスルートの `logback.groovy`

#### 主要責務
- 適切なログレベルの設定
- ログフォーマットの定義
- アペンダーの設定と初期化
- プロファイル別の設定切り替え

### 3.2 SLF4J Logger インターフェース

Java標準のログAPI（SLF4J）を通じてログを出力するインターフェースです。

#### 主要メソッド
- `error(String message, Object... args)` - エラーレベルのログ出力
- `error(String message, Throwable t, Object... args)` - 例外情報付きエラーログ出力
- `warn(String message, Object... args)` - 警告レベルのログ出力
- `info(String message, Object... args)` - 情報レベルのログ出力
- `debug(String message, Object... args)` - デバッグレベルのログ出力
- `trace(String message, Object... args)` - トレースレベルのログ出力
- `isErrorEnabled()`, `isWarnEnabled()`, `isInfoEnabled()`, `isDebugEnabled()`, `isTraceEnabled()` - 各ログレベルが有効かチェック

### 3.3 MDC（Mapped Diagnostic Context）

ログメッセージに自動的に含まれるコンテキスト情報を管理するクラスです。

#### 主要メソッド
- `put(String key, String value)` - MDCにキーと値のペアを設定
- `get(String key)` - MDCから指定されたキーの値を取得
- `remove(String key)` - MDCから指定されたキーを削除
- `clear()` - MDCの全てのエントリをクリア

### 3.4 Logback設定コンポーネント

Logbackの設定を行うXMLベースのコンポーネントです。

#### 主要要素
- `<appender>` - ログの出力先を定義（ファイル、コンソール、非同期など）
- `<logger>` - 特定のロガー（パッケージ/クラス）に対するログレベル設定
- `<root>` - デフォルトのログレベル設定
- `<springProfile>` - Springプロファイルに基づいた条件付き設定
- `<property>` - プロパティ定義

### 3.5 LoggingSystemAutoConfiguration

Spring Bootのログシステム自動設定クラスです。

#### 主要責務
- ロギングシステムの自動検出と初期化
- プロパティからのログレベル設定の取得とロガー設定
- アプリケーション名などの自動設定

## 4. 設定詳細

### 4.1 アプリケーションプロパティによる設定

Spring Bootアプリケーションの`application.yml`または`application.properties`ファイルで基本的なロギング設定ができます。

```yaml
# application.yml例
logging:
  level:
    root: INFO
    jp.co.sesmanager: DEBUG
    org.springframework: WARN
  file:
    name: logs/application.log
    max-size: 100MB
    max-history: 30
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
```

### 4.2 Logback設定ファイル

より詳細な設定は`logback-spring.xml`ファイルで行います。JSON形式ログ出力、ログローテーション、非同期ロギングなどの高度な設定が可能です。

```xml
<!-- logback-spring.xml例 -->
<configuration>
  <!-- プロパティ設定 -->
  <springProperty scope="context" name="appName" source="spring.application.name" defaultValue="ses-mgr"/>
  <springProperty scope="context" name="logLevel" source="logging.level.root" defaultValue="INFO"/>
  
  <!-- コンソールアペンダー -->
  <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
    </encoder>
  </appender>
  
  <!-- JSON形式ファイルアペンダー -->
  <appender name="JSON_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>logs/${appName}.json</file>
    <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
      <fileNamePattern>logs/${appName}-%d{yyyy-MM-dd}.%i.json</fileNamePattern>
      <maxFileSize>100MB</maxFileSize>
      <maxHistory>30</maxHistory>
      <totalSizeCap>3GB</totalSizeCap>
    </rollingPolicy>
    <encoder class="net.logstash.logback.encoder.LogstashEncoder">
      <includeMdc>true</includeMdc>
      <includeContext>true</includeContext>
      <customFields>{"application":"${appName}","env":"${SPRING_PROFILES_ACTIVE:-dev}"}</customFields>
    </encoder>
  </appender>
  
  <!-- 非同期アペンダー -->
  <appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
    <discardingThreshold>0</discardingThreshold>
    <queueSize>512</queueSize>
    <appender-ref ref="JSON_FILE" />
  </appender>
  
  <!-- 環境別設定 -->
  <springProfile name="dev">
    <root level="INFO">
      <appender-ref ref="CONSOLE" />
      <appender-ref ref="ASYNC" />
    </root>
  </springProfile>
  
  <springProfile name="prod">
    <root level="WARN">
      <appender-ref ref="ASYNC" />
    </root>
  </springProfile>
  
  <!-- ロガーレベル設定 -->
  <logger name="jp.co.sesmanager" level="DEBUG" />
  <logger name="org.springframework" level="INFO" />
</configuration>
```

## 5. 使用例

### 5.1 基本的なログ出力

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SampleService {
    // ロガーの取得
    private static final Logger logger = LoggerFactory.getLogger(SampleService.class);
    
    public void processData(String id) {
        // INFOレベルのログ出力
        logger.info("処理を開始します: id={}", id);
        
        try {
            // 処理ロジック
            // ...
            
            // 処理完了のログ
            logger.info("処理が完了しました: id={}", id);
        } catch (Exception e) {
            // 例外情報付きエラーログ
            logger.error("処理中にエラーが発生しました: id={}", id, e);
            throw e;
        }
    }
    
    public void analyzeData(String id) {
        // 条件付きログ出力（パフォーマンス最適化）
        if (logger.isDebugEnabled()) {
            logger.debug("詳細分析情報: id={}, data={}", id, fetchDetailedData(id));
        }
        
        // 処理ロジック
    }
}
```

### 5.2 MDCを利用したコンテキスト情報の付加

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

public class TransactionService {
    private static final Logger logger = LoggerFactory.getLogger(TransactionService.class);
    
    public void executeTransaction(String transactionId, String userId) {
        // MDCにコンテキスト情報を設定
        MDC.put("transactionId", transactionId);
        MDC.put("userId", userId);
        
        try {
            // ビジネスロジック実行（ログ出力時に自動的にMDC情報が付加される）
            logger.info("トランザクション処理開始");
            processTransaction();
            logger.info("トランザクション処理完了");
        } finally {
            // MDCのクリーンアップ
            MDC.remove("transactionId");
            MDC.remove("userId");
        }
    }
    
    private void processTransaction() {
        // 処理ロジック
        // ...
        
        // 途中経過ログ（MDC情報は自動的に付加される）
        logger.info("支払い処理実行中");
    }
}
```

### 5.3 マーカーを使用したログのカテゴリ分け

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

public class SecurityService {
    private static final Logger logger = LoggerFactory.getLogger(SecurityService.class);
    
    // マーカーの定義
    private static final Marker SECURITY_MARKER = MarkerFactory.getMarker("SECURITY");
    private static final Marker AUDIT_MARKER = MarkerFactory.getMarker("AUDIT");
    
    public void login(String username) {
        // セキュリティマーカー付きのログ
        logger.info(SECURITY_MARKER, "ログイン試行: username={}", username);
        
        // 認証処理
        // ...
        
        // 監査マーカー付きのログ
        logger.info(AUDIT_MARKER, "ログイン成功: username={}", username);
    }
    
    public void changePermission(String username, String role) {
        // 複合的なマーカー
        logger.warn(SECURITY_MARKER, "権限変更: username={}, role={}", username, role);
    }
}
```

### 5.4 Spring Boot依存性注入環境での使用

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

@Service
public class CustomerService {
    // コンポーネントクラスでのロガー取得
    private static final Logger logger = LoggerFactory.getLogger(CustomerService.class);
    
    public void processCustomer(Customer customer) {
        logger.info("顧客処理開始: ID={}, 名前={}", customer.getId(), customer.getName());
        // 処理ロジック
    }
}
```

## 6. 例外処理

### 6.1 一般的な例外ハンドリング

ログ出力中の例外は基本的にキャッチして上位に伝播させません。ロギング処理の失敗がビジネスロジックに影響を与えないようにします。ただし、初期化時の例外は起動失敗として扱います。

```java
try {
    // 例外が発生する可能性のあるログ処理
    logger.info("複雑な処理結果: {}", generateComplexOutput());
} catch (Exception ex) {
    // ロギングの失敗はシステムログに記録するが、アプリケーション処理は継続
    System.err.println("ログ出力中にエラーが発生しました: " + ex.getMessage());
}
```

### 6.2 非同期ロギングの例外処理

Logbackの非同期アペンダー使用時の例外処理設定例：

```xml
<appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
    <!-- ディスカード閾値設定 (0=破棄しない, デフォルト=20%) -->
    <discardingThreshold>0</discardingThreshold>
    <!-- キューサイズ設定 (デフォルト=256) -->
    <queueSize>512</queueSize>
    <!-- キュー溢れ時の動作 (デフォルト=ASYNC_APPENDER_WAIT) -->
    <neverBlock>false</neverBlock>
    <!-- 非同期処理のタイムアウト (ミリ秒) -->
    <maxFlushTime>5000</maxFlushTime>
    <!-- 参照するアペンダー -->
    <appender-ref ref="FILE" />
</appender>
```

### 6.3 ディスク容量不足時の対応

ディスク容量不足時のフォールバック設定例：

```xml
<appender name="FAILSAFE" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
        <pattern>FAILSAFE [%thread] %-5level %logger{36} - %msg%n</pattern>
    </encoder>
</appender>

<root level="INFO">
    <appender-ref ref="FILE" />
    <appender-ref ref="FAILSAFE" />
</root>
```

## 7. パフォーマンス考慮事項

### 7.1 非同期ロギングの活用

パフォーマンスへの影響を最小限に抑えるための非同期ロギング設定：

```xml
<!-- 高性能な非同期アペンダー -->
<appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
    <queueSize>512</queueSize>
    <discardingThreshold>0</discardingThreshold>
    <includeCallerData>false</includeCallerData>
    <appender-ref ref="FILE" />
</appender>
```

### 7.2 条件付きログ出力

不要なログ処理コストを削減するための条件チェック：

```java
// DEBUGが有効な場合のみ実行（オブジェクト生成コストを削減）
if (logger.isDebugEnabled()) {
    logger.debug("詳細情報: {}", createExpensiveDetailString());
}

// TRACEが有効な場合のみ実行（大量データの文字列化コストを削減）
if (logger.isTraceEnabled()) {
    logger.trace("完全なデータダンプ: {}", dumpCompleteObjectState());
}
```

### 7.3 ログレベルの適切な使い分け

Spring Boot設定での環境別ログレベル設定例：

```yaml
# 開発環境設定
spring:
  profiles: dev
logging:
  level:
    root: INFO
    jp.co.sesmanager: DEBUG
    org.springframework: INFO

---
# テスト環境設定
spring:
  profiles: test
logging:
  level:
    root: INFO
    jp.co.sesmanager: INFO
    org.springframework: WARN

---
# 本番環境設定
spring:
  profiles: prod
logging:
  level:
    root: WARN
    jp.co.sesmanager: INFO
    org.springframework: WARN
```

## 8. バージョン履歴

| バージョン | 更新日     | 担当者    | 変更内容                                |
|----------|------------|---------|--------------------------------------|
| 0.1      | 2023/10/01 | 山田太郎  | 初版作成                               |
| 0.2      | 2023/11/15 | 佐藤次郎  | JSON形式ログ出力対応追加                  |
| 0.3      | 2024/01/20 | 鈴木三郎  | 非同期ログ機能強化                        |
| 0.4      | 2024/05/10 | 一丸柴也  | 実装コードを削除し、設計情報のみに修正     |
| 0.5      | 2024/05/15 | 一丸柴也  | Spring標準機能を活用した設計に変更        |