# エラー処理機能のインターフェース定義

## 1. 概要

エラー処理機能は、アプリケーション全体でのエラーハンドリングを統一し、適切なエラーレスポンスの生成、ログ記録、および例外管理を行うためのサービスを提供します。本ドキュメントでは、Spring Frameworkの標準機能を最大限に活用したエラー処理機能が提供するインターフェースと、それを利用するためのAPI仕様を定義します。

## 2. 提供インターフェース一覧

| インターフェース名 | 概要 | 利用モジュール |
|-----------------|------|-------------|
| GlobalExceptionHandler | Spring標準の例外ハンドリングを提供 | 全モジュール |
| ErrorCodeService | エラーコードの一元管理と参照を提供 | 全モジュール |
| ErrorLogService | エラーログの記録と管理を提供 | 全モジュール |
| CustomProblemDetailFactory | ProblemDetail生成の拡張機能を提供 | Web/API層 |

## 3. 要求インターフェース一覧

| インターフェース名 | 提供モジュール/フレームワーク | 概要 |
|-----------------|--------------|------|
| MessageSource | Spring Framework | メッセージの国際化と解決に利用 |
| JpaRepository | Spring Data JPA | エラーログの永続化に利用 |
| ApplicationEventPublisher | Spring Framework | エラーイベントの発行に利用 |
| DefaultErrorAttributes | Spring Boot | エラー属性のカスタマイズに利用 |
| MeterRegistry | Spring Boot Actuator | エラーメトリクスの収集に利用 |

## 4. インターフェース詳細

### 4.1 GlobalExceptionHandler クラス

Spring MVC/WebFluxの`@ControllerAdvice`を利用した集中型例外ハンドリングクラスです。

```java
/**
 * 集中型例外ハンドリングを提供するグローバルハンドラー
 * Spring MVCのResponseEntityExceptionHandlerを継承し標準例外処理を提供
 */
@RestControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {
    
    private final MessageSource messageSource;
    private final ErrorLogService errorLogService;
    private final CustomProblemDetailFactory problemDetailFactory;
    private final MeterRegistry meterRegistry;
    private final ApplicationEventPublisher eventPublisher;
    
    /**
     * 入力検証例外のハンドリング
     */
    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex, 
            HttpHeaders headers, 
            HttpStatusCode status, 
            WebRequest request) {
        
        // 検証エラーを持つProblemDetailの生成
        ProblemDetail problemDetail = problemDetailFactory.createValidationProblemDetail(
                ex.getBindingResult(), request, Locale.getDefault());
        
        // エラーイベントの発行
        publishErrorEvent(ex, request, problemDetail);
        
        // メトリクスのインクリメント
        incrementErrorMetric("validation.error");
        
        return handleExceptionInternal(ex, problemDetail, headers, status, request);
    }
    
    /**
     * リソース未検出例外のハンドリング
     */
    @ExceptionHandler(ResourceNotFoundException.class)
    public ProblemDetail handleResourceNotFoundException(
            ResourceNotFoundException ex, 
            WebRequest request) {
        
        // カスタムProblemDetailの生成
        ProblemDetail problemDetail = problemDetailFactory.createProblemDetail(
                ex, HttpStatus.NOT_FOUND, request, Locale.getDefault());
        
        // エラーイベントの発行
        publishErrorEvent(ex, request, problemDetail);
        
        // メトリクスのインクリメント
        incrementErrorMetric("resource.not.found");
        
        return problemDetail;
    }
    
    /**
     * ビジネスルール違反例外のハンドリング
     */
    @ExceptionHandler(BusinessRuleViolationException.class)
    public ProblemDetail handleBusinessRuleViolationException(
            BusinessRuleViolationException ex, 
            WebRequest request) {
        
        // カスタムProblemDetailの生成
        ProblemDetail problemDetail = problemDetailFactory.createProblemDetail(
                ex, HttpStatus.UNPROCESSABLE_ENTITY, request, Locale.getDefault());
        
        // エラーイベントの発行
        publishErrorEvent(ex, request, problemDetail);
        
        // メトリクスのインクリメント
        incrementErrorMetric("business.rule.violation");
        
        return problemDetail;
    }
    
    /**
     * システム例外のハンドリング
     */
    @ExceptionHandler(SystemException.class)
    public ProblemDetail handleSystemException(
            SystemException ex, 
            WebRequest request) {
        
        // カスタムProblemDetailの生成（機密情報を含まない）
        ProblemDetail problemDetail = problemDetailFactory.createProblemDetail(
                ex, HttpStatus.INTERNAL_SERVER_ERROR, request, Locale.getDefault());
        
        // 重大なエラーイベントの発行
        publishCriticalErrorEvent(ex, request, problemDetail);
        
        // メトリクスのインクリメント
        incrementErrorMetric("system.error");
        
        return problemDetail;
    }
    
    /**
     * Spring Securityの認証例外のハンドリング
     */
    @ExceptionHandler(AuthenticationException.class)
    public ProblemDetail handleAuthenticationException(
            AuthenticationException ex, 
            WebRequest request) {
        
        // カスタムProblemDetailの生成
        ProblemDetail problemDetail = problemDetailFactory.createProblemDetail(
                ex, HttpStatus.UNAUTHORIZED, request, Locale.getDefault());
        
        // セキュリティエラーイベントの発行
        publishSecurityErrorEvent(ex, request, problemDetail);
        
        // メトリクスのインクリメント
        incrementErrorMetric("security.authentication");
        
        return problemDetail;
    }
    
    /**
     * Spring Securityのアクセス拒否例外のハンドリング
     */
    @ExceptionHandler(AccessDeniedException.class)
    public ProblemDetail handleAccessDeniedException(
            AccessDeniedException ex, 
            WebRequest request) {
        
        // カスタムProblemDetailの生成
        ProblemDetail problemDetail = problemDetailFactory.createProblemDetail(
                ex, HttpStatus.FORBIDDEN, request, Locale.getDefault());
        
        // セキュリティエラーイベントの発行
        publishSecurityErrorEvent(ex, request, problemDetail);
        
        // メトリクスのインクリメント
        incrementErrorMetric("security.access.denied");
        
        return problemDetail;
    }
    
    /**
     * 未処理の例外のハンドリング（最終的なフォールバック）
     */
    @ExceptionHandler(Exception.class)
    public ProblemDetail handleUnknownException(
            Exception ex, 
            WebRequest request) {
        
        // カスタムProblemDetailの生成（機密情報を含まない）
        ProblemDetail problemDetail = problemDetailFactory.createProblemDetail(
                ex, HttpStatus.INTERNAL_SERVER_ERROR, request, Locale.getDefault());
        
        // 重大なエラーイベントの発行
        publishCriticalErrorEvent(ex, request, problemDetail);
        
        // メトリクスのインクリメント
        incrementErrorMetric("unexpected.error");
        
        return problemDetail;
    }
    
    /**
     * エラーイベントを発行する
     */
    private void publishErrorEvent(Throwable exception, WebRequest request, ProblemDetail problemDetail) {
        ErrorEvent event = new ErrorEvent(this, exception, extractRequestInfo(request), problemDetail);
        eventPublisher.publishEvent(event);
    }
    
    /**
     * 重大なエラーイベントを発行する
     */
    private void publishCriticalErrorEvent(Throwable exception, WebRequest request, ProblemDetail problemDetail) {
        CriticalErrorEvent event = new CriticalErrorEvent(this, exception, extractRequestInfo(request), problemDetail);
        eventPublisher.publishEvent(event);
    }
    
    /**
     * セキュリティエラーイベントを発行する
     */
    private void publishSecurityErrorEvent(Throwable exception, WebRequest request, ProblemDetail problemDetail) {
        SecurityErrorEvent event = new SecurityErrorEvent(this, exception, extractRequestInfo(request), problemDetail);
        eventPublisher.publishEvent(event);
    }
    
    /**
     * エラーメトリクスをインクリメントする
     */
    private void incrementErrorMetric(String errorType) {
        meterRegistry.counter("app.errors", "type", errorType).increment();
    }
    
    /**
     * WebRequestから必要な情報を抽出する
     */
    private RequestInfo extractRequestInfo(WebRequest request) {
        // 実装省略
        return new RequestInfo();
    }
}
```

### 4.2 CustomProblemDetailFactory インターフェース

RFC 7807準拠のProblemDetailを生成するためのファクトリーインターフェースです。

```java
/**
 * RFC 7807準拠のProblemDetailを生成するファクトリー
 */
public interface CustomProblemDetailFactory {
    
    /**
     * 例外からProblemDetailを生成します
     */
    ProblemDetail createProblemDetail(
            Throwable exception, 
            HttpStatus status, 
            WebRequest request, 
            Locale locale);
    
    /**
     * バリデーションエラーからProblemDetailを生成します
     */
    ProblemDetail createValidationProblemDetail(
            BindingResult bindingResult, 
            WebRequest request, 
            Locale locale);
    
    /**
     * エラーコードとパラメータからProblemDetailを生成します
     */
    ProblemDetail createProblemDetail(
            ErrorCode errorCode, 
            HttpStatus status, 
            WebRequest request, 
            Locale locale, 
            Object... args);
}
```

### 4.3 ErrorCodeService インターフェース

エラーコードの管理と参照を提供するサービスインターフェースです。

```java
/**
 * エラーコードの管理と参照を提供するサービス
 */
public interface ErrorCodeService {
    
    /**
     * エラーコードに対応するメッセージを取得します
     */
    String getMessage(ErrorCode code, Locale locale, Object... args);
    
    /**
     * エラーコードに対応するHTTPステータスコードを取得します
     */
    HttpStatus getHttpStatus(ErrorCode code);
    
    /**
     * エラーコードのカテゴリを取得します
     */
    String getCategory(ErrorCode code);
    
    /**
     * エラーコードの重大度を取得します
     */
    ErrorSeverity getSeverity(ErrorCode code);
    
    /**
     * エラーコードタイプ（技術的詳細）を取得します
     */
    URI getType(ErrorCode code);
    
    /**
     * エラーコード情報をすべて取得します
     */
    List<ErrorCodeInfo> getAllErrorCodes();
}
```

### 4.4 ErrorLogService インターフェース

エラーログの記録と管理を提供するサービスインターフェースです。Spring Eventsと統合されています。

```java
/**
 * エラーログの記録と管理を提供するサービス
 */
public interface ErrorLogService {
    
    /**
     * エラーイベントを処理します
     */
    @EventListener
    @Async
    void handleErrorEvent(ErrorEvent event);
    
    /**
     * 重大なエラーイベントを処理します
     */
    @EventListener
    @Async
    void handleCriticalErrorEvent(CriticalErrorEvent event);
    
    /**
     * セキュリティエラーイベントを処理します
     */
    @EventListener
    @Async
    void handleSecurityErrorEvent(SecurityErrorEvent event);
    
    /**
     * エラーログを検索します
     */
    Page<ErrorLogSummary> searchErrorLogs(ErrorLogSearchCriteria criteria, Pageable pageable);
    
    /**
     * エラー統計情報を取得します
     */
    ErrorStatistics getErrorStatistics(LocalDateTime startTime, LocalDateTime endTime);
    
    /**
     * トレースIDによりエラーの詳細を取得します
     */
    Optional<ErrorLogDetail> getErrorDetailByTraceId(String traceId);
}
```

### 4.5 エラーイベントクラス

エラーイベントを表すクラス階層です。Spring ApplicationEventを継承しています。

```java
/**
 * エラーイベントの基底クラス
 */
public class ErrorEvent extends ApplicationEvent {
    
    private final Throwable exception;
    private final RequestInfo requestInfo;
    private final ProblemDetail problemDetail;
    
    public ErrorEvent(Object source, Throwable exception, 
                     RequestInfo requestInfo, ProblemDetail problemDetail) {
        super(source);
        this.exception = exception;
        this.requestInfo = requestInfo;
        this.problemDetail = problemDetail;
    }
    
    // ゲッターメソッド
}

/**
 * 重大なエラーイベント
 */
public class CriticalErrorEvent extends ErrorEvent {
    // 継承実装
}

/**
 * セキュリティエラーイベント
 */
public class SecurityErrorEvent extends ErrorEvent {
    // 継承実装
}
```

### 4.6 カスタムErrorAttributesの実装

Spring BootのDefaultErrorAttributesをカスタマイズする実装です。

```java
/**
 * Spring BootのErrorAttributesをカスタマイズする実装
 */
@Component
public class CustomErrorAttributes extends DefaultErrorAttributes {
    
    private final ErrorCodeService errorCodeService;
    private final TraceProvider traceProvider;
    
    @Override
    public Map<String, Object> getErrorAttributes(
            WebRequest webRequest, ErrorAttributeOptions options) {
        
        Map<String, Object> errorAttributes = super.getErrorAttributes(
                webRequest, options);
        
        // トレースID追加
        errorAttributes.put("traceId", traceProvider.getCurrentTraceId());
        
        // 環境に応じた属性制御
        if (isProductionEnvironment()) {
            errorAttributes.remove("exception");
            errorAttributes.remove("trace");
        }
        
        // ProblemDetailが存在する場合はそのプロパティを使用
        Throwable error = getError(webRequest);
        if (error instanceof ResponseStatusException) {
            ProblemDetail problemDetail = ((ResponseStatusException) error).getBody();
            if (problemDetail != null) {
                enrichErrorAttributesFromProblemDetail(errorAttributes, problemDetail);
            }
        }
        
        return errorAttributes;
    }
    
    /**
     * ProblemDetailからエラー属性を拡張する
     */
    private void enrichErrorAttributesFromProblemDetail(
            Map<String, Object> errorAttributes, ProblemDetail problemDetail) {
        
        // ProblemDetailの各属性をエラー属性にマッピング
        errorAttributes.put("type", problemDetail.getType());
        errorAttributes.put("title", problemDetail.getTitle());
        errorAttributes.put("detail", problemDetail.getDetail());
        errorAttributes.put("instance", problemDetail.getInstance());
        
        // 追加プロパティの処理
        Map<String, Object> properties = problemDetail.getProperties();
        if (properties != null) {
            errorAttributes.putAll(properties);
        }
    }
    
    /**
     * 本番環境かどうかを判定
     */
    private boolean isProductionEnvironment() {
        // 実装省略
        return false;
    }
}
```

## 5. Spring標準エラーハンドリング統合

### 5.1 Spring MVC/WebFluxとの統合

Spring MVCのResponseEntityExceptionHandlerおよびSpring WebFluxのWebFluxResponseStatusExceptionHandlerを継承して標準エラー処理を拡張します。

### 5.2 ErrorMVCAutoConfigurationとの統合

Spring Bootの自動設定を拡張し、カスタムエラーページとErrorAttributesを提供します。

```java
/**
 * エラー処理の自動設定クラス
 */
@Configuration
public class ErrorHandlingAutoConfiguration {
    
    /**
     * カスタムエラー属性の設定
     */
    @Bean
    @ConditionalOnMissingBean(ErrorAttributes.class)
    public DefaultErrorAttributes errorAttributes(
            ErrorCodeService errorCodeService, 
            TraceProvider traceProvider) {
        return new CustomErrorAttributes(errorCodeService, traceProvider);
    }
    
    /**
     * ProblemDetail用のJacksonモジュール
     */
    @Bean
    public SimpleModule problemDetailJacksonModule() {
        SimpleModule module = new SimpleModule();
        module.addSerializer(ProblemDetail.class, new ProblemDetailSerializer());
        return module;
    }
    
    /**
     * エラーメトリクス登録
     */
    @Bean
    @ConditionalOnBean(MeterRegistry.class)
    public ErrorMetricsConfiguration errorMetricsConfiguration(MeterRegistry registry) {
        return new ErrorMetricsConfiguration(registry);
    }
}
```

### 5.3 ProblemDetailの拡張

Spring 6のProblemDetail実装を拡張して、アプリケーション固有の情報を追加します。

```java
/**
 * ProblemDetailファクトリーの実装
 */
@Component
public class CustomProblemDetailFactoryImpl implements CustomProblemDetailFactory {
    
    private final ErrorCodeService errorCodeService;
    private final MessageSource messageSource;
    private final TraceProvider traceProvider;
    
    @Override
    public ProblemDetail createProblemDetail(
            Throwable exception, 
            HttpStatus status, 
            WebRequest request, 
            Locale locale) {
        
        // 例外タイプに基づくエラーコード解決
        ErrorCode errorCode = resolveErrorCode(exception);
        String message = errorCodeService.getMessage(errorCode, locale);
        
        // ProblemDetailの生成
        ProblemDetail problemDetail = ProblemDetail.forStatusAndDetail(status, message);
        problemDetail.setType(errorCodeService.getType(errorCode));
        problemDetail.setTitle(getTitle(errorCode, locale));
        
        // 追加プロパティ
        problemDetail.setProperty("code", errorCode.getFullCode());
        problemDetail.setProperty("timestamp", Instant.now().toString());
        problemDetail.setProperty("traceId", traceProvider.getCurrentTraceId());
        
        // 環境に応じたデバッグ情報
        if (!isProductionEnvironment() && exception != null) {
            problemDetail.setProperty("exception", exception.getClass().getName());
        }
        
        return problemDetail;
    }
    
    // その他のメソッド実装...
}
```

## 6. バリデーション統合

### 6.1 Bean Validationの統合

Jakarta Bean ValidationおよびSpring Validationとの統合によるバリデーションエラー処理です。

```java
/**
 * バリデーションエラー用ProblemDetail拡張
 */
@Override
public ProblemDetail createValidationProblemDetail(
        BindingResult bindingResult, 
        WebRequest request, 
        Locale locale) {
    
    // バリデーションエラー用ProblemDetailの生成
    ProblemDetail problemDetail = createProblemDetail(
            ErrorCode.VALIDATION_ERROR, 
            HttpStatus.BAD_REQUEST, 
            request, 
            locale);
    
    // フィールドエラーの変換
    List<Map<String, Object>> fieldErrors = bindingResult.getFieldErrors()
            .stream()
            .map(fieldError -> {
                Map<String, Object> error = new HashMap<>();
                error.put("field", fieldError.getField());
                error.put("message", messageSource.getMessage(
                        fieldError, locale));
                error.put("code", fieldError.getCode());
                error.put("rejectedValue", fieldError.getRejectedValue());
                return error;
            })
            .collect(Collectors.toList());
    
    // グローバルエラーの変換
    List<Map<String, Object>> globalErrors = bindingResult.getGlobalErrors()
            .stream()
            .map(objectError -> {
                Map<String, Object> error = new HashMap<>();
                error.put("object", objectError.getObjectName());
                error.put("message", messageSource.getMessage(
                        objectError, locale));
                error.put("code", objectError.getCode());
                return error;
            })
            .collect(Collectors.toList());
    
    // エラー情報の追加
    problemDetail.setProperty("fieldErrors", fieldErrors);
    problemDetail.setProperty("globalErrors", globalErrors);
    
    return problemDetail;
}
```

### 6.2 メソッドバリデーション統合

Spring AOPを活用したメソッドバリデーションとの統合です。

```java
/**
 * メソッドバリデーション例外変換のアドバイス
 */
@ControllerAdvice
public class MethodValidationExceptionHandlerAdvice {
    
    private final CustomProblemDetailFactory problemDetailFactory;
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ProblemDetail> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex, 
            HttpServletRequest request) {
        
        // メソッドパラメータバリデーションエラー処理
        ProblemDetail problemDetail = problemDetailFactory.createValidationProblemDetail(
                ex.getBindingResult(), 
                new ServletWebRequest(request), 
                LocaleContextHolder.getLocale());
        
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(problemDetail);
    }
    
    @ExceptionHandler(MethodValidationException.class)
    public ResponseEntity<ProblemDetail> handleMethodValidation(
            MethodValidationException ex, 
            HttpServletRequest request) {
        
        // ConstraintValidatorが生成したバリデーションエラーを処理
        ProblemDetail problemDetail = problemDetailFactory.createConstraintViolationProblemDetail(
                ex.getAllValidationResults(),
                new ServletWebRequest(request),
                LocaleContextHolder.getLocale());
        
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(problemDetail);
    }
}
```

## 7. 非同期処理とエラーログ記録

### 7.1 イベント駆動ロギング

Spring EventsとSpring AOPを組み合わせた非同期エラーログ記録の実装です。

```java
/**
 * エラーログサービスの実装
 */
@Service
public class ErrorLogServiceImpl implements ErrorLogService {
    
    private final ErrorLogRepository errorLogRepository;
    private final NotificationService notificationService;
    private final ObjectMapper objectMapper;
    private final Logger log = LoggerFactory.getLogger(ErrorLogServiceImpl.class);
    
    @EventListener
    @Async("errorProcessingExecutor")
    @Override
    public void handleErrorEvent(ErrorEvent event) {
        try {
            // エラー情報のログ記録
            logErrorInformation(event);
            
            // データベースへの永続化
            saveErrorLog(event);
            
        } catch (Exception ex) {
            // ロギング自体のエラーをフォールバックロガーで記録
            log.error("Failed to process error event", ex);
        }
    }
    
    @EventListener
    @Async("errorProcessingExecutor")
    @Override
    public void handleCriticalErrorEvent(CriticalErrorEvent event) {
        try {
            // 重大エラー情報のログ記録
            logCriticalErrorInformation(event);
            
            // データベースへの永続化
            saveErrorLog(event);
            
            // 通知の送信
            sendErrorNotification(event);
            
        } catch (Exception ex) {
            // ロギング自体のエラーをフォールバックロガーで記録
            log.error("Failed to process critical error event", ex);
        }
    }
    
    // 実装省略...
}
```

### 7.2 非同期処理設定

エラー処理用の非同期実行設定です。

```java
/**
 * エラー処理の非同期実行設定
 */
@Configuration
@EnableAsync
public class ErrorProcessingAsyncConfig {
    
    /**
     * エラー処理用のExecutorService
     */
    @Bean
    public Executor errorProcessingExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(5);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("error-processing-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
    
    /**
     * 非同期例外ハンドラー
     */
    @Bean
    public AsyncUncaughtExceptionHandler asyncUncaughtExceptionHandler() {
        return new SimpleAsyncUncaughtExceptionHandler();
    }
}
```

## 8. セキュリティ連携

### 8.1 Spring Securityとの統合

Spring Securityのセキュリティ例外をハンドリングするための設定です。

```java
/**
 * Spring Securityのエラーハンドリング設定
 */
@Configuration
@EnableWebSecurity
public class SecurityErrorHandlingConfig {
    
    private final CustomProblemDetailFactory problemDetailFactory;
    private final ObjectMapper objectMapper;
    
    @Bean
    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // 認証・認可設定...
            
            // エラーハンドラー
            .exceptionHandling(exceptionHandling -> exceptionHandling
                .authenticationEntryPoint(authenticationEntryPoint())
                .accessDeniedHandler(accessDeniedHandler()));
        
        return http.build();
    }
    
    /**
     * 認証エラーエントリーポイント
     */
    @Bean
    public AuthenticationEntryPoint authenticationEntryPoint() {
        return (request, response, exception) -> {
            ProblemDetail problemDetail = problemDetailFactory.createProblemDetail(
                    exception, 
                    HttpStatus.UNAUTHORIZED, 
                    new ServletWebRequest(request), 
                    LocaleContextHolder.getLocale());
            
            response.setStatus(HttpStatus.UNAUTHORIZED.value());
            response.setContentType(MediaType.APPLICATION_PROBLEM_JSON_VALUE);
            response.getWriter().write(objectMapper.writeValueAsString(problemDetail));
        };
    }
    
    /**
     * アクセス拒否ハンドラー
     */
    @Bean
    public AccessDeniedHandler accessDeniedHandler() {
        return (request, response, exception) -> {
            ProblemDetail problemDetail = problemDetailFactory.createProblemDetail(
                    exception, 
                    HttpStatus.FORBIDDEN, 
                    new ServletWebRequest(request), 
                    LocaleContextHolder.getLocale());
            
            response.setStatus(HttpStatus.FORBIDDEN.value());
            response.setContentType(MediaType.APPLICATION_PROBLEM_JSON_VALUE);
            response.getWriter().write(objectMapper.writeValueAsString(problemDetail));
        };
    }
}
```

## 9. モニタリングとメトリクス

### 9.1 Actuatorとの統合

Spring Boot Actuatorを利用したエラーメトリクス収集の設定です。

```java
/**
 * エラーメトリクスの設定
 */
@Configuration
public class ErrorMetricsConfiguration {
    
    private final MeterRegistry registry;
    
    @EventListener
    public void onErrorEvent(ErrorEvent event) {
        String errorType = extractErrorType(event);
        
        // エラータイプごとのカウンターをインクリメント
        registry.counter("app.errors", "type", errorType).increment();
        
        // エラー発生時刻の記録
        registry.gauge("app.error.last", Clock.SYSTEM.wallTime());
        
        // エラー重大度ごとのカウンター
        if (event instanceof CriticalErrorEvent) {
            registry.counter("app.errors.critical").increment();
        }
    }
    
    // 実装省略...
}
```

### 9.2 HealthIndicatorの実装

エラー発生状況に基づくヘルスインジケーターの実装です。

```java
/**
 * エラー状況に基づくヘルスインジケーター
 */
@Component
public class ErrorHealthIndicator implements HealthIndicator {
    
    private final ErrorLogService errorLogService;
    
    @Override
    public Health health() {
        try {
            // 直近のエラー状況を確認
            ErrorStatistics statistics = errorLogService.getErrorStatistics(
                    LocalDateTime.now().minusMinutes(5), 
                    LocalDateTime.now());
            
            // 重大エラーが一定数以上ある場合はDOWN状態を返す
            long criticalErrors = statistics.getCountBySeverity()
                    .getOrDefault(ErrorSeverity.CRITICAL.name(), 0L);
            
            if (criticalErrors > 5) {
                return Health.down()
                        .withDetail("reason", "Too many critical errors")
                        .withDetail("criticalErrors", criticalErrors)
                        .build();
            }
            
            // それ以外はUP状態を返す
            return Health.up()
                    .withDetail("recentErrors", statistics.getTotalCount())
                    .build();
            
        } catch (Exception ex) {
            return Health.unknown()
                    .withDetail("reason", "Failed to check error statistics")
                    .withDetail("exception", ex.getMessage())
                    .build();
        }
    }
}
```

## 10. API仕様

### 10.1 ProblemDetail準拠のエラーレスポンス

RFC 7807に準拠したProblemDetailレスポンスの例です。

```json
{
  "type": "https://api.sesapp.example.jp/errors/validation",
  "title": "入力値が無効です",
  "status": 400,
  "detail": "入力内容に1つ以上のエラーがあります",
  "instance": "/api/v1/engineers",
  "code": "E11001",
  "timestamp": "2025-05-14T10:15:30.123Z",
  "traceId": "abc123xyz456",
  "fieldErrors": [
    {
      "field": "email",
      "message": "有効なメールアドレスを入力してください",
      "code": "Email",
      "rejectedValue": "invalid-email"
    },
    {
      "field": "phoneNumber",
      "message": "有効な電話番号を入力してください",
      "code": "Pattern",
      "rejectedValue": "123"
    }
  ]
}
```

### 10.2 設定パラメータ

エラー処理機能で利用可能な主な設定パラメータです。

| パラメータ名 | 説明 | デフォルト値 |
|--------------|------|-------------|
| spring.mvc.problemdetails.enabled | ProblemDetail機能の有効化 | true |
| app.error.include-stacktrace | スタックトレースを含めるかどうか | never (本番), always (開発) |
| app.error.include-debug-details | デバッグ詳細を含めるかどうか | false (本番), true (開発) |
| app.error.async.core-pool-size | エラー処理用スレッドプールのコアサイズ | 2 |
| app.error.async.max-pool-size | エラー処理用スレッドプールの最大サイズ | 5 |
| app.error.notification.enabled | エラー通知の有効化 | true |
| app.error.notification.threshold | 通知するエラーの閾値（重大度） | ERROR |
| management.metrics.enable.app.errors | エラーメトリクスの有効化 | true |

## 11. まとめ

Spring Frameworkの標準機能を活用したエラー処理機能は以下のコンポーネントで構成されます：

1. **GlobalExceptionHandler**: Spring MVCの集中例外ハンドリング機能を提供
2. **CustomProblemDetailFactory**: RFC 7807に準拠したエラーレスポンス生成を提供
3. **ErrorCodeService**: エラーコードの一元管理と参照機能を提供
4. **ErrorLogService**: エラーイベントの処理とログ記録を提供

これらのコンポーネントは、Spring Frameworkの標準機能である@ControllerAdvice、ProblemDetail、ApplicationEvent、AOPを活用して、宣言的で拡張性の高いエラー処理基盤を実現します。また、Spring Boot ActuatorやSpring Securityとの統合により、運用監視性とセキュリティも強化されています。