# エラーログ機能

## 1. 目的と概要

エラーログ機能は、Spring Frameworkの標準機能を活用して、システム内で発生したエラー情報を一元的に記録・管理し、効率的なトラブルシューティングを可能にする基盤を提供します。本機能により、発生したエラーの詳細な情報を構造化された形式で保存し、分析や監視を容易にします。

主な目的は以下の通りです：

- Spring標準のロギングフレームワークとの統合によるエラー情報の一元的記録
- エラーの傾向分析と早期検知のためのデータ提供
- アプリケーションイベントを活用した非同期エラーログ処理
- Spring Boot Actuatorを活用したエラーメトリクスの収集と監視
- Spring Data JDBCによるエラーログの効率的な永続化と検索

## 2. 機能要件

### 2.1 エラーログ記録

- Spring の例外ハンドリング機構と連携した各種エラーの詳細情報記録
- Spring 6のProblemDetailに基づくエラー情報の構造化記録
- Spring ApplicationEventを活用した非同期エラーログ処理
- Spring プロファイルに応じたログ詳細度の制御
- Spring Boot Actuatorによるエラーメトリクスの自動収集

### 2.2 エラーログ検索・参照

- Spring Data JDBCを活用したリポジトリパターンによるエラーログ検索
- Spring Data QueryDSLによる柔軟な検索条件の構築
- Spring Cacheを活用した頻出検索結果のキャッシング
- Spring AOPを活用した検索処理のロギングと監視

### 2.3 エラー統計・分析

- Spring Boot Actuatorのメトリクスによるエラー発生状況のリアルタイム監視
- Spring Data JDBCのプロジェクション機能を活用した効率的な集計クエリ
- Spring Schedulingによる定期的なエラー統計レポート生成
- Micrometer/Prometheusとの連携によるエラーメトリクスのダッシュボード表示

### 2.4 通知連携

- Spring EventとListenerを活用した柔軟な通知機構
- Spring Mailによるメール通知
- Spring Integrationを活用した外部システム（Slack、Teamsなど）への通知連携
- Spring条件付きビーンを活用した環境別通知設定

## 3. アーキテクチャ設計

### 3.1 モジュール構成

エラーログ機能は以下のSpring標準コンポーネントを活用して構成されます：

```
                 +--------------------+
                 | GlobalExceptionHandler
                 +----------+---------+
                            |
                            v
        +------------------+-----------------+
        |                                    |
+-------v-----------+            +-----------v------+
| ApplicationEvent  |            | ProblemDetail    |
| (ErrorEvent)      |            | Factory          |
+-------+-----------+            +-----------+------+
        |                                    |
        v                                    v
+-------+-----------+            +-----------+------+
| ErrorEventListener|<-----------+ ErrorLogger      |
+-------+-----------+            +-----------+------+
        |                                    |
        v                                    v
+-------+-----------+            +-----------+------+
| Async Processing  |            | ErrorLog          |
| (@Async)          |            | Repository        |
+-------+-----------+            +--------------------+
        |
        v
+-------+-----------+
| Notification      |
| Service           |
+-------------------+
```

- **GlobalExceptionHandler**: Spring MVCの@ControllerAdviceによる例外ハンドリング
- **ApplicationEvent (ErrorEvent)**: Spring Eventを活用したエラーイベント
- **ProblemDetailFactory**: Spring 6のProblemDetailを生成するファクトリー
- **ErrorEventListener**: Spring @EventListenerによるイベント処理
- **Async Processing**: Spring @Asyncによる非同期処理
- **ErrorLogRepository**: Spring Data JDBCによるデータアクセス
- **Notification Service**: Spring Integrationによる通知連携

### 3.2 データモデル

Spring Data JDBCを活用したエラーログエンティティの主な属性：

| 属性名 | 型 | 説明 |
|--------|-----|------|
| id | Long | エラーログID |
| errorCode | String | エラーコード |
| errorCategory | String | エラーカテゴリ |
| errorSeverity | String | エラー重大度 |
| errorTitle | String | エラータイトル |
| errorDetail | String | 詳細情報 |
| traceId | String | 分散トレースID |
| path | String | リクエストパス |
| method | String | HTTPメソッド |
| userAgent | String | ユーザーエージェント |
| ipAddress | String | クライアントIPアドレス |
| userId | String | ユーザーID |
| exceptionType | String | 例外クラス名 |
| exceptionMessage | String | 例外メッセージ |
| stackTrace | String | スタックトレース（開発環境のみ） |
| timestamp | OffsetDateTime | エラー発生時刻 |

### 3.3 フロー設計

#### エラーログ記録フロー（Spring Eventベース）

1. GlobalExceptionHandlerが例外をProblemDetailに変換
2. ErrorEventをApplicationEventPublisherで発行
3. @Asyncアノテーションが付与されたErrorEventListenerが非同期処理
4. 構造化JSONログの出力とデータベースへの永続化
5. 重大度に応じて通知サービスへの連携

```
+--------------------+     +--------------------+     +--------------------+
| GlobalException    |---->| ApplicationEvent   |---->| @EventListener     |
| Handler            |     | Publisher          |     | (@Async)           |
+--------------------+     +--------------------+     +--------------------+
                                                            |
                +--------------------+     +--------------------+
                | ErrorLog           |<----| ErrorLogger        |
                | Repository         |     | Service            |
                +--------------------+     +--------------------+
                                                  |
                +--------------------+     +------v-------------+
                | Database           |     | Log Appender       |
                | (JDBC)             |     | (JSON)             |
                +--------------------+     +--------------------+
```

## 4. Spring統合インターフェース設計

### 4.1 ErrorEventの定義

Spring ApplicationEventを活用したエラーイベント：

```java
/**
 * エラー発生時に発行されるイベント
 */
public class ErrorEvent extends ApplicationEvent {
    private final HttpServletRequest request;
    private final ProblemDetail problemDetail;
    
    public ErrorEvent(Throwable source, HttpServletRequest request, ProblemDetail problemDetail) {
        super(source);
        this.request = request;
        this.problemDetail = problemDetail;
    }
    
    /**
     * 元の例外を取得
     */
    @Override
    public Throwable getSource() {
        return (Throwable) super.getSource();
    }
    
    // ゲッターメソッド...
}
```

### 4.2 ErrorEventListenerの実装

Spring @EventListenerと@Asyncを組み合わせたイベントリスナー：

```java
/**
 * エラーイベントリスナー
 */
@Component
public class ErrorEventListener {
    
    private static final Logger log = LoggerFactory.getLogger(ErrorEventListener.class);
    
    private final ErrorLogRepository errorLogRepository;
    private final ObjectMapper objectMapper;
    private final NotificationService notificationService;
    
    // コンストラクタ、DI...
    
    /**
     * エラーイベントのハンドリング - 非同期実行
     */
    @Async("errorLogExecutor")
    @EventListener
    public void handleErrorEvent(ErrorEvent event) {
        try {
            // エラー情報をログに出力
            logStructuredError(event);
            
            // エラーログをDBに永続化
            ErrorLog errorLog = createErrorLogEntity(event);
            errorLogRepository.save(errorLog);
            
            // 重大エラーの場合は通知も送信
            if (isHighSeverityError(event)) {
                notificationService.sendErrorNotification(event);
            }
        } catch (Exception ex) {
            log.error("Failed to process error event", ex);
        }
    }
    
    // 各種ヘルパーメソッド...
}
```

### 4.3 ErrorLogRepositoryの定義

Spring Data JDBCを活用したリポジトリインターフェース：

```java
/**
 * エラーログリポジトリ
 */
public interface ErrorLogRepository extends CrudRepository<ErrorLog, Long>, PagingAndSortingRepository<ErrorLog, Long> {
    
    // 基本的な検索メソッド
    List<ErrorLog> findByErrorCode(String errorCode);
    List<ErrorLog> findByErrorCategory(String category);
    List<ErrorLog> findByErrorSeverity(String severity);
    List<ErrorLog> findByTimestampBetween(OffsetDateTime startTime, OffsetDateTime endTime);
    List<ErrorLog> findByTraceId(String traceId);
    List<ErrorLog> findByUserId(String userId);
    
    // カスタムクエリ
    @Query("SELECT * FROM error_logs WHERE path LIKE :pathPattern")
    List<ErrorLog> findByPathPattern(String pathPattern);
    
    // カウントクエリ - プロジェクション使用
    @Query("SELECT error_category as category, COUNT(*) as count FROM error_logs " +
           "WHERE timestamp BETWEEN :startTime AND :endTime " +
           "GROUP BY error_category")
    List<CategoryCount> countByCategory(OffsetDateTime startTime, OffsetDateTime endTime);
    
    @Query("SELECT error_severity as severity, COUNT(*) as count FROM error_logs " +
           "WHERE timestamp BETWEEN :startTime AND :endTime " +
           "GROUP BY error_severity")
    List<SeverityCount> countBySeverity(OffsetDateTime startTime, OffsetDateTime endTime);
    
    // ネストされたインターフェース - プロジェクション
    interface CategoryCount {
        String getCategory();
        long getCount();
    }
    
    interface SeverityCount {
        String getSeverity();
        long getCount();
    }
}
```

### 4.4 AsyncConfigurationの設定

Spring @Asyncによる非同期処理の設定：

```java
/**
 * 非同期処理の設定
 */
@Configuration
@EnableAsync
public class AsyncErrorLogConfig {
    
    /**
     * エラーログ処理用の非同期タスク実行者を設定
     */
    @Bean
    public Executor errorLogExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(5);
        executor.setQueueCapacity(500);
        executor.setThreadNamePrefix("error-log-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}
```

## 5. ログフォーマット設計

### 5.1 Jacksonを活用した構造化JSONログ

Spring標準のJackson ObjectMapperを活用した構造化JSONログ出力：

```java
/**
 * 構造化エラーログの出力
 */
private void logStructuredError(ErrorEvent event) throws JsonProcessingException {
    // エラー情報をJSONに変換
    Map<String, Object> logData = new HashMap<>();
    // 基本情報を設定
    logData.put("timestamp", OffsetDateTime.now().toString());
    logData.put("level", determineLogLevel(event.getSource()));
    logData.put("traceId", event.getProblemDetail().getProperties().get("traceId"));
    
    // 例外情報を設定
    Map<String, Object> exceptionData = new HashMap<>();
    exceptionData.put("type", event.getSource().getClass().getName());
    exceptionData.put("message", event.getSource().getMessage());
    if (isDevelopmentOrTestEnvironment()) {
        exceptionData.put("stackTrace", getStackTraceAsStringArray(event.getSource()));
    }
    logData.put("exception", exceptionData);
    
    // ProblemDetail情報を設定
    logData.put("problemDetail", event.getProblemDetail());
    
    // リクエスト情報を設定
    Map<String, Object> requestData = new HashMap<>();
    HttpServletRequest request = event.getRequest();
    requestData.put("method", request.getMethod());
    requestData.put("path", request.getRequestURI());
    requestData.put("query", request.getQueryString());
    requestData.put("remoteAddr", request.getRemoteAddr());
    requestData.put("userAgent", request.getHeader("User-Agent"));
    logData.put("request", requestData);
    
    // ログ出力 - JSON形式
    log.error("{}", objectMapper.writeValueAsString(logData));
}
```

### 5.2 Spring Profilesによる環境別ログ設定

Spring Profilesを活用した環境別ログ設定：

```java
/**
 * 環境判定メソッド
 */
private boolean isDevelopmentOrTestEnvironment() {
    Environment env = applicationContext.getEnvironment();
    return env.acceptsProfiles(Profiles.of("dev", "test"));
}

/**
 * ログレベル判定メソッド
 */
private String determineLogLevel(Throwable exception) {
    if (exception instanceof ApplicationException) {
        ApplicationException appEx = (ApplicationException) exception;
        switch (appEx.getErrorCode().getSeverity()) {
            case CRITICAL:
                return "FATAL";
            case ERROR:
                return "ERROR";
            case WARNING:
                return "WARN";
            case INFO:
                return "INFO";
            default:
                return "ERROR";
        }
    }
    return "ERROR";
}
```

## 6. Spring Boot Actuator統合

### 6.1 エラーメトリクスの定義

Spring Boot ActuatorとMicrometer統合によるエラーメトリクス定義：

```java
/**
 * エラーメトリクス設定
 */
@Configuration
public class ErrorMetricsConfig {
    
    /**
     * エラーメトリクスを登録
     */
    @Bean
    public MeterBinder errorMetricsBinder() {
        return registry -> {
            // エラーカウンター
            Counter.builder("app.errors.total")
                    .description("Total number of errors")
                    .register(registry);
            
            // カテゴリ別カウンター
            Counter.builder("app.errors")
                    .description("Number of errors by category")
                    .tag("type", "validation")
                    .register(registry);
            
            Counter.builder("app.errors")
                    .description("Number of errors by category")
                    .tag("type", "business")
                    .register(registry);
            
            Counter.builder("app.errors")
                    .description("Number of errors by category")
                    .tag("type", "system")
                    .register(registry);
            
            // 重大エラーカウンター
            Counter.builder("app.errors.critical")
                    .description("Number of critical errors")
                    .register(registry);
        };
    }
    
    /**
     * エラー統計エンドポイント
     */
    @Bean
    @ConditionalOnAvailableEndpoint
    public ErrorStatsEndpoint errorStatsEndpoint(ErrorLogRepository errorLogRepository) {
        return new ErrorStatsEndpoint(errorLogRepository);
    }
}

/**
 * カスタムActuatorエンドポイント
 */
@Component
@Endpoint(id = "errorstats")
public class ErrorStatsEndpoint {
    
    private final ErrorLogRepository errorLogRepository;
    
    // コンストラクタ...
    
    @ReadOperation
    public Map<String, Object> getErrorStats() {
        OffsetDateTime now = OffsetDateTime.now();
        OffsetDateTime oneHourAgo = now.minusHours(1);
        OffsetDateTime oneDayAgo = now.minusDays(1);
        
        Map<String, Object> stats = new HashMap<>();
        
        // 1時間の統計
        stats.put("lastHour", Map.of(
            "byCategory", errorLogRepository.countByCategory(oneHourAgo, now),
            "bySeverity", errorLogRepository.countBySeverity(oneHourAgo, now)
        ));
        
        // 24時間の統計
        stats.put("lastDay", Map.of(
            "byCategory", errorLogRepository.countByCategory(oneDayAgo, now),
            "bySeverity", errorLogRepository.countBySeverity(oneDayAgo, now)
        ));
        
        return stats;
    }
}
```

### 6.2 メトリクスのインクリメント

エラーハンドラーでのメトリクスインクリメント：

```java
/**
 * エラーメトリクスのインクリメント
 */
private void incrementErrorMetrics(Throwable exception) {
    // 総数カウンターをインクリメント
    meterRegistry.counter("app.errors.total").increment();
    
    // カテゴリ別カウンターをインクリメント
    if (exception instanceof ApplicationException) {
        ApplicationException appEx = (ApplicationException) exception;
        String category = appEx.getErrorCode().getCategory().getCode().toLowerCase();
        meterRegistry.counter("app.errors", "type", category).increment();
        
        // 重大エラーの場合は追加カウンターをインクリメント
        if (appEx.getErrorCode().getSeverity() == ErrorSeverity.CRITICAL) {
            meterRegistry.counter("app.errors.critical").increment();
        }
    } else {
        // 未分類エラーの場合
        meterRegistry.counter("app.errors", "type", "unknown").increment();
    }
}
```

## 7. Spring Integration通知機能

### 7.1 通知サービスの実装

Spring Integrationを活用した通知サービスの実装：

```java
/**
 * 通知サービス設定
 */
@Configuration
@EnableIntegration
public class NotificationConfig {
    
    /**
     * メール通知用のチャネル
     */
    @Bean
    public MessageChannel errorMailChannel() {
        return new DirectChannel();
    }
    
    /**
     * Slack通知用のチャネル
     */
    @Bean
    public MessageChannel errorSlackChannel() {
        return new DirectChannel();
    }
    
    /**
     * エラー通知ルーター
     */
    @Bean
    @Router(inputChannel = "errorNotificationChannel")
    public MessageRouter errorNotificationRouter() {
        return message -> {
            ErrorEvent event = (ErrorEvent) message.getPayload();
            List<MessageChannel> channels = new ArrayList<>();
            
            // 重大度に応じて通知先を決定
            if (isCriticalError(event)) {
                channels.add(errorMailChannel());
                channels.add(errorSlackChannel());
            } else if (isErrorSeverity(event)) {
                channels.add(errorSlackChannel());
            }
            
            return channels;
        };
    }
    
    /**
     * メール通知ハンドラー
     */
    @Bean
    @ServiceActivator(inputChannel = "errorMailChannel")
    public MessageHandler errorMailHandler(JavaMailSender mailSender, 
                                          @Value("${app.error.notification.mail.to}") String toAddress,
                                          @Value("${app.error.notification.mail.from}") String fromAddress) {
        return message -> {
            ErrorEvent event = (ErrorEvent) message.getPayload();
            SimpleMailMessage mailMessage = new SimpleMailMessage();
            mailMessage.setTo(toAddress);
            mailMessage.setFrom(fromAddress);
            mailMessage.setSubject("Critical Error: " + event.getProblemDetail().getTitle());
            
            // メール本文の構築
            StringBuilder body = new StringBuilder();
            body.append("Error Code: ").append(event.getProblemDetail().getProperties().get("code")).append("\n");
            body.append("Path: ").append(event.getRequest().getRequestURI()).append("\n");
            body.append("Time: ").append(event.getProblemDetail().getProperties().get("timestamp")).append("\n");
            body.append("TraceId: ").append(event.getProblemDetail().getProperties().get("traceId")).append("\n");
            body.append("Details: ").append(event.getProblemDetail().getDetail());
            
            mailMessage.setText(body.toString());
            mailSender.send(mailMessage);
        };
    }
    
    /**
     * Slack通知ハンドラー
     */
    @Bean
    @ServiceActivator(inputChannel = "errorSlackChannel")
    public MessageHandler errorSlackHandler(RestTemplate restTemplate,
                                           @Value("${app.error.notification.slack.webhook}") String webhookUrl) {
        return message -> {
            ErrorEvent event = (ErrorEvent) message.getPayload();
            
            // Slackメッセージペイロードの構築
            Map<String, Object> payload = new HashMap<>();
            payload.put("text", "Error Alert: " + event.getProblemDetail().getTitle());
            
            // ...メッセージ本文の構築...
            
            // WebhookにPOST
            restTemplate.postForEntity(webhookUrl, payload, String.class);
        };
    }
}
```

## 8. セキュリティ設計

### 8.1 Spring Security連携

Spring Securityと連携したアクセス制御：

```java
/**
 * エラーログ画面のセキュリティ設定
 */
@Configuration
@EnableMethodSecurity
public class ErrorLogSecurityConfig {
    
    /**
     * エラーログ管理画面へのアクセス制御
     */
    @Bean
    public SecurityFilterChain errorLogFilterChain(HttpSecurity http) throws Exception {
        return http
            .securityMatcher("/admin/error-logs/**")
            .authorizeHttpRequests(authorize -> authorize
                .requestMatchers("/admin/error-logs/view").hasAuthority("ERROR_LOG_VIEW")
                .requestMatchers("/admin/error-logs/details").hasAuthority("ERROR_LOG_DETAILS")
                .requestMatchers("/admin/error-logs/download").hasAuthority("ERROR_LOG_DOWNLOAD")
                .anyRequest().denyAll()
            )
            .build();
    }
}
```

### 8.2 機密情報のマスキング機能

Spring AOP を活用した機密情報マスキング：

```java
/**
 * ログマスキング処理のAOP
 */
@Aspect
@Component
public class LogMaskingAspect {
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Autowired
    private ErrorLogMaskingProperties maskingProperties;
    
    /**
     * ErrorEventListenerのハンドラーメソッド実行前にマスキング処理を行う
     */
    @Before("execution(* jp.co.example.sesapp.*.errorlog.ErrorEventListener.handleErrorEvent(..))")
    public void maskSensitiveDataInErrorEvent(JoinPoint joinPoint) {
        Object[] args = joinPoint.getArgs();
        if (args != null && args.length > 0 && args[0] instanceof ErrorEvent) {
            ErrorEvent event = (ErrorEvent) args[0];
            HttpServletRequest request = event.getRequest();
            
            // パラメータのマスキング処理
            maskParameters(request);
            
            // ProblemDetailのマスキング処理
            maskProblemDetailProperties(event.getProblemDetail());
        }
    }
    
    /**
     * リクエストパラメータのマスキング
     */
    private void maskParameters(HttpServletRequest request) {
        // マスキング対象のパラメータ名パターン
        List<Pattern> sensitiveParamPatterns = maskingProperties.getSensitiveParamPatterns();
        
        // リクエストパラメータをラップして機密情報をマスク
        request.setAttribute("originalParameters", request.getParameterMap());
        request.setAttribute("maskedParameters", createMaskedParameterMap(request, sensitiveParamPatterns));
    }
    
    /**
     * ProblemDetailプロパティのマスキング
     */
    private void maskProblemDetailProperties(ProblemDetail problemDetail) {
        if (problemDetail.getProperties() != null) {
            Map<String, Object> properties = new HashMap<>(problemDetail.getProperties());
            
            // 機密性の高いプロパティをマスク
            for (String key : maskingProperties.getSensitivePropertyKeys()) {
                if (properties.containsKey(key)) {
                    properties.put(key, "********");
                }
            }
            
            // マスク済みプロパティをセット
            problemDetail.setProperties(properties);
        }
    }
}
```

## 9. Spring Cacheを活用したパフォーマンス最適化

### 9.1 エラーログキャッシュ設定

Spring Cache抽象化を活用したキャッシュの実装：

```java
/**
 * エラーログキャッシュ設定
 */
@Configuration
@EnableCaching
public class ErrorLogCacheConfig {
    
    /**
     * エラーログ用キャッシュマネージャー
     */
    @Bean
    public CacheManager errorLogCacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager(
                "errorLogStatistics", "errorLogByCode", "errorLogByTraceId");
        
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .maximumSize(200)
                .expireAfterWrite(Duration.ofMinutes(10))
                .recordStats());
        
        return cacheManager;
    }
}

/**
 * キャッシュを活用したエラーログサービス
 */
@Service
public class CachedErrorLogService {
    
    private final ErrorLogRepository errorLogRepository;
    
    // コンストラクタ...
    
    /**
     * エラーコードによる検索 - キャッシュ適用
     */
    @Cacheable(cacheNames = "errorLogByCode", key = "#errorCode")
    public List<ErrorLog> findByErrorCode(String errorCode) {
        return errorLogRepository.findByErrorCode(errorCode);
    }
    
    /**
     * トレースIDによる検索 - キャッシュ適用
     */
    @Cacheable(cacheNames = "errorLogByTraceId", key = "#traceId")
    public List<ErrorLog> findByTraceId(String traceId) {
        return errorLogRepository.findByTraceId(traceId);
    }
    
    /**
     * エラー統計取得 - キャッシュ適用
     */
    @Cacheable(cacheNames = "errorLogStatistics", 
               key = "#startTime.toEpochSecond() + '_' + #endTime.toEpochSecond()")
    public Map<String, Object> getErrorStatistics(OffsetDateTime startTime, OffsetDateTime endTime) {
        Map<String, Object> statistics = new HashMap<>();
        
        statistics.put("byCategory", errorLogRepository.countByCategory(startTime, endTime));
        statistics.put("bySeverity", errorLogRepository.countBySeverity(startTime, endTime));
        statistics.put("total", errorLogRepository.countByTimestampBetween(startTime, endTime));
        
        return statistics;
    }
    
    /**
     * キャッシュ無効化 - エラーログ保存時
     */
    @CacheEvict(cacheNames = "errorLogStatistics", allEntries = true)
    public void invalidateStatisticsCache() {
        // キャッシュ無効化のみ
    }
}
```

## 10. Spring Schedulingによる自動処理

### 10.1 エラーログクリーンアップスケジューラー

Spring Schedulingを活用した定期的なエラーログ処理：

```java
/**
 * スケジュールタスク設定
 */
@Configuration
@EnableScheduling
public class ErrorLogSchedulingConfig {
    
    private final ErrorLogRepository errorLogRepository;
    private final ErrorLogProperties properties;
    
    // コンストラクタ...
    
    /**
     * 古いエラーログの削除 - 毎日午前3時に実行
     */
    @Scheduled(cron = "0 0 3 * * ?")
    public void cleanupOldErrorLogs() {
        OffsetDateTime cutoffDate = OffsetDateTime.now().minusDays(properties.getRetentionDays());
        long deletedCount = errorLogRepository.deleteByTimestampBefore(cutoffDate);
        log.info("Deleted {} old error logs before {}", deletedCount, cutoffDate);
    }
    
    /**
     * エラー統計レポート生成 - 毎日午前7時に実行
     */
    @Scheduled(cron = "0 0 7 * * ?")
    public void generateDailyErrorReport() {
        OffsetDateTime now = OffsetDateTime.now();
        OffsetDateTime yesterday = now.minusDays(1);
        
        // 日次統計を生成
        Map<String, Object> statistics = errorLogRepository.getDailyStatistics(yesterday, now);
        
        // レポートの作成と通知
        // ...
    }
}
```

## 11. まとめ

Spring標準機能を活用したエラーログ機能は、以下の要素によって構成されます：

1. **Spring 6のProblemDetail**：RFC 7807準拠のエラー表現を活用した構造化ログ
2. **Spring ApplicationEvent**：イベント駆動型のエラーログ処理
3. **Spring @Async**：非同期処理によるパフォーマンス最適化
4. **Spring Data JDBC**：エラーログの効率的な永続化と検索
5. **Spring Boot Actuator**：エラーメトリクスの監視とダッシュボード
6. **Spring Cache**：頻出クエリ結果のキャッシング
7. **Spring Integration**：外部システムとの通知連携
8. **Spring AOP**：機密情報マスキングなどの横断的関心事の分離
9. **Spring Scheduling**：定期的なログクリーンアップと統計レポート生成

この設計により、高性能で拡張性のあるエラーログ機能を提供し、Spring Frameworkの豊富な機能を活用してシステム全体での統一的なエラー処理と監視を実現します。