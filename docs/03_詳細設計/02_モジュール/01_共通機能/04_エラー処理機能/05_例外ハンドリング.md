# 例外ハンドリング

## 1. 目的と概要

例外ハンドリング機能は、アプリケーション内で発生する様々な例外を捕捉し、適切に処理する仕組みを提供します。本ドキュメントでは、例外の捕捉方法、変換方法、およびエラーレスポンス生成の詳細な処理フローについて説明します。

この機能の主な目的は以下の通りです：

- アプリケーション全体で一貫した例外処理を実現する
- 発生した例外を適切なエラーレスポンスに変換する
- 開発者とエンドユーザーに適切なエラー情報を提供する
- 例外発生時の影響範囲を最小限に抑える

## 2. 例外ハンドリングの基本方針

### 2.1 層別例外ハンドリング方針

アプリケーションの各層における例外ハンドリングの方針を以下に示します。

| 層 | 例外ハンドリング方針 |
|---|-------------------|
| コントローラー層 | 基本的に例外を補足せず、グローバル例外ハンドラーに委譲する |
| サービス層 | 業務ロジックに関わる例外を検知し、適切な業務例外に変換してスローする |
| リポジトリ層 | データアクセス例外を捕捉し、わかりやすい業務例外または技術例外に変換する |
| 外部サービス連携層 | 外部サービスからの例外を捕捉し、内部で扱いやすい形式に変換する |

### 2.2 例外変換の基本原則

- 下位層で発生した技術的例外は、上位層でより意味のある業務例外に変換する
- 例外変換時には元の例外を必ず原因例外（cause）として保持する
- 例外変換時にはコンテキスト情報を可能な限り保持する
- フレームワーク固有の例外はアプリケーション境界で変換し、内部実装の依存を閉じ込める

## 3. グローバル例外ハンドラーの実装

Spring MVCのControllerAdviceを利用した集中型例外ハンドリングの実装概要を示します。

### 3.1 グローバル例外ハンドラークラスの構成

```
/**
 * アプリケーション全体の例外を一元的に処理するグローバル例外ハンドラー
 */
@RestControllerAdvice
@Order(Ordered.HIGHEST_PRECEDENCE)
public class GlobalExceptionHandler {
    
    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    
    private final ExceptionHandlingService exceptionHandlingService;
    private final ErrorResponseBuilder errorResponseBuilder;
    private final ErrorLogger errorLogger;
    
    // インジェクション、初期化処理...
    
    // 以下、各種例外ハンドラーメソッド
}
```

### 3.2 バリデーション例外のハンドリング

```
/**
 * 入力検証例外のハンドリング
 */
@ExceptionHandler({
    MethodArgumentNotValidException.class,
    BindException.class,
    ConstraintViolationException.class
})
public ResponseEntity<ValidationErrorResponse> handleValidationExceptions(
        Exception ex, WebRequest request, Locale locale) {
    
    RequestContext context = createRequestContext(request);
    ErrorInfo errorInfo;
    BindingResult bindingResult = null;
    
    // 例外の種類に応じた処理分岐
    // エラーログの記録
    // エラーレスポンスの構築と返却
}
```

### 3.3 業務例外のハンドリング

```
/**
 * 業務例外のハンドリング
 */
@ExceptionHandler(BusinessException.class)
public ResponseEntity<ErrorResponse> handleBusinessException(
        BusinessException ex, WebRequest request, Locale locale) {
    
    // リクエストコンテキストの作成
    // 例外からエラー情報への変換
    // エラーログの記録
    // エラーレスポンスの構築と返却
}

/**
 * リソース未検出例外のハンドリング
 */
@ExceptionHandler(ResourceNotFoundException.class)
public ResponseEntity<ErrorResponse> handleResourceNotFoundException(
        ResourceNotFoundException ex, WebRequest request, Locale locale) {
    
    // 同様の処理フロー
}
```

### 3.4 システム例外のハンドリング

```
/**
 * システム例外のハンドリング
 */
@ExceptionHandler(SystemException.class)
public ResponseEntity<ErrorResponse> handleSystemException(
        SystemException ex, WebRequest request, Locale locale) {
    
    // リクエストコンテキストの作成
    // 例外からエラー情報への変換
    // 重大なエラーとしてログ記録
    // エラーレスポンスの構築と返却
}
```

### 3.5 セキュリティ例外のハンドリング

```
/**
 * 認証例外のハンドリング
 */
@ExceptionHandler({
    AuthenticationException.class,
    org.springframework.security.core.AuthenticationException.class
})
public ResponseEntity<ErrorResponse> handleAuthenticationException(
        Exception ex, WebRequest request, Locale locale) {
    
    // フレームワーク例外からアプリケーション例外への変換
    // エラーレスポンスの構築と返却
}
```

### 3.6 未処理例外のハンドリング

```
/**
 * 未処理の例外のハンドリング（最終的なフォールバック）
 */
@ExceptionHandler(Exception.class)
public ResponseEntity<ErrorResponse> handleUnknownException(
        Exception ex, WebRequest request, Locale locale) {
    
    // 予期しない例外を内部サーバーエラーとして処理
    // 重大なエラーとしてログ記録
    // エラーレスポンスの構築と返却
}
```

## 4. 例外ハンドリングサービスの実装

例外を適切なエラー情報に変換するサービスの実装概要を示します。

### 4.1 ExceptionHandlingService インターフェース

```
/**
 * 例外ハンドリングサービスのインターフェース
 */
public interface ExceptionHandlingService {
    /**
     * 例外をハンドリングしてエラー情報を生成します
     */
    ErrorInfo handleException(Throwable exception, RequestContext request);
    
    /**
     * 入力検証エラーをハンドリングしてエラー情報を生成します
     */
    ErrorInfo handleValidationError(BindingResult bindingResult, RequestContext request);
    
    /**
     * 業務例外をハンドリングしてエラー情報を生成します
     */
    ErrorInfo handleBusinessException(BusinessException exception, RequestContext request);
    
    // その他の例外ハンドリングメソッド
}
```

### 4.2 実装クラスの主要メソッド

```
/**
 * 例外ハンドリングサービスの実装クラス
 */
@Service
public class ExceptionHandlingServiceImpl implements ExceptionHandlingService {

    private final ErrorCodeRegistry errorCodeRegistry;
    private final MessageSource messageSource;
    
    // コンストラクタ、DI...
    
    @Override
    public ErrorInfo handleException(Throwable exception, RequestContext request) {
        // 未知の例外は内部サーバーエラーとして扱う
        return createErrorInfo(
                ErrorCode.UNEXPECTED_ERROR,
                request,
                Map.of("exceptionType", exception.getClass().getName()),
                exception.getMessage()
        );
    }
    
    @Override
    public ErrorInfo handleValidationError(BindingResult bindingResult, RequestContext request) {
        // 入力検証エラーの詳細情報を収集
        Map<String, Object> data = new HashMap<>();
        data.put("fieldErrors", collectFieldErrors(bindingResult));
        
        return createErrorInfo(
                ErrorCode.VALIDATION_ERROR,
                request,
                data,
                "入力検証エラーが発生しました"
        );
    }
    
    // その他の例外ハンドリングメソッド...
    
    /**
     * エラー情報オブジェクトを作成するヘルパーメソッド
     */
    private ErrorInfo createErrorInfo(
            ErrorCode errorCode,
            RequestContext request,
            Map<String, Object> data,
            String detail) {
        
        return new ErrorInfo.Builder()
                .errorCode(errorCode)
                .path(request.getPath())
                .method(request.getMethod())
                .traceId(request.getTraceId())
                .userId(request.getUserId())
                .timestamp(LocalDateTime.now())
                .detail(detail)
                .data(data)
                .build();
    }
}
```

## 5. 例外変換の実装例

### 5.1 データアクセス例外の変換

Spring Dataのデータアクセス例外をアプリケーション例外に変換する例：

```
/**
 * データアクセス例外をアプリケーション例外に変換するアドバイザー
 */
@Component
public class DataAccessExceptionTranslator {
    
    /**
     * データアクセス例外をアプリケーション例外に変換します
     */
    public RuntimeException translateException(DataAccessException ex) {
        if (ex instanceof DataIntegrityViolationException) {
            // データ整合性違反の処理（一意制約違反など）
        } else if (ex instanceof EmptyResultDataAccessException) {
            // リソースが見つからないエラーとして扱う
        } else if (ex instanceof OptimisticLockingFailureException) {
            // 楽観的ロック失敗の処理
        }
        
        // デフォルトはデータベースエラーとして扱う
        return new DatabaseException(
                "unknown",
                "unknown",
                ErrorCode.DATABASE_ERROR,
                Map.of("exceptionType", ex.getClass().getName()),
                ex
        );
    }
}
```

### 5.2 外部サービス例外の変換

REST APIなどの外部サービス呼び出しで発生する例外の変換例：

```
/**
 * 外部サービス連携時の例外をアプリケーション例外に変換するユーティリティクラス
 */
@Component
public class ExternalServiceExceptionTranslator {
    
    /**
     * RESTテンプレートのエラーレスポンスハンドラー
     */
    public ResponseErrorHandler createRestTemplateErrorHandler(String serviceName) {
        return new DefaultResponseErrorHandler() {
            @Override
            public void handleError(ClientHttpResponse response) throws IOException {
                HttpStatus statusCode = response.getStatusCode();
                String responseBody = StreamUtils.copyToString(
                        response.getBody(), StandardCharsets.UTF_8);
                
                // HTTPステータスコードに基づいて適切な例外に変換
                if (statusCode.is4xxClientError()) {
                    throw translateClientError(
                            serviceName, statusCode, responseBody);
                } else if (statusCode.is5xxServerError()) {
                    throw translateServerError(
                            serviceName, statusCode, responseBody);
                }
                
                // その他の例外処理
            }
        };
    }
    
    /**
     * クライアントエラー（4xx）を適切なアプリケーション例外に変換
     */
    private RuntimeException translateClientError(
            String serviceName, HttpStatus statusCode, String responseBody) {
        
        // HTTPステータスコードに基づいた例外変換（404, 401, 403など）
        
        return new IntegrationException(
                serviceName,
                "client_error",
                ErrorCode.EXTERNAL_SERVICE_CLIENT_ERROR,
                Map.of(
                    "statusCode", statusCode.value(),
                    "responseBody", responseBody
                )
        );
    }
}
```

## 6. セキュリティ例外の処理

Spring Securityと連携したセキュリティ例外処理の実装例：

```
/**
 * Spring Securityのセキュリティ例外ハンドラー設定
 */
@Configuration
@EnableWebSecurity
public class SecurityExceptionConfig extends WebSecurityConfigurerAdapter {
    
    private final ObjectMapper objectMapper;
    private final ErrorCodeRegistry errorCodeRegistry;
    
    // コンストラクタ、DI...
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // 他のセキュリティ設定...
            
            // 認証エラーハンドラー
            .exceptionHandling()
                .authenticationEntryPoint(authenticationEntryPoint())
                .accessDeniedHandler(accessDeniedHandler());
    }
    
    /**
     * 認証エラーエントリーポイント（未認証アクセス時の処理）
     */
    @Bean
    public AuthenticationEntryPoint authenticationEntryPoint() {
        return (request, response, authException) -> {
            // JSON形式のエラーレスポンスを返却
        };
    }
    
    /**
     * アクセス拒否ハンドラー（権限不足時の処理）
     */
    @Bean
    public AccessDeniedHandler accessDeniedHandler() {
        return (request, response, accessDeniedException) -> {
            // JSON形式のエラーレスポンスを返却
        };
    }
}
```

## 7. ロギングとトレース

### 7.1 エラーログ記録

エラー情報を構造化された形式でログに記録する例：

```
@Service
public class ErrorLoggerImpl implements ErrorLogger {
    
    private static final Logger log = LoggerFactory.getLogger(ErrorLoggerImpl.class);
    
    // 依存サービス...
    
    @Override
    public void logError(ErrorInfo errorInfo, Throwable exception) {
        try {
            Map<String, Object> logData = createLogData(errorInfo, exception, false);
            log.error("{}", objectMapper.writeValueAsString(logData));
            
            // エラー情報の永続化
            persistErrorLog(errorInfo, exception);
        } catch (Exception e) {
            log.error("Failed to log error", e);
        }
    }
    
    @Override
    public void logCriticalError(ErrorInfo errorInfo, Throwable exception) {
        try {
            Map<String, Object> logData = createLogData(errorInfo, exception, true);
            log.error("{}", objectMapper.writeValueAsString(logData));
            
            // 重大なエラーは通知も送信
            sendErrorNotification(errorInfo, exception);
            
            // エラー情報の永続化
            persistErrorLog(errorInfo, exception);
        } catch (Exception e) {
            log.error("Failed to log critical error", e);
        }
    }
    
    /**
     * ログ出力用のデータを作成するヘルパーメソッド
     */
    private Map<String, Object> createLogData(
            ErrorInfo errorInfo, Throwable exception, boolean isCritical) {
        
        // エラー情報から構造化されたログデータを生成
        Map<String, Object> logData = new HashMap<>();
        
        // タイムスタンプ、レベル等の基本情報
        
        // エラー詳細情報
        
        // 例外情報（スタックトレースは環境により制御）
        
        return logData;
    }
}
```

### 7.2 分散トレーシングとの統合

OpenTelemetryなどの分散トレーシングと統合する例：

```
/**
 * 分散トレーシングと統合するための設定
 */
@Configuration
public class TracingConfig {
    
    /**
     * TracerをSpring Contextにビーンとして登録
     */
    @Bean
    public Tracer tracer(io.opentelemetry.api.trace.Tracer otelTracer) {
        return new OpenTelemetryTracer(otelTracer);
    }
    
    /**
     * グローバル例外ハンドラーで使用するトレースIDプロバイダ
     */
    @Bean
    public TraceIdProvider traceIdProvider(Tracer tracer) {
        return new OpenTelemetryTraceIdProvider(tracer);
    }
    
    /**
     * OpenTelemetryトレーサー実装
     */
    private static class OpenTelemetryTracer implements Tracer {
        
        // スパンにエラー情報を追加するメソッド
        @Override
        public void addErrorInfoToSpan(ErrorInfo errorInfo) {
            Span currentSpan = Span.current();
            if (currentSpan != null) {
                // エラー情報をスパン属性として追加
                currentSpan.setAttribute("error.code", errorInfo.getErrorCode().getFullCode());
                currentSpan.setAttribute("error.message", errorInfo.getDetail());
                // その他の属性設定
                
                // スパンのステータスをエラーに設定
                currentSpan.setStatus(StatusCode.ERROR, errorInfo.getDetail());
            }
        }
    }
}
```

## 8. パフォーマンスとチューニング

### 8.1 キャッシュとパフォーマンス最適化

エラーメッセージのキャッシュなど、パフォーマンス最適化の例：

```
/**
 * エラーメッセージキャッシュの実装
 */
@Component
public class ErrorMessageCache {
    
    private final MessageSource messageSource;
    private final Cache<ErrorMessageCacheKey, String> messageCache;
    
    // コンストラクタ、初期化...
    
    /**
     * エラーコードとロケールに基づいてメッセージを取得
     */
    public String getMessage(ErrorCode code, Locale locale, Object... args) {
        // 引数がない場合はキャッシュから取得
        if (args == null || args.length == 0) {
            ErrorMessageCacheKey key = new ErrorMessageCacheKey(code, locale);
            return messageCache.get(key, k -> 
                    messageSource.getMessage("error." + code.name(), args, locale));
        }
        
        // 引数がある場合はキャッシュせずに直接取得
        return messageSource.getMessage("error." + code.name(), args, locale);
    }
}
```

### 8.2 非同期エラーログ処理

エラーログ処理を非同期化してパフォーマンスを向上させる例：

```
/**
 * 非同期エラーロガーの実装
 */
@Service
public class AsyncErrorLogger implements ErrorLogger {
    
    private final ErrorLogger delegateLogger;
    private final Executor asyncExecutor;
    
    // コンストラクタ、DI...
    
    @Override
    public void logError(ErrorInfo errorInfo, Throwable exception) {
        // 非同期でエラーログを記録
        asyncExecutor.execute(() -> {
            try {
                delegateLogger.logError(errorInfo, exception);
            } catch (Exception e) {
                log.error("Failed to log error asynchronously", e);
            }
        });
    }
    
    @Override
    public void logCriticalError(ErrorInfo errorInfo, Throwable exception) {
        // 重大なエラーは同期的に記録して確実に通知
        try {
            delegateLogger.logCriticalError(errorInfo, exception);
        } catch (Exception e) {
            log.error("Failed to log critical error", e);
        }
    }
}
```

## 9. テスト戦略

例外ハンドリング機能のテスト実装例を示します。

### 9.1 単体テスト例

```
/**
 * ExceptionHandlingServiceの単体テスト
 */
@ExtendWith(MockitoExtension.class)
public class ExceptionHandlingServiceTest {
    
    @Mock
    private ErrorCodeRegistry errorCodeRegistry;
    
    @Mock
    private MessageSource messageSource;
    
    @InjectMocks
    private ExceptionHandlingServiceImpl exceptionHandlingService;
    
    private RequestContext requestContext;
    
    @BeforeEach
    public void setUp() {
        // テスト用のリクエストコンテキストをセットアップ
        
        // モックの振る舞いを設定
    }
    
    @Test
    public void testHandleResourceNotFoundException() {
        // 準備
        UUID resourceId = UUID.randomUUID();
        ResourceNotFoundException exception = new ResourceNotFoundException(
                "user",
                resourceId,
                ErrorCode.RESOURCE_NOT_FOUND,
                Map.of("key", "value"),
                null
        );
        
        // 実行
        ErrorInfo errorInfo = exceptionHandlingService.handleResourceNotFoundException(
                exception, requestContext);
        
        // 検証
        assertNotNull(errorInfo);
        assertEquals(ErrorCode.RESOURCE_NOT_FOUND, errorInfo.getErrorCode());
        // その他の検証
    }
    
    // その他のテストケース
}
```

### 9.2 統合テスト例

```
/**
 * グローバル例外ハンドラーの統合テスト
 */
@SpringBootTest
@AutoConfigureMockMvc
public class GlobalExceptionHandlerIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private UserService userService;
    
    @Test
    public void testResourceNotFoundException() throws Exception {
        // サービスモックの設定
        when(userService.findUserById(any(UUID.class)))
                .thenThrow(new ResourceNotFoundException(
                        "user",
                        UUID.randomUUID(),
                        ErrorCode.USER_NOT_FOUND,
                        null,
                        null
                ));
        
        // リクエストの実行と検証
        mockMvc.perform(get("/api/users/{id}", UUID.randomUUID())
                .header("X-B3-TraceId", "test-trace-id")
                .accept(MediaType.APPLICATION_JSON))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.code").value("E20001"))
                // その他の検証
    }
    
    // その他のテストケース
}
```

## 10. まとめ

例外ハンドリング機能のコア機能について概要を示します。

1. **グローバル例外ハンドラー**
   - アプリケーション全体での統一的な例外処理
   - 例外タイプに応じた適切なハンドリング
   - 構造化されたエラーレスポンスの生成

2. **例外階層と変換**
   - 業務例外とシステム例外の明確な区別
   - 技術的例外から意味のある業務例外への変換
   - フレームワーク依存の例外のラッピング

3. **エラーコード管理**
   - 体系的なエラーコード設計
   - 多言語対応したエラーメッセージ
   - エラーカテゴリと重大度の分類

4. **エラーログ記録**
   - 構造化ログフォーマット
   - 重大度に基づく処理の分岐
   - 通知機能との連携

5. **トレーシングとデバッグ**
   - 分散トレーシングとの統合
   - トレースIDによる例外追跡
   - 環境に応じたデバッグ情報の提供

この例外ハンドリング機能は、アプリケーション全体のエラー処理を標準化し、開発者とエンドユーザーの両方に適切なフィードバックを提供することで、より堅牢で保守性の高いシステムの実現に貢献します。