# 例外ハンドリング

## 1. 目的と概要

例外ハンドリング機能は、アプリケーション内で発生する様々な例外を捕捉し、適切に処理する仕組みを提供します。本ドキュメントでは、例外の捕捉方法、変換方法、およびエラーレスポンス生成の詳細な処理フローについて説明します。

この機能の主な目的は以下の通りです：

- Spring Frameworkの標準機能を活用した一貫性のある例外処理を実現する
- 発生した例外をRFC 7807に準拠したProblemDetailレスポンスに変換する
- 開発者とエンドユーザーに適切なエラー情報を提供する
- 例外発生時の影響範囲を最小限に抑える
- Spring Bootの機能を活用したメトリクス収集と監視を実現する

## 2. 例外ハンドリングの基本方針

### 2.1 層別例外ハンドリング方針

アプリケーションの各層における例外ハンドリングの方針を以下に示します。

| 層 | 例外ハンドリング方針 |
|---|-------------------|
| コントローラー層 | 基本的に例外を捕捉せず、SpringのControllerAdviceに委譲する |
| サービス層 | 業務ロジックに関わる例外を検知し、適切な業務例外に変換してスローする |
| リポジトリ層 | Spring Data JDBCの例外を捕捉し、わかりやすい業務例外または技術例外に変換する |
| 外部サービス連携層 | RestClientExceptionやWebClientExceptionを捕捉し、内部で扱いやすい形式に変換する |

### 2.2 例外変換の基本原則

- Spring Frameworkの標準例外体系を活用し、カスタム例外は最小限に抑える
- 下位層で発生した技術的例外は、上位層でよりSpringの標準例外または意味のある業務例外に変換する
- 例外変換時には元の例外を必ず原因例外（cause）として保持する
- 例外変換時にはコンテキスト情報を可能な限り保持する
- Spring BootのErrorAttributesカスタマイズ機能を活用してエラー情報を拡張する

## 3. グローバル例外ハンドラーの実装

Spring MVCの@ControllerAdvice/@RestControllerAdviceと`ResponseEntityExceptionHandler`を活用した集中型例外ハンドリングの実装概要を示します。

### 3.1 グローバル例外ハンドラークラスの構成

```java
/**
 * アプリケーション全体の例外を一元的に処理するグローバル例外ハンドラー
 * Spring標準のResponseEntityExceptionHandlerを拡張して実装
 */
@RestControllerAdvice
@Order(Ordered.HIGHEST_PRECEDENCE)
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {
    
    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    
    private final MeterRegistry meterRegistry;
    private final ProblemDetailFactory problemDetailFactory;
    private final ApplicationEventPublisher eventPublisher;
    private final MessageSource messageSource;
    
    /**
     * コンストラクタインジェクション
     */
    public GlobalExceptionHandler(
            MeterRegistry meterRegistry,
            ProblemDetailFactory problemDetailFactory,
            ApplicationEventPublisher eventPublisher,
            MessageSource messageSource) {
        this.meterRegistry = meterRegistry;
        this.problemDetailFactory = problemDetailFactory;
        this.eventPublisher = eventPublisher;
        this.messageSource = messageSource;
    }
    
    // 以下、各種例外ハンドラーメソッド
    
    /**
     * エラーメトリクスをインクリメントする
     */
    private void incrementErrorMetric(String errorType) {
        meterRegistry.counter("app.errors", "type", errorType).increment();
    }
    
    /**
     * エラーイベントを発行する
     */
    private void publishErrorEvent(Throwable ex, HttpServletRequest request, ProblemDetail problemDetail) {
        eventPublisher.publishEvent(new ErrorEvent(ex, request, problemDetail));
    }
}
```

### 3.2 バリデーション例外のハンドリング

Spring標準のバリデーション例外ハンドリングを拡張します。

```java
/**
 * MethodArgumentNotValidExceptionのハンドリング - Bean Validationの例外
 * ResponseEntityExceptionHandlerのメソッドをオーバーライド
 */
@Override
protected ResponseEntity<Object> handleMethodArgumentNotValid(
        MethodArgumentNotValidException ex,
        HttpHeaders headers,
        HttpStatusCode status,
        WebRequest request) {
    
    // Spring 6のProblemDetailを作成
    ProblemDetail problemDetail = createValidationProblemDetail(ex.getBindingResult(), request.getLocale());
    
    // エラーメトリクスをインクリメント
    incrementErrorMetric("validation");
    
    // エラーイベントを発行
    publishErrorEvent(ex, ((ServletWebRequest) request).getRequest(), problemDetail);
    
    return ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .body(problemDetail);
}

/**
 * ProblemDetailにバリデーションエラーの詳細情報を設定
 */
private ProblemDetail createValidationProblemDetail(BindingResult bindingResult, Locale locale) {
    ProblemDetail problemDetail = ProblemDetail.forStatusAndDetail(
            HttpStatus.BAD_REQUEST,
            messageSource.getMessage("error.validation.failed", null, locale));
    
    problemDetail.setTitle(messageSource.getMessage("error.validation.title", null, locale));
    problemDetail.setType(URI.create("https://example.com/errors/validation"));
    
    // バリデーションエラーの詳細情報を収集
    Map<String, List<String>> fieldErrors = new HashMap<>();
    bindingResult.getFieldErrors().forEach(error -> {
        String field = error.getField();
        String message = messageSource.getMessage(error, locale);
        fieldErrors.computeIfAbsent(field, k -> new ArrayList<>()).add(message);
    });
    
    // バリデーションエラーをプロパティとして追加
    problemDetail.setProperty("fieldErrors", fieldErrors);
    
    // グローバルエラーがあれば追加
    if (bindingResult.hasGlobalErrors()) {
        List<String> globalErrors = bindingResult.getGlobalErrors().stream()
                .map(error -> messageSource.getMessage(error, locale))
                .collect(Collectors.toList());
        problemDetail.setProperty("globalErrors", globalErrors);
    }
    
    return problemDetail;
}
```

### 3.3 業務例外のハンドリング

業務例外を`ProblemDetail`に変換します。

```java
/**
 * 業務例外のハンドリング
 */
@ExceptionHandler(BusinessException.class)
public ResponseEntity<ProblemDetail> handleBusinessException(
        BusinessException ex, WebRequest request, Locale locale) {
    
    // Spring 6のProblemDetailを作成
    HttpStatus status = determineHttpStatus(ex);
    ProblemDetail problemDetail = problemDetailFactory.createFromException(ex, status, request, locale);
    
    // エラーメトリクスをインクリメント
    incrementErrorMetric("business." + ex.getErrorCode().getCategory().toLowerCase());
    
    // エラーイベントを発行
    publishErrorEvent(ex, ((ServletWebRequest) request).getRequest(), problemDetail);
    
    return ResponseEntity
            .status(status)
            .body(problemDetail);
}

/**
 * リソース未検出例外のハンドリング
 */
@ExceptionHandler(ResourceNotFoundException.class)
public ResponseEntity<ProblemDetail> handleResourceNotFoundException(
        ResourceNotFoundException ex, WebRequest request, Locale locale) {
    
    // リソース未検出用のProblemDetailを作成
    ProblemDetail problemDetail = problemDetailFactory.createFromException(
            ex, HttpStatus.NOT_FOUND, request, locale);
    
    // エラーメトリクスをインクリメント
    incrementErrorMetric("not_found");
    
    // エラーイベントを発行
    publishErrorEvent(ex, ((ServletWebRequest) request).getRequest(), problemDetail);
    
    return ResponseEntity
            .status(HttpStatus.NOT_FOUND)
            .body(problemDetail);
}
```

### 3.4 システム例外のハンドリング

```java
/**
 * システム例外のハンドリング
 */
@ExceptionHandler(SystemException.class)
public ResponseEntity<ProblemDetail> handleSystemException(
        SystemException ex, WebRequest request, Locale locale) {
    
    // システムエラー用のProblemDetailを作成
    ProblemDetail problemDetail = problemDetailFactory.createFromException(
            ex, HttpStatus.INTERNAL_SERVER_ERROR, request, locale);
    
    // エラーメトリクスをインクリメント
    incrementErrorMetric("system." + ex.getErrorCode().getCategory().toLowerCase());
    
    // エラーイベントを発行（重大なエラーとしてマーク）
    publishErrorEvent(ex, ((ServletWebRequest) request).getRequest(), problemDetail);
    
    return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(problemDetail);
}
```

### 3.5 セキュリティ例外のハンドリング

Spring Securityとの統合例を示します。

```java
/**
 * 認証例外のハンドリング
 */
@ExceptionHandler(org.springframework.security.core.AuthenticationException.class)
public ResponseEntity<ProblemDetail> handleAuthenticationException(
        org.springframework.security.core.AuthenticationException ex, WebRequest request, Locale locale) {
    
    // 認証エラー用のProblemDetailを作成
    ProblemDetail problemDetail = problemDetailFactory.createFromExceptionAndErrorCode(
            ex, ErrorCode.AUTHENTICATION_ERROR, HttpStatus.UNAUTHORIZED, request, locale);
    
    // エラーメトリクスをインクリメント
    incrementErrorMetric("security.authentication");
    
    // エラーイベントを発行
    publishErrorEvent(ex, ((ServletWebRequest) request).getRequest(), problemDetail);
    
    return ResponseEntity
            .status(HttpStatus.UNAUTHORIZED)
            .body(problemDetail);
}

/**
 * アクセス拒否例外のハンドリング
 */
@ExceptionHandler(org.springframework.security.access.AccessDeniedException.class)
public ResponseEntity<ProblemDetail> handleAccessDeniedException(
        org.springframework.security.access.AccessDeniedException ex, WebRequest request, Locale locale) {
    
    // アクセス拒否エラー用のProblemDetailを作成
    ProblemDetail problemDetail = problemDetailFactory.createFromExceptionAndErrorCode(
            ex, ErrorCode.ACCESS_DENIED, HttpStatus.FORBIDDEN, request, locale);
    
    // エラーメトリクスをインクリメント
    incrementErrorMetric("security.access_denied");
    
    // エラーイベントを発行
    publishErrorEvent(ex, ((ServletWebRequest) request).getRequest(), problemDetail);
    
    return ResponseEntity
            .status(HttpStatus.FORBIDDEN)
            .body(problemDetail);
}
```

### 3.6 未処理例外のハンドリング

```java
/**
 * 未処理の例外のハンドリング（最終的なフォールバック）
 */
@ExceptionHandler(Exception.class)
public ResponseEntity<ProblemDetail> handleUnknownException(
        Exception ex, WebRequest request, Locale locale) {
    
    // 予期しない例外を内部サーバーエラーとして処理
    ProblemDetail problemDetail = problemDetailFactory.createFromExceptionAndErrorCode(
            ex, ErrorCode.UNEXPECTED_ERROR, HttpStatus.INTERNAL_SERVER_ERROR, request, locale);
    
    // エクセプションタイプを追加
    problemDetail.setProperty("exceptionType", ex.getClass().getName());
    
    // エラーメトリクスをインクリメント
    incrementErrorMetric("unexpected");
    
    // エラーイベントを発行（重大なエラーとしてマーク）
    publishErrorEvent(ex, ((ServletWebRequest) request).getRequest(), problemDetail);
    
    // Actuatorメトリクスに致命的なエラーを記録
    meterRegistry.counter("app.errors.critical").increment();
    
    return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(problemDetail);
}
```

## 4. ProblemDetailファクトリーの実装

Spring 6のProblemDetailをカスタマイズするファクトリーの実装概要を示します。

### 4.1 ProblemDetailFactoryインターフェース

```java
/**
 * ProblemDetailを生成するファクトリーのインターフェース
 */
public interface ProblemDetailFactory {
    /**
     * 例外からProblemDetailを生成
     */
    ProblemDetail createFromException(
            Throwable exception, 
            HttpStatusCode status, 
            WebRequest request, 
            Locale locale);
    
    /**
     * 例外と指定されたエラーコードからProblemDetailを生成
     */
    ProblemDetail createFromExceptionAndErrorCode(
            Throwable exception,
            ErrorCode errorCode,
            HttpStatusCode status,
            WebRequest request,
            Locale locale);
}
```

### 4.2 ProblemDetailFactoryの実装

```java
/**
 * ProblemDetailファクトリーの実装クラス
 */
@Component
public class ProblemDetailFactoryImpl implements ProblemDetailFactory {

    private final ErrorCodeRegistry errorCodeRegistry;
    private final MessageSource messageSource;
    private final TraceContextProvider traceContextProvider;
    private final Clock clock;
    
    // コンストラクタ、DI...
    
    @Override
    public ProblemDetail createFromException(
            Throwable exception, 
            HttpStatusCode status, 
            WebRequest request, 
            Locale locale) {
        
        // 例外クラスからエラーコードを推測
        ErrorCode errorCode = determineErrorCode(exception);
        
        return createFromExceptionAndErrorCode(
                exception, errorCode, status, request, locale);
    }
    
    @Override
    public ProblemDetail createFromExceptionAndErrorCode(
            Throwable exception,
            ErrorCode errorCode,
            HttpStatusCode status,
            WebRequest request,
            Locale locale) {
        
        // ProblemDetailの基本情報を設定
        ProblemDetail problemDetail = ProblemDetail.forStatus(status);
        
        // エラーコードに基づいてタイトルとメッセージを設定
        String title = messageSource.getMessage(
                "error." + errorCode.name() + ".title", 
                null, 
                errorCode.getDefaultTitle(), 
                locale);
        String detail = messageSource.getMessage(
                "error." + errorCode.name() + ".detail", 
                extractMessageArguments(exception), 
                getExceptionMessage(exception), 
                locale);
        
        problemDetail.setTitle(title);
        problemDetail.setDetail(detail);
        
        // エラーコード情報を設定
        problemDetail.setProperty("code", errorCode.getFullCode());
        problemDetail.setProperty("category", errorCode.getCategory());
        
        // タイプURIを設定
        problemDetail.setType(URI.create("https://example.com/errors/" + errorCode.getCategory().toLowerCase()));
        
        // トレース情報を追加
        String traceId = traceContextProvider.getCurrentTraceId();
        if (traceId != null) {
            problemDetail.setProperty("traceId", traceId);
        }
        
        // タイムスタンプを追加
        problemDetail.setProperty("timestamp", OffsetDateTime.now(clock).toString());
        
        // 例外固有の追加情報を設定
        enrichProblemDetailFromException(problemDetail, exception);
        
        // リクエスト情報の追加
        if (request instanceof ServletWebRequest servletRequest) {
            problemDetail.setProperty("path", servletRequest.getRequest().getRequestURI());
            problemDetail.setProperty("method", servletRequest.getRequest().getMethod());
        }
        
        return problemDetail;
    }
    
    /**
     * 例外クラスからエラーコードを推測する
     */
    private ErrorCode determineErrorCode(Throwable exception) {
        if (exception instanceof ApplicationException appEx) {
            return appEx.getErrorCode();
        }
        
        // Spring MVCの例外マッピング
        if (exception instanceof HttpRequestMethodNotSupportedException) {
            return ErrorCode.METHOD_NOT_ALLOWED;
        } else if (exception instanceof HttpMediaTypeNotSupportedException) {
            return ErrorCode.UNSUPPORTED_MEDIA_TYPE;
        } else if (exception instanceof MethodArgumentNotValidException || 
                   exception instanceof BindException) {
            return ErrorCode.VALIDATION_ERROR;
        }
        
        // Spring Securityの例外マッピング
        if (exception instanceof AuthenticationException) {
            return ErrorCode.AUTHENTICATION_ERROR;
        } else if (exception instanceof AccessDeniedException) {
            return ErrorCode.ACCESS_DENIED;
        }
        
        // データアクセス層の例外マッピング
        if (exception instanceof DataAccessException) {
            return mapDataAccessException((DataAccessException) exception);
        }
        
        // その他の例外はデフォルトのエラーコード
        return ErrorCode.UNEXPECTED_ERROR;
    }
    
    // その他のヘルパーメソッド...
}
```

## 5. 例外変換の実装例

### 5.1 データアクセス例外の変換

Spring Data JDBCのデータアクセス例外をアプリケーション例外に変換する例：

```java
/**
 * データアクセス例外をアプリケーション例外に変換するアドバイザー
 */
@Component
public class DataAccessExceptionTranslator {
    
    /**
     * データアクセス例外をアプリケーション例外に変換します
     */
    @Pointcut("execution(* jp.co.example.sesapp.*.repository.*.*(..))")
    public void repositoryMethods() {
    }
    
    @AfterThrowing(pointcut = "repositoryMethods()", throwing = "ex")
    public void translateException(JoinPoint jp, DataAccessException ex) throws Throwable {
        if (ex instanceof DataIntegrityViolationException) {
            // 一意制約違反の処理
            if (ex.getMessage() != null && ex.getMessage().contains("unique_constraint")) {
                throw new DuplicateResourceException(
                        determineResourceType(jp),
                        getConstraintName(ex),
                        ErrorCode.DUPLICATE_RESOURCE,
                        Map.of("constraintName", getConstraintName(ex)),
                        ex
                );
            }
        } else if (ex instanceof EmptyResultDataAccessException) {
            // リソースが見つからないエラーとして扱う
            throw new ResourceNotFoundException(
                    determineResourceType(jp),
                    determineResourceId(jp, ex),
                    ErrorCode.RESOURCE_NOT_FOUND,
                    Map.of("methodName", jp.getSignature().getName()),
                    ex
            );
        } else if (ex instanceof OptimisticLockingFailureException) {
            // 楽観的ロック失敗の処理
            throw new ConcurrentModificationException(
                    determineResourceType(jp),
                    determineResourceId(jp, ex),
                    ErrorCode.CONCURRENT_MODIFICATION,
                    Map.of("methodName", jp.getSignature().getName()),
                    ex
            );
        }
        
        // その他のデータアクセス例外はそのままスロー
        throw ex;
    }
    
    // ヘルパーメソッド...
}
```

### 5.2 外部サービス例外の変換

Spring WebClientやRestClientを使用した外部サービス呼び出しで発生する例外の変換例：

```java
/**
 * WebClientの例外ハンドラー
 */
@Component
public class WebClientExceptionHandler {

    /**
     * WebClientのエラーハンドラーを作成
     */
    public ExchangeFilterFunction createExchangeFilterFunction(String serviceName) {
        return ExchangeFilterFunction.ofResponseProcessor(clientResponse -> {
            if (clientResponse.statusCode().isError()) {
                return clientResponse.bodyToMono(String.class)
                        .flatMap(errorBody -> Mono.error(translateStatusCodeError(
                                serviceName, 
                                clientResponse.statusCode(), 
                                errorBody)));
            }
            return Mono.just(clientResponse);
        });
    }
    
    /**
     * HTTPステータスコードに基づいて適切な例外に変換
     */
    private Throwable translateStatusCodeError(
            String serviceName, HttpStatusCode statusCode, String responseBody) {
        
        if (statusCode.equals(HttpStatus.NOT_FOUND)) {
            return new IntegrationResourceNotFoundException(
                    serviceName,
                    "resource",
                    ErrorCode.INTEGRATION_RESOURCE_NOT_FOUND,
                    Map.of(
                        "statusCode", statusCode.value(),
                        "responseBody", responseBody
                    )
            );
        } else if (statusCode.equals(HttpStatus.UNAUTHORIZED)) {
            return new IntegrationAuthenticationException(
                    serviceName,
                    ErrorCode.INTEGRATION_AUTHENTICATION_ERROR,
                    Map.of(
                        "statusCode", statusCode.value(),
                        "responseBody", responseBody
                    )
            );
        } else if (statusCode.equals(HttpStatus.FORBIDDEN)) {
            return new IntegrationAuthorizationException(
                    serviceName,
                    ErrorCode.INTEGRATION_AUTHORIZATION_ERROR,
                    Map.of(
                        "statusCode", statusCode.value(),
                        "responseBody", responseBody
                    )
            );
        } else if (statusCode.is4xxClientError()) {
            return new IntegrationClientException(
                    serviceName,
                    ErrorCode.INTEGRATION_CLIENT_ERROR,
                    Map.of(
                        "statusCode", statusCode.value(),
                        "responseBody", responseBody
                    )
            );
        } else if (statusCode.is5xxServerError()) {
            return new IntegrationServerException(
                    serviceName,
                    ErrorCode.INTEGRATION_SERVER_ERROR,
                    Map.of(
                        "statusCode", statusCode.value(),
                        "responseBody", responseBody
                    )
            );
        }
        
        // その他のエラーはデフォルトの統合例外として扱う
        return new IntegrationException(
                serviceName,
                ErrorCode.INTEGRATION_ERROR,
                Map.of(
                    "statusCode", statusCode.value(),
                    "responseBody", responseBody
                )
        );
    }
}
```

## 6. セキュリティ例外の処理

Spring Securityと連携したセキュリティ例外処理の実装例：

```java
/**
 * Spring Securityのセキュリティ例外ハンドラー設定
 */
@Configuration
@EnableWebSecurity
public class SecurityExceptionConfig {
    
    private final ProblemDetailFactory problemDetailFactory;
    private final ObjectMapper objectMapper;
    
    // コンストラクタ、DI...
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
            // 他のセキュリティ設定...
            
            // 認証エラーハンドラーとアクセス拒否ハンドラーを設定
            .exceptionHandling(ex -> ex
                .authenticationEntryPoint(authenticationEntryPoint())
                .accessDeniedHandler(accessDeniedHandler())
            )
            .build();
    }
    
    /**
     * 認証エラーエントリーポイント（未認証アクセス時の処理）
     */
    @Bean
    public AuthenticationEntryPoint authenticationEntryPoint() {
        return (request, response, exception) -> {
            response.setStatus(HttpStatus.UNAUTHORIZED.value());
            response.setContentType(MediaType.APPLICATION_PROBLEM_JSON_VALUE);
            
            // ProblemDetailを作成
            ProblemDetail problemDetail = problemDetailFactory.createFromExceptionAndErrorCode(
                    exception,
                    ErrorCode.AUTHENTICATION_ERROR,
                    HttpStatus.UNAUTHORIZED,
                    new ServletWebRequest(request),
                    request.getLocale()
            );
            
            // ProblemDetailをJSONとして出力
            try (Writer writer = response.getWriter()) {
                objectMapper.writeValue(writer, problemDetail);
            }
        };
    }
    
    /**
     * アクセス拒否ハンドラー（権限不足時の処理）
     */
    @Bean
    public AccessDeniedHandler accessDeniedHandler() {
        return (request, response, exception) -> {
            response.setStatus(HttpStatus.FORBIDDEN.value());
            response.setContentType(MediaType.APPLICATION_PROBLEM_JSON_VALUE);
            
            // ProblemDetailを作成
            ProblemDetail problemDetail = problemDetailFactory.createFromExceptionAndErrorCode(
                    exception,
                    ErrorCode.ACCESS_DENIED,
                    HttpStatus.FORBIDDEN,
                    new ServletWebRequest(request),
                    request.getLocale()
            );
            
            // ProblemDetailをJSONとして出力
            try (Writer writer = response.getWriter()) {
                objectMapper.writeValue(writer, problemDetail);
            }
        };
    }
}
```

## 7. エラーイベントとログ処理

### 7.1 エラーイベントの定義

Spring ApplicationEventを活用したエラーイベント処理：

```java
/**
 * エラー発生時に発行されるイベント
 */
public class ErrorEvent extends ApplicationEvent {
    
    private final HttpServletRequest request;
    private final ProblemDetail problemDetail;
    
    public ErrorEvent(Throwable source, HttpServletRequest request, ProblemDetail problemDetail) {
        super(source);
        this.request = request;
        this.problemDetail = problemDetail;
    }
    
    /**
     * 元の例外を取得
     */
    @Override
    public Throwable getSource() {
        return (Throwable) super.getSource();
    }
    
    // ゲッターメソッド...
}

/**
 * エラーイベントリスナー
 */
@Component
public class ErrorEventListener {
    
    private static final Logger log = LoggerFactory.getLogger(ErrorEventListener.class);
    
    private final ErrorLogRepository errorLogRepository;
    private final ObjectMapper objectMapper;
    
    // コンストラクタ、DI...
    
    /**
     * エラーイベントのハンドリング
     * 非同期で処理するため@Asyncアノテーション付与
     */
    @Async
    @EventListener
    public void handleErrorEvent(ErrorEvent event) {
        try {
            // エラー情報をログに出力
            logError(event);
            
            // エラーログをDBに永続化
            persistErrorLog(event);
        } catch (Exception ex) {
            log.error("Failed to process error event", ex);
        }
    }
    
    /**
     * 構造化されたエラーログを出力
     */
    private void logError(ErrorEvent event) throws JsonProcessingException {
        // エラー情報をJSONに変換
        Map<String, Object> logData = new HashMap<>();
        // 基本情報を設定
        logData.put("timestamp", OffsetDateTime.now().toString());
        logData.put("level", determineLogLevel(event.getSource()));
        logData.put("traceId", event.getProblemDetail().getProperties().get("traceId"));
        logData.put("path", event.getRequest().getRequestURI());
        logData.put("method", event.getRequest().getMethod());
        
        // 例外情報を設定
        Map<String, Object> exceptionData = new HashMap<>();
        exceptionData.put("type", event.getSource().getClass().getName());
        exceptionData.put("message", event.getSource().getMessage());
        exceptionData.put("stackTrace", getStackTraceForLog(event.getSource()));
        logData.put("exception", exceptionData);
        
        // ProblemDetail情報を設定
        logData.put("problemDetail", event.getProblemDetail());
        
        // ログ出力
        log.error("{}", objectMapper.writeValueAsString(logData));
    }
    
    /**
     * エラーログをデータベースに永続化
     */
    private void persistErrorLog(ErrorEvent event) {
        ErrorLog errorLog = new ErrorLog();
        // エラーログエンティティに情報を設定
        errorLog.setTimestamp(OffsetDateTime.now());
        errorLog.setTraceId((String) event.getProblemDetail().getProperties().get("traceId"));
        errorLog.setPath(event.getRequest().getRequestURI());
        errorLog.setMethod(event.getRequest().getMethod());
        errorLog.setUserAgent(event.getRequest().getHeader("User-Agent"));
        errorLog.setIpAddress(getClientIpAddress(event.getRequest()));
        errorLog.setErrorCode((String) event.getProblemDetail().getProperties().get("code"));
        errorLog.setErrorCategory((String) event.getProblemDetail().getProperties().get("category"));
        errorLog.setErrorTitle(event.getProblemDetail().getTitle());
        errorLog.setErrorDetail(event.getProblemDetail().getDetail());
        errorLog.setExceptionType(event.getSource().getClass().getName());
        errorLog.setExceptionMessage(event.getSource().getMessage());
        
        // リポジトリを使用して永続化
        errorLogRepository.save(errorLog);
    }
    
    // ヘルパーメソッド...
}
```

### 7.2 分散トレーシングとの統合

Spring Cloud Sleuthとの統合例：

```java
/**
 * トレースIDプロバイダー
 */
@Component
public class TraceContextProvider {
    
    /**
     * 現在のトレースIDを取得
     */
    public String getCurrentTraceId() {
        return Span.current().getSpanContext().getTraceId();
    }
    
    /**
     * 現在のスパンIDを取得
     */
    public String getCurrentSpanId() {
        return Span.current().getSpanContext().getSpanId();
    }
    
    /**
     * 例外情報をスパンに追加
     */
    public void addExceptionToCurrentSpan(Throwable exception, ProblemDetail problemDetail) {
        Span currentSpan = Span.current();
        if (currentSpan != null) {
            // エラー情報をスパン属性として追加
            currentSpan.setAttribute("error", true);
            currentSpan.setAttribute("error.code", (String) problemDetail.getProperties().get("code"));
            currentSpan.setAttribute("error.category", (String) problemDetail.getProperties().get("category"));
            currentSpan.setAttribute("error.message", problemDetail.getDetail());
            
            // スパンのステータスをエラーに設定
            currentSpan.setStatus(StatusCode.ERROR, problemDetail.getDetail());
            
            // 例外情報を記録
            currentSpan.recordException(exception);
        }
    }
}
```

## 8. Spring Boot Actuatorとの統合

エラーメトリクスの収集とActuatorエンドポイントのカスタマイズ：

```java
/**
 * Spring Boot Actuatorカスタマイズ
 */
@Configuration
public class ErrorMetricsConfig {
    
    /**
     * エラーメトリクスを登録
     */
    @Bean
    public MeterBinder errorMetrics(MeterRegistry meterRegistry) {
        return registry -> {
            // エラーカウンターの登録
            Counter.builder("app.errors.total")
                    .description("Total number of errors")
                    .register(registry);
            
            // エラーカテゴリ別カウンターの登録
            Counter.builder("app.errors")
                    .description("Number of errors by type")
                    .tag("type", "validation")
                    .register(registry);
            
            Counter.builder("app.errors")
                    .description("Number of errors by type")
                    .tag("type", "business")
                    .register(registry);
            
            Counter.builder("app.errors")
                    .description("Number of errors by type")
                    .tag("type", "system")
                    .register(registry);
            
            Counter.builder("app.errors")
                    .description("Number of errors by type")
                    .tag("type", "security")
                    .register(registry);
            
            Counter.builder("app.errors")
                    .description("Number of errors by type")
                    .tag("type", "unexpected")
                    .register(registry);
            
            // 重大エラーカウンター
            Counter.builder("app.errors.critical")
                    .description("Number of critical errors")
                    .register(registry);
        };
    }
    
    /**
     * エラー情報のActuatorエンドポイントをカスタマイズ
     */
    @Bean
    public ErrorAttributesCustomizer errorAttributesCustomizer(
            TraceContextProvider traceContextProvider,
            Clock clock) {
        return attributes -> {
            // エラー情報にトレースIDを追加
            String traceId = traceContextProvider.getCurrentTraceId();
            if (traceId != null) {
                attributes.put("traceId", traceId);
            }
            
            // タイムスタンプをISO 8601形式に変換
            if (attributes.containsKey("timestamp")) {
                Instant timestamp = (Instant) attributes.get("timestamp");
                attributes.put("timestamp", OffsetDateTime.ofInstant(timestamp, clock.getZone()).toString());
            }
            
            // エラー情報を見やすくするためにクラス名を短くする
            if (attributes.containsKey("exception")) {
                String exceptionClass = (String) attributes.get("exception");
                attributes.put("exception", exceptionClass.substring(exceptionClass.lastIndexOf('.') + 1));
            }
            
            // スタックトレースは本番環境では非表示にする
            if (!"dev".equals(System.getProperty("spring.profiles.active"))) {
                attributes.remove("trace");
            }
        };
    }
}
```

## 9. パフォーマンスとチューニング

### 9.1 キャッシュとパフォーマンス最適化

Spring Cacheを活用したエラーメッセージのキャッシュ：

```java
/**
 * エラーメッセージキャッシュの設定
 */
@Configuration
@EnableCaching
public class ErrorCacheConfig {
    
    /**
     * エラーメッセージ用キャッシュマネージャー
     */
    @Bean
    public CacheManager errorCacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager("errorMessages");
        
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .maximumSize(500)
                .expireAfterWrite(Duration.ofHours(1))
                .recordStats());
        
        return cacheManager;
    }
}

/**
 * キャッシュを活用したメッセージソースラッパー
 */
@Component
public class CachedMessageSource {
    
    private final MessageSource delegate;
    
    public CachedMessageSource(MessageSource delegate) {
        this.delegate = delegate;
    }
    
    /**
     * キャッシュを利用したメッセージ解決
     */
    @Cacheable(cacheNames = "errorMessages", key = "#code + '_' + #locale")
    public String getMessage(String code, Locale locale) {
        return delegate.getMessage(code, null, code, locale);
    }
    
    /**
     * 引数付きメッセージ解決（キャッシュなし）
     */
    public String getMessage(String code, Object[] args, Locale locale) {
        return delegate.getMessage(code, args, code, locale);
    }
}
```

### 9.2 非同期エラーログ処理

Spring の@Asyncを活用した非同期エラーログ処理：

```java
/**
 * 非同期処理設定
 */
@Configuration
@EnableAsync
public class AsyncConfig {
    
    /**
     * エラーログ処理用の非同期実行者
     */
    @Bean
    public Executor errorLogExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(5);
        executor.setQueueCapacity(500);
        executor.setThreadNamePrefix("error-log-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}

/**
 * 非同期エラーロガーの実装
 */
@Service
public class AsyncErrorLogService {
    
    private static final Logger log = LoggerFactory.getLogger(AsyncErrorLogService.class);
    
    private final ErrorLogRepository errorLogRepository;
    
    // コンストラクタ、DI...
    
    /**
     * エラーログを非同期で保存
     */
    @Async("errorLogExecutor")
    public CompletableFuture<Void> saveErrorLogAsync(ErrorLog errorLog) {
        try {
            errorLogRepository.save(errorLog);
            return CompletableFuture.completedFuture(null);
        } catch (Exception ex) {
            log.error("Failed to save error log asynchronously", ex);
            return CompletableFuture.failedFuture(ex);
        }
    }
    
    /**
     * 重大なエラーを非同期で通知
     */
    @Async("errorLogExecutor")
    public CompletableFuture<Void> notifyCriticalError(ErrorEvent event) {
        try {
            // メール通知、Slack通知などの処理
            // ...
            
            return CompletableFuture.completedFuture(null);
        } catch (Exception ex) {
            log.error("Failed to notify critical error", ex);
            return CompletableFuture.failedFuture(ex);
        }
    }
}
```

## 10. テスト戦略

例外ハンドリング機能のテスト実装例を示します。

### 10.1 単体テスト例

```java
/**
 * GlobalExceptionHandlerの単体テスト
 */
@ExtendWith(MockitoExtension.class)
class GlobalExceptionHandlerTest {
    
    @Mock
    private MeterRegistry meterRegistry;
    
    @Mock
    private ProblemDetailFactory problemDetailFactory;
    
    @Mock
    private ApplicationEventPublisher eventPublisher;
    
    @Mock
    private MessageSource messageSource;
    
    @Mock
    private Counter counter;
    
    @InjectMocks
    private GlobalExceptionHandler exceptionHandler;
    
    private MockHttpServletRequest servletRequest;
    private ServletWebRequest webRequest;
    private Locale locale = Locale.JAPANESE;
    
    @BeforeEach
    void setUp() {
        servletRequest = new MockHttpServletRequest();
        servletRequest.setRequestURI("/api/test");
        servletRequest.setMethod("GET");
        webRequest = new ServletWebRequest(servletRequest);
        
        // Counter mockのセットアップ
        when(meterRegistry.counter(anyString(), any(String[].class))).thenReturn(counter);
    }
    
    @Test
    void handleResourceNotFoundException() {
        // 準備
        UUID resourceId = UUID.randomUUID();
        ResourceNotFoundException ex = new ResourceNotFoundException(
                "user",
                resourceId.toString(),
                ErrorCode.RESOURCE_NOT_FOUND,
                null
        );
        
        ProblemDetail expectedProblemDetail = ProblemDetail.forStatus(HttpStatus.NOT_FOUND);
        expectedProblemDetail.setTitle("Resource Not Found");
        expectedProblemDetail.setDetail("The requested user resource was not found");
        
        when(problemDetailFactory.createFromException(
                eq(ex), eq(HttpStatus.NOT_FOUND), eq(webRequest), eq(locale)))
                .thenReturn(expectedProblemDetail);
        
        // 実行
        ResponseEntity<ProblemDetail> response = exceptionHandler.handleResourceNotFoundException(
                ex, webRequest, locale);
        
        // 検証
        assertNotNull(response);
        assertEquals(HttpStatus.NOT_FOUND, response.getStatusCode());
        assertEquals(expectedProblemDetail, response.getBody());
        
        // メトリクスとイベント発行の検証
        verify(meterRegistry).counter("app.errors", "type", "not_found");
        verify(counter).increment();
        verify(eventPublisher).publishEvent(any(ErrorEvent.class));
    }
    
    // その他のテストケース...
}
```

### 10.2 統合テスト例

```java
/**
 * 例外ハンドリングの統合テスト
 */
@SpringBootTest
@AutoConfigureMockMvc
class ExceptionHandlingIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private UserService userService;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Test
    void testResourceNotFoundException() throws Exception {
        // サービスモックの設定
        UUID userId = UUID.randomUUID();
        when(userService.findUserById(eq(userId)))
                .thenThrow(new ResourceNotFoundException(
                        "user",
                        userId.toString(),
                        ErrorCode.USER_NOT_FOUND,
                        null
                ));
        
        // リクエストの実行と検証
        mockMvc.perform(get("/api/users/{id}", userId)
                .accept(MediaType.APPLICATION_JSON))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.type").value("https://example.com/errors/resource"))
                .andExpect(jsonPath("$.title").value("Resource Not Found"))
                .andExpect(jsonPath("$.status").value(404))
                .andExpect(jsonPath("$.detail").exists())
                .andExpect(jsonPath("$.properties.code").value("E4001"))
                .andExpect(jsonPath("$.properties.traceId").exists())
                .andExpect(jsonPath("$.properties.timestamp").exists());
    }
    
    @Test
    void testValidationError() throws Exception {
        // 無効なリクエストボディを作成
        UserCreateRequest invalidRequest = new UserCreateRequest();
        invalidRequest.setEmail("invalid-email");
        
        // リクエストの実行と検証
        mockMvc.perform(post("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(invalidRequest))
                .accept(MediaType.APPLICATION_JSON))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.type").value("https://example.com/errors/validation"))
                .andExpect(jsonPath("$.title").value("Validation Error"))
                .andExpect(jsonPath("$.status").value(400))
                .andExpect(jsonPath("$.properties.fieldErrors").exists())
                .andExpect(jsonPath("$.properties.fieldErrors.email").isArray());
    }
    
    // その他のテストケース...
}
```

## 11. まとめ

Spring標準機能を活用した例外ハンドリング機能の主要な特徴について概要を示します。

1. **Spring標準の例外処理機能**
   - ResponseEntityExceptionHandlerを継承したグローバル例外ハンドラー
   - RFC 7807に準拠したProblemDetail応答の活用
   - Actuatorとの統合によるメトリクス収集と監視

2. **Spring Eventを活用した非同期処理**
   - ApplicationEventPublisherによるイベント駆動型エラーログ記録
   - @Asyncアノテーションを使用した非同期エラー処理
   - エラーイベントのリスナーによる柔軟な拡張性

3. **Spring Cacheとの統合**
   - Caffeine Cache統合によるエラーメッセージのキャッシング
   - パフォーマンス最適化とリソース効率の向上

4. **Spring Data JDBCとの統合**
   - データアクセス例外の自動変換
   - リポジトリを活用したエラーログの永続化

5. **Spring Securityとの統合**
   - 認証・認可例外の統一的な処理
   - セキュリティフィルターチェーンとの連携

6. **Observabilityの強化**
   - Spring Boot Actuatorによるエラーメトリクスの収集
   - 分散トレーシングとの統合
   - 構造化ログフォーマットの活用

この例外ハンドリング機能は、Spring FrameworkとSpring Bootの標準機能を最大限に活用し、アプリケーション全体での一貫した例外処理と、開発者/エンドユーザー双方にとって有用なエラーフィードバックを提供します。標準的なRFC 7807形式のエラーレスポンスを採用することで、API互換性と保守性の向上にも貢献します。