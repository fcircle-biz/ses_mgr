# 統一エラーモデル

## 1. 目的と概要

統一エラーモデルは、システム全体で一貫したエラー表現と処理を実現するための基盤を提供します。Spring FrameworkとSpring Bootが提供する標準機能を活用し、RFC 7807に準拠したProblemDetailを中心としたエラーモデルを採用します。これにより、以下の利点を得ることができます：

- フロントエンドとバックエンドでの一貫したエラー処理パターンの確立
- エラー情報の構造化と標準化によるデバッグ効率の向上
- Spring標準機能との親和性と保守性の向上
- 国際化対応を含むユーザーフレンドリーなエラーメッセージの提供
- 運用監視とトラブルシューティングの効率化

本ドキュメントでは、Spring標準機能を活用したエラーモデルの構造、エラーコードの管理方法、およびエラー情報の生成・伝播メカニズムについて詳細に説明します。

## 2. エラーモデル定義

### 2.1 ProblemDetail クラス

Spring 6で導入されたRFC 7807準拠のProblemDetailクラスを中心としたエラーモデルを採用します。

```java
/**
 * RFC 7807準拠のProblemDetailを拡張したエラーモデル
 */
public class CustomProblemDetail extends ProblemDetail {

    /**
     * ProblemDetailを生成する
     */
    public static ProblemDetail forStatusAndDetail(HttpStatusCode status, String detail) {
        ProblemDetail problemDetail = ProblemDetail.forStatusAndDetail(status, detail);
        problemDetail.setProperty("timestamp", Instant.now().toString());
        // 他の共通属性設定
        return problemDetail;
    }
    
    /**
     * エラーコードからProblemDetailを生成する
     */
    public static ProblemDetail forErrorCode(ErrorCode errorCode, String detail, ErrorCodeService errorCodeService) {
        ProblemDetail problemDetail = forStatusAndDetail(errorCodeService.getHttpStatus(errorCode), detail);
        
        // エラーコード固有の情報設定
        problemDetail.setType(errorCodeService.getType(errorCode));
        problemDetail.setTitle(errorCodeService.getTitle(errorCode));
        problemDetail.setProperty("code", errorCode.getFullCode());
        
        return problemDetail;
    }
}
```

### 2.2 バリデーションエラー拡張

Bean ValidationとSpring Validationによるバリデーションエラーを扱うためのProblemDetail拡張です。

```java
/**
 * バリデーションエラー用ProblemDetail拡張
 */
public class ValidationProblemDetailBuilder {
    
    /**
     * BindingResultからバリデーションエラー用ProblemDetailを生成する
     */
    public static ProblemDetail fromBindingResult(
            BindingResult bindingResult, 
            ErrorCode errorCode,
            ErrorCodeService errorCodeService,
            MessageSource messageSource,
            Locale locale) {
        
        // 基本ProblemDetail生成
        ProblemDetail problemDetail = CustomProblemDetail.forErrorCode(
                errorCode, 
                messageSource.getMessage("error.validation.failed", null, locale),
                errorCodeService);
        
        // フィールドエラーの変換
        List<Map<String, Object>> fieldErrors = bindingResult.getFieldErrors()
                .stream()
                .map(fieldError -> convertFieldError(fieldError, messageSource, locale))
                .collect(Collectors.toList());
        
        // グローバルエラーの変換
        List<Map<String, Object>> globalErrors = bindingResult.getGlobalErrors()
                .stream()
                .map(objectError -> convertObjectError(objectError, messageSource, locale))
                .collect(Collectors.toList());
        
        // エラー情報の追加
        problemDetail.setProperty("fieldErrors", fieldErrors);
        
        if (!globalErrors.isEmpty()) {
            problemDetail.setProperty("globalErrors", globalErrors);
        }
        
        return problemDetail;
    }
    
    /**
     * フィールドエラーを変換
     */
    private static Map<String, Object> convertFieldError(
            FieldError fieldError, MessageSource messageSource, Locale locale) {
        
        Map<String, Object> error = new HashMap<>();
        error.put("field", fieldError.getField());
        error.put("message", messageSource.getMessage(fieldError, locale));
        error.put("code", fieldError.getCode());
        error.put("rejectedValue", fieldError.getRejectedValue());
        return error;
    }
    
    /**
     * オブジェクトエラーを変換
     */
    private static Map<String, Object> convertObjectError(
            ObjectError objectError, MessageSource messageSource, Locale locale) {
        
        Map<String, Object> error = new HashMap<>();
        error.put("object", objectError.getObjectName());
        error.put("message", messageSource.getMessage(objectError, locale));
        error.put("code", objectError.getCode());
        return error;
    }
}
```

### 2.3 アプリケーション例外階層

Spring標準例外と統合したアプリケーション例外階層です。

```java
/**
 * アプリケーション全体の基本例外クラス
 * データ転送可能な例外として、Spring MVCの標準例外を継承
 */
public abstract class ApplicationException extends ResponseStatusException {
    
    private final ErrorCode errorCode;
    private final Map<String, Object> data;
    
    /**
     * アプリケーション例外を生成
     */
    protected ApplicationException(ErrorCode errorCode, String message, Map<String, Object> data) {
        super(errorCode.getHttpStatus(), message);
        this.errorCode = errorCode;
        this.data = data != null ? Collections.unmodifiableMap(new HashMap<>(data)) : Collections.emptyMap();
    }
    
    /**
     * アプリケーション例外を生成
     */
    protected ApplicationException(ErrorCode errorCode, String message, Map<String, Object> data, Throwable cause) {
        super(errorCode.getHttpStatus(), message, cause);
        this.errorCode = errorCode;
        this.data = data != null ? Collections.unmodifiableMap(new HashMap<>(data)) : Collections.emptyMap();
    }
    
    /**
     * エラーコードを取得
     */
    public ErrorCode getErrorCode() {
        return errorCode;
    }
    
    /**
     * 追加データを取得
     */
    public Map<String, Object> getData() {
        return data;
    }
}
```

### 2.4 業務例外

業務ロジックに関連する例外のクラス階層です。

```java
/**
 * 業務ロジックに関わる例外の基底クラス
 */
public class BusinessException extends ApplicationException {

    /**
     * 業務例外を生成
     */
    public BusinessException(ErrorCode errorCode, String message, Map<String, Object> data) {
        super(errorCode, message, data);
    }
    
    /**
     * 業務例外を生成
     */
    public BusinessException(ErrorCode errorCode, String message, Map<String, Object> data, Throwable cause) {
        super(errorCode, message, data, cause);
    }
}

/**
 * リソースが見つからないことを示す例外
 */
public class ResourceNotFoundException extends BusinessException {
    
    private final String resourceType;
    private final Object resourceId;
    
    /**
     * リソース未検出例外を生成
     */
    public ResourceNotFoundException(String resourceType, Object resourceId, ErrorCode errorCode) {
        super(errorCode, 
              String.format("%s resource with id '%s' not found", resourceType, resourceId),
              Map.of("resourceType", resourceType, "resourceId", resourceId));
        this.resourceType = resourceType;
        this.resourceId = resourceId;
    }
    
    // ゲッター
}

/**
 * ビジネスルール違反を表す例外
 */
public class BusinessRuleViolationException extends BusinessException {
    
    private final String ruleId;
    
    /**
     * ビジネスルール違反例外を生成
     */
    public BusinessRuleViolationException(String ruleId, ErrorCode errorCode, Map<String, Object> data) {
        super(errorCode, 
              String.format("Business rule '%s' violation", ruleId),
              addRuleId(ruleId, data));
        this.ruleId = ruleId;
    }
    
    // ゲッター
    
    private static Map<String, Object> addRuleId(String ruleId, Map<String, Object> data) {
        Map<String, Object> result = new HashMap<>(data != null ? data : Collections.emptyMap());
        result.put("ruleId", ruleId);
        return result;
    }
}
```

### 2.5 システム例外

システム内部エラーを表す例外のクラス階層です。

```java
/**
 * システム内部で発生する例外の基底クラス
 */
public class SystemException extends ApplicationException {
    
    /**
     * システム例外を生成
     */
    public SystemException(ErrorCode errorCode, String message, Map<String, Object> data) {
        super(errorCode, message, data);
    }
    
    /**
     * システム例外を生成
     */
    public SystemException(ErrorCode errorCode, String message, Map<String, Object> data, Throwable cause) {
        super(errorCode, message, data, cause);
    }
}

/**
 * データベース操作に関連する例外
 */
public class DatabaseException extends SystemException {
    
    private final String operation;
    private final String entity;
    
    /**
     * データベース例外を生成
     */
    public DatabaseException(
            String operation, 
            String entity, 
            ErrorCode errorCode, 
            Map<String, Object> data, 
            Throwable cause) {
        super(errorCode, 
              String.format("Database operation '%s' failed for entity '%s'", operation, entity),
              addOperationAndEntity(operation, entity, data),
              cause);
        this.operation = operation;
        this.entity = entity;
    }
    
    // ゲッター
    
    private static Map<String, Object> addOperationAndEntity(String operation, String entity, Map<String, Object> data) {
        Map<String, Object> result = new HashMap<>(data != null ? data : Collections.emptyMap());
        result.put("operation", operation);
        result.put("entity", entity);
        return result;
    }
}
```

### 2.6 セキュリティ例外

Spring Securityとの統合を考慮したセキュリティ例外のクラス階層です。

```java
/**
 * セキュリティに関連する例外の基底クラス
 */
public class SecurityException extends ApplicationException {
    
    /**
     * セキュリティ例外を生成
     */
    public SecurityException(ErrorCode errorCode, String message, Map<String, Object> data) {
        super(errorCode, message, data);
    }
    
    /**
     * セキュリティ例外を生成
     */
    public SecurityException(ErrorCode errorCode, String message, Map<String, Object> data, Throwable cause) {
        super(errorCode, message, data, cause);
    }
}

/**
 * アクセス権限不足を表す例外
 */
public class InsufficientPermissionsException extends SecurityException {
    
    private final Set<String> requiredPermissions;
    
    /**
     * アクセス権限不足例外を生成
     */
    public InsufficientPermissionsException(Set<String> requiredPermissions, ErrorCode errorCode) {
        super(errorCode, 
              String.format("Insufficient permissions, required: %s", requiredPermissions),
              Map.of("requiredPermissions", requiredPermissions));
        this.requiredPermissions = Collections.unmodifiableSet(new HashSet<>(requiredPermissions));
    }
    
    // ゲッター
}
```

## 3. エラーコード管理

### 3.1 ErrorCode 列挙型

システムで発生する可能性のあるエラーを列挙型として定義します。

```java
/**
 * システム全体のエラーコードを定義する列挙型
 */
public enum ErrorCode {
    // 認証・認可エラー (10000-10999)
    AUTHENTICATION_FAILED(10001, HttpStatus.UNAUTHORIZED, URI.create("https://api.sesapp.example.jp/problems/auth/failed")),
    INVALID_CREDENTIALS(10002, HttpStatus.UNAUTHORIZED, URI.create("https://api.sesapp.example.jp/problems/auth/invalid-credentials")),
    TOKEN_EXPIRED(10003, HttpStatus.UNAUTHORIZED, URI.create("https://api.sesapp.example.jp/problems/auth/token-expired")),
    INSUFFICIENT_PERMISSIONS(10004, HttpStatus.FORBIDDEN, URI.create("https://api.sesapp.example.jp/problems/auth/insufficient-permissions")),
    
    // バリデーションエラー (11000-11999)
    VALIDATION_ERROR(11001, HttpStatus.BAD_REQUEST, URI.create("https://api.sesapp.example.jp/problems/validation/general")),
    INVALID_PARAMETER(11002, HttpStatus.BAD_REQUEST, URI.create("https://api.sesapp.example.jp/problems/validation/invalid-parameter")),
    MISSING_REQUIRED_FIELD(11003, HttpStatus.BAD_REQUEST, URI.create("https://api.sesapp.example.jp/problems/validation/missing-field")),
    
    // 業務ロジックエラー (20000-29999)
    // - 技術者管理 (20000-20999)
    ENGINEER_NOT_FOUND(20001, HttpStatus.NOT_FOUND, URI.create("https://api.sesapp.example.jp/problems/engineer/not-found")),
    DUPLICATE_ENGINEER(20002, HttpStatus.CONFLICT, URI.create("https://api.sesapp.example.jp/problems/engineer/duplicate")),
    
    // 他の業務エラーコードは省略...
    
    // システムエラー (90000-99999)
    INTERNAL_SERVER_ERROR(90001, HttpStatus.INTERNAL_SERVER_ERROR, URI.create("https://api.sesapp.example.jp/problems/system/internal")),
    DATABASE_ERROR(90002, HttpStatus.INTERNAL_SERVER_ERROR, URI.create("https://api.sesapp.example.jp/problems/system/database")),
    EXTERNAL_SERVICE_ERROR(90003, HttpStatus.SERVICE_UNAVAILABLE, URI.create("https://api.sesapp.example.jp/problems/system/external-service")),
    UNEXPECTED_ERROR(99999, HttpStatus.INTERNAL_SERVER_ERROR, URI.create("https://api.sesapp.example.jp/problems/system/unexpected"));
    
    private final int code;
    private final HttpStatus httpStatus;
    private final URI type;
    
    /**
     * エラーコードを生成
     */
    ErrorCode(int code, HttpStatus httpStatus, URI type) {
        this.code = code;
        this.httpStatus = httpStatus;
        this.type = type;
    }
    
    /**
     * 数値コードを取得
     */
    public int getCode() {
        return code;
    }
    
    /**
     * HTTPステータスコードを取得
     */
    public HttpStatus getHttpStatus() {
        return httpStatus;
    }
    
    /**
     * 問題タイプURIを取得
     */
    public URI getType() {
        return type;
    }
    
    /**
     * フォーマットされたエラーコードを取得
     */
    public String getFullCode() {
        return "E" + code;
    }
}
```

### 3.2 ErrorCodeService インターフェース

エラーコードの管理と参照を提供するサービスインターフェースです。Spring MessageSourceと統合しています。

```java
/**
 * エラーコードの管理と参照を提供するサービス
 */
public interface ErrorCodeService {
    
    /**
     * エラーコードに対応するメッセージを取得します
     */
    String getMessage(ErrorCode code, Locale locale, Object... args);
    
    /**
     * エラーコードに対応するタイトルを取得します
     */
    String getTitle(ErrorCode code, Locale locale);
    
    /**
     * エラーコードに対応するHTTPステータスコードを取得します
     */
    HttpStatus getHttpStatus(ErrorCode code);
    
    /**
     * エラーコードタイプ（技術的詳細）を取得します
     */
    URI getType(ErrorCode code);
    
    /**
     * エラーコードのカテゴリを取得します
     */
    String getCategory(ErrorCode code);
    
    /**
     * エラーコードの重大度を取得します
     */
    ErrorSeverity getSeverity(ErrorCode code);
    
    /**
     * エラーコード情報をすべて取得します
     */
    List<ErrorCodeInfo> getAllErrorCodes();
}
```

### 3.3 ErrorCodeServiceImpl クラス

`ErrorCodeService` インターフェースのSpring標準機能を活用した実装です。

```java
/**
 * エラーコードサービスの実装
 */
@Service
public class ErrorCodeServiceImpl implements ErrorCodeService {
    
    private final MessageSource messageSource;
    private final Map<ErrorCode, ErrorCodeInfo> errorCodeInfoMap;
    private final CacheManager cacheManager;
    
    /**
     * エラーコードサービスを生成
     */
    @Autowired
    public ErrorCodeServiceImpl(
            MessageSource messageSource, 
            @Qualifier("errorCodeCacheManager") CacheManager cacheManager) {
        this.messageSource = messageSource;
        this.cacheManager = cacheManager;
        this.errorCodeInfoMap = initializeErrorCodeInfoMap();
    }
    
    /**
     * エラーコードに対応するメッセージを取得
     */
    @Override
    @Cacheable(cacheNames = "errorMessages", key = "#code.name() + '_' + #locale")
    public String getMessage(ErrorCode code, Locale locale, Object... args) {
        try {
            // messageSource.propertiesからエラーメッセージを取得
            return messageSource.getMessage("error." + code.name(), args, locale);
        } catch (NoSuchMessageException e) {
            // メッセージが見つからない場合はデフォルトメッセージを返す
            return "Error occurred: " + code.name();
        }
    }
    
    /**
     * エラーコードに対応するタイトルを取得
     */
    @Override
    @Cacheable(cacheNames = "errorTitles", key = "#code.name() + '_' + #locale")
    public String getTitle(ErrorCode code, Locale locale) {
        try {
            // messageSource.propertiesからタイトルを取得
            return messageSource.getMessage("error." + code.name() + ".title", null, locale);
        } catch (NoSuchMessageException e) {
            // タイトルが見つからない場合はデフォルトタイトルを返す
            return getDefaultTitle(code, locale);
        }
    }
    
    /**
     * デフォルトのタイトルを取得
     */
    private String getDefaultTitle(ErrorCode code, Locale locale) {
        try {
            // カテゴリに基づくデフォルトタイトル
            return messageSource.getMessage(
                    "error.category." + getCategory(code) + ".title", 
                    null, 
                    "Error", 
                    locale);
        } catch (NoSuchMessageException e) {
            return "Error";
        }
    }
    
    // 他のメソッド実装は省略...
    
    /**
     * エラーコード情報マップを初期化
     */
    private Map<ErrorCode, ErrorCodeInfo> initializeErrorCodeInfoMap() {
        Map<ErrorCode, ErrorCodeInfo> map = new EnumMap<>(ErrorCode.class);
        
        // 各エラーコードに対する情報を設定
        map.put(ErrorCode.AUTHENTICATION_FAILED, 
                new ErrorCodeInfo("security", ErrorSeverity.ERROR));
        map.put(ErrorCode.INVALID_CREDENTIALS, 
                new ErrorCodeInfo("security", ErrorSeverity.ERROR));
        
        // 他のエラーコード設定...
        
        return Collections.unmodifiableMap(map);
    }
}
```

### 3.4 Spring Cache統合

エラーメッセージのキャッシングを実現するSpring Cache設定です。

```java
/**
 * エラーコードキャッシュの設定
 */
@Configuration
@EnableCaching
public class ErrorCodeCacheConfig {
    
    /**
     * エラーコードキャッシュマネージャー
     */
    @Bean
    @Qualifier("errorCodeCacheManager")
    public CacheManager errorCodeCacheManager() {
        // Caffeine Cacheを使用したキャッシュマネージャー
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        
        // エラーメッセージキャッシュの設定
        cacheManager.setCacheNames(Arrays.asList(
                "errorMessages", 
                "errorTitles", 
                "errorCategories"));
        
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .expireAfterWrite(1, TimeUnit.HOURS)
                .maximumSize(500)
                .recordStats());
        
        return cacheManager;
    }
}
```

## 4. メッセージ管理

### 4.1 メッセージリソース構成

Spring MessageSourceを使用したメッセージリソースの構成です。

```
src/main/resources/
  └── messages/
      ├── error-messages.properties     # デフォルトメッセージ（英語）
      ├── error-messages_ja.properties  # 日本語メッセージ
      └── error-messages_zh.properties  # 中国語メッセージ
```

### 4.2 メッセージ定義例

```properties
# error-messages.properties (英語)
error.AUTHENTICATION_FAILED=Authentication failed
error.AUTHENTICATION_FAILED.title=Authentication Failed
error.INVALID_CREDENTIALS=Invalid username or password
error.INVALID_CREDENTIALS.title=Invalid Credentials
error.TOKEN_EXPIRED=Session has expired. Please log in again.
error.TOKEN_EXPIRED.title=Session Expired
error.INSUFFICIENT_PERMISSIONS=You do not have permission to access this resource
error.INSUFFICIENT_PERMISSIONS.title=Access Denied

error.VALIDATION_ERROR=The provided input is invalid
error.VALIDATION_ERROR.title=Validation Failed
error.INVALID_PARAMETER=Invalid parameter: {0}
error.INVALID_PARAMETER.title=Invalid Input
error.MISSING_REQUIRED_FIELD=Required field is missing: {0}
error.MISSING_REQUIRED_FIELD.title=Missing Field

# カテゴリタイトル
error.category.security.title=Security Error
error.category.validation.title=Validation Error
error.category.business.title=Business Error
error.category.system.title=System Error

# error-messages_ja.properties (日本語)
error.AUTHENTICATION_FAILED=認証に失敗しました
error.AUTHENTICATION_FAILED.title=認証失敗
# 以下省略...
```

### 4.3 MessageSource構成

Spring BootのMessageSource設定です。

```java
/**
 * メッセージソース設定
 */
@Configuration
public class MessageSourceConfig {
    
    /**
     * エラーメッセージソース
     */
    @Bean
    @Primary
    public MessageSource messageSource() {
        ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource();
        messageSource.setBasenames(
                "classpath:messages/error-messages",
                "classpath:messages/validation-messages",
                "classpath:messages/app-messages");
        messageSource.setDefaultEncoding("UTF-8");
        // 開発環境では1秒ごとにリロード
        messageSource.setCacheSeconds(isDevelopmentProfile() ? 1 : -1);
        return messageSource;
    }
    
    /**
     * 開発環境かどうかを判定
     */
    private boolean isDevelopmentProfile() {
        // 実装省略
        return true;
    }
}
```

## 5. RFC 7807準拠のProblemDetail

### 5.1 ProblemDetail構造

Spring 6で導入されたProblemDetailを拡張したエラーレスポンス構造です。

基本構造:
```json
{
  "type": "https://api.sesapp.example.jp/problems/validation/general",
  "title": "入力値が無効です",
  "status": 400,
  "detail": "入力内容に1つ以上のエラーがあります",
  "instance": "/api/v1/engineers",
  "properties": {
    "code": "E11001",
    "timestamp": "2025-05-14T10:15:30.123Z",
    "traceId": "abc123xyz456"
  }
}
```

バリデーションエラー拡張:
```json
{
  "type": "https://api.sesapp.example.jp/problems/validation/general",
  "title": "入力値が無効です",
  "status": 400,
  "detail": "入力内容に1つ以上のエラーがあります",
  "instance": "/api/v1/engineers",
  "properties": {
    "code": "E11001",
    "timestamp": "2025-05-14T10:15:30.123Z",
    "traceId": "abc123xyz456",
    "fieldErrors": [
      {
        "field": "email",
        "message": "有効なメールアドレスを入力してください",
        "code": "Email",
        "rejectedValue": "invalid-email"
      },
      {
        "field": "phoneNumber",
        "message": "有効な電話番号を入力してください",
        "code": "Pattern",
        "rejectedValue": "123"
      }
    ]
  }
}
```

### 5.2 ProblemDetailカスタマイズ

Spring BootのProblemDetail設定をカスタマイズします。

```java
/**
 * ProblemDetail設定のカスタマイズ
 */
@Configuration
public class ProblemDetailConfig {
    
    /**
     * ProblemDetailのJacksonモジュール
     */
    @Bean
    public SimpleModule problemDetailModule() {
        SimpleModule module = new SimpleModule();
        
        // ProblemDetailのシリアライズカスタマイズ
        module.addSerializer(ProblemDetail.class, new ProblemDetailSerializer());
        
        return module;
    }
    
    /**
     * ProblemDetailのシリアライザ
     */
    static class ProblemDetailSerializer extends JsonSerializer<ProblemDetail> {
        @Override
        public void serialize(ProblemDetail value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
            gen.writeStartObject();
            
            // 標準フィールド
            gen.writeStringField("type", value.getType().toString());
            gen.writeStringField("title", value.getTitle());
            gen.writeNumberField("status", value.getStatus());
            gen.writeStringField("detail", value.getDetail());
            
            if (value.getInstance() != null) {
                gen.writeStringField("instance", value.getInstance().toString());
            }
            
            // 拡張プロパティ
            Map<String, Object> properties = value.getProperties();
            if (properties != null && !properties.isEmpty()) {
                for (Map.Entry<String, Object> entry : properties.entrySet()) {
                    gen.writeObjectField(entry.getKey(), entry.getValue());
                }
            }
            
            gen.writeEndObject();
        }
    }
}
```

## 6. エラーログ記録

### 6.1 イベント駆動ロギング

Spring EventsとSpring AOPを活用した非同期エラーログ記録です。

```java
/**
 * エラーイベント基底クラス
 */
public abstract class ErrorEvent extends ApplicationEvent {
    private final Throwable exception;
    private final RequestInfo requestInfo;
    private final ProblemDetail problemDetail;
    
    // コンストラクタ、ゲッター
}

/**
 * エラーログ記録のためのイベントリスナー
 */
@Component
public class ErrorEventListener {
    
    private final Logger log = LoggerFactory.getLogger(ErrorEventListener.class);
    private final ErrorLogRepository errorLogRepository;
    private final ObjectMapper objectMapper;
    
    /**
     * 標準エラーイベントを処理
     */
    @EventListener
    @Async("errorProcessingExecutor")
    public void handleErrorEvent(ErrorEvent event) {
        try {
            // 構造化ログの記録
            log.error(createLogMessage(event), event.getException());
            
            // データベースへの永続化
            saveErrorLog(event);
            
        } catch (Exception ex) {
            // ロギング自体のエラー処理
            log.error("Failed to process error event", ex);
        }
    }
    
    /**
     * ログメッセージを生成
     */
    private String createLogMessage(ErrorEvent event) throws JsonProcessingException {
        Map<String, Object> logData = new HashMap<>();
        
        // 基本情報
        logData.put("timestamp", Instant.now().toString());
        logData.put("traceId", event.getRequestInfo().getTraceId());
        
        // エラー情報
        Map<String, Object> errorInfo = new HashMap<>();
        errorInfo.put("code", event.getProblemDetail().getProperties().get("code"));
        errorInfo.put("type", event.getProblemDetail().getType().toString());
        errorInfo.put("message", event.getProblemDetail().getDetail());
        
        if (event.getException() != null) {
            errorInfo.put("exception", event.getException().getClass().getName());
        }
        
        logData.put("error", errorInfo);
        
        // リクエスト情報
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("method", event.getRequestInfo().getMethod());
        requestInfo.put("path", event.getRequestInfo().getPath());
        requestInfo.put("remoteAddr", event.getRequestInfo().getClientIp());
        
        logData.put("request", requestInfo);
        
        return objectMapper.writeValueAsString(logData);
    }
    
    /**
     * エラーログをデータベースに保存
     */
    private void saveErrorLog(ErrorEvent event) {
        ErrorLogEntity errorLog = new ErrorLogEntity();
        // エンティティの設定
        // 実装省略
        
        errorLogRepository.save(errorLog);
    }
}
```

### 6.2 エラーログエンティティ

JPA/Spring Data JPAを活用したエラーログのエンティティとリポジトリです。

```java
/**
 * エラーログエンティティ
 */
@Entity
@Table(name = "error_logs")
public class ErrorLogEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "error_code", length = 10, nullable = false)
    private String errorCode;
    
    @Column(name = "message", nullable = false)
    private String message;
    
    @Column(name = "detail", columnDefinition = "TEXT")
    private String detail;
    
    @Column(name = "trace_id", length = 50)
    private String traceId;
    
    @Column(name = "request_id", length = 50)
    private String requestId;
    
    @Column(name = "user_id", length = 50)
    private String userId;
    
    @Column(name = "path", length = 200)
    private String path;
    
    @Column(name = "method", length = 10)
    private String method;
    
    @Column(name = "category", length = 20, nullable = false)
    private String category;
    
    @Column(name = "severity", length = 10, nullable = false)
    @Enumerated(EnumType.STRING)
    private ErrorSeverity severity;
    
    @Column(name = "stack_trace", columnDefinition = "TEXT")
    private String stackTrace;
    
    @Column(name = "additional_data", columnDefinition = "JSONB")
    private String additionalData;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    // ゲッター、セッター
}

/**
 * エラーログリポジトリ
 */
@Repository
public interface ErrorLogRepository extends JpaRepository<ErrorLogEntity, Long> {
    Page<ErrorLogEntity> findByErrorCode(String errorCode, Pageable pageable);
    
    Page<ErrorLogEntity> findByCategory(String category, Pageable pageable);
    
    Page<ErrorLogEntity> findBySeverity(ErrorSeverity severity, Pageable pageable);
    
    Page<ErrorLogEntity> findByCreatedAtBetween(LocalDateTime start, LocalDateTime end, Pageable pageable);
    
    Optional<ErrorLogEntity> findByTraceId(String traceId);
    
    @Query(value = "SELECT category, COUNT(*) as count FROM error_logs " +
            "WHERE created_at BETWEEN :startTime AND :endTime " +
            "GROUP BY category", nativeQuery = true)
    List<Object[]> countByCategory(LocalDateTime startTime, LocalDateTime endTime);
    
    @Query(value = "SELECT severity, COUNT(*) as count FROM error_logs " +
            "WHERE created_at BETWEEN :startTime AND :endTime " +
            "GROUP BY severity", nativeQuery = true)
    List<Object[]> countBySeverity(LocalDateTime startTime, LocalDateTime endTime);
}
```

## 7. Spring Security統合

Spring Securityとの統合によるセキュリティ例外のハンドリングです。

```java
/**
 * セキュリティエラーハンドリング設定
 */
@Configuration
@EnableWebSecurity
public class SecurityErrorHandlingConfig {
    
    private final CustomProblemDetailFactory problemDetailFactory;
    private final ObjectMapper objectMapper;
    
    @Bean
    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // 認証・認可設定...
            
            // エラーハンドラー
            .exceptionHandling(exceptionHandling -> exceptionHandling
                .authenticationEntryPoint(authenticationEntryPoint())
                .accessDeniedHandler(accessDeniedHandler()));
        
        return http.build();
    }
    
    /**
     * 認証エラーエントリーポイント
     */
    @Bean
    public AuthenticationEntryPoint authenticationEntryPoint() {
        return (request, response, exception) -> {
            // 認証例外からProblemDetailを生成
            ProblemDetail problemDetail = problemDetailFactory.createProblemDetail(
                    exception, 
                    HttpStatus.UNAUTHORIZED, 
                    new ServletWebRequest(request), 
                    LocaleContextHolder.getLocale());
            
            // レスポンスの設定
            response.setStatus(HttpStatus.UNAUTHORIZED.value());
            response.setContentType(MediaType.APPLICATION_PROBLEM_JSON_VALUE);
            response.getWriter().write(objectMapper.writeValueAsString(problemDetail));
        };
    }
    
    /**
     * アクセス拒否ハンドラー
     */
    @Bean
    public AccessDeniedHandler accessDeniedHandler() {
        return (request, response, exception) -> {
            // アクセス拒否例外からProblemDetailを生成
            ProblemDetail problemDetail = problemDetailFactory.createProblemDetail(
                    exception, 
                    HttpStatus.FORBIDDEN, 
                    new ServletWebRequest(request), 
                    LocaleContextHolder.getLocale());
            
            // レスポンスの設定
            response.setStatus(HttpStatus.FORBIDDEN.value());
            response.setContentType(MediaType.APPLICATION_PROBLEM_JSON_VALUE);
            response.getWriter().write(objectMapper.writeValueAsString(problemDetail));
        };
    }
}
```

## 8. Spring Boot Actuator統合

Spring Boot Actuatorを活用したエラーメトリクスの収集と監視です。

```java
/**
 * エラーメトリクス設定
 */
@Configuration
public class ErrorMetricsConfiguration {
    
    private final MeterRegistry registry;
    
    /**
     * エラーイベントの監視
     */
    @EventListener
    public void onErrorEvent(ErrorEvent event) {
        String errorType = extractErrorType(event);
        
        // エラーカウンターのインクリメント
        registry.counter("app.errors", 
                "type", errorType, 
                "severity", extractSeverity(event)).increment();
        
        // エラー発生時刻の記録
        registry.gauge("app.error.last", Tags.of(
                "type", errorType, 
                "severity", extractSeverity(event)), Clock.SYSTEM.wallTime());
    }
    
    /**
     * エラータイプを抽出
     */
    private String extractErrorType(ErrorEvent event) {
        if (event.getException() instanceof BusinessException) {
            return "business";
        } else if (event.getException() instanceof SystemException) {
            return "system";
        } else if (event.getException() instanceof SecurityException) {
            return "security";
        } else {
            return "other";
        }
    }
    
    /**
     * エラー重大度を抽出
     */
    private String extractSeverity(ErrorEvent event) {
        Object code = event.getProblemDetail().getProperties().get("code");
        if (code != null && code instanceof String) {
            // エラーコードから重大度を特定する処理
            return "error";
        }
        return "unknown";
    }
}
```

## 9. まとめ

統一エラーモデルは、Spring Frameworkの標準機能を最大限に活用することで、以下の要素から構成されています：

1. **ProblemDetail**: Spring 6で導入されたRFC 7807準拠のエラー表現
2. **例外階層**: Spring標準例外と統合されたアプリケーション例外階層
3. **エラーコード管理**: メッセージ国際化をサポートするSpring MessageSourceとの統合
4. **イベント駆動ロギング**: Spring Eventsを活用した非同期エラーログ記録
5. **セキュリティ統合**: Spring Securityの例外ハンドリングとの統合
6. **メトリクス収集**: Spring Boot Actuatorを活用したエラーモニタリング

これらのコンポーネントが連携することで、保守性が高く、標準に準拠した、ユーザーフレンドリーなエラー処理基盤を実現します。