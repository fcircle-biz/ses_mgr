# 統一エラーモデル

## 1. 目的と概要

統一エラーモデルは、システム全体で一貫したエラー表現と処理を実現するための基盤を提供します。これにより、以下の利点を得ることができます：

- フロントエンドとバックエンドでの一貫したエラー処理パターンの確立
- エラー情報の構造化と標準化によるデバッグ効率の向上
- 国際化対応を含むユーザーフレンドリーなエラーメッセージの提供
- 運用監視とトラブルシューティングの効率化

本ドキュメントでは、エラーモデルの構造、エラーコードの管理方法、およびエラー情報の生成・伝播メカニズムについて詳細に説明します。

## 2. エラーモデル定義

### 2.1 ErrorResponse クラス

APIレスポンスとして返却されるエラー情報を表す基本クラスです。

```java
public class ErrorResponse {
    private String code;              // エラーコード
    private String message;           // ユーザー向けメッセージ
    private String detail;            // 詳細エラー情報（開発者向け）
    private String traceId;           // 追跡用ID
    private String timestamp;         // エラー発生時刻
    private String path;              // エラーが発生したリクエストパス
    private Map<String, Object> data; // 付加情報
    
    // コンストラクタ、ゲッター、ビルダーパターン実装
}
```

### 2.2 ValidationErrorResponse クラス

バリデーションエラーの詳細情報を含むレスポンスクラスです。

```java
public class ValidationErrorResponse extends ErrorResponse {
    private List<FieldError> fieldErrors; // フィールド単位のエラー情報
    
    // コンストラクタ、ゲッター、ビルダーパターン実装
}

public class FieldError {
    private String field;     // エラーが発生したフィールド名
    private String message;   // エラーメッセージ
    private String code;      // エラーコード
    private Object rejectedValue; // 拒否された値
    
    // コンストラクタ、ゲッター
}
```

### 2.3 業務ロジック例外

業務ロジックに関わる例外を表す基本クラスです。

```java
public class BusinessException extends RuntimeException {
    private final ErrorCode errorCode;
    private final Map<String, Object> data;
    
    // コンストラクタ、ゲッター
}
```

### 2.4 システム例外

システム内部エラーを表す例外クラスです。

```java
public class SystemException extends RuntimeException {
    private final ErrorCode errorCode;
    private final Map<String, Object> data;
    
    // コンストラクタ、ゲッター
}
```

### 2.5 認証・認可例外

認証・認可に関する例外クラスです。

```java
public class AuthenticationException extends BusinessException {
    // コンストラクタ
}

public class AuthorizationException extends BusinessException {
    private final List<String> requiredPermissions;
    
    // コンストラクタ、ゲッター
}
```

## 3. エラーコード管理

### 3.1 ErrorCode 列挙型

システムで発生する可能性のあるエラーを列挙型として定義します。

```java
public enum ErrorCode {
    // 認証・認可エラー (10000-10999)
    AUTHENTICATION_FAILED(10001, HttpStatus.UNAUTHORIZED),
    INVALID_CREDENTIALS(10002, HttpStatus.UNAUTHORIZED),
    TOKEN_EXPIRED(10003, HttpStatus.UNAUTHORIZED),
    INSUFFICIENT_PERMISSIONS(10004, HttpStatus.FORBIDDEN),
    
    // バリデーションエラー (11000-11999)
    VALIDATION_ERROR(11001, HttpStatus.BAD_REQUEST),
    INVALID_PARAMETER(11002, HttpStatus.BAD_REQUEST),
    MISSING_REQUIRED_FIELD(11003, HttpStatus.BAD_REQUEST),
    
    // 業務ロジックエラー (20000-29999)
    // - 技術者管理 (20000-20999)
    ENGINEER_NOT_FOUND(20001, HttpStatus.NOT_FOUND),
    DUPLICATE_ENGINEER(20002, HttpStatus.CONFLICT),
    
    // - 案件管理 (21000-21999)
    PROJECT_NOT_FOUND(21001, HttpStatus.NOT_FOUND),
    PROJECT_ALREADY_CLOSED(21002, HttpStatus.CONFLICT),
    
    // - マッチング (22000-22999)
    MATCHING_NOT_FOUND(22001, HttpStatus.NOT_FOUND),
    ENGINEER_NOT_AVAILABLE(22002, HttpStatus.CONFLICT),
    
    // - 契約管理 (23000-23999)
    CONTRACT_NOT_FOUND(23001, HttpStatus.NOT_FOUND),
    CONTRACT_ALREADY_SIGNED(23002, HttpStatus.CONFLICT),
    
    // - 勤怠工数管理 (24000-24999)
    TIMESHEET_NOT_FOUND(24001, HttpStatus.NOT_FOUND),
    TIMESHEET_ALREADY_APPROVED(24002, HttpStatus.CONFLICT),
    
    // - 請求支払管理 (25000-25999)
    INVOICE_NOT_FOUND(25001, HttpStatus.NOT_FOUND),
    PAYMENT_NOT_FOUND(25002, HttpStatus.NOT_FOUND),
    
    // - レポーティング (26000-26999)
    REPORT_NOT_FOUND(26001, HttpStatus.NOT_FOUND),
    
    // システムエラー (90000-99999)
    INTERNAL_SERVER_ERROR(90001, HttpStatus.INTERNAL_SERVER_ERROR),
    DATABASE_ERROR(90002, HttpStatus.INTERNAL_SERVER_ERROR),
    EXTERNAL_SERVICE_ERROR(90003, HttpStatus.SERVICE_UNAVAILABLE),
    UNEXPECTED_ERROR(99999, HttpStatus.INTERNAL_SERVER_ERROR);
    
    private final int code;
    private final HttpStatus httpStatus;
    
    // コンストラクタ、ゲッター
    
    public String getFullCode() {
        return "E" + code;
    }
}
```

### 3.2 ErrorCodeRegistry インターフェース

エラーコードを一元管理し、検索・参照機能を提供します。

```java
public interface ErrorCodeRegistry {
    /**
     * エラーコードに対応するメッセージを取得します
     * @param code エラーコード
     * @param locale ロケール
     * @param args メッセージ引数
     * @return ローカライズされたメッセージ
     */
    String getMessage(ErrorCode code, Locale locale, Object... args);
    
    /**
     * エラーコードが所属するカテゴリを取得します
     * @param code エラーコード
     * @return エラーカテゴリ
     */
    String getCategory(ErrorCode code);
    
    /**
     * エラーコードの重大度を取得します
     * @param code エラーコード
     * @return エラー重大度
     */
    ErrorSeverity getSeverity(ErrorCode code);
    
    /**
     * エラーコード情報をすべて取得します
     * @return エラーコード情報のリスト
     */
    List<ErrorCodeInfo> getAllErrorCodes();
}
```

### 3.3 ErrorCodeRegistryImpl クラス

`ErrorCodeRegistry` インターフェースの実装クラスです。

```java
@Service
public class ErrorCodeRegistryImpl implements ErrorCodeRegistry {
    private final MessageSource messageSource;
    private final Map<ErrorCode, ErrorCodeInfo> errorCodeInfoMap;
    
    @Autowired
    public ErrorCodeRegistryImpl(MessageSource messageSource) {
        this.messageSource = messageSource;
        this.errorCodeInfoMap = initializeErrorCodeInfoMap();
    }
    
    private Map<ErrorCode, ErrorCodeInfo> initializeErrorCodeInfoMap() {
        // エラーコード情報の初期化
        Map<ErrorCode, ErrorCodeInfo> map = new EnumMap<>(ErrorCode.class);
        
        // カテゴリと重大度の設定
        // 認証・認可エラー
        map.put(ErrorCode.AUTHENTICATION_FAILED, 
                new ErrorCodeInfo("security", ErrorSeverity.WARNING));
        // 以下同様に各エラーコードに対する情報を設定
        
        return Collections.unmodifiableMap(map);
    }
    
    @Override
    public String getMessage(ErrorCode code, Locale locale, Object... args) {
        return messageSource.getMessage("error." + code.name(), args, locale);
    }
    
    @Override
    public String getCategory(ErrorCode code) {
        return errorCodeInfoMap.get(code).getCategory();
    }
    
    @Override
    public ErrorSeverity getSeverity(ErrorCode code) {
        return errorCodeInfoMap.get(code).getSeverity();
    }
    
    @Override
    public List<ErrorCodeInfo> getAllErrorCodes() {
        return new ArrayList<>(errorCodeInfoMap.values());
    }
}
```

### 3.4 ErrorCodeInfo クラス

エラーコードに関する詳細情報を保持するクラスです。

```java
public class ErrorCodeInfo {
    private final String category;    // エラーカテゴリ
    private final ErrorSeverity severity; // エラー重大度
    
    // コンストラクタ、ゲッター
}
```

### 3.5 ErrorSeverity 列挙型

エラーの重大度を表す列挙型です。

```java
public enum ErrorSeverity {
    INFO,       // 情報
    WARNING,    // 警告
    ERROR,      // エラー
    CRITICAL    // 致命的
}
```

## 4. エラーメッセージ管理

エラーメッセージは国際化に対応し、プロパティファイルで管理します。

### 4.1 メッセージリソース構成

```
src/main/resources/
  └── messages/
      ├── errors.properties     # デフォルトメッセージ（英語）
      ├── errors_ja.properties  # 日本語メッセージ
      └── errors_zh.properties  # 中国語メッセージ
```

### 4.2 メッセージ定義例

```properties
# errors.properties (英語)
error.AUTHENTICATION_FAILED=Authentication failed
error.INVALID_CREDENTIALS=Invalid username or password
error.TOKEN_EXPIRED=Session has expired. Please log in again.
error.INSUFFICIENT_PERMISSIONS=You do not have permission to access this resource

# errors_ja.properties (日本語)
error.AUTHENTICATION_FAILED=認証に失敗しました
error.INVALID_CREDENTIALS=ユーザー名またはパスワードが正しくありません
error.TOKEN_EXPIRED=セッションの有効期限が切れました。再度ログインしてください。
error.INSUFFICIENT_PERMISSIONS=このリソースにアクセスする権限がありません
```

## 5. エラーコードの拡張方法

新しい業務モジュールやエラーパターンが追加された場合のエラーコード拡張手順：

1. `ErrorCode` 列挙型に新しいエラーコードを追加
2. 各言語のメッセージプロパティファイルにエラーメッセージを追加
3. `ErrorCodeRegistryImpl` のマッピング情報を更新

## 6. エラー情報のログ記録

エラー情報は構造化されたJSONフォーマットでログに記録されます。

### 6.1 ログフォーマット例

```json
{
  "timestamp": "2025-05-14T10:15:30.123Z",
  "level": "ERROR",
  "thread": "http-nio-8080-exec-1",
  "logger": "com.example.errorhandling.ExceptionHandlerAdvice",
  "message": "Request processing failed",
  "error": {
    "code": "E10001",
    "type": "AuthenticationException",
    "message": "Authentication failed",
    "path": "/api/v1/auth/login",
    "traceId": "4f8d3e2c1a0b9876",
    "stackTrace": "..."
  },
  "request": {
    "method": "POST",
    "path": "/api/v1/auth/login",
    "remoteAddr": "192.168.1.100",
    "userAgent": "Mozilla/5.0 ..."
  }
}
```

### 6.2 ログ記録実装例

```java
@Component
public class ErrorLoggerImpl implements ErrorLogger {
    private static final Logger log = LoggerFactory.getLogger(ErrorLoggerImpl.class);
    private final ObjectMapper objectMapper;
    private final ErrorLogRepository errorLogRepository;
    
    @Autowired
    public ErrorLoggerImpl(ObjectMapper objectMapper, ErrorLogRepository errorLogRepository) {
        this.objectMapper = objectMapper;
        this.errorLogRepository = errorLogRepository;
    }
    
    @Override
    public void logError(ErrorInfo errorInfo, Throwable exception) {
        try {
            Map<String, Object> errorLog = createErrorLogMap(errorInfo, exception);
            log.error(objectMapper.writeValueAsString(errorLog));
        } catch (JsonProcessingException e) {
            log.error("Failed to serialize error log", e);
        }
    }
    
    private Map<String, Object> createErrorLogMap(ErrorInfo errorInfo, Throwable exception) {
        Map<String, Object> errorLog = new HashMap<>();
        errorLog.put("timestamp", errorInfo.getTimestamp().toString());
        errorLog.put("code", errorInfo.getCode());
        errorLog.put("message", errorInfo.getMessage());
        errorLog.put("path", errorInfo.getPath());
        errorLog.put("traceId", errorInfo.getTraceId());
        
        if (exception != null) {
            errorLog.put("exception", exception.getClass().getName());
            errorLog.put("exceptionMessage", exception.getMessage());
            
            // 開発環境・テスト環境のみスタックトレースを追加
            if (!isProductionEnvironment()) {
                StringWriter sw = new StringWriter();
                exception.printStackTrace(new PrintWriter(sw));
                errorLog.put("stackTrace", sw.toString());
            }
        }
        
        return errorLog;
    }
    
    private boolean isProductionEnvironment() {
        // 実装省略
        return false;
    }
}
```

## 7. エラーレスポンス生成メカニズム

### 7.1 ErrorResponseBuilder インターフェース

エラー情報をAPIレスポンスに変換するインターフェースです。

```java
public interface ErrorResponseBuilder {
    /**
     * エラー情報からエラーレスポンスを構築します
     * @param errorInfo エラー情報
     * @param locale ロケール
     * @return エラーレスポンス
     */
    ErrorResponse buildErrorResponse(ErrorInfo errorInfo, Locale locale);
    
    /**
     * エラー情報からHTTPレスポンスエンティティを構築します
     * @param errorInfo エラー情報
     * @param locale ロケール
     * @return HTTPレスポンスエンティティ
     */
    ResponseEntity<ErrorResponse> buildResponseEntity(ErrorInfo errorInfo, Locale locale);
}
```

### 7.2 実装例

```java
@Component
public class ErrorResponseBuilderImpl implements ErrorResponseBuilder {
    private final ErrorCodeRegistry errorCodeRegistry;
    private final boolean includeDebugDetails;
    
    @Autowired
    public ErrorResponseBuilderImpl(
            ErrorCodeRegistry errorCodeRegistry,
            @Value("${app.error.include-debug-details:false}") boolean includeDebugDetails) {
        this.errorCodeRegistry = errorCodeRegistry;
        this.includeDebugDetails = includeDebugDetails;
    }
    
    @Override
    public ErrorResponse buildErrorResponse(ErrorInfo errorInfo, Locale locale) {
        String message = errorCodeRegistry.getMessage(errorInfo.getErrorCode(), locale);
        
        ErrorResponse response = new ErrorResponse();
        response.setCode(errorInfo.getErrorCode().getFullCode());
        response.setMessage(message);
        response.setTimestamp(DateTimeFormatter.ISO_INSTANT.format(errorInfo.getTimestamp()));
        response.setPath(errorInfo.getPath());
        response.setTraceId(errorInfo.getTraceId());
        
        // デバッグ詳細情報は開発環境でのみ含める
        if (includeDebugDetails) {
            response.setDetail(errorInfo.getDetail());
            response.setData(errorInfo.getData());
        }
        
        return response;
    }
    
    @Override
    public ResponseEntity<ErrorResponse> buildResponseEntity(ErrorInfo errorInfo, Locale locale) {
        ErrorResponse response = buildErrorResponse(errorInfo, locale);
        HttpStatus status = errorInfo.getErrorCode().getHttpStatus();
        return new ResponseEntity<>(response, status);
    }
}
```

## 8. セキュリティに関する考慮事項

### 8.1 機密情報の扱い

- 内部エラー情報はログには記録するが、APIレスポンスには含めない
- プロダクション環境ではスタックトレースをAPIレスポンスに含めない
- セキュリティに関するエラーについては、最小限の情報のみをユーザーに公開

### 8.2 エラーコードとメッセージの公開基準

- ユーザー入力に関するエラーは具体的な情報を提供
- システムエラーやセキュリティエラーは一般的なメッセージのみを提供
- 外部からの攻撃者に有用な情報を含まない

### 8.3 エラーレスポンスのセキュリティ設定

```java
@Configuration
public class ErrorHandlingSecurityConfig {
    @Value("${app.error.include-debug-details}")
    private boolean includeDebugDetails;
    
    @Value("${app.error.include-stacktrace}")
    private String includeStackTrace;
    
    @Bean
    public ErrorAttributes errorAttributes() {
        return new DefaultErrorAttributes() {
            @Override
            public Map<String, Object> getErrorAttributes(
                    WebRequest webRequest, ErrorAttributeOptions options) {
                Map<String, Object> errorAttributes = super.getErrorAttributes(
                        webRequest, options);
                
                // プロダクション環境ではスタックトレースを含めない
                if ("never".equals(includeStackTrace) || 
                        ("when_param".equals(includeStackTrace) && 
                         !webRequest.getParameter("trace", null).equals("true"))) {
                    errorAttributes.remove("trace");
                }
                
                // デバッグ詳細を含めるかどうか
                if (!includeDebugDetails) {
                    errorAttributes.remove("detail");
                }
                
                // トレースIDを追加
                errorAttributes.put("traceId", TraceContext.getCurrentTraceId());
                
                return errorAttributes;
            }
        };
    }
}
```

## 9. フロントエンドでのエラーハンドリング

### 9.1 フロントエンドエラーハンドリングの考慮事項

バックエンドから返されるエラーレスポンスを適切に処理するためのフロントエンド側の実装例です。

```typescript
// APIエラーレスポンスインターフェース
interface ErrorResponse {
  code: string;
  message: string;
  detail?: string;
  traceId: string;
  timestamp: string;
  path: string;
  data?: any;
}

// バリデーションエラーレスポンスインターフェース
interface ValidationErrorResponse extends ErrorResponse {
  fieldErrors: {
    field: string;
    message: string;
    code: string;
    rejectedValue: any;
  }[];
}

// グローバルエラーハンドリング
class ApiErrorHandler {
  // HTTPエラーを処理するメソッド
  static handleHttpError(error: any): never {
    if (error.response) {
      const errorData = error.response.data as ErrorResponse;
      
      // 認証エラー
      if (error.response.status === 401) {
        this.handleAuthenticationError(errorData);
      }
      
      // 権限エラー
      if (error.response.status === 403) {
        this.handleAuthorizationError(errorData);
      }
      
      // バリデーションエラー
      if (error.response.status === 400 && 'fieldErrors' in errorData) {
        this.handleValidationError(errorData as ValidationErrorResponse);
      }
      
      // 業務エラー (404, 409等)
      if (error.response.status >= 400 && error.response.status < 500) {
        this.handleBusinessError(errorData);
      }
      
      // システムエラー
      if (error.response.status >= 500) {
        this.handleSystemError(errorData);
      }
      
      // 未処理のエラー
      throw new Error(`${errorData.code}: ${errorData.message}`);
    }
    
    // ネットワークエラーなど
    throw new Error('Network error occurred');
  }
  
  // 認証エラーの処理
  private static handleAuthenticationError(errorData: ErrorResponse): never {
    // セッションタイムアウト時にはログイン画面にリダイレクト
    if (errorData.code === 'E10003') { // TOKEN_EXPIRED
      AuthService.logout();
      window.location.href = '/login?reason=session_timeout';
    }
    
    throw new Error(`Authentication error: ${errorData.message}`);
  }
  
  // 認可エラーの処理
  private static handleAuthorizationError(errorData: ErrorResponse): never {
    NotificationService.error('アクセス権限がありません', errorData.message);
    throw new Error(`Authorization error: ${errorData.message}`);
  }
  
  // バリデーションエラーの処理
  private static handleValidationError(errorData: ValidationErrorResponse): never {
    // フォームにエラーを表示するためのイベント発行
    EventBus.emit('form:validation-error', {
      formErrors: errorData.fieldErrors.reduce((acc, curr) => {
        acc[curr.field] = curr.message;
        return acc;
      }, {} as Record<string, string>)
    });
    
    throw new Error(`Validation error: ${errorData.message}`);
  }
  
  // 業務ロジックエラーの処理
  private static handleBusinessError(errorData: ErrorResponse): never {
    NotificationService.warning(errorData.message);
    throw new Error(`Business error: ${errorData.message}`);
  }
  
  // システムエラーの処理
  private static handleSystemError(errorData: ErrorResponse): never {
    // エラートラッキングサービスにエラーを報告
    ErrorTracking.captureError({
      code: errorData.code,
      message: errorData.message,
      traceId: errorData.traceId,
      timestamp: errorData.timestamp,
      path: errorData.path
    });
    
    NotificationService.error(
      'システムエラーが発生しました',
      `担当者に問い合わせる際は以下のコードをお知らせください: ${errorData.code} (${errorData.traceId})`
    );
    
    throw new Error(`System error: ${errorData.message}`);
  }
}

// APIクライアントでの使用例
class ApiClient {
  static async get<T>(url: string): Promise<T> {
    try {
      const response = await axios.get<T>(url);
      return response.data;
    } catch (error) {
      return ApiErrorHandler.handleHttpError(error);
    }
  }
  
  static async post<T>(url: string, data: any): Promise<T> {
    try {
      const response = await axios.post<T>(url, data);
      return response.data;
    } catch (error) {
      return ApiErrorHandler.handleHttpError(error);
    }
  }
  
  // 他のHTTPメソッドも同様に実装
}
```

## 10. まとめ

統一エラーモデルは、以下のコンポーネントで構成されています：

1. エラーレスポンスクラス階層 - クライアントへの一貫した形式でのエラー情報提供
2. 例外クラス階層 - ビジネスロジックとシステムエラーの明確な区別
3. エラーコード体系 - 体系的なエラー分類と管理
4. エラーメッセージ国際化 - 複数言語対応
5. エラーログ記録 - トラブルシューティングと監視のための構造化記録

このモデルにより、全アプリケーション層でのエラー処理の一貫性が確保され、開発効率、運用効率、およびユーザー体験の向上に貢献します。