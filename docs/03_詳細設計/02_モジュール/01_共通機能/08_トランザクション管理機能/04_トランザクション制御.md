# トランザクション制御機能

## 1. 概要

トランザクション制御機能は、SES管理システム内のトランザクション境界を管理し、データの整合性を保証するための中核的な機能を提供します。この機能は、Spring Frameworkのトランザクション管理フレームワークを活用しつつ、システム固有の要件に合わせて拡張します。

本機能は、アプリケーション層とデータアクセス層の間に位置し、一貫したトランザクション管理を実現するためのインフラストラクチャを提供します。

## 2. 機能構成

トランザクション制御機能は、以下のコンポーネントで構成されます：

### 2.1 コンポーネント構成図

```
+--------------------------------+
| アプリケーション層              |
| (@Transactional アノテーション) |
+--------------------------------+
               |
+--------------------------------+
| TransactionInterceptor         | --- 宣言的トランザクション制御
+--------------------------------+
               |
+--------------------------------+
| PlatformTransactionManager     | --- トランザクション管理
|  - SpringTransactionManager    |
+--------------------------------+
               |
+--------------------------------+
| TransactionSynchronizationMgr  | --- トランザクションフック管理
+--------------------------------+
               |
+--------------------------------+
| データアクセス層                |
| (Repository, JDBC等)           |
+--------------------------------+
```

### 2.2 主要コンポーネント

1. **SpringTransactionManager**
   - Spring PlatformTransactionManagerのカスタム実装
   - トランザクション開始、コミット、ロールバックの制御
   - トランザクション伝播方式と分離レベルの管理

2. **TransactionInterceptor**
   - @Transactionalアノテーションによる宣言的トランザクション管理
   - アスペクト指向プログラミングによるトランザクション境界制御
   - 例外ハンドリングとロールバックルールの適用

3. **TransactionSynchronizationManager**
   - トランザクション前後のコールバック処理
   - リソース管理とバインディング
   - 現在のトランザクションコンテキスト管理

4. **TransactionAttributeSource**
   - トランザクション属性の解析と管理
   - アノテーションベースの設定解釈

5. **TransactionMonitor**
   - アクティブトランザクションの監視
   - 長時間実行トランザクションの検出
   - トランザクションメトリクスの収集

## 3. トランザクション境界制御

### 3.1 宣言的トランザクション管理

Spring Frameworkの@Transactionalアノテーションを活用した宣言的トランザクション管理を実装します。

#### 3.1.1 @Transactionalアノテーションの拡張

```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Transactional {
    // Spring標準アノテーション属性
    String value() default "";
    Propagation propagation() default Propagation.REQUIRED;
    Isolation isolation() default Isolation.DEFAULT;
    int timeout() default -1;
    boolean readOnly() default false;
    Class<? extends Throwable>[] rollbackFor() default {};
    Class<? extends Throwable>[] noRollbackFor() default {};
    
    // 拡張属性
    String description() default "";  // トランザクション説明（ログ用）
    String[] resources() default {};  // 関連リソース
    LogLevel logLevel() default LogLevel.INFO;  // ログレベル
    boolean traceSql() default false;  // SQL文のトレース
}
```

#### 3.1.2 トランザクション境界の適用箇所

| レイヤー | 適用方針 | 推奨伝播方式 |
|---------|---------|------------|
| Controllerレイヤー | 原則適用しない | - |
| Serviceレイヤー | 業務トランザクション境界として積極的に適用 | REQUIRED |
| Repositoryレイヤー | 個々のメソッドに対して必要に応じて適用 | SUPPORTS |
| ドメインサービス | ドメインルールを含む処理に適用 | REQUIRED |
| ユーティリティ | 読み取り処理のみに適用（必要な場合） | SUPPORTS / REQUIRED |

### 3.2 プログラム的トランザクション管理

TransactionTemplateを使用したプログラム的なトランザクション管理を提供します。

#### 3.2.1 トランザクションテンプレートの利用パターン

```
// 汎用的な利用パターン
Result result = transactionTemplate.execute(status -> {
    // トランザクション内で実行する処理
    Result intermediateResult = someOperation();
    
    if (shouldRollback(intermediateResult)) {
        status.setRollbackOnly();
        return errorResult();
    }
    
    // 処理続行
    return successResult();
});

// 読み取り専用トランザクション
Data data = transactionTemplate.executeReadOnly(status -> {
    return dataAccessOperation();
});
```

#### 3.2.2 ネストしたトランザクション処理

トランザクション伝播方式を活用したネストトランザクション処理のサポート：

```
// 外部トランザクション
Result result = transactionTemplate.execute(outerStatus -> {
    // 外部トランザクション処理
    
    // 内部トランザクション（新しいトランザクション）
    TransactionTemplate nestedTemplate = new TransactionTemplate(transactionManager);
    nestedTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
    
    NestedResult nestedResult = nestedTemplate.execute(innerStatus -> {
        // 内部トランザクション処理
        return executeNestedOperation();
    });
    
    // 外部トランザクション続行
    return combineResults(outerOperation(), nestedResult);
});
```

### 3.3 トランザクション伝播方式

システムで使用するトランザクション伝播方式と、その適用ガイドライン：

| 伝播方式 | 説明 | 適用ガイドライン |
|---------|------|---------------|
| REQUIRED | 既存トランザクションに参加、なければ新規作成 | 標準的なサービスメソッドに使用 |
| REQUIRES_NEW | 常に新しいトランザクションを作成 | 親トランザクションと独立して処理する場合 |
| SUPPORTS | 既存トランザクションに参加、なければトランザクションなしで実行 | 読み取り処理に使用 |
| MANDATORY | 既存トランザクションが必須（なければ例外） | 明示的に別メソッドからの呼び出しを強制する場合 |
| NOT_SUPPORTED | トランザクションなしで実行 | トランザクション外で実行すべき処理（ロギングなど） |
| NEVER | トランザクションがあると例外 | トランザクション外であることを保証したい処理 |
| NESTED | 既存トランザクション内にネストしたトランザクションを作成 | 部分的なロールバックが必要な処理 |

### 3.4 トランザクション分離レベル

システムで使用するトランザクション分離レベルと、その適用ガイドライン：

| 分離レベル | 説明 | 適用ガイドライン |
|-----------|------|---------------|
| DEFAULT | データベースのデフォルト設定を使用 | 特に指定がない場合の標準設定 |
| READ_UNCOMMITTED | 未コミットデータの読み取りを許可 | 高性能が必要で一貫性より重要な場合（稀） |
| READ_COMMITTED | コミット済みデータのみ読み取り可能 | 標準的な参照処理 |
| REPEATABLE_READ | トランザクション中の再読み取りで同じ結果 | データ整合性が重要な集計処理など |
| SERIALIZABLE | 最も厳格な分離レベル、直列化可能 | 極めて高い整合性が必要な重要トランザクション |

#### 3.4.1 業務処理とトランザクション分離レベルの対応表

| 業務処理 | 推奨分離レベル | 理由 |
|---------|--------------|------|
| 技術者情報参照 | READ_COMMITTED | 通常の参照処理 |
| 技術者情報更新 | REPEATABLE_READ | 更新中の一貫性確保 |
| 案件情報参照 | READ_COMMITTED | 通常の参照処理 |
| 案件情報更新 | REPEATABLE_READ | 更新中の一貫性確保 |
| マッチング検索 | READ_COMMITTED | 最新情報を参照 |
| 契約処理 | SERIALIZABLE | 契約データの完全な一貫性確保 |
| 請求処理 | REPEATABLE_READ | 請求データの一貫性確保 |
| レポート生成 | READ_COMMITTED | 通常の参照処理 |
| バッチ処理 | 処理内容による | 個別設計による |

### 3.5 タイムアウト管理

トランザクションのタイムアウト管理と対策：

#### 3.5.1 タイムアウト設定ガイドライン

| トランザクション種別 | 推奨タイムアウト | 適用箇所 |
|-------------------|---------------|---------|
| 標準オンラインユーザー処理 | 30秒 | 一般的なユーザー操作処理 |
| 参照専用処理 | 60秒 | 複雑な検索・集計処理 |
| バッチ処理 | 処理内容による（最大30分） | データ移行、集計処理など |
| バルク更新 | 300秒 | 大量データ更新処理 |
| 分散トランザクション | 60秒 | マイクロサービス間連携 |

#### 3.5.2 タイムアウト検知と対応

1. **タイムアウト監視**:
   - トランザクション開始時にタイマータスク登録
   - タイムアウト時にトランザクションを強制ロールバック
   - タイムアウトイベントの発行と記録

2. **タイムアウト対策**:
   - 長時間トランザクションの分割設計
   - 読み取り専用処理のトランザクション分離
   - 大量データ処理のバッチ化またはページング

### 3.6 コネクション管理

JDBC接続の管理と最適化：

#### 3.6.1 コネクションプールとの連携

1. **コネクションプール設定**:
   - 最小接続数: 10
   - 最大接続数: 100
   - 接続の生存時間: 30分
   - 接続検証クエリ: SELECT 1
   - 接続取得タイムアウト: 5秒

2. **トランザクションとの連携**:
   - トランザクション開始時に接続取得
   - トランザクション終了時に接続返却
   - 同一トランザクション内での接続再利用の保証

#### 3.6.2 コネクション漏れ防止

1. **コネクション追跡**:
   - 開いたコネクションの追跡
   - トランザクション終了時の未クローズコネクションチェック
   - コネクション取得履歴のログ記録（開発モード）

2. **自動クローズ保証**:
   - try-with-resources パターンの推奨
   - トランザクション完了時の自動クローズ
   - 例外発生時の確実なリソース解放

## 4. トランザクション監視と管理

### 4.1 アクティブトランザクション監視

現在実行中のトランザクションを監視するための機能：

#### 4.1.1 トランザクションモニターの実装

1. **アクティブトランザクション追跡**:
   - トランザクション開始・終了イベントの捕捉
   - スレッドローカルを活用したトランザクションコンテキスト管理
   - トランザクションIDによるトレーサビリティ確保

2. **統計情報収集**:
   - トランザクション数（開始数、完了数、アクティブ数）
   - 平均実行時間
   - 成功/失敗率
   - リソース使用状況

#### 4.1.2 長時間実行トランザクション検出

1. **検出メカニズム**:
   - 定期的なアクティブトランザクションスキャン
   - 設定閾値を超えるトランザクションの特定
   - 実行中トランザクションのスタックトレース取得

2. **通知と対応**:
   - アラート発行（閾値超過時）
   - ログ記録（詳細情報）
   - オプションの強制終了機能

### 4.2 メトリクス収集

トランザクション実行に関するメトリクスの収集と分析：

#### 4.2.1 収集メトリクス

1. **基本メトリクス**:
   - トランザクション数（総数、成功、失敗）
   - 平均実行時間
   - 最大実行時間
   - 標準偏差

2. **詳細メトリクス**:
   - メソッド別トランザクション統計
   - 伝播方式別統計
   - ロールバック原因分析
   - リソース使用統計

#### 4.2.2 メトリクス可視化

1. **運用ダッシュボード連携**:
   - リアルタイムトランザクション状況表示
   - 傾向分析グラフ
   - 異常検知アラート
   - リソース使用率表示

2. **レポート生成**:
   - 日次/週次/月次トランザクション統計
   - パフォーマンス傾向分析
   - 異常パターン検出
   - キャパシティプランニング支援

### 4.3 例外ハンドリング

トランザクション実行中の例外処理と対応：

#### 4.3.1 例外カテゴリと対応

| 例外カテゴリ | 自動ロールバック | 再試行戦略 | ログレベル |
|------------|---------------|----------|---------|
| DataAccessException | あり | 条件付き再試行 | ERROR |
| ConcurrencyFailureException | あり | 自動再試行 | WARN |
| TransactionSystemException | あり | なし | ERROR |
| ValidationException | あり | なし | WARN |
| BusinessException | 設定による | なし | INFO/WARN |
| UnexpectedException | あり | なし | ERROR |

#### 4.3.2 トランザクション再試行メカニズム

1. **再試行ポリシー**:
   - 最大再試行回数: 3回
   - 再試行間隔: 指数バックオフ（初回100ms）
   - 再試行対象例外: 一時的な障害（デッドロック、競合など）

2. **再試行実装**:
   - Spring Retryフレームワーク活用
   - 再試行前のコンテキストクリーンアップ
   - 再試行履歴の記録と監視

### 4.4 リソースデッドロック対策

デッドロック状態の検出と回避戦略：

#### 4.4.1 デッドロック検出

1. **検出メカニズム**:
   - データベースデッドロック例外の捕捉
   - 長時間ロック待ち状態の監視
   - リソースグラフの分析（高度機能）

2. **診断情報**:
   - 関連トランザクションID
   - 競合リソース情報
   - ロック取得順序
   - SQL文

#### 4.4.2 デッドロック回避戦略

1. **設計レベル**:
   - 一貫したリソースアクセス順序の強制
   - 長時間ロックの回避
   - 過度に大きいトランザクションの分割

2. **実行時対策**:
   - デッドロック検出時の自動再試行
   - 段階的なタイムアウト
   - ロック取得時のタイムアウト設定