# 分散トランザクション機能

## 1. 概要

分散トランザクション機能は、複数のサービスやデータソースにまたがるトランザクションの一貫性を保証するための機能です。SES管理システムでは、契約管理、請求支払管理など、複数のドメインやサブシステムと連携する処理において、データの整合性を確保するために利用されます。

本機能は、従来の2フェーズコミットプロトコル(2PC)の制約を克服するため、最終的な一貫性（Eventual Consistency）や補償トランザクション（Compensating Transaction）などの手法を組み合わせて実装します。

## 2. 機能アーキテクチャ

### 2.1 アーキテクチャ概要図

```
+----------------------------------+
| 分散トランザクション調整サービス    |
|  - コーディネーター               |
|  - トランザクション状態管理        |
|  - 参加者管理                    |
+----------------------------------+
          |         |
+-----------------+ +-----------------+
| トランザクション | | 補償トランザクション|
| プロトコル実装   | | マネージャ       |
+-----------------+ +-----------------+
          |         |
+----------------------------------+
| 参加サービス                      |
|  - トランザクション参加インターフェース |
|  - ローカルトランザクション         |
|  - 補償アクション                 |
+----------------------------------+
```

### 2.2 主要コンポーネント

1. **DistributedTransactionCoordinator（分散トランザクションコーディネーター）**
   - 分散トランザクションの開始、調整、完了
   - 参加者の登録と状態管理
   - トランザクションの状態追跡

2. **TransactionProtocolManager（トランザクションプロトコルマネージャ）**
   - 分散トランザクションプロトコルの実装
   - 2フェーズコミット(2PC)、TCC (Try-Confirm-Cancel)、Saga パターンのサポート
   - 参加者との通信制御

3. **CompensationManager（補償マネージャ）**
   - 補償トランザクションの定義と実行
   - 障害発生時の復旧処理
   - 補償アクションの順序制御

4. **ParticipantManager（参加者マネージャ）**
   - トランザクション参加者の登録と管理
   - 参加者の状態追跡
   - タイムアウト監視

5. **TransactionStateStore（トランザクション状態ストア）**
   - 分散トランザクション状態の永続化
   - リカバリ情報の保存
   - トランザクション履歴の管理

## 3. 分散トランザクションパターン

システムで採用する3つの主要な分散トランザクションパターン：

### 3.1 TCC (Try-Confirm-Cancel) パターン

2フェーズコミットの代替として、ビジネスロジックに特化した3つのフェーズを持つパターン。

#### 3.1.1 TCCフェーズの定義

1. **Try フェーズ**
   - リソースの確保とビジネスチェック
   - 本作業のための準備（仮予約など）
   - 後続処理が可能かの確認

2. **Confirm フェーズ**
   - 確保したリソースに対する本作業の実行
   - データの確定
   - Try フェーズでの仮予約の確定

3. **Cancel フェーズ**
   - Try フェーズでの変更の取り消し
   - リソースの解放
   - 仮予約のキャンセル

#### 3.1.2 適用ケース

| 業務ケース | Try アクション | Confirm アクション | Cancel アクション |
|----------|--------------|-----------------|----------------|
| 契約締結 | 契約情報の仮登録、契約条件確認 | 契約の確定、関連データの更新 | 仮登録の削除 |
| 請求処理 | 請求データ作成、請求可能性確認 | 請求の確定、債権データ作成 | 請求データの削除 |
| 技術者アサイン | 技術者の仮予約、スケジュール確認 | アサインの確定、稼働スケジュール更新 | 仮予約の解除 |

### 3.2 Saga パターン

一連のローカルトランザクションとそれに対応する補償トランザクションで構成されるパターン。

#### 3.2.1 Sagaの実装方式

1. **コレオグラフィ方式**
   - 参加サービス間でイベントを直接交換
   - 中央の調整役が存在しない分散型アプローチ
   - サービス間の疎結合性が高い

2. **オーケストレーション方式**
   - 中央のオーケストレーターがプロセスを制御
   - 全体のフローをオーケストレーターが管理
   - プロセスの可視性と制御性が高い

#### 3.2.2 適用ケース

| 業務ケース | サブトランザクション | 補償アクション | 実装方式 |
|----------|-------------------|--------------|---------|
| 月次請求生成 | 勤怠集計→請求データ作成→請求書生成→メール送信 | 各ステップの取り消し処理 | オーケストレーション |
| マッチング成立 | 案件更新→技術者更新→契約データ作成→通知送信 | 各ステップの取り消し処理 | オーケストレーション |
| クライアント登録 | 基本情報登録→担当者登録→アカウント作成→初期設定 | 各ステップの取り消し処理 | オーケストレーション |

### 3.3 最終的一貫性（Eventual Consistency）パターン

非同期メッセージングと冪等性を活用した緩やかな一貫性を実現するパターン。

#### 3.3.1 実装メカニズム

1. **イベント駆動アーキテクチャ**
   - ドメインイベントの発行と購読
   - 非同期メッセージングによる連携
   - 再試行メカニズムの実装

2. **状態追跡**
   - 分散システム全体の状態追跡
   - 不整合検出と自動修復
   - 定期的な整合性チェック

#### 3.3.2 適用ケース

| 業務ケース | 一貫性要件 | 許容遅延 | 実装アプローチ |
|----------|----------|---------|------------|
| レポートデータ集計 | 参照整合性 | 数分〜1時間 | イベントストリーミング |
| ダッシュボード更新 | 表示整合性 | 数秒〜数分 | メッセージキュー |
| 通知送信 | 配信保証 | 数秒〜数分 | 再試行キュー |

## 4. 分散トランザクション実装

### 4.1 TCC実装

#### 4.1.1 参加者インターフェース

```java
public interface TCCParticipant {
    /**
     * Tryフェーズの処理
     * @param context 分散トランザクションコンテキスト
     * @return 処理結果
     */
    TryResult try(DistributedTransactionContext context);
    
    /**
     * Confirmフェーズの処理
     * @param context 分散トランザクションコンテキスト
     * @return 処理結果
     */
    ConfirmResult confirm(DistributedTransactionContext context);
    
    /**
     * Cancelフェーズの処理
     * @param context 分散トランザクションコンテキスト
     * @return 処理結果
     */
    CancelResult cancel(DistributedTransactionContext context);
}
```

#### 4.1.2 TCCトランザクション実行フロー

1. **コーディネーターの処理フロー**
   1. 分散トランザクション開始と参加者登録
   2. 全参加者のTryフェーズ実行
   3. Try成功なら全参加者のConfirmフェーズ実行、失敗なら全参加者のCancelフェーズ実行
   4. トランザクション完了と結果の返却

2. **参加者の処理フロー**
   1. Try処理の実装（リソース仮確保など）
   2. Confirm処理の実装（確定処理）
   3. Cancel処理の実装（取り消し処理）
   4. 各フェーズの冪等性確保

#### 4.1.3 障害ハンドリング

1. **通信障害対策**
   - タイムアウト設定
   - 再試行メカニズム
   - 参加者の状態追跡

2. **参加者障害対策**
   - 障害参加者の自動除外
   - 部分的コミットの防止
   - リカバリアクションの実行

### 4.2 Saga実装

#### 4.2.1 Sagaオーケストレーター

```java
public interface SagaOrchestrator {
    /**
     * Sagaトランザクションを開始する
     * @param sagaDefinition Saga定義
     * @param input 入力データ
     * @return Saga実行コンテキスト
     */
    SagaContext startSaga(SagaDefinition sagaDefinition, Object input);
    
    /**
     * 次のステップを実行する
     * @param context Saga実行コンテキスト
     * @return 実行結果
     */
    StepResult executeNextStep(SagaContext context);
    
    /**
     * 補償処理を実行する
     * @param context Saga実行コンテキスト
     * @param fromStep 補償開始ステップ
     * @return 補償実行結果
     */
    CompensationResult executeCompensation(SagaContext context, int fromStep);
}
```

#### 4.2.2 Saga定義

```java
public class SagaDefinition {
    private String sagaName;
    private List<SagaStep> steps;
    private SagaCompletionPolicy completionPolicy;
    private int retryAttempts;
    private long retryDelay;
    private String description;
    
    // getter, setterメソッド
}

public class SagaStep {
    private String stepName;
    private SagaAction action;
    private SagaAction compensationAction;
    private RetryPolicy retryPolicy;
    private boolean isRequired;
    private Map<String, Object> metadata;
    
    // getter, setterメソッド
}
```

#### 4.2.3 Saga実行フロー

1. **順方向実行**
   1. Sagaオーケストレーターが順次アクションを実行
   2. 各ステップの成功/失敗状態を記録
   3. 全ステップ成功で完了

2. **障害時の補償処理**
   1. ステップ失敗を検知
   2. 実行済みステップの補償アクションを逆順に実行
   3. 補償完了でSagaをロールバック状態に更新

#### 4.2.4 永続化と回復メカニズム

1. **Saga状態の永続化**
   - 各ステップの実行前後で状態を保存
   - 実行コンテキストの完全な永続化
   - リカバリ情報の保存

2. **システム障害からの回復**
   - 起動時の未完了Sagaの検出
   - 中断ポイントからの再開または補償実行
   - 孤立したSagaの検出と解決

### 4.3 最終的一貫性実装

#### 4.3.1 イベント発行機構

```java
public interface EventPublisher {
    /**
     * イベントを発行する
     * @param event 発行するイベント
     * @return 発行結果
     */
    PublishResult publish(DomainEvent event);
    
    /**
     * 保証付きイベント発行
     * @param event 発行するイベント
     * @param options 発行オプション（再試行など）
     * @return 発行結果
     */
    PublishResult publishWithGuarantee(DomainEvent event, PublishOptions options);
}
```

#### 4.3.2 イベント購読機構

```java
public interface EventSubscriber {
    /**
     * イベントを購読する
     * @param eventType 購読するイベントタイプ
     * @param handler イベントハンドラー
     * @return 購読ID
     */
    String subscribe(String eventType, EventHandler handler);
    
    /**
     * 購読を解除する
     * @param subscriptionId 購読ID
     */
    void unsubscribe(String subscriptionId);
}

public interface EventHandler {
    /**
     * イベントを処理する
     * @param event 受信イベント
     * @return 処理結果
     */
    HandlingResult handle(DomainEvent event);
}
```

#### 4.3.3 冪等性の確保

1. **冪等キーの管理**
   - イベントIDを用いた重複検出
   - 冪等キーの永続化と有効期限管理
   - 処理済みイベントの追跡

2. **べき等性実装パターン**
   - 条件付き更新（バージョン番号、タイムスタンプなど）
   - 状態ベース検証（現在の状態に基づく処理判断）
   - 巻き戻し可能な設計（取り消し操作の実装）

#### 4.3.4 整合性モニタリング

1. **不整合検出メカニズム**
   - 定期的な整合性チェックジョブ
   - クロスサービスデータ検証
   - 異常パターンの検出ルール

2. **自動修復メカニズム**
   - 不整合データの修正操作
   - リコンシリエーションイベントの発行
   - 手動承認による修復

## 5. 分散トランザクション管理

### 5.1 トランザクション状態管理

#### 5.1.1 状態モデル

```java
public enum DistributedTransactionState {
    // 初期状態
    CREATED,
    
    // TCCトランザクション状態
    TRY_STARTED,
    TRY_SUCCEEDED,
    TRY_FAILED,
    CONFIRM_STARTED,
    CONFIRM_SUCCEEDED,
    CONFIRM_FAILED,
    CANCEL_STARTED,
    CANCEL_SUCCEEDED,
    CANCEL_FAILED,
    
    // Sagaトランザクション状態
    SAGA_STARTED,
    SAGA_EXECUTING,
    SAGA_COMPLETED,
    SAGA_COMPENSATING,
    SAGA_COMPENSATED,
    
    // 共通終了状態
    COMMITTED,
    ROLLED_BACK,
    PARTIALLY_COMMITTED,  // 部分的コミット（異常）
    HEURISTICALLY_COMPLETED,  // ヒューリスティック完了
    UNKNOWN,  // 不明状態
    TIMED_OUT  // タイムアウト
}
```

#### 5.1.2 状態遷移管理

1. **トランザクション状態マシン**
   - 状態遷移ルールの定義
   - 無効な状態遷移の防止
   - 状態変更ログの記録

2. **タイムアウト管理**
   - 各状態のタイムアウト設定
   - タイムアウト検出と対応アクション
   - ゴーストトランザクションの検出と解決

### 5.2 リカバリメカニズム

#### 5.2.1 コーディネーター障害からの回復

1. **ログベースリカバリ**
   - トランザクションログからの状態再構築
   - 最後の既知の状態からの処理再開
   - 中断ポイントの特定

2. **障害転送**
   - バックアップコーディネーターへの処理移管
   - 状態情報の共有
   - シームレスな障害復旧

#### 5.2.2 参加者障害からの回復

1. **部分障害対応**
   - 障害参加者の分離
   - 復旧時の追跡と再同期
   - 代替参加者への切り替え

2. **再試行とスキップポリシー**
   - 重要度に基づく参加者分類
   - 必須参加者と任意参加者の区別
   - 条件付き完了ポリシー

### 5.3 モニタリングと運用管理

#### 5.3.1 監視メカニズム

1. **リアルタイムモニタリング**
   - アクティブトランザクション監視
   - 異常状態検出
   - パフォーマンスメトリクス収集

2. **アラート機能**
   - タイムアウトアラート
   - 異常状態アラート
   - リソース枯渇警告

#### 5.3.2 運用ツール

1. **トランザクション状態確認**
   - トランザクションID検索
   - 状態履歴表示
   - 詳細ログ表示

2. **手動介入機能**
   - 中断トランザクションの再開
   - 強制コミット/ロールバック
   - 補償トランザクションの手動実行

## 6. 適用ガイドライン

### 6.1 トランザクションパターン選択指針

| 特性 | TCC | Saga | 最終的一貫性 |
|-----|-----|------|------------|
| 整合性レベル | 強 | 中 | 弱 |
| 応答時間 | 中〜長 | 中 | 短 |
| 実装複雑性 | 高 | 中 | 低 |
| 推奨ユースケース | 短期間で強い整合性が必要な取引処理 | 複数ステップの業務プロセス | 非同期更新、通知処理 |

### 6.2 業務機能別推奨パターン

| 業務機能 | 推奨パターン | 理由 |
|---------|------------|------|
| 契約締結 | TCC | 法的に強い整合性が必要 |
| 請求処理 | Saga | 複数ステップの処理が必要 |
| マッチング | TCC | 技術者と案件の同時更新が必要 |
| レポート更新 | 最終的一貫性 | リアルタイム性より一貫性が重要 |
| 通知送信 | 最終的一貫性 | 多少の遅延は許容される |
| バッチ処理 | Saga | 長時間実行で複数ステップを含む |

### 6.3 実装上の注意点

1. **全般的な注意点**
   - トランザクションの境界を明確に定義する
   - トランザクションのタイムアウトを適切に設定する
   - 冪等性を確保する
   - 障害シナリオを考慮した設計を行う

2. **TCC固有の注意点**
   - Tryフェーズは軽量に保つ
   - リソースロックの時間を最小化する
   - 確実なCancel処理を実装する

3. **Saga固有の注意点**
   - 補償トランザクションの正確な実装
   - 補償の順序制御（逆順）
   - 非同期性による副作用の考慮

4. **最終的一貫性固有の注意点**
   - 不整合状態の許容範囲を定義する
   - タイムアウトと再試行の適切な設定
   - データの最終的な収束を確認する機構の実装