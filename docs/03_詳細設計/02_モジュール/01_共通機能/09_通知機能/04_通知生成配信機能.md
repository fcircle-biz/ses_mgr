# 通知機能 - 通知生成配信機能

## 1. 機能概要

通知生成配信機能は、さまざまな通知を生成し、適切な配信チャネルを通じてユーザーに配信することを担当します。この機能は以下の責務を持ちます：

- 業務イベントからの通知生成
- テンプレートベースの通知フォーマット
- 複数の配信チャネル（アプリ内通知、メール通知）の管理
- リアルタイム通知のためのストリーミング提供

## 2. コンポーネント構成

### 2.1 NotificationFactory

通知の生成を担当するファクトリーコンポーネントです。

#### 責務
- 通知エンティティの生成
- 通知メタデータの構築
- テンプレートからの通知生成

#### 主要メソッド

```
public interface NotificationFactory {
    // 通知の生成
    Notification createNotification(
        NotificationType type,
        User recipient,
        String title,
        String body,
        Map<String, Object> metadata,
        User sender
    );
    
    // テンプレートからの通知生成
    Notification createFromTemplate(
        NotificationTemplate template,
        User recipient,
        Map<String, Object> parameters,
        User sender
    );
    
    // メタデータの構築
    Map<String, Object> buildMetadata(
        String entityType,
        String entityId,
        String actionUrl,
        String importance,
        LocalDateTime expiresAt,
        Map<String, Object> additionalData
    );
}
```

#### 実装の詳細

- パラメータのバリデーションを徹底的に行い、不正な通知が生成されないようにする
- テンプレートからの生成時は、必要なパラメータが欠けていないか検証する
- 通知の作成日時は自動的に設定し、既読フラグはデフォルトで未読（false）にする
- メタデータはJSON形式で扱い、シリアライズ/デシリアライズが容易な構造にする

### 2.2 NotificationEventListener

システム内の各種イベントをリッスンし、通知に変換するコンポーネントです。

#### 責務
- 業務イベントのリスニング
- イベントから通知への変換
- 通知サービスへの通知作成依頼

#### 主要実装例

```
@Component
public class ProjectEventListener {
    private final NotificationService notificationService;
    private final UserService userService;
    
    @EventListener
    public void handleProjectCreatedEvent(ProjectCreatedEvent event) {
        Project project = event.getProject();
        List<User> recipients = userService.getUsersWithRole("PROJECT_MANAGER");
        
        Map<String, Object> metadata = new HashMap<>();
        metadata.put("projectId", project.getId());
        metadata.put("projectName", project.getName());
        metadata.put("clientName", project.getClient().getName());
        metadata.put("actionUrl", "/projects/" + project.getId());
        
        notificationService.createNotification(
            NotificationType.EVENT,
            recipients,
            "新規案件が登録されました",
            String.format("「%s」という新しい案件が登録されました。", project.getName()),
            metadata
        );
    }
    
    @EventListener
    public void handleProjectAssignmentEvent(ProjectAssignmentEvent event) {
        // 案件アサイン通知の実装
    }
    
    @EventListener
    public void handleProjectDeadlineApproachingEvent(ProjectDeadlineEvent event) {
        // 案件の期限通知の実装
    }
}
```

#### 実装のパターン

通知が必要なイベントの例：

1. **案件管理モジュール**
   - 案件登録イベント → 営業担当者への通知
   - 案件内容更新イベント → 担当者への通知
   - 案件期限接近イベント → プロジェクトマネージャーへの通知

2. **技術者管理モジュール**
   - 技術者登録イベント → 営業担当者への通知
   - 稼働状況変更イベント → リソース管理者への通知
   - スキルシート更新イベント → マッチングチームへの通知

3. **契約管理モジュール**
   - 契約書作成イベント → 承認者への通知
   - 署名完了イベント → 関係者への通知
   - 契約期限接近イベント → 担当者への通知

4. **請求・支払管理モジュール**
   - 請求書発行イベント → 承認者への通知
   - 支払期限接近イベント → 経理担当への通知
   - 入金確認イベント → 営業担当者への通知

### 2.3 DeliveryEngine

通知の配信方法を決定し、配信を実行するコンポーネントです。

#### 責務
- 配信チャネルの決定
- アプリ内通知の配信
- メール通知の送信
- テンプレートの適用

#### 主要メソッド

```
public interface DeliveryEngine {
    // 通知の配信
    void deliver(Notification notification);
    
    // 配信チャネルの決定
    Set<DeliveryChannel> determineChannels(User user, NotificationType type);
    
    // アプリ内通知の配信
    void deliverInApp(Notification notification);
    
    // メール通知の送信
    void deliverEmail(Notification notification);
    
    // テンプレート適用
    String applyTemplate(String template, Map<String, Object> parameters);
}
```

#### 実装の詳細

- ユーザーの通知設定に基づいて配信チャネルを決定する
- アプリ内通知はデータベースに保存し、WebSocketやSSEで即時配信する
- メール通知は非同期で処理し、失敗時はリトライ機構を設ける
- テンプレートエンジンにはThymeleafなどのテンプレートエンジンを使用する

### 2.4 NotificationStreamManager

リアルタイム通知のストリーミングを管理するコンポーネントです。

#### 責務
- SSEセッションの管理
- ユーザーごとの通知ストリームの提供
- 通知のリアルタイム配信

#### 主要メソッド

```
public interface NotificationStreamManager {
    // ユーザーの通知ストリームを取得
    Flux<ServerSentEvent<NotificationDto>> getUserNotificationStream(String username);
    
    // 新しい通知をストリームに発行
    void publishNotification(Notification notification);
    
    // アクティブなセッションを管理
    void registerSession(String username, String sessionId);
    void removeSession(String username, String sessionId);
    
    // セッション統計を取得
    Map<String, Integer> getActiveSessions();
}
```

#### 実装の詳細

- Spring WebFluxのFluxを使用したリアクティブストリーミング
- ユーザーごとにSink（データシンク）を管理
- 通知発生時に対象ユーザーのSinkにデータをプッシュ
- セッション切断時のクリーンアップ処理
- スケーラビリティのための分散イベントバス（例：Redis PubSub）の利用

## 3. 通知テンプレート管理

### 3.1 テンプレートエンジン

通知テンプレートの処理を担当するコンポーネントです。

#### 責務
- テンプレートの解析と変数置換
- テンプレートの検証
- テンプレートのキャッシュ管理

#### 主要メソッド

```
public interface TemplateEngine {
    // テンプレート処理
    String processTemplate(String template, Map<String, Object> variables);
    
    // テンプレート検証
    List<String> validateTemplate(String template);
    
    // テンプレートの必須変数を抽出
    Set<String> extractRequiredVariables(String template);
    
    // キャッシュ管理
    void invalidateCache(String templateKey);
}
```

#### 実装の詳細

- 変数構文：`${variable}` 形式での変数参照をサポート
- 条件分岐：`#{if condition}...#{else}...#{endif}` のような条件ブロックをサポート
- ループ処理：`#{for item in items}...#{endfor}` のようなループ構文をサポート
- エスケープ処理：HTMLエスケープやJSONエスケープの自動適用
- キャッシュ：頻繁に使用されるテンプレートのパース結果をキャッシュ

### 3.2 標準テンプレート

システムに標準で組み込まれる通知テンプレートです。

#### システム通知テンプレート

```
【テンプレートキー】system_maintenance
【タイトル】システムメンテナンスのお知らせ
【本文】
${date}に${duration}時間のシステムメンテナンスを実施いたします。
メンテナンス時間中はシステムをご利用いただけません。
ご不便をおかけしますが、ご理解いただきますようお願いいたします。

■メンテナンス日時
${date} ${startTime}～${endTime}

■影響範囲
${scope}

#{if reason}
■メンテナンス理由
${reason}
#{endif}
```

#### タスク通知テンプレート

```
【テンプレートキー】task_approval_request
【タイトル】${entityType}の承認依頼があります
【本文】
${requesterName}より${entityType}「${entityName}」の承認依頼が届いています。
内容をご確認の上、承認または差し戻しをお願いいたします。

■承認期限: ${dueDate}
■リンク: ${actionUrl}

#{if comment}
■依頼者コメント
${comment}
#{endif}
```

#### アラート通知テンプレート

```
【テンプレートキー】alert_contract_expiration
【タイトル】契約期限が近づいています
【本文】
契約「${contractName}」の期限が${daysRemaining}日後に迫っています。
更新手続きが必要な場合は、早めのご対応をお願いいたします。

■契約情報
契約先: ${clientName}
契約期間: ${startDate}～${endDate}
契約担当: ${managerName}

■詳細リンク
${actionUrl}
```

#### イベント通知テンプレート

```
【テンプレートキー】event_engineer_assigned
【タイトル】技術者が案件にアサインされました
【本文】
技術者「${engineerName}」が案件「${projectName}」にアサインされました。

■アサイン情報
案件名: ${projectName}
顧客名: ${clientName}
アサイン期間: ${startDate}～${endDate}
#{if role}役割: ${role}#{endif}

■詳細リンク
${actionUrl}
```

## 4. メール通知の実装

### 4.1 メールテンプレート

メール通知で使用するHTMLテンプレート形式です。

#### 基本構造

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        /* メールテンプレートのCSS */
        body { font-family: sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { border-bottom: 1px solid #eee; padding-bottom: 10px; }
        .footer { border-top: 1px solid #eee; padding-top: 10px; color: #777; font-size: 0.8em; }
        .content { padding: 20px 0; }
        .button { display: inline-block; padding: 10px 20px; background-color: #1a56db; color: white; text-decoration: none; border-radius: 4px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>${title}</h1>
        </div>
        <div class="content">
            ${content}
            
            #{if actionUrl}
            <p><a href="${actionUrl}" class="button">詳細を表示</a></p>
            #{endif}
        </div>
        <div class="footer">
            <p>このメールは自動送信されています。返信はできませんのでご了承ください。</p>
            <p>© ${currentYear} SES業務システム</p>
        </div>
    </div>
</body>
</html>
```

### 4.2 メール送信実装

メール送信処理の実装例です。

```java
@Service
public class EmailDeliveryService {
    private final JavaMailSender mailSender;
    private final TemplateEngine templateEngine;
    private final String fromAddress;
    
    // コンストラクタ、依存性注入
    
    public void sendNotificationEmail(Notification notification) {
        // ユーザーのメールアドレスを取得
        String recipientEmail = notification.getRecipient().getEmail();
        if (recipientEmail == null || recipientEmail.isEmpty()) {
            throw new EmailDeliveryException("受信者のメールアドレスが設定されていません");
        }
        
        try {
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");
            
            helper.setFrom(fromAddress);
            helper.setTo(recipientEmail);
            helper.setSubject(notification.getTitle());
            
            // HTMLテンプレートを適用
            Map<String, Object> variables = new HashMap<>();
            variables.put("title", notification.getTitle());
            variables.put("content", notification.getBody().replace("\n", "<br>"));
            variables.put("actionUrl", notification.getMetadata().get("actionUrl"));
            variables.put("currentYear", Year.now().getValue());
            
            String htmlContent = templateEngine.processTemplate("email_template", variables);
            helper.setText(htmlContent, true);
            
            // メール送信（非同期実行）
            CompletableFuture.runAsync(() -> mailSender.send(message));
        } catch (Exception e) {
            throw new EmailDeliveryException("メール送信に失敗しました", e);
        }
    }
}
```

## 5. リアルタイム通知の実装

### 5.1 Server-Sent Events（SSE）の実装

SSEを使用したリアルタイム通知の実装例です。

#### コントローラ

```java
@RestController
@RequestMapping("/api/v1/common/notifications")
public class NotificationStreamController {
    private final NotificationStreamManager streamManager;
    
    // コンストラクタ、依存性注入
    
    @GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<NotificationDto>> streamNotifications(
            @AuthenticationPrincipal UserDetails user,
            HttpServletRequest request) {
        
        String username = user.getUsername();
        String sessionId = request.getSession().getId();
        
        // セッション登録
        streamManager.registerSession(username, sessionId);
        
        // セッション終了時の処理
        Mono<Void> onCompletion = Mono.fromRunnable(() -> 
            streamManager.removeSession(username, sessionId));
        
        // ユーザーの通知ストリームを取得して返却
        return streamManager.getUserNotificationStream(username)
                .doOnCancel(() -> onCompletion.subscribe())
                .doOnComplete(() -> onCompletion.subscribe());
    }
}
```

#### ストリームマネージャ

```java
@Service
public class NotificationStreamManagerImpl implements NotificationStreamManager {
    private final Map<String, List<UnicastProcessor<ServerSentEvent<NotificationDto>>>> userProcessors = new ConcurrentHashMap<>();
    private final Map<String, Map<String, String>> userSessions = new ConcurrentHashMap<>();
    
    @Override
    public Flux<ServerSentEvent<NotificationDto>> getUserNotificationStream(String username) {
        // ユーザー用のプロセッサを取得または作成
        userProcessors.computeIfAbsent(username, k -> new CopyOnWriteArrayList<>());
        
        UnicastProcessor<ServerSentEvent<NotificationDto>> processor = UnicastProcessor.create();
        userProcessors.get(username).add(processor);
        
        // キープアライブイベントを5分ごとに送信
        Flux<ServerSentEvent<NotificationDto>> keepAlive = Flux.interval(Duration.ofMinutes(5))
            .map(i -> ServerSentEvent.<NotificationDto>builder()
                .event("keep-alive")
                .build());
        
        // プロセッサのストリームとキープアライブを結合
        return Flux.merge(processor, keepAlive)
            .doFinally(signalType -> {
                userProcessors.get(username).remove(processor);
                if (userProcessors.get(username).isEmpty()) {
                    userProcessors.remove(username);
                }
            });
    }
    
    @Override
    public void publishNotification(Notification notification) {
        String username = notification.getRecipient().getUsername();
        List<UnicastProcessor<ServerSentEvent<NotificationDto>>> processors = userProcessors.get(username);
        
        if (processors != null && !processors.isEmpty()) {
            NotificationDto dto = NotificationDto.from(notification);
            ServerSentEvent<NotificationDto> event = ServerSentEvent.<NotificationDto>builder()
                .id(notification.getId().toString())
                .event("notification")
                .data(dto)
                .build();
                
            processors.forEach(processor -> processor.onNext(event));
        }
    }
    
    // セッション管理メソッドの実装
}
```

### 5.2 WebSocket 実装（代替方式）

双方向通信が必要な場合のWebSocket実装例です。

#### WebSocketハンドラ

```java
@Component
public class NotificationWebSocketHandler extends TextWebSocketHandler {
    private final NotificationService notificationService;
    private final ObjectMapper objectMapper;
    private final Map<String, Set<WebSocketSession>> userSessions = new ConcurrentHashMap<>();
    
    // コンストラクタ、依存性注入
    
    @Override
    public void afterConnectionEstablished(WebSocketSession session) {
        String username = getUsernameFromSession(session);
        userSessions.computeIfAbsent(username, k -> new CopyOnWriteArraySet<>());
        userSessions.get(username).add(session);
    }
    
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {
        String username = getUsernameFromSession(session);
        if (userSessions.containsKey(username)) {
            userSessions.get(username).remove(session);
            if (userSessions.get(username).isEmpty()) {
                userSessions.remove(username);
            }
        }
    }
    
    public void sendNotification(Notification notification) {
        String username = notification.getRecipient().getUsername();
        Set<WebSocketSession> sessions = userSessions.get(username);
        
        if (sessions != null && !sessions.isEmpty()) {
            try {
                NotificationDto dto = NotificationDto.from(notification);
                String message = objectMapper.writeValueAsString(dto);
                
                for (WebSocketSession session : sessions) {
                    if (session.isOpen()) {
                        session.sendMessage(new TextMessage(message));
                    }
                }
            } catch (Exception e) {
                // エラーハンドリング
            }
        }
    }
    
    private String getUsernameFromSession(WebSocketSession session) {
        // セッションからユーザー名を取得する処理
    }
}
```

## 6. 通知配信の最適化

### 6.1 バッチ処理

大量の通知を効率的に処理するためのバッチ処理機能です。

```java
@Service
public class NotificationBatchService {
    private final NotificationRepository repository;
    private final DeliveryEngine deliveryEngine;
    private final int batchSize = 100;
    
    // コンストラクタ、依存性注入
    
    @Scheduled(fixedDelay = 60000) // 1分ごとに実行
    public void processUndeliveredNotifications() {
        int page = 0;
        boolean hasMore = true;
        
        while (hasMore) {
            PageRequest pageRequest = PageRequest.of(page, batchSize);
            Page<Notification> notifications = repository.findByDeliveryStatusAndCreatedAtBefore(
                DeliveryStatus.PENDING, 
                LocalDateTime.now().minusMinutes(1),
                pageRequest
            );
            
            if (notifications.isEmpty()) {
                hasMore = false;
            } else {
                notifications.forEach(deliveryEngine::deliver);
                page++;
            }
        }
    }
    
    @Scheduled(cron = "0 0 3 * * ?") // 毎日午前3時に実行
    public void archiveExpiredNotifications() {
        LocalDateTime cutoffDate = LocalDateTime.now().minusDays(90);
        repository.archiveNotificationsCreatedBefore(cutoffDate);
    }
}
```

### 6.2 優先度に基づく配信

通知の優先度に基づいて配信を管理する機能です。

```java
@Service
public class PriorityDeliveryService {
    private final ThreadPoolTaskExecutor highPriorityExecutor;
    private final ThreadPoolTaskExecutor normalPriorityExecutor;
    private final ThreadPoolTaskExecutor lowPriorityExecutor;
    
    // コンストラクタ、依存性注入
    
    public void deliverWithPriority(Notification notification) {
        String importance = (String) notification.getMetadata().getOrDefault("importance", "medium");
        
        switch (importance) {
            case "high":
                highPriorityExecutor.execute(() -> doDeliver(notification));
                break;
            case "low":
                lowPriorityExecutor.execute(() -> doDeliver(notification));
                break;
            default:
                normalPriorityExecutor.execute(() -> doDeliver(notification));
                break;
        }
    }
    
    private void doDeliver(Notification notification) {
        // 実際の配信ロジック
    }
}
```