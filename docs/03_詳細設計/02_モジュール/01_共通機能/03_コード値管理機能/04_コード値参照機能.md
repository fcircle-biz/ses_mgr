# コード値管理機能 - コード値参照機能

## 1. 機能概要

コード値参照機能は、SES業務システム全体で使用されるコード値（マスタデータ）を効率的に参照するための機能を提供します。
この機能は、各種選択肢やマスタデータ表示のための標準的な方法として、システム全体のほぼすべてのモジュールで利用されます。
参照性能を最適化するためのキャッシュ機構も備えています。

## 2. 主要コンポーネント構成

コード値参照機能は以下のコンポーネントで構成されます：

### 2.1 コンポーネント構成図

```
                      ┌─────────────────────┐
                      │    CodeController    │
                      └───────────┬───────────┘
                                  │
                                  ▼
┌─────────────────┐      ┌─────────────────┐      ┌──────────────────┐
│  CacheManager   │◄─────┤   CodeService   │─────►│  CodeRepository  │
└─────────────────┘      └─────────────────┘      └──────────────────┘
```

### 2.2 コンポーネント説明

- **CodeController**: コード値参照のRESTful APIエンドポイントを提供、Spring MVCの標準機能を活用
- **CodeService**: コード値参照のビジネスロジックを実装、Spring Cacheアノテーションによるキャッシュ管理
- **CodeRepository**: Spring Data JPAを活用した宣言的なデータアクセス層
- **CacheManager**: Spring Cacheフレームワークによるキャッシュ管理（CaffeineCache実装）

## 3. 処理フロー

### 3.1 コード値カテゴリ一覧取得フロー

```
1. クライアントがコード値カテゴリ一覧取得APIを呼び出し
2. CodeController.getCategories()メソッドが実行される
3. CodeService.findAllCategories()メソッドが呼び出される
   3.1. Spring Cacheの@Cacheable「codeCategories」アノテーションにより、まずキャッシュからの取得を試行
   3.2. キャッシュミスの場合、メソッド本体が実行され、CodeRepositoryから取得
   3.3. 各カテゴリのコード値件数を計算
   3.4. 結果は自動的にキャッシュに格納（@Cacheable機能）
4. カテゴリ一覧DTOをクライアントに返却
```

### 3.2 カテゴリ別コード値一覧取得フロー

```
1. クライアントがカテゴリ別コード値一覧取得APIを呼び出し
2. CodeController.getCodeValues()メソッドが実行される
   2.1. Spring MVCの@RequestParamでリクエストパラメータをバリデーション
3. CodeService.findByCategory()メソッドが呼び出される
   3.1. @Cacheable(value = "codeValues", key = "#categoryId + ':' + #keyword + ':' + #parent + ':' + #activeOnly")によるキャッシュ制御
   3.2. キャッシュミスの場合、カテゴリの存在確認
   3.3. CodeRepositoryから取得（Spring Data JPAメソッド使用）
   3.4. フィルタリング条件（キーワード、親コード、有効フラグ）による絞り込み
   3.5. ソート順でソート
   3.6. 結果は自動的にキャッシュに格納（@Cacheable機能）
4. コード値一覧DTOをクライアントに返却
```

### 3.3 コード値詳細取得フロー

```
1. クライアントがコード値詳細取得APIを呼び出し
2. CodeController.getCodeValue()メソッドが実行される
   2.1. Spring MVCの@PathVariableでパスパラメータを取得
3. CodeService.findByCode()メソッドが呼び出される
   3.1. @Cacheable(value = "codeValueDetails", key = "#categoryId + ':' + #code")によるキャッシュ制御
   3.2. キャッシュミスの場合、CodeRepositoryから取得（Spring Data JPAメソッド使用）
   3.3. コード値が存在しない場合はEntityNotFoundExceptionをスロー（Spring例外変換機能で処理）
   3.4. 階層構造の場合は親コードと子コードの情報も取得
   3.5. 結果は自動的にキャッシュに格納（@Cacheable機能）
4. コード値詳細DTOをクライアントに返却
```

### 3.4 階層構造コード値取得フロー

```
1. クライアントが階層構造コード値取得APIを呼び出し
2. CodeController.getCodeValueTree()メソッドが実行される
   2.1. Spring MVCの@RequestParamでリクエストパラメータをバリデーション
3. CodeService.getCodeValueTree()メソッドが呼び出される
   3.1. @Cacheable(value = "codeValueTrees", key = "#categoryId + ':tree:' + #activeOnly")によるキャッシュ制御
   3.2. キャッシュミスの場合、カテゴリの存在確認
   3.3. CodeRepositoryから取得（Spring Data JPAメソッド使用）
   3.4. 親子関係に基づいてツリー構造を構築
   3.5. 有効フラグによるフィルタリング（要求された場合）
   3.6. 結果は自動的にキャッシュに格納（@Cacheable機能）
4. コード値ツリーDTOをクライアントに返却
```

### 3.5 コード名称マッピング取得フロー

```
1. クライアントがコード名称マッピング取得APIを呼び出し
2. CodeController.getCodeNameMap()メソッドが実行される
3. CodeService.getCodeNameMap()メソッドが呼び出される
   3.1. カテゴリの存在確認
   3.2. 指定されたコードリストの存在確認
   3.3. コードと名称のマッピングを作成
4. コード-名称マッピングをクライアントに返却
```

### 3.6 キャッシュ更新フロー

```
1. コード値データの変更を検知（AdminCodeServiceから通知またはSpring Applicationイベント）
2. CodeService.refreshCache()メソッドが呼び出される
   3.1. 更新対象のカテゴリを特定
   3.2. @CacheEvict(value = {"codeCategories", "codeValues", "codeValueDetails", "codeValueTrees"}, key = "...)アノテーションによりキャッシュを自動的に無効化
   3.3. または、allEntries=trueパラメータにより特定キャッシュ全体を無効化
```

## 4. 実装詳細

### 4.1 CodeController 実装

```java
@RestController
@RequestMapping("/api/v1/common/codes")
@Validated
public class CodeController {

    private final CodeService codeService;
    
    @Autowired
    public CodeController(CodeService codeService) {
        this.codeService = codeService;
    }
    
    @GetMapping
    public ResponseEntity<List<CodeCategoryDTO>> getCategories() {
        List<CodeCategoryDTO> categories = codeService.findAllCategories();
        return ResponseEntity.ok(categories);
    }
    
    @GetMapping("/{categoryId}")
    public ResponseEntity<List<CodeValueDTO>> getCodeValues(
            @PathVariable @Pattern(regexp = "^[a-z0-9_]{3,32}$") String categoryId,
            @RequestParam(required = false) String keyword,
            @RequestParam(required = false) String parent,
            @RequestParam(required = false, defaultValue = "true") Boolean activeOnly) {
        
        // 例外ハンドラが@ControllerAdviceで集中管理されているため、try-catchは不要
        List<CodeValueDTO> codeValues = codeService.findByCategory(categoryId, keyword, parent, activeOnly);
        return ResponseEntity.ok(codeValues);
    }
    
    @GetMapping("/{categoryId}/{code}")
    public ResponseEntity<CodeValueDetailDTO> getCodeValue(
            @PathVariable @Pattern(regexp = "^[a-z0-9_]{3,32}$") String categoryId, 
            @PathVariable @NotBlank String code) {
        
        CodeValueDetailDTO codeValue = codeService.findByCode(categoryId, code);
        return ResponseEntity.ok(codeValue);
    }
    
    @GetMapping("/{categoryId}/tree")
    public ResponseEntity<CodeValueTreeDTO> getCodeValueTree(
            @PathVariable @Pattern(regexp = "^[a-z0-9_]{3,32}$") String categoryId,
            @RequestParam(required = false, defaultValue = "true") Boolean activeOnly) {
        
        CodeValueTreeDTO tree = codeService.getCodeValueTree(categoryId, activeOnly);
        return ResponseEntity.ok(tree);
    }
    
    @PostMapping("/{categoryId}/names")
    public ResponseEntity<Map<String, String>> getCodeNameMap(
            @PathVariable @Pattern(regexp = "^[a-z0-9_]{3,32}$") String categoryId,
            @RequestBody @NotEmpty @Size(max = 100) List<@NotBlank String> codes) {
        
        Map<String, String> nameMap = codeService.getCodeNameMap(categoryId, codes);
        return ResponseEntity.ok(nameMap);
    }
}
```

### 4.2 CodeServiceImpl 実装

```java
@Service
@CacheConfig(cacheNames = {"codeCategories", "codeValues", "codeValueDetails", "codeValueTrees"})
public class CodeServiceImpl implements CodeService {

    private final CodeCategoryRepository categoryRepository;
    private final CodeValueRepository codeValueRepository;
    
    @Autowired
    public CodeServiceImpl(
            CodeCategoryRepository categoryRepository,
            CodeValueRepository codeValueRepository) {
        this.categoryRepository = categoryRepository;
        this.codeValueRepository = codeValueRepository;
    }
    
    @Override
    @Cacheable(value = "codeCategories", key = "'all'")
    public List<CodeCategoryDTO> findAllCategories() {
        // Spring Cacheがキャッシュ制御を担当するため、手動キャッシュ操作は不要
        
        // DBから取得
        List<CodeCategory> categories = categoryRepository.findAllByOrderBySortOrder();
        List<CodeCategoryDTO> result = categories.stream()
                .map(category -> {
                    CodeCategoryDTO dto = convertToDTO(category);
                    // コード値件数を設定
                    long count = codeValueRepository.countByCategoryId(category.getId());
                    dto.setCodeCount((int) count);
                    return dto;
                })
                .collect(Collectors.toList());
        
        return result;
    }
    
    @Override
    @Cacheable(value = "codeValues", key = "#categoryId + ':' + #keyword + ':' + #parentCode + ':' + #activeOnly")
    @Transactional(readOnly = true)
    public List<CodeValueDTO> findByCategory(String categoryId, String keyword, String parentCode, Boolean activeOnly) {
        // カテゴリの存在確認
        if (!categoryRepository.existsById(categoryId)) {
            throw new EntityNotFoundException("Category not found with id: " + categoryId);
        }
        
        // DBから取得
        List<CodeValue> codeValues;
        
        if (parentCode != null) {
            // 親コードが指定されている場合は子コードのみ取得
            codeValues = codeValueRepository.findByCategoryIdAndParentCode(categoryId, parentCode);
        } else {
            // 親コードが指定されていない場合はカテゴリ内の全コードまたはルートレベルのコードを取得
            codeValues = parentCode == null ? 
                    codeValueRepository.findByCategoryId(categoryId) : 
                    codeValueRepository.findByCategoryIdAndParentCodeIsNull(categoryId);
        }
        
        // フィルタリング条件の適用
        List<CodeValueDTO> result = codeValues.stream()
                .filter(codeValue -> filterCodeValue(codeValue, keyword, activeOnly))
                .sorted(Comparator.comparing(CodeValue::getSortOrder))
                .map(this::convertToDTO)
                .collect(Collectors.toList());
        
        return result;
    }
    
    @Override
    @Cacheable(value = "codeValueDetails", key = "#categoryId + ':' + #code")
    @Transactional(readOnly = true)
    public CodeValueDetailDTO findByCode(String categoryId, String code) {
        // キャッシュはSpring Cacheが管理
        
        // DBから取得
        CodeValueId id = new CodeValueId(categoryId, code);
        CodeValue codeValue = codeValueRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Code value not found with id: " + id));
        
        // カテゴリ情報の取得
        CodeCategory category = categoryRepository.findById(categoryId)
                .orElseThrow(() -> new EntityNotFoundException("Category not found with id: " + categoryId));
        
        // 子コードの取得
        List<String> childCodes = codeValueRepository.findByCategoryIdAndParentCode(categoryId, code).stream()
                .map(CodeValue::getCode)
                .collect(Collectors.toList());
        
        // 詳細DTOの作成
        CodeValueDetailDTO detailDTO = convertToDetailDTO(codeValue, category, childCodes);
        
        return detailDTO;
    }
    
    @Override
    @Cacheable(value = "codeValueTrees", key = "#categoryId + ':tree:' + #activeOnly")
    @Transactional(readOnly = true)
    public CodeValueTreeDTO getCodeValueTree(String categoryId, Boolean activeOnly) {
        // キャッシュはSpring Cacheが管理
        
        // カテゴリの存在確認
        if (!categoryRepository.existsById(categoryId)) {
            throw new EntityNotFoundException("Category not found with id: " + categoryId);
        }
        
        // カテゴリ内のすべてのコード値を取得
        List<CodeValue> allCodeValues = codeValueRepository.findByCategoryId(categoryId);
        
        // アクティブフラグでフィルタリング
        if (activeOnly) {
            allCodeValues = allCodeValues.stream()
                    .filter(CodeValue::isActive)
                    .collect(Collectors.toList());
        }
        
        // ツリー構造の構築
        CodeValueTreeDTO root = buildCodeValueTree(allCodeValues, null);
        
        return root;
    }
    
    @Override
    @Transactional(readOnly = true)
    public Map<String, String> getCodeNameMap(String categoryId, List<String> codes) {
        // カテゴリの存在確認
        if (!categoryRepository.existsById(categoryId)) {
            throw new EntityNotFoundException("Category not found with id: " + categoryId);
        }
        
        // 指定されたコード値のリストを取得
        List<CodeValue> codeValues = codeValueRepository.findByCategoryIdAndCodeIn(categoryId, codes);
        
        // コード→名称のマッピングを作成
        Map<String, String> nameMap = codeValues.stream()
                .collect(Collectors.toMap(
                        CodeValue::getCode,
                        CodeValue::getName,
                        (oldValue, newValue) -> oldValue // 重複時の解決（発生しないはずだが念のため）
                ));
        
        return nameMap;
    }
    
    @Override
    @CacheEvict(value = {"codeCategories", "codeValues", "codeValueDetails", "codeValueTrees"}, 
                allEntries = true, condition = "#categoryId == null")
    @Caching(evict = {
        @CacheEvict(value = "codeValues", keyGenerator = "categoryPrefixKeyGenerator", condition = "#categoryId != null"),
        @CacheEvict(value = "codeValueDetails", keyGenerator = "categoryPrefixKeyGenerator", condition = "#categoryId != null"),
        @CacheEvict(value = "codeValueTrees", keyGenerator = "categoryPrefixKeyGenerator", condition = "#categoryId != null")
    })
    public void refreshCache(String categoryId) {
        // 実装なし - アノテーションによりキャッシュの無効化が自動的に行われる
        // キー生成はカスタムKeyGeneratorを使用（別途定義）
    }
    
    // ヘルパーメソッド
    
    private boolean filterCodeValue(CodeValue codeValue, String keyword, Boolean activeOnly) {
        // アクティブフラグによるフィルタリング
        if (activeOnly && !codeValue.isActive()) {
            return false;
        }
        
        // キーワードによるフィルタリング
        if (keyword != null && !keyword.isEmpty()) {
            String lowerKeyword = keyword.toLowerCase();
            return codeValue.getCode().toLowerCase().contains(lowerKeyword) ||
                   codeValue.getName().toLowerCase().contains(lowerKeyword) ||
                   (codeValue.getDescription() != null && 
                    codeValue.getDescription().toLowerCase().contains(lowerKeyword));
        }
        
        return true;
    }
    
    private String generateCacheKey(String categoryId, String keyword, String parentCode, Boolean activeOnly) {
        StringBuilder keyBuilder = new StringBuilder(categoryId);
        
        if (keyword != null) {
            keyBuilder.append(":kw=").append(keyword);
        }
        
        if (parentCode != null) {
            keyBuilder.append(":parent=").append(parentCode);
        }
        
        keyBuilder.append(":active=").append(activeOnly);
        
        return keyBuilder.toString();
    }
    
    private CodeValueTreeDTO buildCodeValueTree(List<CodeValue> allCodeValues, String parentCode) {
        if (parentCode == null) {
            // ルートノードの作成（ダミー）
            CodeValueTreeDTO root = new CodeValueTreeDTO();
            root.setCode("ROOT");
            root.setName("ROOT");
            root.setActive(true);
            
            // 親コードがnullのノードを子として追加
            List<CodeValueTreeDTO> children = allCodeValues.stream()
                    .filter(cv -> cv.getParentCode() == null)
                    .sorted(Comparator.comparing(CodeValue::getSortOrder))
                    .map(cv -> buildCodeValueTree(allCodeValues, cv.getCode()))
                    .collect(Collectors.toList());
            
            root.setChildren(children);
            return root;
        } else {
            // 該当するコード値を取得
            CodeValue current = allCodeValues.stream()
                    .filter(cv -> cv.getCode().equals(parentCode))
                    .findFirst()
                    .orElse(null);
            
            if (current == null) {
                return null;
            }
            
            // ツリーノードの作成
            CodeValueTreeDTO node = new CodeValueTreeDTO();
            node.setCode(current.getCode());
            node.setName(current.getName());
            node.setActive(current.isActive());
            
            // 子ノードの追加
            List<CodeValueTreeDTO> children = allCodeValues.stream()
                    .filter(cv -> parentCode.equals(cv.getParentCode()))
                    .sorted(Comparator.comparing(CodeValue::getSortOrder))
                    .map(cv -> buildCodeValueTree(allCodeValues, cv.getCode()))
                    .filter(Objects::nonNull)
                    .collect(Collectors.toList());
            
            node.setChildren(children);
            return node;
        }
    }
    
    private CodeCategoryDTO convertToDTO(CodeCategory category) {
        CodeCategoryDTO dto = new CodeCategoryDTO();
        dto.setId(category.getId());
        dto.setName(category.getName());
        dto.setDescription(category.getDescription());
        dto.setSortOrder(category.getSortOrder());
        dto.setCreatedAt(category.getCreatedAt());
        dto.setUpdatedAt(category.getUpdatedAt());
        return dto;
    }
    
    private CodeValueDTO convertToDTO(CodeValue codeValue) {
        CodeValueDTO dto = new CodeValueDTO();
        dto.setCode(codeValue.getCode());
        dto.setName(codeValue.getName());
        dto.setDescription(codeValue.getDescription());
        dto.setSortOrder(codeValue.getSortOrder());
        dto.setActive(codeValue.isActive());
        dto.setAttributes(parseAttributes(codeValue.getAttributes()));
        dto.setParentCode(codeValue.getParentCode());
        return dto;
    }
    
    private CodeValueDetailDTO convertToDetailDTO(CodeValue codeValue, CodeCategory category, List<String> childCodes) {
        CodeValueDetailDTO dto = new CodeValueDetailDTO();
        
        // カテゴリ情報設定
        CodeCategoryDTO categoryDTO = convertToDTO(category);
        dto.setCategory(categoryDTO);
        
        // コード値情報設定
        dto.setCode(codeValue.getCode());
        dto.setName(codeValue.getName());
        dto.setDescription(codeValue.getDescription());
        dto.setSortOrder(codeValue.getSortOrder());
        dto.setActive(codeValue.isActive());
        dto.setAttributes(parseAttributes(codeValue.getAttributes()));
        dto.setParentCode(codeValue.getParentCode());
        dto.setChildCodes(childCodes);
        dto.setCreatedAt(codeValue.getCreatedAt());
        dto.setUpdatedAt(codeValue.getUpdatedAt());
        
        return dto;
    }
    
    @SuppressWarnings("unchecked")
    private Map<String, Object> parseAttributes(String attributesJson) {
        if (attributesJson == null || attributesJson.isEmpty()) {
            return Collections.emptyMap();
        }
        
        try {
            ObjectMapper objectMapper = new ObjectMapper();
            return objectMapper.readValue(attributesJson, Map.class);
        } catch (Exception e) {
            // JSON解析エラーの場合は空のマップを返す
            return Collections.emptyMap();
        }
    }
}
```

### 4.3 Repository 実装

```java
// Spring Data JPAリポジトリ - メソッド名による自動的なクエリ生成を活用
public interface CodeCategoryRepository extends JpaRepository<CodeCategory, String> {
    
    List<CodeCategory> findAllByOrderBySortOrder();
    
    // Spring Dataの規約に則ったメソッド名で追加
    Optional<CodeCategory> findByIdAndActiveTrue(String id);
    
    @Query(value = "SELECT c FROM CodeCategory c WHERE c.sortOrder <= :maxOrder")
    List<CodeCategory> findAllLightWeight(@Param("maxOrder") int maxOrder);
}

public interface CodeValueRepository extends JpaRepository<CodeValue, CodeValueId> {
    
    List<CodeValue> findByCategoryIdOrderBySortOrder(String categoryId);
    
    List<CodeValue> findByCategoryId(String categoryId);
    
    List<CodeValue> findByCategoryIdAndParentCodeIsNull(String categoryId);
    
    List<CodeValue> findByCategoryIdAndParentCode(String categoryId, String parentCode);
    
    List<CodeValue> findByCategoryIdAndActiveTrue(String categoryId);
    
    List<CodeValue> findByCategoryIdAndCodeIn(String categoryId, List<String> codes);
    
    // 多対多関連のSQLを最適化するためにIN句を使用
    @Query("SELECT cv FROM CodeValue cv WHERE cv.categoryId = :categoryId AND cv.code IN :codes AND cv.active = true")
    List<CodeValue> findActiveByCategoryIdAndCodeIn(@Param("categoryId") String categoryId, @Param("codes") List<String> codes);
    
    // ページングをサポート
    Page<CodeValue> findByCategoryId(String categoryId, Pageable pageable);
    
    long countByCategoryId(String categoryId);
    
    @Query("SELECT cv FROM CodeValue cv WHERE cv.categoryId = :categoryId AND " +
           "(LOWER(cv.code) LIKE LOWER(CONCAT('%', :keyword, '%')) OR " +
           "LOWER(cv.name) LIKE LOWER(CONCAT('%', :keyword, '%')) OR " +
           "LOWER(cv.description) LIKE LOWER(CONCAT('%', :keyword, '%')))")
    List<CodeValue> findByCategoryIdAndKeyword(@Param("categoryId") String categoryId, @Param("keyword") String keyword);
    
    // 特定のカテゴリのコード値をCSVエクスポート用に取得
    @Query(value = "SELECT new jp.co.example.sesapp.common.code.dto.CodeExportDTO(" +
           "cv.code, cv.name, cv.description, cv.sortOrder, cv.active, " +
           "cv.parentCode, cv.attributes) FROM CodeValue cv " +
           "WHERE cv.categoryId = :categoryId ORDER BY cv.sortOrder")
    List<CodeExportDTO> findForExport(@Param("categoryId") String categoryId);
    
    // 性能最適化クエリ - コード値の存在確認
    @Query("SELECT COUNT(cv) > 0 FROM CodeValue cv WHERE cv.categoryId = :categoryId AND cv.code = :code")
    boolean existsByCategoryIdAndCode(@Param("categoryId") String categoryId, @Param("code") String code);
}
```

## 5. キャッシュ戦略

コード値参照機能では、以下のキャッシュ戦略を採用します：

### 5.1 キャッシュレイヤー

- **カテゴリキャッシュ**: コードカテゴリ一覧をキャッシュ
- **コード値キャッシュ**: カテゴリごとのコード値一覧をキャッシュ
- **コード値詳細キャッシュ**: 個別コード値の詳細情報をキャッシュ
- **コード値ツリーキャッシュ**: 階層構造を持つコード値のツリー構造をキャッシュ

### 5.2 キャッシュキー設計

- カテゴリキャッシュ: `all-categories`
- コード値キャッシュ: `{categoryId}[:kw={keyword}][:parent={parentCode}][:active={activeOnly}]`
- コード値詳細キャッシュ: `{categoryId}:{code}`
- コード値ツリーキャッシュ: `{categoryId}:tree:{activeOnly}`

### 5.3 キャッシュ無効化戦略

- コード値更新時：該当するカテゴリのコード値キャッシュを無効化
- コードカテゴリ更新時：カテゴリキャッシュを無効化
- 階層構造変更時：該当するカテゴリのツリーキャッシュを無効化
- 定期的なキャッシュ更新：TTL（Time To Live）設定によるキャッシュの自動更新

### 5.4 キャッシュ実装方式

```java
@Configuration
@EnableCaching
public class CodeCacheConfig {

    @Bean
    public CacheManager codeCacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        
        // デフォルトのキャッシュ設定
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .expireAfterWrite(60, TimeUnit.MINUTES)
                .maximumSize(1000));
        
        // カテゴリキャッシュ設定
        Cache<Object, Object> categoryCache = Caffeine.newBuilder()
                .expireAfterWrite(60, TimeUnit.MINUTES)
                .recordStats() // 統計情報を記録
                .build();
        
        // コード値キャッシュ設定
        Cache<Object, Object> codeValueCache = Caffeine.newBuilder()
                .expireAfterWrite(30, TimeUnit.MINUTES)
                .maximumSize(5000)
                .recordStats() // 統計情報を記録
                .build();
        
        // コード値詳細キャッシュ設定
        Cache<Object, Object> codeDetailCache = Caffeine.newBuilder()
                .expireAfterWrite(30, TimeUnit.MINUTES)
                .maximumSize(2000)
                .recordStats() // 統計情報を記録
                .build();
        
        // コード値ツリーキャッシュ設定
        Cache<Object, Object> codeTreeCache = Caffeine.newBuilder()
                .expireAfterWrite(30, TimeUnit.MINUTES)
                .recordStats() // 統計情報を記録
                .build();
        
        // Spring Cacheの命名規則に合わせたキャッシュ名を使用
        cacheManager.registerCustomCache("codeCategories", categoryCache);
        cacheManager.registerCustomCache("codeValues", codeValueCache);
        cacheManager.registerCustomCache("codeValueDetails", codeDetailCache);
        cacheManager.registerCustomCache("codeValueTrees", codeTreeCache);
        
        return cacheManager;
    }
    
    /**
     * カテゴリIDプレフィックスに基づくキーを生成するためのカスタムKeyGenerator
     */
    @Bean
    public KeyGenerator categoryPrefixKeyGenerator() {
        return (target, method, params) -> {
            // パラメータからcategoryIdを取得し、プレフィックスキーを生成
            if (params.length > 0 && params[0] instanceof String) {
                String categoryId = (String) params[0];
                return categoryId + "*";
            }
            return "defaultKey";
        };
    }
    
    /**
     * キャッシュ統計情報をPrometheusメトリクスにエクスポートする設定
     */
    @Bean
    @ConditionalOnClass(name = "io.micrometer.core.instrument.MeterRegistry")
    public CaffeineCacheMetricsConfigurer cacheMetricsConfigurer(MeterRegistry registry) {
        return (cacheName, cache) -> {
            // キャッシュ統計情報をPrometheusメトリクスとして登録
            CaffeineCacheMetrics.monitor(registry, cache, cacheName);
        };
    }
}
```

## 6. 例外処理

コード値参照機能では、以下の例外処理を実装します：

### 6.1 例外クラス

```java
// カテゴリまたはコード値が存在しない場合の例外
public class EntityNotFoundException extends RuntimeException {
    public EntityNotFoundException(String message) {
        super(message);
    }
}

// キャッシュ操作に関する例外
public class CacheOperationException extends RuntimeException {
    public CacheOperationException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

### 6.2 例外ハンドリング

```java
@RestControllerAdvice
public class CodeExceptionHandler {
    
    private static final Logger log = LoggerFactory.getLogger(CodeExceptionHandler.class);
    
    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleEntityNotFoundException(EntityNotFoundException ex) {
        ErrorResponse error = new ErrorResponse("NOT_FOUND", ex.getMessage());
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException ex) {
        // Bean Validationの例外をハンドリング
        List<String> errors = ex.getBindingResult().getFieldErrors().stream()
                .map(fieldError -> fieldError.getField() + ": " + fieldError.getDefaultMessage())
                .collect(Collectors.toList());
                
        ErrorResponse error = new ErrorResponse("VALIDATION_ERROR", 
                "入力値検証に失敗しました", errors);
                
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }
    
    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity<ErrorResponse> handleConstraintViolation(ConstraintViolationException ex) {
        // パス変数や単一パラメータのバリデーションエラーをハンドリング
        List<String> errors = ex.getConstraintViolations().stream()
                .map(violation -> violation.getPropertyPath() + ": " + violation.getMessage())
                .collect(Collectors.toList());
                
        ErrorResponse error = new ErrorResponse("VALIDATION_ERROR", 
                "入力値検証に失敗しました", errors);
                
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }
    
    @ExceptionHandler(CacheException.class)
    public ResponseEntity<ErrorResponse> handleCacheException(CacheException ex) {
        // Spring Cacheフレームワークの例外をハンドリング
        log.error("キャッシュ操作エラー", ex);
        ErrorResponse error = new ErrorResponse("CACHE_ERROR", "キャッシュ操作中にエラーが発生しました");
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        // 予期しない例外をログに記録
        log.error("予期しないエラー", ex);
        ErrorResponse error = new ErrorResponse("SERVER_ERROR", "サーバー内部エラーが発生しました");
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}

/**
 * 標準エラーレスポンスクラス
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse {
    private String code;
    private String message;
    private List<String> details;
    private Date timestamp;

    public ErrorResponse(String code, String message) {
        this.code = code;
        this.message = message;
        this.timestamp = new Date();
    }

    public ErrorResponse(String code, String message, List<String> details) {
        this(code, message);
        this.details = details;
    }

    // Getters, Setters
}
```

## 7. パフォーマンス最適化

コード値参照機能のパフォーマンスを最適化するために、以下の施策を実施します：

### 7.1 N+1問題の回避

- コード値一覧取得時に必要な関連データを一括で取得
- バッチ処理によるコード名称一括変換機能の提供

### 7.2 クエリ最適化

- カテゴリIDとコード値の複合インデックス作成
- コード名や説明の部分文字列検索用のインデックス作成
- 親子関係のクエリ用のインデックス作成

### 7.3 大量データ対応

- ページング機能の実装（大量データの場合）
- 条件指定による絞り込み検索の推奨
- 結果セットの上限設定

### 7.4 キャッシュチューニング

- 利用頻度の高いカテゴリのプリロード
- カテゴリごとのキャッシュTTL調整
- キャッシュ使用状況のモニタリング

## 8. テスト方針

### 8.1 単体テスト

- Springのテストサポート機能を活用したUnit/Mockテスト
  ```java
  @SpringBootTest
  @ExtendWith(MockitoExtension.class)
  class CodeServiceTest {
    
      @MockBean
      private CodeCategoryRepository categoryRepository;
      
      @MockBean
      private CodeValueRepository codeValueRepository;
      
      @Autowired
      private CodeService codeService;
      
      @Test
      void findAllCategories_ShouldReturnCachedResult_WhenCalledMultipleTimes() {
          // モックデータ設定
          when(categoryRepository.findAllByOrderBySortOrder()).thenReturn(mockCategories());
          
          // 1回目の呼び出し
          List<CodeCategoryDTO> result1 = codeService.findAllCategories();
          
          // 2回目の呼び出し
          List<CodeCategoryDTO> result2 = codeService.findAllCategories();
          
          // @Cacheableが機能していることの検証 - リポジトリは1回だけ呼ばれる
          verify(categoryRepository, times(1)).findAllByOrderBySortOrder();
          
          // 結果の検証
          assertEquals(2, result1.size());
          assertEquals(result1, result2);
      }
  }
  ```

### 8.2 統合テスト

- Spring Testによるサービス層のPseud-Integration Test
  ```java
  @SpringBootTest
  @AutoConfigureTestDatabase
  class CodeServiceIntegrationTest {
      
      @Autowired
      private CodeService codeService;
      
      @Autowired
      private CodeCategoryRepository categoryRepository;
      
      @Autowired
      private CodeValueRepository codeValueRepository;
      
      @BeforeEach
      void setup() {
          // テストデータのセットアップ
      }
      
      @Test
      void findByCategory_ShouldReturnFilteredResults() {
          // テスト実行
          List<CodeValueDTO> results = codeService.findByCategory("test_category", "keyword", null, true);
          
          // 検証
          assertThat(results).isNotEmpty();
          assertThat(results).allMatch(dto -> 
              dto.getName().contains("keyword") || 
              dto.getCode().contains("keyword") || 
              (dto.getDescription() != null && dto.getDescription().contains("keyword")));
      }
  }
  ```

### 8.3 コントローラーテスト

- Spring MVCテストによるREST APIテスト
  ```java
  @WebMvcTest(CodeController.class)
  class CodeControllerTest {
      
      @Autowired
      private MockMvc mockMvc;
      
      @MockBean
      private CodeService codeService;
      
      @Test
      void getCategories_ShouldReturnOk() throws Exception {
          // モックデータ設定
          when(codeService.findAllCategories()).thenReturn(Collections.emptyList());
          
          // APIテスト実行
          mockMvc.perform(get("/api/v1/common/codes"))
              .andExpect(status().isOk())
              .andExpect(content().contentType(MediaType.APPLICATION_JSON))
              .andExpect(jsonPath("$", isA(JSONArray.class)));
      }
      
      @Test
      void getCodeValues_WithInvalidCategory_ShouldReturnBadRequest() throws Exception {
          // 無効なカテゴリID（バリデーションエラー）でのテスト
          mockMvc.perform(get("/api/v1/common/codes/Invalid-ID")
              .param("activeOnly", "true"))
              .andExpect(status().isBadRequest())
              .andExpect(jsonPath("$.code", is("VALIDATION_ERROR")));
      }
  }
  ```

### 8.4 キャッシュテスト

- キャッシュ動作を検証するインテグレーションテスト
  ```java
  @TestConfiguration
  static class CacheTestConfig {
      @Bean
      public CacheManager testCacheManager() {
          return new ConcurrentMapCacheManager("codeCategories", "codeValues", "codeValueDetails", "codeValueTrees");
      }
  }
  
  @SpringBootTest
  @Import(CacheTestConfig.class)
  class CodeCacheTest {
      
      @Autowired
      private CodeService codeService;
      
      @Autowired
      private CacheManager cacheManager;
      
      @Test
      void cacheEvict_ShouldClearCacheEntries() {
          // キャッシュにデータを投入
          codeService.findAllCategories();
          
          // キャッシュに値が存在することを確認
          Cache cache = cacheManager.getCache("codeCategories");
          assertNotNull(cache.get("all"));
          
          // キャッシュをクリア
          codeService.refreshCache(null);
          
          // キャッシュがクリアされたことを確認
          assertNull(cache.get("all"));
      }
  }
  ```

### 8.5 性能テスト

- JMHベンチマークによるパフォーマンステスト
  ```java
  @State(Scope.Thread)
  public class CodeServiceBenchmark {
      
      private ApplicationContext context;
      private CodeService codeService;
      
      @Setup
      public void setup() {
          context = new AnnotationConfigApplicationContext(TestConfig.class);
          codeService = context.getBean(CodeService.class);
      }
      
      @Benchmark
      @BenchmarkMode(Mode.AverageTime)
      @OutputTimeUnit(TimeUnit.MICROSECONDS)
      public List<CodeCategoryDTO> benchmarkFindAllCategories() {
          return codeService.findAllCategories();
      }
      
      // その他ベンチマークメソッド
  }
  ```