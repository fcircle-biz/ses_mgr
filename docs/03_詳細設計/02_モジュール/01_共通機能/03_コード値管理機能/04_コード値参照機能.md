# コード値管理機能 - コード値参照機能

## 1. 機能概要

コード値参照機能は、SES業務システム全体で使用されるコード値（マスタデータ）を効率的に参照するための機能を提供します。
この機能は、各種選択肢やマスタデータ表示のための標準的な方法として、システム全体のほぼすべてのモジュールで利用されます。
参照性能を最適化するためのキャッシュ機構も備えています。

## 2. 主要コンポーネント構成

コード値参照機能は以下のコンポーネントで構成されます：

### 2.1 コンポーネント構成図

```
                    ┌─────────────────┐
                    │  CodeController │
                    └────────┬────────┘
                             │
                             ▼
┌─────────────────┐   ┌─────────────────┐   ┌──────────────────┐
│  CacheService   │◄──┤   CodeService   │──►│  CodeRepository  │
└─────────────────┘   └─────────────────┘   └──────────────────┘
```

### 2.2 コンポーネント説明

- **CodeController**: コード値参照のRESTful APIエンドポイントを提供
- **CodeService**: コード値参照のビジネスロジックを実装
- **CodeRepository**: コード値データのデータアクセス層
- **CacheService**: コード値のキャッシュ管理を担当

## 3. 処理フロー

### 3.1 コード値カテゴリ一覧取得フロー

```
1. クライアントがコード値カテゴリ一覧取得APIを呼び出し
2. CodeController.getCategories()メソッドが実行される
3. CodeService.findAllCategories()メソッドが呼び出される
   3.1. キャッシュからカテゴリ一覧を取得試行
   3.2. キャッシュに存在しない場合はCodeRepositoryから取得
   3.3. 各カテゴリのコード値件数を計算
   3.4. 結果をキャッシュに格納（存在しなかった場合）
4. カテゴリ一覧DTOをクライアントに返却
```

### 3.2 カテゴリ別コード値一覧取得フロー

```
1. クライアントがカテゴリ別コード値一覧取得APIを呼び出し
2. CodeController.getCodeValues()メソッドが実行される
3. CodeService.findByCategory()メソッドが呼び出される
   3.1. カテゴリの存在確認
   3.2. キャッシュからコード値一覧を取得試行
   3.3. キャッシュに存在しない場合はCodeRepositoryから取得
   3.4. フィルタリング条件（キーワード、親コード、有効フラグ）による絞り込み
   3.5. ソート順でソート
   3.6. 結果をキャッシュに格納（存在しなかった場合）
4. コード値一覧DTOをクライアントに返却
```

### 3.3 コード値詳細取得フロー

```
1. クライアントがコード値詳細取得APIを呼び出し
2. CodeController.getCodeValue()メソッドが実行される
3. CodeService.findByCode()メソッドが呼び出される
   3.1. キャッシュからコード値詳細を取得試行
   3.2. キャッシュに存在しない場合はCodeRepositoryから取得
   3.3. コード値が存在しない場合はEntityNotFoundExceptionをスロー
   3.4. 階層構造の場合は親コードと子コードの情報も取得
   3.5. 結果をキャッシュに格納（存在しなかった場合）
4. コード値詳細DTOをクライアントに返却
```

### 3.4 階層構造コード値取得フロー

```
1. クライアントが階層構造コード値取得APIを呼び出し
2. CodeController.getCodeValueTree()メソッドが実行される
3. CodeService.getCodeValueTree()メソッドが呼び出される
   3.1. カテゴリの存在確認
   3.2. キャッシュからコード値ツリーを取得試行
   3.3. キャッシュに存在しない場合はCodeRepositoryから取得
   3.4. 親子関係に基づいてツリー構造を構築
   3.5. 有効フラグによるフィルタリング（要求された場合）
   3.6. 結果をキャッシュに格納（存在しなかった場合）
4. コード値ツリーDTOをクライアントに返却
```

### 3.5 コード名称マッピング取得フロー

```
1. クライアントがコード名称マッピング取得APIを呼び出し
2. CodeController.getCodeNameMap()メソッドが実行される
3. CodeService.getCodeNameMap()メソッドが呼び出される
   3.1. カテゴリの存在確認
   3.2. 指定されたコードリストの存在確認
   3.3. コードと名称のマッピングを作成
4. コード-名称マッピングをクライアントに返却
```

### 3.6 キャッシュ更新フロー

```
1. コード値データの変更を検知（AdminCodeServiceから通知）
2. CodeService.refreshCache()メソッドが呼び出される
   3.1. 更新対象のカテゴリを特定
   3.2. CacheService経由で該当カテゴリのキャッシュをクリア
   3.3. 必要に応じてキャッシュを再ロード
```

## 4. 実装詳細

### 4.1 CodeController 実装

```java
@RestController
@RequestMapping("/api/v1/common/codes")
public class CodeController {

    private final CodeService codeService;
    
    @Autowired
    public CodeController(CodeService codeService) {
        this.codeService = codeService;
    }
    
    @GetMapping
    public ResponseEntity<List<CodeCategoryDTO>> getCategories() {
        List<CodeCategoryDTO> categories = codeService.findAllCategories();
        return ResponseEntity.ok(categories);
    }
    
    @GetMapping("/{categoryId}")
    public ResponseEntity<List<CodeValueDTO>> getCodeValues(
            @PathVariable String categoryId,
            @RequestParam(required = false) String keyword,
            @RequestParam(required = false) String parent,
            @RequestParam(required = false, defaultValue = "true") Boolean activeOnly) {
        
        try {
            List<CodeValueDTO> codeValues = codeService.findByCategory(categoryId, keyword, parent, activeOnly);
            return ResponseEntity.ok(codeValues);
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }
    
    @GetMapping("/{categoryId}/{code}")
    public ResponseEntity<CodeValueDetailDTO> getCodeValue(@PathVariable String categoryId, @PathVariable String code) {
        try {
            CodeValueDetailDTO codeValue = codeService.findByCode(categoryId, code);
            return ResponseEntity.ok(codeValue);
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }
    
    @GetMapping("/{categoryId}/tree")
    public ResponseEntity<CodeValueTreeDTO> getCodeValueTree(
            @PathVariable String categoryId,
            @RequestParam(required = false, defaultValue = "true") Boolean activeOnly) {
        
        try {
            CodeValueTreeDTO tree = codeService.getCodeValueTree(categoryId, activeOnly);
            return ResponseEntity.ok(tree);
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }
    
    @PostMapping("/{categoryId}/names")
    public ResponseEntity<Map<String, String>> getCodeNameMap(
            @PathVariable String categoryId,
            @RequestBody List<String> codes) {
        
        try {
            Map<String, String> nameMap = codeService.getCodeNameMap(categoryId, codes);
            return ResponseEntity.ok(nameMap);
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }
}
```

### 4.2 CodeServiceImpl 実装

```java
@Service
public class CodeServiceImpl implements CodeService {

    private static final String CATEGORY_CACHE_NAME = "code-categories";
    private static final String CATEGORY_CACHE_KEY = "all-categories";
    private static final String CODE_VALUES_CACHE_NAME = "code-values";
    private static final String CODE_TREE_CACHE_NAME = "code-trees";
    
    private final CodeCategoryRepository categoryRepository;
    private final CodeValueRepository codeValueRepository;
    private final CacheService cacheService;
    
    @Autowired
    public CodeServiceImpl(
            CodeCategoryRepository categoryRepository,
            CodeValueRepository codeValueRepository,
            CacheService cacheService) {
        this.categoryRepository = categoryRepository;
        this.codeValueRepository = codeValueRepository;
        this.cacheService = cacheService;
    }
    
    @Override
    public List<CodeCategoryDTO> findAllCategories() {
        // キャッシュから取得試行
        List<CodeCategoryDTO> cachedCategories = cacheService.get(CATEGORY_CACHE_NAME, CATEGORY_CACHE_KEY, List.class);
        
        if (cachedCategories != null) {
            return cachedCategories;
        }
        
        // キャッシュにない場合はDBから取得
        List<CodeCategory> categories = categoryRepository.findAllByOrderBySortOrder();
        List<CodeCategoryDTO> result = categories.stream()
                .map(category -> {
                    CodeCategoryDTO dto = convertToDTO(category);
                    // コード値件数を設定
                    long count = codeValueRepository.countByCategoryId(category.getId());
                    dto.setCodeCount((int) count);
                    return dto;
                })
                .collect(Collectors.toList());
        
        // キャッシュに格納
        cacheService.put(CATEGORY_CACHE_NAME, CATEGORY_CACHE_KEY, result);
        
        return result;
    }
    
    @Override
    public List<CodeValueDTO> findByCategory(String categoryId, String keyword, String parentCode, Boolean activeOnly) {
        // カテゴリの存在確認
        if (!categoryRepository.existsById(categoryId)) {
            throw new EntityNotFoundException("Category not found with id: " + categoryId);
        }
        
        // キャッシュからの取得を試行
        String cacheKey = generateCacheKey(categoryId, keyword, parentCode, activeOnly);
        List<CodeValueDTO> cachedValues = cacheService.get(CODE_VALUES_CACHE_NAME, cacheKey, List.class);
        
        if (cachedValues != null) {
            return cachedValues;
        }
        
        // キャッシュにない場合はDBから取得
        List<CodeValue> codeValues;
        
        if (parentCode != null) {
            // 親コードが指定されている場合は子コードのみ取得
            codeValues = codeValueRepository.findByCategoryIdAndParentCode(categoryId, parentCode);
        } else {
            // 親コードが指定されていない場合はカテゴリ内の全コードまたはルートレベルのコードを取得
            codeValues = parentCode == null ? 
                    codeValueRepository.findByCategoryId(categoryId) : 
                    codeValueRepository.findByCategoryIdAndParentCodeIsNull(categoryId);
        }
        
        // フィルタリング条件の適用
        List<CodeValueDTO> result = codeValues.stream()
                .filter(codeValue -> filterCodeValue(codeValue, keyword, activeOnly))
                .sorted(Comparator.comparing(CodeValue::getSortOrder))
                .map(this::convertToDTO)
                .collect(Collectors.toList());
        
        // キャッシュに格納
        cacheService.put(CODE_VALUES_CACHE_NAME, cacheKey, result);
        
        return result;
    }
    
    @Override
    public CodeValueDetailDTO findByCode(String categoryId, String code) {
        // キャッシュからの取得を試行
        String cacheKey = categoryId + ":" + code;
        CodeValueDetailDTO cachedValue = cacheService.get(CODE_VALUES_CACHE_NAME, cacheKey, CodeValueDetailDTO.class);
        
        if (cachedValue != null) {
            return cachedValue;
        }
        
        // キャッシュにない場合はDBから取得
        CodeValueId id = new CodeValueId(categoryId, code);
        CodeValue codeValue = codeValueRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Code value not found with id: " + id));
        
        // カテゴリ情報の取得
        CodeCategory category = categoryRepository.findById(categoryId)
                .orElseThrow(() -> new EntityNotFoundException("Category not found with id: " + categoryId));
        
        // 子コードの取得
        List<String> childCodes = codeValueRepository.findByCategoryIdAndParentCode(categoryId, code).stream()
                .map(CodeValue::getCode)
                .collect(Collectors.toList());
        
        // 詳細DTOの作成
        CodeValueDetailDTO detailDTO = convertToDetailDTO(codeValue, category, childCodes);
        
        // キャッシュに格納
        cacheService.put(CODE_VALUES_CACHE_NAME, cacheKey, detailDTO);
        
        return detailDTO;
    }
    
    @Override
    public CodeValueTreeDTO getCodeValueTree(String categoryId, Boolean activeOnly) {
        // キャッシュからの取得を試行
        String cacheKey = categoryId + ":tree:" + activeOnly;
        CodeValueTreeDTO cachedTree = cacheService.get(CODE_TREE_CACHE_NAME, cacheKey, CodeValueTreeDTO.class);
        
        if (cachedTree != null) {
            return cachedTree;
        }
        
        // カテゴリの存在確認
        if (!categoryRepository.existsById(categoryId)) {
            throw new EntityNotFoundException("Category not found with id: " + categoryId);
        }
        
        // カテゴリ内のすべてのコード値を取得
        List<CodeValue> allCodeValues = codeValueRepository.findByCategoryId(categoryId);
        
        // アクティブフラグでフィルタリング
        if (activeOnly) {
            allCodeValues = allCodeValues.stream()
                    .filter(CodeValue::isActive)
                    .collect(Collectors.toList());
        }
        
        // ツリー構造の構築
        CodeValueTreeDTO root = buildCodeValueTree(allCodeValues, null);
        
        // キャッシュに格納
        cacheService.put(CODE_TREE_CACHE_NAME, cacheKey, root);
        
        return root;
    }
    
    @Override
    public Map<String, String> getCodeNameMap(String categoryId, List<String> codes) {
        // カテゴリの存在確認
        if (!categoryRepository.existsById(categoryId)) {
            throw new EntityNotFoundException("Category not found with id: " + categoryId);
        }
        
        // 指定されたコード値のリストを取得
        List<CodeValue> codeValues = codeValueRepository.findByCategoryIdAndCodeIn(categoryId, codes);
        
        // コード→名称のマッピングを作成
        Map<String, String> nameMap = codeValues.stream()
                .collect(Collectors.toMap(
                        CodeValue::getCode,
                        CodeValue::getName
                ));
        
        return nameMap;
    }
    
    @Override
    public void refreshCache(String categoryId) {
        if (categoryId == null) {
            // 全カテゴリのキャッシュをクリア
            cacheService.clear(CATEGORY_CACHE_NAME);
            cacheService.clear(CODE_VALUES_CACHE_NAME);
            cacheService.clear(CODE_TREE_CACHE_NAME);
        } else {
            // 特定カテゴリのキャッシュをクリア
            String keyPrefix = categoryId + ":";
            
            // TODO: CacheServiceに前方一致削除メソッドがあれば利用
            // キャッシュ実装によっては全削除後に必要なものを再キャッシュする方法もある
        }
    }
    
    // ヘルパーメソッド
    
    private boolean filterCodeValue(CodeValue codeValue, String keyword, Boolean activeOnly) {
        // アクティブフラグによるフィルタリング
        if (activeOnly && !codeValue.isActive()) {
            return false;
        }
        
        // キーワードによるフィルタリング
        if (keyword != null && !keyword.isEmpty()) {
            String lowerKeyword = keyword.toLowerCase();
            return codeValue.getCode().toLowerCase().contains(lowerKeyword) ||
                   codeValue.getName().toLowerCase().contains(lowerKeyword) ||
                   (codeValue.getDescription() != null && 
                    codeValue.getDescription().toLowerCase().contains(lowerKeyword));
        }
        
        return true;
    }
    
    private String generateCacheKey(String categoryId, String keyword, String parentCode, Boolean activeOnly) {
        StringBuilder keyBuilder = new StringBuilder(categoryId);
        
        if (keyword != null) {
            keyBuilder.append(":kw=").append(keyword);
        }
        
        if (parentCode != null) {
            keyBuilder.append(":parent=").append(parentCode);
        }
        
        keyBuilder.append(":active=").append(activeOnly);
        
        return keyBuilder.toString();
    }
    
    private CodeValueTreeDTO buildCodeValueTree(List<CodeValue> allCodeValues, String parentCode) {
        if (parentCode == null) {
            // ルートノードの作成（ダミー）
            CodeValueTreeDTO root = new CodeValueTreeDTO();
            root.setCode("ROOT");
            root.setName("ROOT");
            root.setActive(true);
            
            // 親コードがnullのノードを子として追加
            List<CodeValueTreeDTO> children = allCodeValues.stream()
                    .filter(cv -> cv.getParentCode() == null)
                    .sorted(Comparator.comparing(CodeValue::getSortOrder))
                    .map(cv -> buildCodeValueTree(allCodeValues, cv.getCode()))
                    .collect(Collectors.toList());
            
            root.setChildren(children);
            return root;
        } else {
            // 該当するコード値を取得
            CodeValue current = allCodeValues.stream()
                    .filter(cv -> cv.getCode().equals(parentCode))
                    .findFirst()
                    .orElse(null);
            
            if (current == null) {
                return null;
            }
            
            // ツリーノードの作成
            CodeValueTreeDTO node = new CodeValueTreeDTO();
            node.setCode(current.getCode());
            node.setName(current.getName());
            node.setActive(current.isActive());
            
            // 子ノードの追加
            List<CodeValueTreeDTO> children = allCodeValues.stream()
                    .filter(cv -> parentCode.equals(cv.getParentCode()))
                    .sorted(Comparator.comparing(CodeValue::getSortOrder))
                    .map(cv -> buildCodeValueTree(allCodeValues, cv.getCode()))
                    .filter(Objects::nonNull)
                    .collect(Collectors.toList());
            
            node.setChildren(children);
            return node;
        }
    }
    
    private CodeCategoryDTO convertToDTO(CodeCategory category) {
        CodeCategoryDTO dto = new CodeCategoryDTO();
        dto.setId(category.getId());
        dto.setName(category.getName());
        dto.setDescription(category.getDescription());
        dto.setSortOrder(category.getSortOrder());
        dto.setCreatedAt(category.getCreatedAt());
        dto.setUpdatedAt(category.getUpdatedAt());
        return dto;
    }
    
    private CodeValueDTO convertToDTO(CodeValue codeValue) {
        CodeValueDTO dto = new CodeValueDTO();
        dto.setCode(codeValue.getCode());
        dto.setName(codeValue.getName());
        dto.setDescription(codeValue.getDescription());
        dto.setSortOrder(codeValue.getSortOrder());
        dto.setActive(codeValue.isActive());
        dto.setAttributes(parseAttributes(codeValue.getAttributes()));
        dto.setParentCode(codeValue.getParentCode());
        return dto;
    }
    
    private CodeValueDetailDTO convertToDetailDTO(CodeValue codeValue, CodeCategory category, List<String> childCodes) {
        CodeValueDetailDTO dto = new CodeValueDetailDTO();
        
        // カテゴリ情報設定
        CodeCategoryDTO categoryDTO = convertToDTO(category);
        dto.setCategory(categoryDTO);
        
        // コード値情報設定
        dto.setCode(codeValue.getCode());
        dto.setName(codeValue.getName());
        dto.setDescription(codeValue.getDescription());
        dto.setSortOrder(codeValue.getSortOrder());
        dto.setActive(codeValue.isActive());
        dto.setAttributes(parseAttributes(codeValue.getAttributes()));
        dto.setParentCode(codeValue.getParentCode());
        dto.setChildCodes(childCodes);
        dto.setCreatedAt(codeValue.getCreatedAt());
        dto.setUpdatedAt(codeValue.getUpdatedAt());
        
        return dto;
    }
    
    @SuppressWarnings("unchecked")
    private Map<String, Object> parseAttributes(String attributesJson) {
        if (attributesJson == null || attributesJson.isEmpty()) {
            return Collections.emptyMap();
        }
        
        try {
            ObjectMapper objectMapper = new ObjectMapper();
            return objectMapper.readValue(attributesJson, Map.class);
        } catch (Exception e) {
            // JSON解析エラーの場合は空のマップを返す
            return Collections.emptyMap();
        }
    }
}
```

### 4.3 Repository 実装

```java
public interface CodeCategoryRepository extends JpaRepository<CodeCategory, String> {
    
    List<CodeCategory> findAllByOrderBySortOrder();
    
}

public interface CodeValueRepository extends JpaRepository<CodeValue, CodeValueId> {
    
    List<CodeValue> findByCategoryIdOrderBySortOrder(String categoryId);
    
    List<CodeValue> findByCategoryId(String categoryId);
    
    List<CodeValue> findByCategoryIdAndParentCodeIsNull(String categoryId);
    
    List<CodeValue> findByCategoryIdAndParentCode(String categoryId, String parentCode);
    
    List<CodeValue> findByCategoryIdAndCodeIn(String categoryId, List<String> codes);
    
    long countByCategoryId(String categoryId);
    
    @Query("SELECT cv FROM CodeValue cv WHERE cv.categoryId = :categoryId AND " +
           "(LOWER(cv.code) LIKE LOWER(CONCAT('%', :keyword, '%')) OR " +
           "LOWER(cv.name) LIKE LOWER(CONCAT('%', :keyword, '%')) OR " +
           "LOWER(cv.description) LIKE LOWER(CONCAT('%', :keyword, '%')))")
    List<CodeValue> findByCategoryIdAndKeyword(String categoryId, String keyword);
}
```

## 5. キャッシュ戦略

コード値参照機能では、以下のキャッシュ戦略を採用します：

### 5.1 キャッシュレイヤー

- **カテゴリキャッシュ**: コードカテゴリ一覧をキャッシュ
- **コード値キャッシュ**: カテゴリごとのコード値一覧をキャッシュ
- **コード値詳細キャッシュ**: 個別コード値の詳細情報をキャッシュ
- **コード値ツリーキャッシュ**: 階層構造を持つコード値のツリー構造をキャッシュ

### 5.2 キャッシュキー設計

- カテゴリキャッシュ: `all-categories`
- コード値キャッシュ: `{categoryId}[:kw={keyword}][:parent={parentCode}][:active={activeOnly}]`
- コード値詳細キャッシュ: `{categoryId}:{code}`
- コード値ツリーキャッシュ: `{categoryId}:tree:{activeOnly}`

### 5.3 キャッシュ無効化戦略

- コード値更新時：該当するカテゴリのコード値キャッシュを無効化
- コードカテゴリ更新時：カテゴリキャッシュを無効化
- 階層構造変更時：該当するカテゴリのツリーキャッシュを無効化
- 定期的なキャッシュ更新：TTL（Time To Live）設定によるキャッシュの自動更新

### 5.4 キャッシュ実装方式

```java
@Configuration
@EnableCaching
public class CodeCacheConfig {

    @Bean
    public CacheManager codeCacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        
        // デフォルトのキャッシュ設定
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .expireAfterWrite(60, TimeUnit.MINUTES)
                .maximumSize(1000));
        
        // カテゴリキャッシュ設定
        Cache<Object, Object> categoryCache = Caffeine.newBuilder()
                .expireAfterWrite(60, TimeUnit.MINUTES)
                .build();
        
        // コード値キャッシュ設定
        Cache<Object, Object> codeValueCache = Caffeine.newBuilder()
                .expireAfterWrite(30, TimeUnit.MINUTES)
                .maximumSize(5000)
                .build();
        
        // コード値ツリーキャッシュ設定
        Cache<Object, Object> codeTreeCache = Caffeine.newBuilder()
                .expireAfterWrite(30, TimeUnit.MINUTES)
                .build();
        
        cacheManager.registerCustomCache("code-categories", categoryCache);
        cacheManager.registerCustomCache("code-values", codeValueCache);
        cacheManager.registerCustomCache("code-trees", codeTreeCache);
        
        return cacheManager;
    }
}
```

## 6. 例外処理

コード値参照機能では、以下の例外処理を実装します：

### 6.1 例外クラス

```java
// カテゴリまたはコード値が存在しない場合の例外
public class EntityNotFoundException extends RuntimeException {
    public EntityNotFoundException(String message) {
        super(message);
    }
}

// キャッシュ操作に関する例外
public class CacheOperationException extends RuntimeException {
    public CacheOperationException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

### 6.2 例外ハンドリング

```java
@ControllerAdvice
public class CodeExceptionHandler {
    
    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleEntityNotFoundException(EntityNotFoundException ex) {
        ErrorResponse error = new ErrorResponse("NOT_FOUND", ex.getMessage());
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }
    
    @ExceptionHandler(CacheOperationException.class)
    public ResponseEntity<ErrorResponse> handleCacheOperationException(CacheOperationException ex) {
        ErrorResponse error = new ErrorResponse("CACHE_ERROR", "キャッシュ操作中にエラーが発生しました");
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        ErrorResponse error = new ErrorResponse("SERVER_ERROR", "サーバー内部エラーが発生しました");
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

## 7. パフォーマンス最適化

コード値参照機能のパフォーマンスを最適化するために、以下の施策を実施します：

### 7.1 N+1問題の回避

- コード値一覧取得時に必要な関連データを一括で取得
- バッチ処理によるコード名称一括変換機能の提供

### 7.2 クエリ最適化

- カテゴリIDとコード値の複合インデックス作成
- コード名や説明の部分文字列検索用のインデックス作成
- 親子関係のクエリ用のインデックス作成

### 7.3 大量データ対応

- ページング機能の実装（大量データの場合）
- 条件指定による絞り込み検索の推奨
- 結果セットの上限設定

### 7.4 キャッシュチューニング

- 利用頻度の高いカテゴリのプリロード
- カテゴリごとのキャッシュTTL調整
- キャッシュ使用状況のモニタリング

## 8. テスト方針

### 8.1 単体テスト

- CodeServiceの各メソッドのテスト
- キャッシュ動作の確認テスト
- フィルタリング処理のテスト
- 階層構造変換処理のテスト

### 8.2 統合テスト

- API呼び出しの結合テスト
- データベースとの連携テスト
- キャッシュマネージャーとの連携テスト

### 8.3 性能テスト

- 大量データでの参照性能テスト
- キャッシュ有効時と無効時の性能比較
- 同時アクセス時の挙動テスト