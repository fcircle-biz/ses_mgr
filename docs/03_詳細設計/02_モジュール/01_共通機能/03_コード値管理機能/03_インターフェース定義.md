# コード値管理機能 - インターフェース定義

## 1. インターフェース概要

コード値管理機能は、SES業務システム全体に対してコード値（マスタデータ）を提供するための標準的なインターフェースを定義します。本インターフェースは、参照機能と管理機能の2つの主要な責務に分かれています。Spring標準機能を最大限に活用し、統一的で効率的なAPIを提供します。

## 2. 提供インターフェース

### 2.1 CodeService

**目的**: コード値参照のための主要インターフェース。システム全体のあらゆるモジュールがコード値を参照するために使用します。

**責務**:
- コードカテゴリの取得
- コード値の検索・取得
- 階層構造化されたコード値の取得
- コード値名称マッピングの提供
- キャッシュ管理（Spring Cacheアノテーション活用）

#### インターフェース定義

```java
@Service
public interface CodeService {

    /**
     * システムで利用可能なすべてのコードカテゴリを取得する
     * @return コードカテゴリDTOのリスト
     */
    @Cacheable(value = "codeCategories", key = "'all'")
    List<CodeCategoryDTO> findAllCategories();
    
    /**
     * 指定されたカテゴリに属するコード値の一覧を取得する
     * @param categoryId カテゴリID
     * @param keyword 検索キーワード（任意）
     * @param parentCode 親コード（任意、階層構造の場合）
     * @param activeOnly 有効なコード値のみ取得するフラグ（デフォルトtrue）
     * @return コード値DTOのリスト
     * @throws EntityNotFoundException カテゴリが存在しない場合
     */
    @Cacheable(value = "codeValues", key = "{#categoryId, #keyword, #parentCode, #activeOnly}", 
               condition = "#keyword == null || #keyword.isEmpty()")
    List<CodeValueDTO> findByCategory(
            String categoryId, 
            @Nullable String keyword, 
            @Nullable String parentCode, 
            @Nullable Boolean activeOnly);
    
    /**
     * 指定されたカテゴリとコードの組み合わせによるコード値の詳細情報を取得する
     * @param categoryId カテゴリID
     * @param code コード値
     * @return コード値詳細DTO
     * @throws EntityNotFoundException コード値が存在しない場合
     */
    @Cacheable(value = "codeValueDetails", key = "{#categoryId, #code}")
    CodeValueDetailDTO findByCode(String categoryId, String code);
    
    /**
     * 階層構造を持つコード値の階層ツリーを取得する
     * @param categoryId カテゴリID
     * @param activeOnly 有効なコード値のみ取得するフラグ（デフォルトtrue）
     * @return 階層構造化されたコード値のツリー
     * @throws EntityNotFoundException カテゴリが存在しない場合
     */
    @Cacheable(value = "codeValueTrees", key = "{#categoryId, #activeOnly}")
    CodeValueTreeDTO getCodeValueTree(String categoryId, @Nullable Boolean activeOnly);
    
    /**
     * 指定されたカテゴリIDとコード値一覧から名称マッピングを取得する
     * @param categoryId カテゴリID
     * @param codes コード値のリスト
     * @return コード値と名称のマッピング
     * @throws EntityNotFoundException カテゴリが存在しない場合
     */
    Map<String, String> getCodeNameMap(String categoryId, List<String> codes);
    
    /**
     * コード値のキャッシュを更新する
     * @param categoryId カテゴリID（nullの場合は全カテゴリ）
     */
    void refreshCache(@Nullable String categoryId);
}
```

#### 実装サンプル

```java
@Service
@Slf4j
public class CodeServiceImpl implements CodeService {

    private final CodeCategoryRepository categoryRepository;
    private final CodeValueRepository codeValueRepository;
    
    public CodeServiceImpl(CodeCategoryRepository categoryRepository, 
                           CodeValueRepository codeValueRepository) {
        this.categoryRepository = categoryRepository;
        this.codeValueRepository = codeValueRepository;
    }
    
    @Override
    @Cacheable(value = "codeCategories", key = "'all'")
    public List<CodeCategoryDTO> findAllCategories() {
        log.debug("Fetching all code categories");
        List<CodeCategory> categories = categoryRepository.findAllByOrderBySortOrder();
        
        return categories.stream()
                .map(this::mapToCategoryDTO)
                .collect(Collectors.toList());
    }
    
    @Override
    @Cacheable(value = "codeValues", key = "{#categoryId, #keyword, #parentCode, #activeOnly}",
               condition = "#keyword == null || #keyword.isEmpty()")
    public List<CodeValueDTO> findByCategory(
            String categoryId, 
            @Nullable String keyword, 
            @Nullable String parentCode, 
            @Nullable Boolean activeOnly) {
        
        log.debug("Fetching code values for category={}, keyword={}, parentCode={}, activeOnly={}",
                categoryId, keyword, parentCode, activeOnly);
        
        // カテゴリの存在確認
        if (!categoryRepository.existsById(categoryId)) {
            throw new EntityNotFoundException("Category not found with id: " + categoryId);
        }
        
        List<CodeValue> codeValues;
        boolean onlyActive = activeOnly == null || activeOnly;
        
        // クエリ条件に基づいてデータを取得
        if (parentCode != null) {
            codeValues = codeValueRepository.findByCategoryIdAndParentCode(categoryId, parentCode);
        } else {
            codeValues = codeValueRepository.findByCategoryId(categoryId);
        }
        
        // フィルタリング
        Stream<CodeValue> filtered = codeValues.stream();
        
        if (onlyActive) {
            filtered = filtered.filter(CodeValue::isActive);
        }
        
        if (keyword != null && !keyword.isEmpty()) {
            String lowerKeyword = keyword.toLowerCase();
            filtered = filtered.filter(value -> 
                    value.getCode().toLowerCase().contains(lowerKeyword) ||
                    value.getName().toLowerCase().contains(lowerKeyword) ||
                    (value.getDescription() != null && 
                     value.getDescription().toLowerCase().contains(lowerKeyword)));
        }
        
        // 表示順でソート
        return filtered
                .sorted(Comparator.comparing(CodeValue::getSortOrder))
                .map(this::mapToCodeValueDTO)
                .collect(Collectors.toList());
    }
    
    // 他のメソッド実装...
    
    @Override
    @CacheEvict(value = {"codeCategories", "codeValues", "codeValueDetails", "codeValueTrees"}, 
                allEntries = true, condition = "#categoryId == null")
    @Caching(evict = {
            @CacheEvict(value = "codeValues", allEntries = true, 
                      condition = "#categoryId != null"),
            @CacheEvict(value = "codeValueDetails", allEntries = true, 
                      condition = "#categoryId != null"),
            @CacheEvict(value = "codeValueTrees", key = "{#categoryId, true}", 
                      condition = "#categoryId != null"),
            @CacheEvict(value = "codeValueTrees", key = "{#categoryId, false}", 
                      condition = "#categoryId != null")
    })
    public void refreshCache(@Nullable String categoryId) {
        log.info("Refreshing code value cache for categoryId={}", 
                 categoryId != null ? categoryId : "all");
        // キャッシュは自動的にクリアされるため、追加の処理は不要
    }
    
    // マッピングメソッド
    private CodeCategoryDTO mapToCategoryDTO(CodeCategory category) {
        CodeCategoryDTO dto = new CodeCategoryDTO();
        BeanUtils.copyProperties(category, dto);
        dto.setCodeCount((int) codeValueRepository.countByCategoryId(category.getId()));
        return dto;
    }
    
    private CodeValueDTO mapToCodeValueDTO(CodeValue codeValue) {
        CodeValueDTO dto = new CodeValueDTO();
        BeanUtils.copyProperties(codeValue, dto);
        dto.setActive(codeValue.isActive());
        dto.setAttributes(codeValue.getAttributesAsMap());
        return dto;
    }
}
```

### 2.2 AdminCodeService

**目的**: コード値管理のための管理用インターフェース。主にシステム管理機能から使用されます。

**責務**:
- コードカテゴリの作成・更新・削除
- コード値の作成・更新・削除
- コード値の有効/無効管理
- コード値の一括インポート・エクスポート
- 変更履歴の取得

#### インターフェース定義

```java
@Service
public interface AdminCodeService {

    /**
     * 新しいコードカテゴリを作成する
     * @param categoryDTO 作成用DTO
     * @return 作成されたコードカテゴリDTO
     * @throws DuplicateEntityException カテゴリIDが既に存在する場合
     * @throws ValidationException バリデーションエラーの場合
     */
    CodeCategoryDTO createCategory(@Valid CodeCategoryCreateDTO categoryDTO);
    
    /**
     * コードカテゴリを更新する
     * @param id カテゴリID
     * @param categoryDTO 更新用DTO
     * @return 更新されたコードカテゴリDTO
     * @throws EntityNotFoundException カテゴリが存在しない場合
     * @throws ValidationException バリデーションエラーの場合
     */
    CodeCategoryDTO updateCategory(String id, @Valid CodeCategoryUpdateDTO categoryDTO);
    
    /**
     * コードカテゴリを削除する
     * @param id カテゴリID
     * @throws EntityNotFoundException カテゴリが存在しない場合
     * @throws BusinessRuleException 削除できないカテゴリの場合またはコード値が存在する場合
     */
    void deleteCategory(String id);
    
    /**
     * 新しいコード値を作成する
     * @param categoryId カテゴリID
     * @param codeValueDTO 作成用DTO
     * @return 作成されたコード値DTO
     * @throws EntityNotFoundException カテゴリが存在しない場合
     * @throws DuplicateEntityException コード値が既に存在する場合
     * @throws ValidationException バリデーションエラーの場合
     */
    CodeValueDTO createCodeValue(String categoryId, @Valid CodeValueCreateDTO codeValueDTO);
    
    /**
     * コード値を更新する
     * @param categoryId カテゴリID
     * @param code コード値
     * @param codeValueDTO 更新用DTO
     * @return 更新されたコード値DTO
     * @throws EntityNotFoundException コード値が存在しない場合
     * @throws ValidationException バリデーションエラーの場合
     */
    CodeValueDTO updateCodeValue(String categoryId, String code, 
                                @Valid CodeValueUpdateDTO codeValueDTO);
    
    /**
     * コード値を削除する
     * @param categoryId カテゴリID
     * @param code コード値
     * @throws EntityNotFoundException コード値が存在しない場合
     * @throws BusinessRuleException 削除できないコード値の場合または参照されている場合
     */
    void deleteCodeValue(String categoryId, String code);
    
    /**
     * コード値の有効/無効を切り替える
     * @param categoryId カテゴリID
     * @param code コード値
     * @param active 有効/無効フラグ
     * @return 更新されたコード値DTO
     * @throws EntityNotFoundException コード値が存在しない場合
     */
    CodeValueDTO toggleCodeValueActive(String categoryId, String code, boolean active);
    
    /**
     * CSVファイルからコード値を一括インポートする
     * @param categoryId カテゴリID
     * @param inputStream CSVファイルの入力ストリーム
     * @param mode インポートモード（追加/更新/全置換）
     * @return インポート結果
     * @throws EntityNotFoundException カテゴリが存在しない場合
     * @throws ValidationException CSVフォーマットエラーの場合
     */
    ImportResult importCodeValues(String categoryId, InputStream inputStream, ImportMode mode);
    
    /**
     * コード値をCSVファイルにエクスポートする
     * @param categoryId カテゴリID
     * @param outputStream 出力ストリーム
     * @throws EntityNotFoundException カテゴリが存在しない場合
     */
    void exportCodeValues(String categoryId, OutputStream outputStream);
    
    /**
     * コード値の変更履歴を取得する
     * @param categoryId カテゴリID
     * @param code コード値
     * @param pageable ページング情報
     * @return コード値履歴DTOのページング結果
     */
    Page<CodeValueHistoryDTO> getCodeValueHistory(String categoryId, String code, Pageable pageable);
}
```

#### 実装サンプル

```java
@Service
@Slf4j
@Transactional
public class AdminCodeServiceImpl implements AdminCodeService {

    private final CodeCategoryRepository categoryRepository;
    private final CodeValueRepository codeValueRepository;
    private final CodeValueHistoryRepository historyRepository;
    private final CodeService codeService;
    private final AuditEventPublisher auditEventPublisher;
    private final SystemCodeProtectionService protectionService;
    
    public AdminCodeServiceImpl(CodeCategoryRepository categoryRepository,
                               CodeValueRepository codeValueRepository,
                               CodeValueHistoryRepository historyRepository,
                               CodeService codeService,
                               AuditEventPublisher auditEventPublisher,
                               SystemCodeProtectionService protectionService) {
        this.categoryRepository = categoryRepository;
        this.codeValueRepository = codeValueRepository;
        this.historyRepository = historyRepository;
        this.codeService = codeService;
        this.auditEventPublisher = auditEventPublisher;
        this.protectionService = protectionService;
    }
    
    @Override
    public CodeCategoryDTO createCategory(@Valid CodeCategoryCreateDTO categoryDTO) {
        log.debug("Creating new code category: {}", categoryDTO.getId());
        
        // ID重複チェック
        if (categoryRepository.existsById(categoryDTO.getId())) {
            throw new DuplicateEntityException("Category with id " + categoryDTO.getId() + " already exists");
        }
        
        // エンティティ変換
        CodeCategory category = new CodeCategory();
        category.setId(categoryDTO.getId());
        category.setName(categoryDTO.getName());
        category.setDescription(categoryDTO.getDescription());
        category.setSortOrder(categoryDTO.getSortOrder());
        
        // 保存
        CodeCategory savedCategory = categoryRepository.save(category);
        
        // 監査イベント発行
        auditEventPublisher.publishAuditEvent(
                AuditEventType.CREATE, 
                "CODE_CATEGORY", 
                savedCategory.getId(),
                Map.of("name", savedCategory.getName()));
        
        // DTOにマッピングして返却
        CodeCategoryDTO resultDTO = new CodeCategoryDTO();
        BeanUtils.copyProperties(savedCategory, resultDTO);
        resultDTO.setCodeCount(0);
        
        return resultDTO;
    }
    
    // 他のメソッド実装...
    
    @Override
    @Transactional
    public CodeValueDTO createCodeValue(String categoryId, @Valid CodeValueCreateDTO codeValueDTO) {
        log.debug("Creating new code value: {}:{}", categoryId, codeValueDTO.getCode());
        
        // カテゴリの存在確認
        if (!categoryRepository.existsById(categoryId)) {
            throw new EntityNotFoundException("Category not found with id: " + categoryId);
        }
        
        // コード値の重複チェック
        CodeValueId id = new CodeValueId(categoryId, codeValueDTO.getCode());
        if (codeValueRepository.existsById(id)) {
            throw new DuplicateEntityException("Code value already exists: " + codeValueDTO.getCode());
        }
        
        // 親コードの存在確認と循環参照チェック
        if (codeValueDTO.getParentCode() != null) {
            validateParentCodeReference(categoryId, codeValueDTO.getCode(), codeValueDTO.getParentCode());
        }
        
        // エンティティ変換
        CodeValue codeValue = new CodeValue();
        codeValue.setCategoryId(categoryId);
        codeValue.setCode(codeValueDTO.getCode());
        codeValue.setName(codeValueDTO.getName());
        codeValue.setDescription(codeValueDTO.getDescription());
        codeValue.setSortOrder(codeValueDTO.getSortOrder());
        codeValue.setActive(codeValueDTO.isActive());
        codeValue.setParentCode(codeValueDTO.getParentCode());
        codeValue.setAttributesFromMap(codeValueDTO.getAttributes());
        
        // 保存
        CodeValue savedCodeValue = codeValueRepository.save(codeValue);
        
        // 履歴作成
        createHistory(savedCodeValue, OperationType.CREATE, null);
        
        // 監査イベント発行
        auditEventPublisher.publishAuditEvent(
                AuditEventType.CREATE, 
                "CODE_VALUE", 
                categoryId + ":" + savedCodeValue.getCode(),
                Map.of("name", savedCodeValue.getName()));
        
        // キャッシュ更新
        codeService.refreshCache(categoryId);
        
        // DTOにマッピングして返却
        CodeValueDTO resultDTO = new CodeValueDTO();
        BeanUtils.copyProperties(savedCodeValue, resultDTO);
        resultDTO.setActive(savedCodeValue.isActive());
        resultDTO.setAttributes(savedCodeValue.getAttributesAsMap());
        
        return resultDTO;
    }

    // その他の実装...
}
```

## 3. RESTful API エンドポイント

コード値管理機能のRESTful APIを提供するコントローラークラスの設計例です。

### 3.1 CodeController（参照用）

```java
@RestController
@RequestMapping("/api/v1/codes")
@Validated
@Tag(name = "Code Values", description = "Code value reference APIs")
public class CodeController {

    private final CodeService codeService;
    
    public CodeController(CodeService codeService) {
        this.codeService = codeService;
    }
    
    @GetMapping
    @Operation(summary = "Get all code categories")
    public ResponseEntity<List<CodeCategoryDTO>> getCategories() {
        List<CodeCategoryDTO> categories = codeService.findAllCategories();
        return ResponseEntity.ok(categories);
    }
    
    @GetMapping("/{categoryId}")
    @Operation(summary = "Get code values by category")
    public ResponseEntity<List<CodeValueDTO>> getCodeValues(
            @PathVariable @NotBlank String categoryId,
            @RequestParam(required = false) String keyword,
            @RequestParam(required = false) String parent,
            @RequestParam(required = false, defaultValue = "true") Boolean activeOnly) {
        
        try {
            List<CodeValueDTO> codeValues = codeService.findByCategory(
                    categoryId, keyword, parent, activeOnly);
            return ResponseEntity.ok(codeValues);
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }
    
    @GetMapping("/{categoryId}/{code}")
    @Operation(summary = "Get code value details")
    public ResponseEntity<CodeValueDetailDTO> getCodeValue(
            @PathVariable @NotBlank String categoryId, 
            @PathVariable @NotBlank String code) {
        try {
            CodeValueDetailDTO codeValue = codeService.findByCode(categoryId, code);
            return ResponseEntity.ok(codeValue);
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }
    
    @GetMapping("/{categoryId}/tree")
    @Operation(summary = "Get hierarchical code value tree")
    public ResponseEntity<CodeValueTreeDTO> getCodeValueTree(
            @PathVariable @NotBlank String categoryId,
            @RequestParam(required = false, defaultValue = "true") Boolean activeOnly) {
        
        try {
            CodeValueTreeDTO tree = codeService.getCodeValueTree(categoryId, activeOnly);
            return ResponseEntity.ok(tree);
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }
    
    @PostMapping("/{categoryId}/names")
    @Operation(summary = "Get code name mapping")
    public ResponseEntity<Map<String, String>> getCodeNameMap(
            @PathVariable @NotBlank String categoryId,
            @RequestBody @NotEmpty List<String> codes) {
        
        try {
            Map<String, String> nameMap = codeService.getCodeNameMap(categoryId, codes);
            return ResponseEntity.ok(nameMap);
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }
}
```

### 3.2 AdminCodeController（管理用）

```java
@RestController
@RequestMapping("/api/v1/admin/codes")
@Validated
@Tag(name = "Code Administration", description = "Code value management APIs")
@PreAuthorize("hasRole('ADMIN')")
public class AdminCodeController {

    private final AdminCodeService adminCodeService;
    
    public AdminCodeController(AdminCodeService adminCodeService) {
        this.adminCodeService = adminCodeService;
    }
    
    @PostMapping
    @Operation(summary = "Create a new code category")
    public ResponseEntity<CodeCategoryDTO> createCategory(
            @RequestBody @Valid CodeCategoryCreateDTO categoryDTO) {
        try {
            CodeCategoryDTO createdCategory = adminCodeService.createCategory(categoryDTO);
            return ResponseEntity.status(HttpStatus.CREATED).body(createdCategory);
        } catch (DuplicateEntityException e) {
            throw new ResponseStatusException(HttpStatus.CONFLICT, e.getMessage());
        }
    }
    
    @PutMapping("/{categoryId}")
    @Operation(summary = "Update an existing code category")
    public ResponseEntity<CodeCategoryDTO> updateCategory(
            @PathVariable @NotBlank String categoryId,
            @RequestBody @Valid CodeCategoryUpdateDTO categoryDTO) {
        
        try {
            CodeCategoryDTO updatedCategory = adminCodeService.updateCategory(categoryId, categoryDTO);
            return ResponseEntity.ok(updatedCategory);
        } catch (EntityNotFoundException e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage());
        }
    }
    
    @DeleteMapping("/{categoryId}")
    @Operation(summary = "Delete a code category")
    public ResponseEntity<Void> deleteCategory(@PathVariable @NotBlank String categoryId) {
        try {
            adminCodeService.deleteCategory(categoryId);
            return ResponseEntity.noContent().build();
        } catch (EntityNotFoundException e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage());
        } catch (BusinessRuleException e) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage());
        }
    }
    
    // コード値管理エンドポイント
    @PostMapping("/{categoryId}/values")
    @Operation(summary = "Create a new code value")
    public ResponseEntity<CodeValueDTO> createCodeValue(
            @PathVariable @NotBlank String categoryId,
            @RequestBody @Valid CodeValueCreateDTO codeValueDTO) {
        
        try {
            CodeValueDTO createdValue = adminCodeService.createCodeValue(categoryId, codeValueDTO);
            return ResponseEntity.status(HttpStatus.CREATED).body(createdValue);
        } catch (EntityNotFoundException e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage());
        } catch (DuplicateEntityException e) {
            throw new ResponseStatusException(HttpStatus.CONFLICT, e.getMessage());
        } catch (BusinessRuleException e) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage());
        }
    }
    
    // 他のエンドポイント実装...
    
    // インポート/エクスポートエンドポイント
    @PostMapping("/{categoryId}/import")
    @Operation(summary = "Import code values from CSV file")
    public ResponseEntity<ImportResult> importCodeValues(
            @PathVariable @NotBlank String categoryId,
            @RequestParam("file") MultipartFile file,
            @RequestParam(value = "mode", defaultValue = "ADD") String mode) {
        
        try {
            ImportMode importMode = ImportMode.fromString(mode);
            ImportResult result = adminCodeService.importCodeValues(
                    categoryId, file.getInputStream(), importMode);
            return ResponseEntity.ok(result);
        } catch (EntityNotFoundException e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage());
        } catch (ValidationException e) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage());
        } catch (IOException e) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Failed to process file: " + e.getMessage());
        }
    }
    
    @GetMapping("/{categoryId}/export")
    @Operation(summary = "Export code values to CSV file")
    public void exportCodeValues(
            @PathVariable @NotBlank String categoryId,
            HttpServletResponse response) {
        
        try {
            response.setContentType("text/csv");
            response.setHeader("Content-Disposition", 
                              "attachment; filename=\"" + categoryId + "_codes.csv\"");
            
            adminCodeService.exportCodeValues(categoryId, response.getOutputStream());
        } catch (EntityNotFoundException e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage());
        } catch (IOException e) {
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, 
                                             "Failed to export: " + e.getMessage());
        }
    }
    
    // 履歴エンドポイント
    @GetMapping("/{categoryId}/values/{code}/history")
    @Operation(summary = "Get code value change history")
    public ResponseEntity<Page<CodeValueHistoryDTO>> getCodeValueHistory(
            @PathVariable @NotBlank String categoryId,
            @PathVariable @NotBlank String code,
            @PageableDefault(size = 20, sort = "operatedAt", direction = Sort.Direction.DESC) Pageable pageable) {
        
        try {
            Page<CodeValueHistoryDTO> history = 
                adminCodeService.getCodeValueHistory(categoryId, code, pageable);
            return ResponseEntity.ok(history);
        } catch (EntityNotFoundException e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage());
        }
    }
}
```

## 4. Spring依存関係

コード値管理機能の実装に必要なSpring関連の依存関係です。

```xml
<!-- Spring Boot Starter Web -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!-- Spring Boot Starter Data JPA -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

<!-- Spring Boot Starter Validation -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>

<!-- Spring Boot Starter Cache -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>

<!-- Caffeine Cache -->
<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
</dependency>

<!-- Spring Boot Starter Security (Optional) -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<!-- Spring Boot Starter AOP -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>

<!-- OpenCSV for CSV processing -->
<dependency>
    <groupId>com.opencsv</groupId>
    <artifactId>opencsv</artifactId>
    <version>5.7.1</version>
</dependency>

<!-- SpringDoc OpenAPI (Optional, for API documentation) -->
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-ui</artifactId>
    <version>1.7.0</version>
</dependency>
```

## 5. 例外処理

Spring標準機能を活用した例外処理の実装例です。

```java
@RestControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    // エンティティ存在しない例外
    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<Object> handleEntityNotFoundException(
            EntityNotFoundException ex, WebRequest request) {
        
        ErrorResponse error = new ErrorResponse(
                HttpStatus.NOT_FOUND.value(),
                "Entity Not Found",
                ex.getMessage(),
                request.getDescription(false));
        
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }
    
    // エンティティ重複例外
    @ExceptionHandler(DuplicateEntityException.class)
    public ResponseEntity<Object> handleDuplicateEntityException(
            DuplicateEntityException ex, WebRequest request) {
        
        ErrorResponse error = new ErrorResponse(
                HttpStatus.CONFLICT.value(),
                "Duplicate Entity",
                ex.getMessage(),
                request.getDescription(false));
        
        return new ResponseEntity<>(error, HttpStatus.CONFLICT);
    }
    
    // ビジネスルール違反例外
    @ExceptionHandler(BusinessRuleException.class)
    public ResponseEntity<Object> handleBusinessRuleException(
            BusinessRuleException ex, WebRequest request) {
        
        ErrorResponse error = new ErrorResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Business Rule Violation",
                ex.getMessage(),
                request.getDescription(false));
        
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }
    
    // バリデーション例外
    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex, 
            HttpHeaders headers, 
            HttpStatus status, 
            WebRequest request) {
        
        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .collect(Collectors.toList());
        
        ErrorResponse error = new ErrorResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Validation Error",
                "Validation failed for request",
                request.getDescription(false),
                errors);
        
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }
    
    // 他の例外ハンドラー...
}

@Getter
public class ErrorResponse {
    private final int status;
    private final String error;
    private final String message;
    private final String path;
    private final Instant timestamp;
    private final List<String> details;
    
    public ErrorResponse(int status, String error, String message, String path) {
        this(status, error, message, path, null);
    }
    
    public ErrorResponse(int status, String error, String message, String path, 
                         List<String> details) {
        this.status = status;
        this.error = error;
        this.message = message;
        this.path = path;
        this.timestamp = Instant.now();
        this.details = details;
    }
}
```

## 6. 監査ログとイベント

Spring標準機能とイベント駆動アーキテクチャを活用した監査ログの実装例です。

```java
// 監査イベントの定義
public enum AuditEventType {
    CREATE, UPDATE, DELETE, ACTIVATE, DEACTIVATE
}

// 監査イベント発行インターフェース
@Component
public class AuditEventPublisher {

    private final ApplicationEventPublisher eventPublisher;
    
    public AuditEventPublisher(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }
    
    public void publishAuditEvent(AuditEventType type, String resourceType, 
                                 String resourceId, Map<String, Object> details) {
        AuditEvent event = new AuditEvent(type, resourceType, resourceId, details);
        eventPublisher.publishEvent(event);
    }
}

// 監査イベントクラス
@Getter
public class AuditEvent extends ApplicationEvent {
    private final AuditEventType type;
    private final String resourceType;
    private final String resourceId;
    private final Map<String, Object> details;
    private final String userId;
    private final Instant timestamp;
    
    public AuditEvent(AuditEventType type, String resourceType, 
                     String resourceId, Map<String, Object> details) {
        super(resourceId);
        this.type = type;
        this.resourceType = resourceType;
        this.resourceId = resourceId;
        this.details = details;
        this.userId = SecurityContextHolder.getContext().getAuthentication() != null ?
                SecurityContextHolder.getContext().getAuthentication().getName() : "system";
        this.timestamp = Instant.now();
    }
}

// 監査イベントリスナー
@Component
@Slf4j
public class AuditEventListener {

    private final AuditLogService auditLogService;
    
    public AuditEventListener(AuditLogService auditLogService) {
        this.auditLogService = auditLogService;
    }
    
    @Async
    @EventListener
    public void handleAuditEvent(AuditEvent event) {
        log.debug("Processing audit event: {}", event);
        
        auditLogService.recordAuditLog(
                event.getType().name(),
                event.getResourceType(),
                event.getResourceId(),
                event.getUserId(),
                event.getDetails());
    }
}
```

## 7. キャッシュ設定

Spring Cacheを活用したキャッシュ設定の例です。

```java
@Configuration
@EnableCaching
public class CodeCacheConfig {

    @Bean
    public CacheManager codeCacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        
        // デフォルトのキャッシュ設定
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .expireAfterWrite(60, TimeUnit.MINUTES)
                .maximumSize(1000));
        
        // コードカテゴリキャッシュ設定
        Cache<Object, Object> categoryCache = Caffeine.newBuilder()
                .expireAfterWrite(60, TimeUnit.MINUTES)
                .build();
        
        // コード値キャッシュ設定
        Cache<Object, Object> codeValueCache = Caffeine.newBuilder()
                .expireAfterWrite(30, TimeUnit.MINUTES)
                .maximumSize(5000)
                .build();
        
        // コード値詳細キャッシュ設定
        Cache<Object, Object> codeDetailCache = Caffeine.newBuilder()
                .expireAfterWrite(30, TimeUnit.MINUTES)
                .maximumSize(1000)
                .build();
        
        // ツリーキャッシュ設定
        Cache<Object, Object> codeTreeCache = Caffeine.newBuilder()
                .expireAfterWrite(30, TimeUnit.MINUTES)
                .maximumSize(100)
                .build();
        
        cacheManager.registerCustomCache("codeCategories", categoryCache);
        cacheManager.registerCustomCache("codeValues", codeValueCache);
        cacheManager.registerCustomCache("codeValueDetails", codeDetailCache);
        cacheManager.registerCustomCache("codeValueTrees", codeTreeCache);
        
        return cacheManager;
    }
    
    @Bean
    public CacheResolver codeCacheResolver(CacheManager codeCacheManager) {
        return new NamedCacheResolver(codeCacheManager, 
                "codeCategories", "codeValues", "codeValueDetails", "codeValueTrees");
    }
}
```

## 8. データ交換モデル

Spring標準の検証アノテーションを活用したDTOクラスの例です。

```java
// コードカテゴリ作成DTO
@Data
public class CodeCategoryCreateDTO {
    
    @NotBlank(message = "カテゴリIDは必須です")
    @Pattern(regexp = "^[a-z0-9_]{3,32}$", 
             message = "カテゴリIDは英小文字、数字、アンダースコアのみ許可され、3〜32文字である必要があります")
    private String id;
    
    @NotBlank(message = "カテゴリ名称は必須です")
    @Size(min = 1, max = 50, message = "カテゴリ名称は1〜50文字で入力してください")
    private String name;
    
    @Size(max = 200, message = "説明は200文字以内で入力してください")
    private String description;
    
    @NotNull(message = "表示順序は必須です")
    @Min(value = 1, message = "表示順序は1以上の整数を入力してください")
    private Integer sortOrder;
}

// コード値作成DTO
@Data
public class CodeValueCreateDTO {
    
    @NotBlank(message = "コードは必須です")
    @Pattern(regexp = "^[A-Za-z0-9_-]{1,32}$", 
             message = "コードは英数字、ハイフン、アンダースコアのみ許可され、1〜32文字である必要があります")
    private String code;
    
    @NotBlank(message = "名称は必須です")
    @Size(min = 1, max = 100, message = "名称は1〜100文字で入力してください")
    private String name;
    
    @Size(max = 500, message = "説明は500文字以内で入力してください")
    private String description;
    
    @NotNull(message = "表示順序は必須です")
    @Min(value = 1, message = "表示順序は1以上の整数を入力してください")
    private Integer sortOrder;
    
    private boolean active = true;
    
    private Map<String, Object> attributes;
    
    private String parentCode;
}

// インポート結果DTO
@Data
public class ImportResult {
    private int total;
    private int success;
    private int error;
    private String summary;
    private List<ImportError> errors;
    private String errorReportUrl;
}

@Data
public class ImportError {
    private int line;
    private String code;
    private String reason;
}
```

## 9. 非機能要件

### 9.1 パフォーマンス要件

- コード値一覧取得: レスポンス時間100ms以内（キャッシュ使用時）
- コード値詳細取得: レスポンス時間50ms以内（キャッシュ使用時）
- コード値更新後のキャッシュ更新: 500ms以内
- コード値一括インポート: 1,000件/5秒以内

### 9.2 キャッシュ戦略

- Spring Cacheアノテーションを活用したキャッシング
- Caffeine高性能キャッシュライブラリの活用
- キャッシュ領域の最適な分割（カテゴリ、コード値、ツリー）
- 更新時の効率的なキャッシュ無効化
- 初回アクセス時の自動キャッシュロード

### 9.3 トランザクション管理

- Spring Transactionalアノテーションを活用
- コード値登録・更新・削除: `@Transactional(REQUIRED)`
- コード値の一括インポート: `@Transactional(REQUIRED)`
- コード値参照操作: `@Transactional(readOnly = true)`

### 9.4 スレッドセーフティ

- Spring Dataリポジトリの活用によるスレッドセーフなデータアクセス
- ConcurrentHashMapベースの並行アクセス対応キャッシュ
- Spring AOPを活用した排他制御（必要に応じて）
- イベント駆動アーキテクチャによる非同期処理