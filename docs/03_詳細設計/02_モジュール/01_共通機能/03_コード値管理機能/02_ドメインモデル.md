# コード値管理機能 - ドメインモデル

## 1. エンティティ定義

### 1.1 CodeCategory（コードカテゴリ）

システム内で管理されるコード値のカテゴリを表すエンティティです。

#### 属性

| 属性名 | 型 | 必須 | 説明 |
|-------|------|------|------|
| id | String | ○ | カテゴリID（一意識別子） |
| name | String | ○ | カテゴリ名称 |
| description | String |  | カテゴリの説明 |
| sortOrder | Integer | ○ | 表示順序 |
| createdAt | LocalDateTime | ○ | 作成日時 |
| updatedAt | LocalDateTime | ○ | 更新日時 |
| createdBy | String | ○ | 作成者 |
| updatedBy | String | ○ | 更新者 |

#### JPA・バリデーションアノテーション

```java
@Entity
@Table(name = "code_categories")
public class CodeCategory {
    @Id
    @Column(name = "id", length = 32, nullable = false)
    @Pattern(regexp = "^[a-z0-9_]{3,32}$", message = "カテゴリIDは英小文字、数字、アンダースコアのみ許可され、3〜32文字である必要があります")
    private String id;
    
    @Column(name = "name", length = 50, nullable = false)
    @NotBlank(message = "カテゴリ名称は必須です")
    @Size(min = 1, max = 50, message = "カテゴリ名称は1〜50文字で入力してください")
    private String name;
    
    @Column(name = "description", length = 200)
    @Size(max = 200, message = "説明は200文字以内で入力してください")
    private String description;
    
    @Column(name = "sort_order", nullable = false)
    @Min(value = 1, message = "表示順序は1以上の整数を入力してください")
    private Integer sortOrder;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    @CreatedDate
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at", nullable = false)
    @LastModifiedDate
    private LocalDateTime updatedAt;
    
    @Column(name = "created_by", nullable = false, updatable = false)
    @CreatedBy
    private String createdBy;
    
    @Column(name = "updated_by", nullable = false)
    @LastModifiedBy
    private String updatedBy;
    
    // getters, setters, hashCode, equals, toString
}
```

#### ビジネスルール

- カテゴリIDは一度作成すると変更不可
- システム定義のカテゴリは削除不可

### 1.2 CodeValue（コード値）

特定のカテゴリに属するコード値を表すエンティティです。

#### 属性

| 属性名 | 型 | 必須 | 説明 |
|-------|------|------|------|
| categoryId | String | ○ | カテゴリID（外部キー） |
| code | String | ○ | コード値（カテゴリ内で一意） |
| name | String | ○ | 表示名称 |
| description | String |  | 説明文 |
| sortOrder | Integer | ○ | 表示順序 |
| isActive | Boolean | ○ | 有効/無効フラグ |
| attributes | String (JSON) |  | 追加属性（カテゴリ固有の属性） |
| parentCode | String |  | 親コード（階層構造の場合） |
| createdAt | LocalDateTime | ○ | 作成日時 |
| updatedAt | LocalDateTime | ○ | 更新日時 |
| createdBy | String | ○ | 作成者 |
| updatedBy | String | ○ | 更新者 |

#### JPA・バリデーションアノテーション

```java
@Entity
@Table(name = "code_values")
@IdClass(CodeValueId.class)
public class CodeValue {
    @Id
    @Column(name = "category_id", length = 32, nullable = false)
    private String categoryId;
    
    @Id
    @Column(name = "code", length = 32, nullable = false)
    @Pattern(regexp = "^[A-Za-z0-9_-]{1,32}$", message = "コードは英数字、ハイフン、アンダースコアのみ許可され、1〜32文字である必要があります")
    private String code;
    
    @Column(name = "name", length = 100, nullable = false)
    @NotBlank(message = "名称は必須です")
    @Size(min = 1, max = 100, message = "名称は1〜100文字で入力してください")
    private String name;
    
    @Column(name = "description", length = 500)
    @Size(max = 500, message = "説明は500文字以内で入力してください")
    private String description;
    
    @Column(name = "sort_order", nullable = false)
    @Min(value = 1, message = "表示順序は1以上の整数を入力してください")
    private Integer sortOrder;
    
    @Column(name = "is_active", nullable = false)
    private boolean isActive = true;
    
    @Column(name = "attributes", columnDefinition = "TEXT")
    private String attributes;
    
    @Column(name = "parent_code", length = 32)
    private String parentCode;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    @CreatedDate
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at", nullable = false)
    @LastModifiedDate
    private LocalDateTime updatedAt;
    
    @Column(name = "created_by", nullable = false, updatable = false)
    @CreatedBy
    private String createdBy;
    
    @Column(name = "updated_by", nullable = false)
    @LastModifiedBy
    private String updatedBy;
    
    // getters, setters, hashCode, equals, toString
    
    // JSON attributes handling methods
    @Transient
    public Map<String, Object> getAttributesAsMap() {
        try {
            if (attributes == null || attributes.isEmpty()) {
                return Collections.emptyMap();
            }
            ObjectMapper mapper = new ObjectMapper();
            return mapper.readValue(attributes, new TypeReference<Map<String, Object>>() {});
        } catch (Exception e) {
            return Collections.emptyMap();
        }
    }
    
    public void setAttributesFromMap(Map<String, Object> attributesMap) {
        try {
            if (attributesMap == null || attributesMap.isEmpty()) {
                this.attributes = null;
                return;
            }
            ObjectMapper mapper = new ObjectMapper();
            this.attributes = mapper.writeValueAsString(attributesMap);
        } catch (Exception e) {
            this.attributes = "{}";
        }
    }
}
```

#### ビジネスルール

- カテゴリIDとコードの組み合わせで一意性を確保
- 階層構造の場合、循環参照（循環的な親子関係）は許可しない
- システム定義の基本コード値は削除不可
- 他のエンティティから参照されているコード値は削除不可（無効化のみ可能）
- 親コードが無効の場合、子コードも自動的に無効とみなす

### 1.3 CodeValueHistory（コード値履歴）

コード値の変更履歴を記録するエンティティです。Spring Data Auditingとの統合により、変更履歴を効率的に管理します。

#### 属性

| 属性名 | 型 | 必須 | 説明 |
|-------|------|------|------|
| id | UUID | ○ | 履歴ID（一意識別子） |
| categoryId | String | ○ | カテゴリID |
| code | String | ○ | コード値 |
| operationType | OperationType | ○ | 操作種別（作成/更新/削除/無効化） |
| beforeValue | String (JSON) |  | 変更前の値 |
| afterValue | String (JSON) |  | 変更後の値 |
| operatedBy | String | ○ | 操作者ID |
| operatedAt | LocalDateTime | ○ | 操作日時 |

#### JPA・バリデーションアノテーション

```java
@Entity
@Table(name = "code_value_history")
public class CodeValueHistory {
    @Id
    @Column(name = "id", nullable = false)
    @Type(type = "uuid-char")
    private UUID id;
    
    @Column(name = "category_id", length = 32, nullable = false)
    private String categoryId;
    
    @Column(name = "code", length = 32, nullable = false)
    private String code;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "operation_type", nullable = false, length = 20)
    private OperationType operationType;
    
    @Column(name = "before_value", columnDefinition = "TEXT")
    private String beforeValue;
    
    @Column(name = "after_value", columnDefinition = "TEXT")
    private String afterValue;
    
    @Column(name = "operated_by", nullable = false)
    private String operatedBy;
    
    @Column(name = "operated_at", nullable = false)
    private LocalDateTime operatedAt;
    
    // getters, setters, hashCode, equals, toString
    
    // JSON value handling methods
    @Transient
    public Map<String, Object> getBeforeValueAsMap() {
        try {
            if (beforeValue == null || beforeValue.isEmpty()) {
                return Collections.emptyMap();
            }
            ObjectMapper mapper = new ObjectMapper();
            return mapper.readValue(beforeValue, new TypeReference<Map<String, Object>>() {});
        } catch (Exception e) {
            return Collections.emptyMap();
        }
    }
    
    @Transient
    public Map<String, Object> getAfterValueAsMap() {
        try {
            if (afterValue == null || afterValue.isEmpty()) {
                return Collections.emptyMap();
            }
            ObjectMapper mapper = new ObjectMapper();
            return mapper.readValue(afterValue, new TypeReference<Map<String, Object>>() {});
        } catch (Exception e) {
            return Collections.emptyMap();
        }
    }
}
```

#### ビジネスルール

- コード値の全ての変更履歴を保持
- 履歴データは削除しない

## 2. 値オブジェクト定義

### 2.1 CodeValueId（コード値ID）

コード値の複合主キーを表す値オブジェクトです。Spring Data JDBCでの複合キー対応のために実装します。

```java
public class CodeValueId implements Serializable {
    private String categoryId;
    private String code;
    
    // デフォルトコンストラクタ（JPA要件）
    public CodeValueId() {
    }
    
    public CodeValueId(String categoryId, String code) {
        this.categoryId = categoryId;
        this.code = code;
    }
    
    // Getters and setters
    public String getCategoryId() {
        return categoryId;
    }
    
    public void setCategoryId(String categoryId) {
        this.categoryId = categoryId;
    }
    
    public String getCode() {
        return code;
    }
    
    public void setCode(String code) {
        this.code = code;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        CodeValueId that = (CodeValueId) o;
        return Objects.equals(categoryId, that.categoryId) &&
               Objects.equals(code, that.code);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(categoryId, code);
    }
    
    @Override
    public String toString() {
        return categoryId + ":" + code;
    }
}
```

### 2.2 ImportMode（インポートモード）

コード値一括インポート時のモードを表す列挙型です。

```java
public enum ImportMode {
    ADD,      // 新規追加のみ
    UPDATE,   // 既存データ更新のみ
    REPLACE;  // 既存データを全て削除して置き換え
    
    public static ImportMode fromString(String value) {
        try {
            return ImportMode.valueOf(value.toUpperCase());
        } catch (Exception e) {
            return ADD; // デフォルト値
        }
    }
}
```

### 2.3 OperationType（操作種別）

コード値履歴の操作種別を表す列挙型です。

```java
public enum OperationType {
    CREATE,     // 作成
    UPDATE,     // 更新
    DELETE,     // 削除
    ACTIVATE,   // 有効化
    DEACTIVATE; // 無効化
}
```

## 3. ドメイン関連図

```
CodeCategory 1 --- * CodeValue
      |
      |
      * CodeValueHistory
```

- `CodeCategory` は複数の `CodeValue` を持つ（1対多）
- `CodeValue` は同一カテゴリ内で親子関係を持つことができる（自己参照）
- `CodeValueHistory` はコード値の変更履歴を記録

## 4. リポジトリインターフェース

### 4.1 CodeCategoryRepository

Spring Data JDBCを活用したリポジトリインターフェースです。

```java
@Repository
public interface CodeCategoryRepository extends JpaRepository<CodeCategory, String> {
    
    @Query("SELECT c FROM CodeCategory c ORDER BY c.sortOrder")
    List<CodeCategory> findAllByOrderBySortOrder();
    
    // カスタムクエリの例
    @Query("SELECT c FROM CodeCategory c WHERE LOWER(c.name) LIKE LOWER(CONCAT('%', :keyword, '%'))")
    List<CodeCategory> findByNameContainingIgnoreCase(@Param("keyword") String keyword);
    
    // システム定義カテゴリの確認
    boolean existsByIdAndSystemDefinedTrue(String id);
}
```

### 4.2 CodeValueRepository

```java
@Repository
public interface CodeValueRepository extends JpaRepository<CodeValue, CodeValueId> {
    
    List<CodeValue> findByCategoryIdOrderBySortOrder(String categoryId);
    
    List<CodeValue> findByCategoryId(String categoryId);
    
    @Query("SELECT cv FROM CodeValue cv WHERE cv.categoryId = :categoryId AND cv.parentCode IS NULL")
    List<CodeValue> findByCategoryIdAndParentCodeIsNull(@Param("categoryId") String categoryId);
    
    @Query("SELECT cv FROM CodeValue cv WHERE cv.categoryId = :categoryId AND cv.parentCode = :parentCode")
    List<CodeValue> findByCategoryIdAndParentCode(@Param("categoryId") String categoryId, 
                                                  @Param("parentCode") String parentCode);
    
    List<CodeValue> findByCategoryIdAndCodeIn(String categoryId, List<String> codes);
    
    @Query("SELECT cv FROM CodeValue cv WHERE cv.categoryId = :categoryId AND " +
           "(LOWER(cv.code) LIKE LOWER(CONCAT('%', :keyword, '%')) OR " +
           "LOWER(cv.name) LIKE LOWER(CONCAT('%', :keyword, '%')) OR " +
           "LOWER(cv.description) LIKE LOWER(CONCAT('%', :keyword, '%')))")
    List<CodeValue> findByCategoryIdAndKeyword(@Param("categoryId") String categoryId, 
                                              @Param("keyword") String keyword);
    
    long countByCategoryId(String categoryId);
    
    // 子コード値の検索
    boolean existsByCategoryIdAndParentCode(String categoryId, String parentCode);
    
    // システム定義コード値の確認
    @Query("SELECT COUNT(cv) FROM CodeValue cv WHERE cv.categoryId = :categoryId " +
           "AND cv.code = :code AND cv.systemDefined = true")
    int countSystemDefinedCodeValue(@Param("categoryId") String categoryId, 
                                   @Param("code") String code);
}
```

### 4.3 CodeValueHistoryRepository

```java
@Repository
public interface CodeValueHistoryRepository extends JpaRepository<CodeValueHistory, UUID> {
    
    Page<CodeValueHistory> findByCategoryIdAndCodeOrderByOperatedAtDesc(
            String categoryId, String code, Pageable pageable);
    
    @Query("SELECT cvh FROM CodeValueHistory cvh WHERE cvh.categoryId = :categoryId " +
           "AND cvh.operatedAt BETWEEN :startDate AND :endDate")
    List<CodeValueHistory> findByCategoryIdAndDateRange(
            @Param("categoryId") String categoryId,
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);
}
```

## 5. 重要なビジネスロジック

### 5.1 コード値の一意性と整合性

```java
@Service
public class CodeValidationService {

    @Autowired
    private CodeCategoryRepository categoryRepository;
    
    @Autowired
    private CodeValueRepository codeValueRepository;
    
    /**
     * コード値の保存前検証
     */
    public void validateBeforeSave(CodeValue codeValue) {
        // カテゴリの存在確認
        if (!categoryRepository.existsById(codeValue.getCategoryId())) {
            throw new EntityNotFoundException("Category not found with id: " + codeValue.getCategoryId());
        }
        
        // 親コードの存在確認
        if (codeValue.getParentCode() != null) {
            CodeValueId parentId = new CodeValueId(codeValue.getCategoryId(), codeValue.getParentCode());
            if (!codeValueRepository.existsById(parentId)) {
                throw new EntityNotFoundException("Parent code not found: " + codeValue.getParentCode());
            }
            
            // 循環参照チェック
            if (codeValue.getCode().equals(codeValue.getParentCode()) || 
                checkCircularReference(codeValue.getCategoryId(), codeValue.getParentCode(), codeValue.getCode())) {
                throw new BusinessRuleException("Circular reference detected in code hierarchy");
            }
        }
    }
    
    /**
     * 階層の循環参照チェック
     */
    private boolean checkCircularReference(String categoryId, String parentCode, String currentCode) {
        if (parentCode == null) {
            return false;
        }
        
        if (parentCode.equals(currentCode)) {
            return true;
        }
        
        CodeValueId parentId = new CodeValueId(categoryId, parentCode);
        Optional<CodeValue> parentOpt = codeValueRepository.findById(parentId);
        
        if (parentOpt.isPresent() && parentOpt.get().getParentCode() != null) {
            return checkCircularReference(categoryId, parentOpt.get().getParentCode(), currentCode);
        }
        
        return false;
    }
}
```

### 5.2 コード値の階層管理

```java
@Service
public class CodeHierarchyService {

    @Autowired
    private CodeValueRepository codeValueRepository;
    
    /**
     * 階層構造のツリー取得
     */
    public CodeValueTreeDTO buildCodeTree(String categoryId, boolean activeOnly) {
        // ルートノード作成
        CodeValueTreeDTO root = new CodeValueTreeDTO();
        root.setCode("ROOT");
        root.setName("ROOT");
        root.setActive(true);
        
        // カテゴリ内の全コード値を取得
        List<CodeValue> allValues = codeValueRepository.findByCategoryId(categoryId);
        
        // アクティブフラグでフィルタリング
        if (activeOnly) {
            allValues = allValues.stream()
                    .filter(CodeValue::isActive)
                    .collect(Collectors.toList());
        }
        
        // ルートレベルのコード値を取得
        List<CodeValueTreeDTO> children = allValues.stream()
                .filter(cv -> cv.getParentCode() == null)
                .sorted(Comparator.comparing(CodeValue::getSortOrder))
                .map(cv -> buildSubTree(cv, allValues))
                .collect(Collectors.toList());
        
        root.setChildren(children);
        return root;
    }
    
    /**
     * 階層構造のサブツリー構築
     */
    private CodeValueTreeDTO buildSubTree(CodeValue current, List<CodeValue> allValues) {
        CodeValueTreeDTO node = new CodeValueTreeDTO();
        node.setCode(current.getCode());
        node.setName(current.getName());
        node.setActive(current.isActive());
        
        // 子ノードを検索して追加
        List<CodeValueTreeDTO> children = allValues.stream()
                .filter(cv -> current.getCode().equals(cv.getParentCode()))
                .sorted(Comparator.comparing(CodeValue::getSortOrder))
                .map(cv -> buildSubTree(cv, allValues))
                .collect(Collectors.toList());
        
        node.setChildren(children);
        return node;
    }
    
    /**
     * 親コードが無効の場合、子コードも再帰的に無効化
     */
    @Transactional
    public void deactivateChildCodes(String categoryId, String parentCode) {
        List<CodeValue> children = codeValueRepository.findByCategoryIdAndParentCode(categoryId, parentCode);
        
        for (CodeValue child : children) {
            child.setActive(false);
            codeValueRepository.save(child);
            
            // 子の子も再帰的に無効化
            deactivateChildCodes(categoryId, child.getCode());
        }
    }
}
```

### 5.3 システム定義コード値の保護

```java
@Component
public class SystemCodeProtectionService {

    private static final Set<String> SYSTEM_CATEGORIES = Set.of(
            "error_code", "system_config", "notification_template", "report_template");
    
    private static final Map<String, Set<String>> SYSTEM_CODES = Map.of(
            "job_type", Set.of("PM", "SE", "PG"),
            "contract_type", Set.of("DELEGATE", "OUTSOURCE", "DISPATCH")
    );
    
    /**
     * システム定義カテゴリかどうかを判定
     */
    public boolean isSystemCategory(String categoryId) {
        return SYSTEM_CATEGORIES.contains(categoryId);
    }
    
    /**
     * システム定義コード値かどうかを判定
     */
    public boolean isSystemCode(String categoryId, String code) {
        Set<String> systemCodes = SYSTEM_CODES.get(categoryId);
        return systemCodes != null && systemCodes.contains(code);
    }
    
    /**
     * システム定義コード値の更新可否を判定
     */
    public void validateSystemCodeUpdate(CodeValue originalValue, CodeValueUpdateDTO updateDTO) {
        if (isSystemCode(originalValue.getCategoryId(), originalValue.getCode())) {
            // 親コードの変更不可
            if (!Objects.equals(originalValue.getParentCode(), updateDTO.getParentCode())) {
                throw new BusinessRuleException("Cannot change parent code for system defined code value");
            }
            
            // システム定義コード値の他の制限チェック
            // 必要に応じて追加
        }
    }
}
```

## 6. DTOクラス定義

Spring標準機能を活用したDTOクラスの設計例です。

### 6.1 コードカテゴリDTO

```java
@Getter
@Setter
public class CodeCategoryDTO implements Serializable {
    
    @JsonProperty("id")
    private String id;
    
    @JsonProperty("name")
    private String name;
    
    @JsonProperty("description")
    private String description;
    
    @JsonProperty("sortOrder")
    private Integer sortOrder;
    
    @JsonProperty("codeCount")
    private Integer codeCount;
    
    @JsonProperty("createdAt")
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime createdAt;
    
    @JsonProperty("updatedAt")
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime updatedAt;
    
    @JsonProperty("createdBy")
    private String createdBy;
    
    @JsonProperty("updatedBy")
    private String updatedBy;
}
```

### 6.2 コード値DTO

```java
@Getter
@Setter
public class CodeValueDTO implements Serializable {
    
    @JsonProperty("code")
    private String code;
    
    @JsonProperty("name")
    private String name;
    
    @JsonProperty("description")
    private String description;
    
    @JsonProperty("sortOrder")
    private Integer sortOrder;
    
    @JsonProperty("isActive")
    private boolean active;
    
    @JsonProperty("attributes")
    private Map<String, Object> attributes;
    
    @JsonProperty("parentCode")
    private String parentCode;
}
```

### 6.3 コード値階層ツリーDTO

```java
@Getter
@Setter
public class CodeValueTreeDTO implements Serializable {
    
    @JsonProperty("code")
    private String code;
    
    @JsonProperty("name")
    private String name;
    
    @JsonProperty("isActive")
    private boolean active;
    
    @JsonProperty("children")
    private List<CodeValueTreeDTO> children = new ArrayList<>();
}
```

## 7. 主要コード値カテゴリ設計例

### 7.1 職種マスタ（job_type）

```json
{
  "PM": {
    "name": "プロジェクトマネージャ",
    "description": "プロジェクト全体の管理と調整を担当",
    "attributes": {
      "abbreviation": "PM",
      "skillLevel": "senior",
      "gradeRange": "G4-G6"
    }
  },
  "SE": {
    "name": "システムエンジニア",
    "description": "システム設計、開発を担当",
    "attributes": {
      "abbreviation": "SE",
      "skillLevel": "middle",
      "gradeRange": "G3-G5"
    }
  },
  "PG": {
    "name": "プログラマ",
    "description": "プログラム開発を担当",
    "attributes": {
      "abbreviation": "PG",
      "skillLevel": "junior",
      "gradeRange": "G1-G3"
    }
  }
}
```

### 7.2 スキル階層マスタ（skill）

```
Programming Language（親）
  |- Java
  |   |- Java 8
  |   |- Java 11
  |   |- Java 17
  |- Python
  |   |- Python 2
  |   |- Python 3
  |- JavaScript
  |   |- TypeScript
  |   |- React
  |   |- Vue.js
  |- C#
  |- PHP
```

### 7.3 案件ステータスマスタ（project_status）

```json
{
  "OPEN": {
    "name": "募集中",
    "description": "募集中の案件",
    "attributes": {
      "color": "#4caf50",
      "allowEdit": true
    }
  },
  "IN_PROGRESS": {
    "name": "提案中",
    "description": "候補者提案中の案件",
    "attributes": {
      "color": "#2196f3",
      "allowEdit": true
    }
  },
  "CONTRACTED": {
    "name": "契約成立",
    "description": "契約が成立した案件",
    "attributes": {
      "color": "#673ab7",
      "allowEdit": false
    }
  },
  "COMPLETED": {
    "name": "完了",
    "description": "完了した案件",
    "attributes": {
      "color": "#9e9e9e",
      "allowEdit": false
    }
  },
  "CANCELLED": {
    "name": "キャンセル",
    "description": "キャンセルされた案件",
    "attributes": {
      "color": "#f44336",
      "allowEdit": false
    }
  }
}
```