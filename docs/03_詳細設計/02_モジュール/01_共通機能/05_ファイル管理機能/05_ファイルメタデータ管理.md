# ファイルメタデータ管理

## 1. 概要

ファイルメタデータ管理は、物理的なファイルのコンテンツとは別に、ファイルに関する説明的情報（メタデータ）を管理するコンポーネントです。メタデータには、ファイル名、サイズ、形式、作成日時などの基本情報だけでなく、ファイルの関連エンティティ、カスタム属性、アクセス権限なども含まれます。

Spring の様々な標準機能を活用することで、ファイルメタデータの構造、保存、検索、および関連処理を効率的に実装します。Spring Data JPAによるデータアクセス、Spring Cache、Spring Security、Spring Validationなどの機能を統合することで、高性能かつ堅牢なファイルメタデータ管理が実現します。

メタデータはSpring Data JPAを通じてリレーショナルデータベースに保存され、Spring Resource抽象化を通じた物理ファイルへの参照を含むことで、ファイルの論理的な管理を可能にします。

## 2. 設計方針

ファイルメタデータ管理コンポーネントは、以下のSpring標準機能を活用した設計方針に基づいています：

1. **分離**: Spring の明確なレイヤー分けを活用した物理ファイルストレージとメタデータ管理の関心事を分離
2. **柔軟性**: Spring Data JPAの継承とComposition機能を活用した様々なファイルタイプとビジネスコンテキストに対応できる柔軟なメタデータモデル
3. **検索性**: Spring Data JPAのクエリ機能とSpecification APIを活用した効率的なファイル検索
4. **監査**: Spring Data JPA Auditingによるファイルのライフサイクル全体を通じた変更履歴の管理
5. **アクセス制御**: Spring SecurityのMethod SecurityとExpression-based accessを活用したきめ細かなアクセス権限管理
6. **整合性**: Spring Transactionとイベント処理を組み合わせたメタデータと物理ファイルの整合性保証

## 3. データモデル

Spring Data JPAとJPA（Java Persistence API）を使用したエンティティモデルを定義します。

### 3.1 FileMetadata（ファイルメタデータ）

```java
@Entity
@Table(name = "file_metadata")
@EntityListeners(AuditingEntityListener.class)
public class FileMetadata {
    
    @Id
    @GeneratedValue(generator = "uuid2")
    @GenericGenerator(name = "uuid2", strategy = "uuid2")
    @Column(name = "id", columnDefinition = "VARCHAR(36)")
    private UUID id;
    
    @NotBlank
    @Size(max = 255)
    @Column(name = "file_name", nullable = false)
    private String fileName;
    
    @NotBlank
    @Size(max = 100)
    @Column(name = "content_type", nullable = false)
    private String contentType;
    
    @NotNull
    @Column(name = "file_size", nullable = false)
    private Long fileSize;
    
    @NotBlank
    @Size(max = 1000)
    @Column(name = "storage_reference", nullable = false)
    private String storageReference;
    
    @NotBlank
    @Size(max = 50)
    @Column(name = "storage_provider", nullable = false)
    private String storageProvider;
    
    @NotBlank
    @Size(max = 50)
    @Column(name = "module_code", nullable = false)
    private String moduleCode;
    
    @Size(max = 100)
    @Column(name = "entity_id")
    private String entityId;
    
    @CreatedBy
    @Column(name = "created_by", nullable = false, updatable = false)
    private String createdBy;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @LastModifiedBy
    @Column(name = "last_modified_by")
    private String lastModifiedBy;
    
    @LastModifiedDate
    @Column(name = "last_modified_at")
    private LocalDateTime lastModifiedAt;
    
    @Column(name = "deleted", nullable = false)
    private boolean deleted = false;
    
    @Size(max = 100)
    @Column(name = "checksum_value")
    private String checksumValue;
    
    @Size(max = 20)
    @Column(name = "checksum_algorithm")
    private String checksumAlgorithm;
    
    @Version
    @Column(name = "version", nullable = false)
    private Integer version = 1;
    
    @Column(name = "expires_at")
    private LocalDateTime expiresAt;
    
    @OneToMany(mappedBy = "file", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<FileAttribute> attributes = new HashSet<>();
    
    @OneToMany(mappedBy = "file", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<FilePermission> permissions = new HashSet<>();
    
    @OneToMany(mappedBy = "file", cascade = CascadeType.ALL, orphanRemoval = true)
    @OrderBy("versionNumber DESC")
    private List<FileVersion> versions = new ArrayList<>();
    
    // Getters and Setters
    // Utility methods
}
```

テーブル構造：
```
テーブル名: file_metadata
```

| フィールド名 | 型 | 説明 | 制約 |
|------------|-----|------|------|
| id | varchar(36) | ファイルの一意識別子（UUID） | PK, NOT NULL |
| file_name | varchar(255) | 元のファイル名 | NOT NULL |
| content_type | varchar(100) | MIMEタイプ | NOT NULL |
| file_size | bigint | ファイルサイズ（バイト） | NOT NULL |
| storage_reference | varchar(1000) | ストレージ参照 | NOT NULL |
| storage_provider | varchar(50) | ストレージプロバイダ | NOT NULL |
| module_code | varchar(50) | 関連モジュールコード | NOT NULL |
| entity_id | varchar(100) | 関連エンティティID | |
| created_by | varchar(50) | 作成者ID | NOT NULL |
| created_at | timestamp | 作成日時 | NOT NULL |
| last_modified_by | varchar(50) | 最終更新者ID | |
| last_modified_at | timestamp | 最終更新日時 | |
| deleted | boolean | 削除フラグ | NOT NULL, default false |
| checksum_value | varchar(100) | チェックサム値 | |
| checksum_algorithm | varchar(20) | チェックサムアルゴリズム | |
| version | int | バージョン番号 | NOT NULL, default 1 |
| expires_at | timestamp | 有効期限 | |

インデックス（JPA Annotations）：
```java
@Table(name = "file_metadata", indexes = {
    @Index(name = "idx_file_metadata_module_entity", columnList = "module_code, entity_id"),
    @Index(name = "idx_file_metadata_created_by", columnList = "created_by"),
    @Index(name = "idx_file_metadata_file_name", columnList = "file_name"),
    @Index(name = "idx_file_metadata_content_type", columnList = "content_type"),
    @Index(name = "idx_file_metadata_created_at", columnList = "created_at")
})
```

### 3.2 FileVersion（ファイルバージョン）

```java
@Entity
@Table(name = "file_version", uniqueConstraints = {
    @UniqueConstraint(name = "uk_file_version_file_id_number", 
                     columnNames = {"file_id", "version_number"})
})
@EntityListeners(AuditingEntityListener.class)
public class FileVersion {
    
    @Id
    @GeneratedValue(generator = "uuid2")
    @GenericGenerator(name = "uuid2", strategy = "uuid2")
    @Column(name = "id", columnDefinition = "VARCHAR(36)")
    private UUID id;
    
    @NotNull
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "file_id", nullable = false)
    private FileMetadata file;
    
    @NotNull
    @Column(name = "version_number", nullable = false)
    private Integer versionNumber;
    
    @NotBlank
    @Size(max = 1000)
    @Column(name = "storage_reference", nullable = false)
    private String storageReference;
    
    @NotNull
    @Column(name = "file_size", nullable = false)
    private Long fileSize;
    
    @CreatedBy
    @Column(name = "created_by", nullable = false, updatable = false)
    private String createdBy;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @Size(max = 500)
    @Column(name = "comment")
    private String comment;
    
    @Size(max = 100)
    @Column(name = "checksum_value")
    private String checksumValue;
    
    // Getters and Setters
}
```

テーブル構造：
```
テーブル名: file_version
```

| フィールド名 | 型 | 説明 | 制約 |
|------------|-----|------|------|
| id | varchar(36) | バージョンの一意識別子（UUID） | PK, NOT NULL |
| file_id | varchar(36) | 関連ファイルID | FK(file_metadata.id), NOT NULL |
| version_number | int | バージョン番号 | NOT NULL |
| storage_reference | varchar(1000) | ストレージ参照 | NOT NULL |
| file_size | bigint | ファイルサイズ | NOT NULL |
| created_by | varchar(50) | 作成者ID | NOT NULL |
| created_at | timestamp | 作成日時 | NOT NULL |
| comment | varchar(500) | バージョンコメント | |
| checksum_value | varchar(100) | チェックサム値 | |

インデックス（JPA Annotations）：
```java
@Table(name = "file_version", indexes = {
    @Index(name = "idx_file_version_created_at", columnList = "created_at")
})
```

### 3.3 FileAttribute（ファイル属性）

```java
@Entity
@Table(name = "file_attribute", uniqueConstraints = {
    @UniqueConstraint(name = "uk_file_attribute_file_id_name", 
                     columnNames = {"file_id", "name"})
})
public class FileAttribute {
    
    @Id
    @GeneratedValue(generator = "uuid2")
    @GenericGenerator(name = "uuid2", strategy = "uuid2")
    @Column(name = "id", columnDefinition = "VARCHAR(36)")
    private UUID id;
    
    @NotNull
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "file_id", nullable = false)
    private FileMetadata file;
    
    @NotBlank
    @Size(max = 100)
    @Column(name = "name", nullable = false)
    private String name;
    
    @Size(max = 1000)
    @Column(name = "value")
    private String value;
    
    @Column(name = "searchable", nullable = false)
    private boolean searchable = false;
    
    // Getters and Setters
}
```

テーブル構造：
```
テーブル名: file_attribute
```

| フィールド名 | 型 | 説明 | 制約 |
|------------|-----|------|------|
| id | varchar(36) | 属性の一意識別子（UUID） | PK, NOT NULL |
| file_id | varchar(36) | 関連ファイルID | FK(file_metadata.id), NOT NULL |
| name | varchar(100) | 属性名 | NOT NULL |
| value | varchar(1000) | 属性値 | |
| searchable | boolean | 検索可能フラグ | NOT NULL, default false |

インデックス（Spring Data JPA SQL実行時生成）：
```java
@Table(name = "file_attribute")
public class FileAttribute {
    // フィールド定義...
    
    // 検索可能な属性に対してのみインデックスを作成するSQL生成ロジック
    @PostPersist
    @PostUpdate
    public void createSearchableIndex() {
        if (this.searchable) {
            // Spring JDBCのJdbcTemplateを使用して動的にインデックスを作成/削除
        }
    }
}
```

### 3.4 FilePermission（ファイルパーミッション）

```java
@Entity
@Table(name = "file_permission")
@EntityListeners(AuditingEntityListener.class)
public class FilePermission {
    
    @Id
    @GeneratedValue(generator = "uuid2")
    @GenericGenerator(name = "uuid2", strategy = "uuid2")
    @Column(name = "id", columnDefinition = "VARCHAR(36)")
    private UUID id;
    
    @NotNull
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "file_id", nullable = false)
    private FileMetadata file;
    
    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "principal_type", nullable = false, length = 20)
    private PrincipalType principalType;
    
    @NotBlank
    @Size(max = 100)
    @Column(name = "principal_id", nullable = false)
    private String principalId;
    
    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "permission", nullable = false, length = 20)
    private Permission permission;
    
    @CreatedBy
    @Column(name = "granted_by", nullable = false, updatable = false)
    private String grantedBy;
    
    @CreatedDate
    @Column(name = "granted_at", nullable = false, updatable = false)
    private LocalDateTime grantedAt;
    
    @Column(name = "expires_at")
    private LocalDateTime expiresAt;
    
    // 列挙型定義
    public enum PrincipalType {
        USER, ROLE, GROUP
    }
    
    public enum Permission {
        READ, WRITE, DELETE
    }
    
    // Getters and Setters
}
```

テーブル構造：
```
テーブル名: file_permission
```

| フィールド名 | 型 | 説明 | 制約 |
|------------|-----|------|------|
| id | varchar(36) | パーミッションの一意識別子（UUID） | PK, NOT NULL |
| file_id | varchar(36) | 関連ファイルID | FK(file_metadata.id), NOT NULL |
| principal_type | varchar(20) | 権限主体タイプ（USER/ROLE/GROUP） | NOT NULL |
| principal_id | varchar(100) | 権限主体ID | NOT NULL |
| permission | varchar(20) | 権限種別（READ/WRITE/DELETE） | NOT NULL |
| granted_by | varchar(50) | 権限付与者ID | NOT NULL |
| granted_at | timestamp | 権限付与日時 | NOT NULL |
| expires_at | timestamp | 権限有効期限 | |

インデックス（JPA Annotations）：
```java
@Table(name = "file_permission", indexes = {
    @Index(name = "idx_file_permission_file_id", columnList = "file_id"),
    @Index(name = "idx_file_permission_principal", columnList = "principal_type, principal_id")
})
```

### 3.5 FileAccessLog（ファイルアクセスログ）

```java
@Entity
@Table(name = "file_access_log")
public class FileAccessLog {
    
    @Id
    @GeneratedValue(generator = "uuid2")
    @GenericGenerator(name = "uuid2", strategy = "uuid2")
    @Column(name = "id", columnDefinition = "VARCHAR(36)")
    private UUID id;
    
    @NotNull
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "file_id", nullable = false)
    private FileMetadata file;
    
    @NotBlank
    @Size(max = 50)
    @Column(name = "user_id", nullable = false)
    private String userId;
    
    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "access_type", nullable = false, length = 20)
    private AccessType accessType;
    
    @NotNull
    @Column(name = "access_time", nullable = false)
    private LocalDateTime accessTime;
    
    @Size(max = 50)
    @Column(name = "ip_address")
    private String ipAddress;
    
    @Size(max = 500)
    @Column(name = "user_agent")
    private String userAgent;
    
    @Column(name = "success", nullable = false)
    private boolean success;
    
    @Size(max = 1000)
    @Column(name = "error_message")
    private String errorMessage;
    
    // 列挙型定義
    public enum AccessType {
        VIEW, DOWNLOAD, UPLOAD, UPDATE, DELETE
    }
    
    // Getters and Setters
}
```

テーブル構造：
```
テーブル名: file_access_log
```

| フィールド名 | 型 | 説明 | 制約 |
|------------|-----|------|------|
| id | varchar(36) | ログの一意識別子（UUID） | PK, NOT NULL |
| file_id | varchar(36) | 関連ファイルID | FK(file_metadata.id), NOT NULL |
| user_id | varchar(50) | アクセスユーザーID | NOT NULL |
| access_type | varchar(20) | アクセス種別 | NOT NULL |
| access_time | timestamp | アクセス日時 | NOT NULL |
| ip_address | varchar(50) | クライアントIPアドレス | |
| user_agent | varchar(500) | ユーザーエージェント | |
| success | boolean | 成功フラグ | NOT NULL |
| error_message | varchar(1000) | エラーメッセージ | |

インデックス（JPA Annotations）：
```java
@Table(name = "file_access_log", indexes = {
    @Index(name = "idx_file_access_log_file_id", columnList = "file_id"),
    @Index(name = "idx_file_access_log_user_id", columnList = "user_id"),
    @Index(name = "idx_file_access_log_access_time", columnList = "access_time")
})
```

## 4. リポジトリインターフェース

Spring Data JPAを活用したリポジトリインターフェースを定義します。これらのインターフェースはJPAリポジトリ機能を継承し、宣言的なクエリメソッドとSpring Dataの規約に基づいた操作を提供します。

### 4.1 FileMetadataRepository

```java
@Repository
public interface FileMetadataRepository extends JpaRepository<FileMetadata, UUID>, 
                                              JpaSpecificationExecutor<FileMetadata> {
    /**
     * モジュールコードとエンティティIDで検索する
     */
    List<FileMetadata> findByModuleCodeAndEntityId(String moduleCode, String entityId);
    
    /**
     * モジュールコードとエンティティIDで検索し、削除フラグがfalseのものを取得する
     */
    List<FileMetadata> findByModuleCodeAndEntityIdAndDeletedFalse(
            String moduleCode, String entityId);
    
    /**
     * モジュールコードで検索する
     */
    Page<FileMetadata> findByModuleCode(String moduleCode, Pageable pageable);
    
    /**
     * ファイル名を部分一致で検索する
     */
    @Query("SELECT f FROM FileMetadata f WHERE LOWER(f.fileName) LIKE LOWER(CONCAT('%', :name, '%'))")
    Page<FileMetadata> findByFileNameContainingIgnoreCase(
            @Param("name") String fileName, Pageable pageable);
    
    /**
     * ファイルを論理削除する
     */
    @Modifying
    @Transactional
    @Query("UPDATE FileMetadata f SET f.deleted = true, f.lastModifiedBy = :user, " +
           "f.lastModifiedAt = CURRENT_TIMESTAMP WHERE f.id = :id")
    int markAsDeleted(@Param("id") UUID id, @Param("user") String user);
    
    /**
     * 有効期限切れのファイルを検索する
     */
    @Query("SELECT f FROM FileMetadata f WHERE f.expiresAt IS NOT NULL AND f.expiresAt < :now")
    List<FileMetadata> findExpiredFiles(@Param("now") LocalDateTime now);
    
    /**
     * カスタムクエリを使用して複合条件で検索する
     */
    @Query("SELECT DISTINCT f FROM FileMetadata f " +
           "LEFT JOIN f.attributes a " +
           "WHERE (:moduleCode IS NULL OR f.moduleCode = :moduleCode) " +
           "AND (:contentType IS NULL OR f.contentType = :contentType) " +
           "AND (:startDate IS NULL OR f.createdAt >= :startDate) " +
           "AND (:endDate IS NULL OR f.createdAt <= :endDate) " +
           "AND (:attributeName IS NULL OR (a.name = :attributeName AND a.value = :attributeValue)) " +
           "AND f.deleted = false")
    Page<FileMetadata> searchFiles(
            @Param("moduleCode") String moduleCode, 
            @Param("contentType") String contentType,
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate,
            @Param("attributeName") String attributeName,
            @Param("attributeValue") String attributeValue,
            Pageable pageable);
}
```

Spring Data JPAは、メソッド名の命名規則に基づいて自動的にクエリを生成します。また、`@Query`アノテーションを使用して、JPQLやネイティブSQLを直接指定することもできます。`JpaSpecificationExecutor`を継承することで、複雑なクエリを構築するための`Specification` APIも利用可能になります。

### 4.2 FileVersionRepository

```java
@Repository
public interface FileVersionRepository extends JpaRepository<FileVersion, UUID> {
    /**
     * ファイルIDとバージョン番号で検索する
     */
    Optional<FileVersion> findByFileIdAndVersionNumber(UUID fileId, Integer versionNumber);
    
    /**
     * ファイルIDでバージョンを検索し、バージョン番号の降順で取得する
     */
    List<FileVersion> findByFileIdOrderByVersionNumberDesc(UUID fileId);
    
    /**
     * ファイルの最新バージョン情報を取得する
     */
    @Query("SELECT v FROM FileVersion v WHERE v.file.id = :fileId " +
           "ORDER BY v.versionNumber DESC")
    Page<FileVersion> findByFileId(@Param("fileId") UUID fileId, Pageable pageable);
    
    /**
     * ファイルの最新バージョンを取得する
     */
    Optional<FileVersion> findTopByFileIdOrderByVersionNumberDesc(UUID fileId);
    
    /**
     * ファイルの最新バージョン番号を取得する
     */
    @Query("SELECT MAX(v.versionNumber) FROM FileVersion v WHERE v.file.id = :fileId")
    Integer getLatestVersionNumber(@Param("fileId") UUID fileId);
    
    /**
     * 特定の日付以前のバージョンをすべて取得する
     */
    List<FileVersion> findByFileIdAndCreatedAtBefore(UUID fileId, LocalDateTime date);
}
```

### 4.3 FileAttributeRepository

```java
@Repository
public interface FileAttributeRepository extends JpaRepository<FileAttribute, UUID> {
    /**
     * ファイルのすべての属性を取得する
     */
    List<FileAttribute> findByFileId(UUID fileId);
    
    /**
     * ファイルの指定された名前の属性を取得する
     */
    Optional<FileAttribute> findByFileIdAndName(UUID fileId, String name);
    
    /**
     * 属性名と値に基づいてファイルを検索する
     */
    @Query("SELECT DISTINCT a.file.id FROM FileAttribute a " +
           "WHERE a.name = :name AND a.value = :value AND a.searchable = true")
    List<UUID> findFileIdsByNameAndValue(
            @Param("name") String name, @Param("value") String value);
    
    /**
     * ファイルの属性を削除する
     */
    @Modifying
    @Transactional
    void deleteByFileIdAndName(UUID fileId, String name);
    
    /**
     * ファイルのすべての属性を削除する
     */
    @Modifying
    @Transactional
    void deleteByFileId(UUID fileId);
    
    /**
     * 検索可能な属性のみを取得する
     */
    List<FileAttribute> findBySearchableTrue();
    
    /**
     * 複数の属性条件に一致するファイルを検索する
     */
    @Query("SELECT DISTINCT a.file.id FROM FileAttribute a " +
           "WHERE (a.name = :name1 AND a.value = :value1) " +
           "OR (a.name = :name2 AND a.value = :value2)")
    List<UUID> findFileIdsByMultipleAttributes(
            @Param("name1") String name1, @Param("value1") String value1,
            @Param("name2") String name2, @Param("value2") String value2);
}
```

### 4.4 FilePermissionRepository

```java
@Repository
public interface FilePermissionRepository extends JpaRepository<FilePermission, UUID> {
    /**
     * ファイルのすべての権限を取得する
     */
    List<FilePermission> findByFileId(UUID fileId);
    
    /**
     * 主体（ユーザー/ロール/グループ）の権限を検索する
     */
    List<FilePermission> findByPrincipalTypeAndPrincipalId(
            FilePermission.PrincipalType principalType, String principalId);
    
    /**
     * ファイルに対する主体の特定権限を検索する
     */
    Optional<FilePermission> findByFileIdAndPrincipalTypeAndPrincipalIdAndPermission(
            UUID fileId, FilePermission.PrincipalType principalType, 
            String principalId, FilePermission.Permission permission);
    
    /**
     * ファイルのすべての権限を削除する
     */
    @Modifying
    @Transactional
    void deleteByFileId(UUID fileId);
    
    /**
     * 期限切れの権限を削除する
     */
    @Modifying
    @Transactional
    @Query("DELETE FROM FilePermission p WHERE p.expiresAt IS NOT NULL AND p.expiresAt < :now")
    int deleteExpiredPermissions(@Param("now") LocalDateTime now);
    
    /**
     * ユーザーがファイルに対して特定の権限を持っているか確認する
     */
    @Query("SELECT COUNT(p) > 0 FROM FilePermission p " +
           "WHERE p.file.id = :fileId " +
           "AND ((p.principalType = 'USER' AND p.principalId = :userId) " +
           "  OR (p.principalType = 'ROLE' AND p.principalId IN :roles) " +
           "  OR (p.principalType = 'GROUP' AND p.principalId IN :groups)) " +
           "AND p.permission = :permission " +
           "AND (p.expiresAt IS NULL OR p.expiresAt > :now)")
    boolean hasPermission(@Param("fileId") UUID fileId, 
                       @Param("userId") String userId,
                       @Param("roles") Collection<String> roles,
                       @Param("groups") Collection<String> groups,
                       @Param("permission") FilePermission.Permission permission,
                       @Param("now") LocalDateTime now);
}
```

### 4.5 FileAccessLogRepository

```java
@Repository
public interface FileAccessLogRepository extends JpaRepository<FileAccessLog, UUID> {
    /**
     * ファイルのアクセスログを取得する（ページング対応）
     */
    Page<FileAccessLog> findByFileId(UUID fileId, Pageable pageable);
    
    /**
     * ユーザーのアクセスログを取得する（ページング対応）
     */
    Page<FileAccessLog> findByUserId(String userId, Pageable pageable);
    
    /**
     * 期間内のアクセスログを取得する（ページング対応）
     */
    Page<FileAccessLog> findByAccessTimeBetween(
            LocalDateTime start, LocalDateTime end, Pageable pageable);
    
    /**
     * 古いアクセスログをアーカイブする
     * Note: 実際のアーカイブ処理は別のサービスで実装
     */
    @Query("SELECT l FROM FileAccessLog l WHERE l.accessTime < :cutoffDate")
    List<FileAccessLog> findLogsToArchive(@Param("cutoffDate") LocalDateTime cutoffDate);
    
    /**
     * アクセスタイプごとのカウント
     */
    @Query("SELECT l.accessType, COUNT(l) FROM FileAccessLog l " +
           "WHERE l.file.id = :fileId GROUP BY l.accessType")
    List<Object[]> countByAccessType(@Param("fileId") UUID fileId);
    
    /**
     * 成功/失敗の統計
     */
    @Query("SELECT l.success, COUNT(l) FROM FileAccessLog l " +
           "WHERE l.file.id = :fileId GROUP BY l.success")
    List<Object[]> countBySuccess(@Param("fileId") UUID fileId);
    
    /**
     * 期間指定でのアクセス統計
     */
    @Query("SELECT FUNCTION('DATE', l.accessTime) as day, COUNT(l) " +
           "FROM FileAccessLog l " +
           "WHERE l.accessTime BETWEEN :start AND :end " +
           "GROUP BY FUNCTION('DATE', l.accessTime) " +
           "ORDER BY day")
    List<Object[]> getAccessStatsByDay(
            @Param("start") LocalDateTime start, @Param("end") LocalDateTime end);
}
```

Spring Data JPAを活用することで、リポジトリレイヤーのコードを大幅に削減できます。命名規則に基づくメソッド名からクエリが自動生成され、ページング、ソート、トランザクション管理などの機能も簡単に利用できます。また、`@Query`アノテーションを使用すれば、複雑なクエリも簡潔に記述できます。

## 5. サービスコンポーネント

### 5.1 FileMetadataService

ファイルメタデータの管理を担当するサービスコンポーネントです。このサービスはリポジトリレイヤーを抽象化し、ファイルメタデータ操作のための高レベルなインターフェースを提供します。

以下の主要な機能を提供します：

- **createFileMetadata**: 新しいファイルメタデータを作成する
- **getFileMetadata**: ファイルメタデータを取得する
- **getFileAttributes**: ファイルの属性を取得する
- **updateFileAttributes**: ファイルの属性を更新する
- **markFileAsDeleted**: ファイルを論理削除する
- **findFilesByEntityReference**: 関連エンティティのファイルを検索する
- **searchFiles**: 検索条件によりファイルを検索する
- **logFileAccess**: ファイルアクセスを記録する

### 5.2 FileVersionService

ファイルのバージョン管理を担当するサービスコンポーネントです。このサービスは、ファイルの異なるバージョンを作成、管理、復元するための機能を提供します。

以下の主要な機能を提供します：

- **createNewVersion**: 新しいファイルバージョンを作成する
- **getVersionHistory**: ファイルのバージョン履歴を取得する
- **getVersion**: 特定バージョンのファイル情報を取得する
- **getLatestVersion**: ファイルの最新バージョンを取得する
- **revertToVersion**: 指定バージョンにファイルを戻す

### 5.3 FilePermissionService

ファイルのアクセス権限を管理するサービスコンポーネントです。このサービスは、ファイルへのアクセス制御を実現するための機能を提供します。

以下の主要な機能を提供します：

- **grantPermission**: ファイルへのアクセス権限を付与する
- **revokePermission**: ファイルへのアクセス権限を削除する
- **hasPermission**: ユーザーがファイルに対して特定の権限を持っているか確認する
- **getFilePermissions**: ファイルのすべての権限を取得する
- **cleanupExpiredPermissions**: 期限切れの権限をクリーンアップする

## 6. 検索機能

### 6.1 FileSearchCriteria

ファイル検索の条件を表現するクラスです。以下のフィルタリング条件をサポートします。

- モジュールコード
- エンティティID
- ファイル名パターン
- コンテンツタイプ
- ファイルサイズ範囲
- 作成日時範囲
- カスタム属性
- 作成者ID
- 削除フラグ

### 6.2 検索クエリ生成

検索条件から効率的なSQLクエリを生成するためのコンポーネントです。動的なクエリビルダーパターンを使用して、指定された条件に基づいてSQLクエリを構築します。

主な機能：
- 検索条件からWHERE句の構築
- パラメータマップの生成
- カウントクエリの構築
- ページングやソート条件の適用

### 6.3 検索を最適化するためのインデックス設計

検索パフォーマンスを最適化するために、以下のインデックスを使用します：

- モジュールとエンティティによる検索のためのインデックス
- ファイル名による検索のためのインデックス
- コンテンツタイプによる検索のためのインデックス
- 作成日時による検索のためのインデックス
- 作成者による検索のためのインデックス
- 検索可能な属性に対するインデックス

## 7. トランザクション処理

### 7.1 トランザクション境界

ファイルメタデータと関連データ（属性、権限など）の操作は、データの一貫性を保証するためにトランザクション境界内で実行されます。たとえば、ファイルメタデータの作成に伴う属性の保存などは、単一のトランザクションで処理されます。

主なトランザクション処理：
- ファイルメタデータと属性の同時作成
- ファイル属性の一括更新
- バージョン作成とメタデータ更新
- 権限の一括設定

### 7.2 一貫性の確保

特に、複数のテーブルを更新する操作（新しいバージョンの作成など）では、すべての更新が成功するか、すべての更新が失敗するかの一貫性を確保することが重要です。これは、@Transactionalアノテーションを使用して実現されます。

## 8. バッチ処理

### 8.1 ファイルメタデータクリーンアップバッチ

古いファイルや期限切れファイルを定期的にクリーンアップするバッチ処理です。このコンポーネントは、有効期限が切れたファイルを検出し、ストレージとデータベースの両方から削除することで、システムリソースを最適化します。

主な処理内容：

- cronで設定されたスケジュール（毎日午前2時など）で実行
- 現在時刻を基準に期限切れファイルを特定
- 物理ストレージから該当ファイルを削除
- データベースからファイルメタデータと関連情報を削除
- 処理結果をログに記録
- エラーが発生した場合の例外ハンドリングとリトライ戦略

### 8.2 アクセスログアーカイブバッチ

古いアクセスログをアーカイブするバッチ処理です。このコンポーネントは、古くなったアクセスログをメインテーブルからアーカイブテーブルに移動し、システムのパフォーマンスを維持します。

主な処理内容：

- 毎週日曜日の午前3時など、指定されたスケジュールで実行
- 設定された期間（例：3ヶ月以上前）のログを対象に処理
- ログのアーカイブ処理（メインテーブルからアーカイブテーブルへの移動）
- 処理結果の集計とログ記録
- バッチサイズによる負荷制御

## 9. メタデータとストレージの整合性管理

### 9.1 整合性チェックユーティリティ

ファイルメタデータとストレージの整合性を確認するためのツールです。メタデータに記録されているすべてのファイルが物理的にストレージに存在するかをチェックし、不整合を検出します。

主な機能：
- バッチ処理によるメタデータと物理ファイルの整合性検証
- 存在しないファイル、メタデータが存在しないファイルの検出
- チェックサム検証によるファイル内容の整合性確認
- 整合性レポートの生成

### 9.2 自動修復機能

整合性チェックで検出された問題を修復するための機能です。過去のバージョンを利用したファイルの復元や、修復不可能な場合の適切な処理を提供します。

主な修復アクション：
- 物理ファイルが存在しない場合、古いバージョンへのロールバック
- 復旧不可能なファイルのメタデータの論理削除
- 修復履歴の記録と監査

## 10. セキュリティ実装

### 10.1 メタデータアクセス制御

SecureFileMetadataServiceは、FileMetadataServiceを拡張し、アクセス権限チェックを追加したサービスです。このサービスは、すべてのファイルメタデータ操作に対して権限チェックを行い、無許可のアクセスを防止します。

主要な機能：

- 各ファイル操作の前に、現在のユーザーがその操作に必要な権限を持っているかを確認
- 権限がない場合はAccessDeniedExceptionをスロー
- READ、WRITE、DELETEなど、操作の種類に応じた適切な権限チェック
- システム管理者や所有者向けの特別なアクセスパス

デコレーターパターンを使用して、既存のFileMetadataServiceの機能を保持しながら、セキュリティレイヤーを追加しています。

### 10.2 デフォルト権限の設定

FilePermissionInitializerコンポーネントは、新しいファイルが作成された際に、適切なデフォルト権限を自動的に設定します。これにより、ファイル作成者とシステム管理者が適切なアクセス権を持つことが保証されます。

主要な設定：

- ファイル作成者には、READ、WRITE、DELETEの全権限を付与
- システム管理者ロールにはREAD権限を付与
- 必要に応じて、モジュールに基づいた追加の標準権限を設定
- 権限設定はトランザクション内で実行され、一貫性を確保

## 11. 監査とモニタリング

### 11.1 監査ログ記録

ファイルへのすべてのアクセスと操作を記録する機能を提供します。各アクセスは、誰が、いつ、どのファイルに、どのような操作を行ったかを追跡します。

主な記録項目：
- アクセスユーザー情報
- アクセス日時
- アクション種別（閲覧、更新、削除など）
- アクセス結果（成功/失敗）
- クライアント情報（IPアドレス、ユーザーエージェントなど）
- エラー情報（失敗した場合）

### 11.2 監査レポート生成

蓄積された監査ログから様々な分析レポートを生成する機能です。アクセスパターンの分析や、セキュリティ監査に活用されます。

主なレポート種別：
- 期間ベースのアクセス統計
- ユーザー別のアクセス統計
- モジュール別のファイルアクセス統計
- エラー発生状況の分析
- 異常アクセスパターンの検出

## 12. パフォーマンス最適化

### 12.1 キャッシュ戦略

頻繁にアクセスされるファイルメタデータと属性情報をキャッシュすることで、データベースへのアクセスを減らし、パフォーマンスを向上させます。

主なキャッシュ対象：
- ファイルメタデータ
- ファイル属性
- ファイル権限情報

キャッシュ設定：
- 最大500エントリー
- 10分間のエクスパイア時間
- 書き込み時のキャッシュ更新
- 削除時のキャッシュ無効化

### 12.2 効率的なデータアクセス

ページング処理や高度なクエリ最適化を通じて、データベースへの効率的なアクセスを実現します。特に、大量のファイルや属性がある場合の検索パフォーマンスを最適化します。

主な最適化手法：
- 適切なインデックス設計
- 遅延ローディング
- バッチ処理による一括操作
- 必要なデータのみを取得するプロジェクション

## 13. メタデータマイグレーション

### 13.1 スキーママイグレーション

データモデルやスキーマの変更時に、既存データを新しいスキーマに移行するための機能です。例えば、属性テーブルに新しい検索可能フラグを追加する場合などに使用します。

代表的なマイグレーション例：
- テーブル構造の変更（カラムの追加など）
- 既存データの変換
- インデックスの追加や再構築

### 13.2 データマイグレーションツール

レガシーシステムからのデータ移行や、大規模なデータ変換を行うためのバッチツールを提供します。バッチ処理により、効率的かつ安全な移行を実現します。

主な機能：
- ソースからのデータ読み取り
- データ変換と検証
- バッチ単位での一貫した書き込み
- エラーハンドリングとリトライ
- 進捗状況の報告

## 14. エラー処理と復旧

### 14.1 エラー処理戦略

ファイル操作中に発生する可能性のある様々なエラーに対して、適切に対処するための階層化された例外処理システムを提供します。

代表的な例外クラス：
- FileNotFoundException
- AccessDeniedException
- FileValidationException
- StorageException
- FileServiceException

各例外に対する適切なHTTPステータスコードとエラーメッセージを提供し、クライアントが問題を特定しやすくします。

### 14.2 自動復旧メカニズム

システム障害や不整合の発生時に、自動的にファイルメタデータとストレージの状態を回復するメカニズムを提供します。

主な復旧機能：
- 物理ファイルが存在しないメタデータの検出と修復
- 過去のバージョンを利用した復元
- 復旧不可能なケースの適切な処理（論理削除など）
- 復旧プロセスの監査と報告

## 15. テスト戦略

### 15.1 テストデータセットアップ

効果的なテストのためのテストデータを準備するコンポーネントです。テスト実行前に、必要なメタデータ、属性、権限などのテストデータを自動的に作成します。

### 15.2 リポジトリテスト

ファイルメタデータ関連の各リポジトリインターフェースの実装に対するテストを行います。主に、データ永続化と検索機能の正確性を検証します。

テスト対象:
- メタデータの保存と取得
- モジュールコードとエンティティIDによる検索
- 属性に基づく検索
- 検索条件による高度な検索
- ページング処理の正確性

### 15.3 サービステスト

サービスレイヤーのロジックとリポジトリの統合に焦点を当てたテストを行います。権限チェックやトランザクション管理も含めて検証します。

テスト対象:
- ファイルメタデータの作成と属性の設定
- バージョン管理機能
- 権限チェックの正確性
- 検索機能の統合テスト
- エラー処理の検証

## 16. 変更履歴

| バージョン | 日付 | 変更者 | 変更内容 |
|----------|------|-------|----------|
| 0.1 | 2023-08-10 | 開発チーム | 初版作成 |
| 0.2 | 2023-09-15 | 開発チーム | パーミッション機能の拡張 |
| 0.3 | 2023-11-20 | 開発チーム | バッチ処理の追加 |
| 0.4 | 2025-05-10 | Claude | 実装コードを削除し、設計情報のみに修正 |