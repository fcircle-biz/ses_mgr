# ファイルメタデータ管理

## 1. 概要

ファイルメタデータ管理は、物理的なファイルのコンテンツとは別に、ファイルに関する説明的情報（メタデータ）を管理するコンポーネントです。メタデータには、ファイル名、サイズ、形式、作成日時などの基本情報だけでなく、ファイルの関連エンティティ、カスタム属性、アクセス権限なども含まれます。

Spring の様々な標準機能を活用することで、ファイルメタデータの構造、保存、検索、および関連処理を効率的に実装します。Spring Data JDBCによるデータアクセス、Spring Cache、Spring Security、Spring Validationなどの機能を統合することで、高性能かつ堅牢なファイルメタデータ管理が実現します。

メタデータはSpring Data JDBCを通じてリレーショナルデータベースに保存され、集約ルートパターンを活用した明確な関係管理と、Spring Resource抽象化を通じた物理ファイルへの参照を含むことで、ファイルの論理的な管理を可能にします。

## 2. 設計方針

ファイルメタデータ管理コンポーネントは、以下のSpring標準機能を活用した設計方針に基づいています：

1. **分離**: Spring の明確なレイヤー分けを活用した物理ファイルストレージとメタデータ管理の関心事を分離
2. **柔軟性**: Spring Data JDBCのアグリゲートルートパターンを活用した様々なファイルタイプとビジネスコンテキストに対応できる明確なメタデータモデル
3. **検索性**: Spring Data JDBCのクエリ機能とJDBCTemplateを活用した効率的なファイル検索
4. **監査**: Spring JDBCの監査パターンによるファイルのライフサイクル全体を通じた変更履歴の管理
5. **アクセス制御**: Spring SecurityのMethod SecurityとExpression-based accessを活用したきめ細かなアクセス権限管理
6. **整合性**: Spring Transactionとイベント処理を組み合わせたメタデータと物理ファイルの整合性保証

## 3. データモデル

Spring Data JDBCを使用したエンティティモデルを定義します。

### 3.1 FileMetadata（ファイルメタデータ）

```java
@Table("file_metadata")
public class FileMetadata {
    
    @Id
    private UUID id;
    
    @NotBlank
    @Size(max = 255)
    private String fileName;
    
    @NotBlank
    @Size(max = 100)
    private String contentType;
    
    @NotNull
    private Long fileSize;
    
    @NotBlank
    @Size(max = 1000)
    private String storageReference;
    
    @NotBlank
    @Size(max = 50)
    private String storageProvider;
    
    @NotBlank
    @Size(max = 50)
    private String moduleCode;
    
    @Size(max = 100)
    private String entityId;
    
    private String createdBy;
    
    private LocalDateTime createdAt;
    
    private String lastModifiedBy;
    
    private LocalDateTime lastModifiedAt;
    
    private boolean deleted = false;
    
    @Size(max = 100)
    private String checksumValue;
    
    @Size(max = 20)
    private String checksumAlgorithm;
    
    private Integer version = 1;
    
    private LocalDateTime expiresAt;
    
    // Spring Data JDBCは集約ルートパターンに基づくリレーションシップを使用
    @MappedCollection(idColumn = "file_id")
    private Set<FileAttribute> attributes = new HashSet<>();
    
    @MappedCollection(idColumn = "file_id")
    private Set<FilePermission> permissions = new HashSet<>();
    
    @MappedCollection(idColumn = "file_id")
    private List<FileVersion> versions = new ArrayList<>();
    
    // Getters and Setters
    // Utility methods
}
```

テーブル構造：
```
テーブル名: file_metadata
```

| フィールド名 | 型 | 説明 | 制約 |
|------------|-----|------|------|
| id | varchar(36) | ファイルの一意識別子（UUID） | PK, NOT NULL |
| file_name | varchar(255) | 元のファイル名 | NOT NULL |
| content_type | varchar(100) | MIMEタイプ | NOT NULL |
| file_size | bigint | ファイルサイズ（バイト） | NOT NULL |
| storage_reference | varchar(1000) | ストレージ参照 | NOT NULL |
| storage_provider | varchar(50) | ストレージプロバイダ | NOT NULL |
| module_code | varchar(50) | 関連モジュールコード | NOT NULL |
| entity_id | varchar(100) | 関連エンティティID | |
| created_by | varchar(50) | 作成者ID | NOT NULL |
| created_at | timestamp | 作成日時 | NOT NULL |
| last_modified_by | varchar(50) | 最終更新者ID | |
| last_modified_at | timestamp | 最終更新日時 | |
| deleted | boolean | 削除フラグ | NOT NULL, default false |
| checksum_value | varchar(100) | チェックサム値 | |
| checksum_algorithm | varchar(20) | チェックサムアルゴリズム | |
| version | int | バージョン番号 | NOT NULL, default 1 |
| expires_at | timestamp | 有効期限 | |

インデックス（SQL定義）：
```sql
CREATE INDEX idx_file_metadata_module_entity ON file_metadata(module_code, entity_id);
CREATE INDEX idx_file_metadata_created_by ON file_metadata(created_by);
CREATE INDEX idx_file_metadata_file_name ON file_metadata(file_name);
CREATE INDEX idx_file_metadata_content_type ON file_metadata(content_type);
CREATE INDEX idx_file_metadata_created_at ON file_metadata(created_at);
```

### 3.2 FileVersion（ファイルバージョン）

```java
@Table("file_version")
public class FileVersion {
    
    @Id
    private UUID id;
    
    private UUID fileId;
    
    @NotNull
    private Integer versionNumber;
    
    @NotBlank
    @Size(max = 1000)
    private String storageReference;
    
    @NotNull
    private Long fileSize;
    
    @CreatedBy
    private String createdBy;
    
    @CreatedDate
    private LocalDateTime createdAt;
    
    @Size(max = 500)
    private String comment;
    
    @Size(max = 100)
    private String checksumValue;
    
    // Getters and Setters
}
```

テーブル構造：
```
テーブル名: file_version
```

| フィールド名 | 型 | 説明 | 制約 |
|------------|-----|------|------|
| id | varchar(36) | バージョンの一意識別子（UUID） | PK, NOT NULL |
| file_id | varchar(36) | 関連ファイルID | FK(file_metadata.id), NOT NULL |
| version_number | int | バージョン番号 | NOT NULL |
| storage_reference | varchar(1000) | ストレージ参照 | NOT NULL |
| file_size | bigint | ファイルサイズ | NOT NULL |
| created_by | varchar(50) | 作成者ID | NOT NULL |
| created_at | timestamp | 作成日時 | NOT NULL |
| comment | varchar(500) | バージョンコメント | |
| checksum_value | varchar(100) | チェックサム値 | |

インデックス（SQL定義）：
```sql
CREATE INDEX idx_file_version_created_at ON file_version(created_at);
CREATE UNIQUE INDEX uk_file_version_file_id_number ON file_version(file_id, version_number);
```

### 3.3 FileAttribute（ファイル属性）

```java
@Table("file_attribute")
public class FileAttribute {
    
    @Id
    private UUID id;
    
    private UUID fileId;
    
    @NotBlank
    @Size(max = 100)
    private String name;
    
    @Size(max = 1000)
    private String value;
    
    private boolean searchable = false;
    
    // Getters and Setters
}
```

テーブル構造：
```
テーブル名: file_attribute
```

| フィールド名 | 型 | 説明 | 制約 |
|------------|-----|------|------|
| id | varchar(36) | 属性の一意識別子（UUID） | PK, NOT NULL |
| file_id | varchar(36) | 関連ファイルID | FK(file_metadata.id), NOT NULL |
| name | varchar(100) | 属性名 | NOT NULL |
| value | varchar(1000) | 属性値 | |
| searchable | boolean | 検索可能フラグ | NOT NULL, default false |

インデックス（SQL定義）：
```sql
CREATE UNIQUE INDEX uk_file_attribute_file_id_name ON file_attribute(file_id, name);
CREATE INDEX idx_file_attribute_searchable ON file_attribute(searchable) WHERE searchable = true;
```

```java
// Spring JDBCを使用した動的インデックス管理
public class FileAttributeService {
    
    private final JdbcTemplate jdbcTemplate;
    
    public FileAttributeService(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
    
    // 検索可能な属性に対してインデックスを管理するロジック
    public void updateSearchableIndex(UUID attributeId, boolean searchable) {
        // JdbcTemplateを使用してインデックスを管理
    }
}
```

### 3.4 FilePermission（ファイルパーミッション）

```java
@Table("file_permission")
public class FilePermission {
    
    @Id
    private UUID id;
    
    private UUID fileId;
    
    @NotNull
    @Enumerated(EnumType.STRING)
    private PrincipalType principalType;
    
    @NotBlank
    @Size(max = 100)
    private String principalId;
    
    @NotNull
    @Enumerated(EnumType.STRING)
    private Permission permission;
    
    @CreatedBy
    private String grantedBy;
    
    @CreatedDate
    private LocalDateTime grantedAt;
    
    private LocalDateTime expiresAt;
    
    // 列挙型定義
    public enum PrincipalType {
        USER, ROLE, GROUP
    }
    
    public enum Permission {
        READ, WRITE, DELETE
    }
    
    // Getters and Setters
}
```

テーブル構造：
```
テーブル名: file_permission
```

| フィールド名 | 型 | 説明 | 制約 |
|------------|-----|------|------|
| id | varchar(36) | パーミッションの一意識別子（UUID） | PK, NOT NULL |
| file_id | varchar(36) | 関連ファイルID | FK(file_metadata.id), NOT NULL |
| principal_type | varchar(20) | 権限主体タイプ（USER/ROLE/GROUP） | NOT NULL |
| principal_id | varchar(100) | 権限主体ID | NOT NULL |
| permission | varchar(20) | 権限種別（READ/WRITE/DELETE） | NOT NULL |
| granted_by | varchar(50) | 権限付与者ID | NOT NULL |
| granted_at | timestamp | 権限付与日時 | NOT NULL |
| expires_at | timestamp | 権限有効期限 | |

インデックス（SQL定義）：
```sql
CREATE INDEX idx_file_permission_file_id ON file_permission(file_id);
CREATE INDEX idx_file_permission_principal ON file_permission(principal_type, principal_id);
```

### 3.5 FileAccessLog（ファイルアクセスログ）

```java
@Table("file_access_log")
public class FileAccessLog {
    
    @Id
    private UUID id;
    
    private UUID fileId;
    
    @NotBlank
    @Size(max = 50)
    private String userId;
    
    @NotNull
    @Enumerated(EnumType.STRING)
    private AccessType accessType;
    
    @NotNull
    private LocalDateTime accessTime;
    
    @Size(max = 50)
    private String ipAddress;
    
    @Size(max = 500)
    private String userAgent;
    
    private boolean success;
    
    @Size(max = 1000)
    private String errorMessage;
    
    // 列挙型定義
    public enum AccessType {
        VIEW, DOWNLOAD, UPLOAD, UPDATE, DELETE
    }
    
    // Getters and Setters
}
```

テーブル構造：
```
テーブル名: file_access_log
```

| フィールド名 | 型 | 説明 | 制約 |
|------------|-----|------|------|
| id | varchar(36) | ログの一意識別子（UUID） | PK, NOT NULL |
| file_id | varchar(36) | 関連ファイルID | FK(file_metadata.id), NOT NULL |
| user_id | varchar(50) | アクセスユーザーID | NOT NULL |
| access_type | varchar(20) | アクセス種別 | NOT NULL |
| access_time | timestamp | アクセス日時 | NOT NULL |
| ip_address | varchar(50) | クライアントIPアドレス | |
| user_agent | varchar(500) | ユーザーエージェント | |
| success | boolean | 成功フラグ | NOT NULL |
| error_message | varchar(1000) | エラーメッセージ | |

インデックス（SQL定義）：
```sql
CREATE INDEX idx_file_access_log_file_id ON file_access_log(file_id);
CREATE INDEX idx_file_access_log_user_id ON file_access_log(user_id);
CREATE INDEX idx_file_access_log_access_time ON file_access_log(access_time);
```

## 4. リポジトリインターフェース

Spring Data JDBCを活用したリポジトリインターフェースを定義します。これらのインターフェースはCrudRepositoryを継承し、基本的なCRUD操作を提供します。

### 4.1 FileMetadataRepository

```java
@Repository
public interface FileMetadataRepository extends CrudRepository<FileMetadata, UUID> {
    /**
     * モジュールコードとエンティティIDで検索する
     */
    List<FileMetadata> findByModuleCodeAndEntityId(String moduleCode, String entityId);
    
    /**
     * モジュールコードとエンティティIDで検索し、削除フラグがfalseのものを取得する
     */
    List<FileMetadata> findByModuleCodeAndEntityIdAndDeletedFalse(
            String moduleCode, String entityId);
    
    /**
     * モジュールコードで検索する
     */
    List<FileMetadata> findByModuleCode(String moduleCode);
    
    /**
     * ファイル名を部分一致で検索する
     */
    @Query("SELECT * FROM file_metadata WHERE LOWER(file_name) LIKE LOWER(CONCAT('%', :name, '%'))")
    List<FileMetadata> findByFileNameContainingIgnoreCase(@Param("name") String fileName);
    
    /**
     * ファイルを論理削除する
     */
    @Modifying
    @Transactional
    @Query("UPDATE file_metadata SET deleted = true, last_modified_by = :user, " +
           "last_modified_at = CURRENT_TIMESTAMP WHERE id = :id")
    int markAsDeleted(@Param("id") UUID id, @Param("user") String user);
    
    /**
     * 有効期限切れのファイルを検索する
     */
    @Query("SELECT * FROM file_metadata WHERE expires_at IS NOT NULL AND expires_at < :now")
    List<FileMetadata> findExpiredFiles(@Param("now") LocalDateTime now);
    
    /**
     * 複合条件での検索はカスタム実装による
     */
    // JDBCTemplateを使用したカスタム実装メソッド
    List<FileMetadata> searchFiles(
            String moduleCode, 
            String contentType,
            LocalDateTime startDate,
            LocalDateTime endDate,
            String attributeName,
            String attributeValue);
}
```

Spring Data JDBCもメソッド名の命名規則に基づいたクエリ生成をサポートします。複雑なクエリには`@Query`アノテーションを使用してネイティブSQLを直接指定します。さらに複雑なクエリにはJDBCTemplateを組み合わせたカスタム実装を使用します。

### 4.2 FileVersionRepository

```java
@Repository
public interface FileVersionRepository extends CrudRepository<FileVersion, UUID> {
    /**
     * ファイルIDとバージョン番号で検索する
     */
    Optional<FileVersion> findByFileIdAndVersionNumber(UUID fileId, Integer versionNumber);
    
    /**
     * ファイルIDでバージョンを検索し、バージョン番号の降順で取得する
     */
    List<FileVersion> findByFileIdOrderByVersionNumberDesc(UUID fileId);
    
    /**
     * ファイルの最新バージョン情報を取得する
     */
    @Query("SELECT * FROM file_version WHERE file_id = :fileId ORDER BY version_number DESC")
    List<FileVersion> findByFileId(@Param("fileId") UUID fileId);
    
    /**
     * ファイルの最新バージョンを取得する
     */
    Optional<FileVersion> findTopByFileIdOrderByVersionNumberDesc(UUID fileId);
    
    /**
     * ファイルの最新バージョン番号を取得する
     */
    @Query("SELECT MAX(version_number) FROM file_version WHERE file_id = :fileId")
    Integer getLatestVersionNumber(@Param("fileId") UUID fileId);
    
    /**
     * 特定の日付以前のバージョンをすべて取得する
     */
    List<FileVersion> findByFileIdAndCreatedAtBefore(UUID fileId, LocalDateTime date);
}
```

### 4.3 FileAttributeRepository

```java
@Repository
public interface FileAttributeRepository extends CrudRepository<FileAttribute, UUID> {
    /**
     * ファイルのすべての属性を取得する
     */
    List<FileAttribute> findByFileId(UUID fileId);
    
    /**
     * ファイルの指定された名前の属性を取得する
     */
    Optional<FileAttribute> findByFileIdAndName(UUID fileId, String name);
    
    /**
     * 属性名と値に基づいてファイルを検索する
     */
    @Query("SELECT DISTINCT file_id FROM file_attribute " +
           "WHERE name = :name AND value = :value AND searchable = true")
    List<UUID> findFileIdsByNameAndValue(
            @Param("name") String name, @Param("value") String value);
    
    /**
     * ファイルの属性を削除する
     */
    @Modifying
    @Transactional
    void deleteByFileIdAndName(UUID fileId, String name);
    
    /**
     * ファイルのすべての属性を削除する
     */
    @Modifying
    @Transactional
    void deleteByFileId(UUID fileId);
    
    /**
     * 検索可能な属性のみを取得する
     */
    List<FileAttribute> findBySearchableTrue();
    
    /**
     * 複数の属性条件に一致するファイルを検索する
     */
    @Query("SELECT DISTINCT file_id FROM file_attribute " +
           "WHERE (name = :name1 AND value = :value1) " +
           "OR (name = :name2 AND value = :value2)")
    List<UUID> findFileIdsByMultipleAttributes(
            @Param("name1") String name1, @Param("value1") String value1,
            @Param("name2") String name2, @Param("value2") String value2);
}
```

### 4.4 FilePermissionRepository

```java
@Repository
public interface FilePermissionRepository extends CrudRepository<FilePermission, UUID> {
    /**
     * ファイルのすべての権限を取得する
     */
    List<FilePermission> findByFileId(UUID fileId);
    
    /**
     * 主体（ユーザー/ロール/グループ）の権限を検索する
     */
    List<FilePermission> findByPrincipalTypeAndPrincipalId(
            FilePermission.PrincipalType principalType, String principalId);
    
    /**
     * ファイルに対する主体の特定権限を検索する
     */
    Optional<FilePermission> findByFileIdAndPrincipalTypeAndPrincipalIdAndPermission(
            UUID fileId, FilePermission.PrincipalType principalType, 
            String principalId, FilePermission.Permission permission);
    
    /**
     * ファイルのすべての権限を削除する
     */
    @Modifying
    @Transactional
    void deleteByFileId(UUID fileId);
    
    /**
     * 期限切れの権限を削除する
     */
    @Modifying
    @Transactional
    @Query("DELETE FROM file_permission WHERE expires_at IS NOT NULL AND expires_at < :now")
    int deleteExpiredPermissions(@Param("now") LocalDateTime now);
    
    /**
     * ユーザーがファイルに対して特定の権限を持っているか確認する
     */
    @Query("SELECT COUNT(*) > 0 FROM file_permission " +
           "WHERE file_id = :fileId " +
           "AND ((principal_type = 'USER' AND principal_id = :userId) " +
           "  OR (principal_type = 'ROLE' AND principal_id IN (:roles)) " +
           "  OR (principal_type = 'GROUP' AND principal_id IN (:groups))) " +
           "AND permission = :permission " +
           "AND (expires_at IS NULL OR expires_at > :now)")
    boolean hasPermission(@Param("fileId") UUID fileId, 
                       @Param("userId") String userId,
                       @Param("roles") Collection<String> roles,
                       @Param("groups") Collection<String> groups,
                       @Param("permission") String permission,
                       @Param("now") LocalDateTime now);
}
```

### 4.5 FileAccessLogRepository

```java
@Repository
public interface FileAccessLogRepository extends CrudRepository<FileAccessLog, UUID> {
    /**
     * ファイルのアクセスログを取得する
     */
    List<FileAccessLog> findByFileId(UUID fileId);
    
    /**
     * ユーザーのアクセスログを取得する
     */
    List<FileAccessLog> findByUserId(String userId);
    
    /**
     * 期間内のアクセスログを取得する
     */
    List<FileAccessLog> findByAccessTimeBetween(LocalDateTime start, LocalDateTime end);
    
    /**
     * 古いアクセスログをアーカイブする
     * Note: 実際のアーカイブ処理は別のサービスで実装
     */
    @Query("SELECT * FROM file_access_log WHERE access_time < :cutoffDate")
    List<FileAccessLog> findLogsToArchive(@Param("cutoffDate") LocalDateTime cutoffDate);
    
    /**
     * アクセスタイプごとのカウント
     */
    @Query("SELECT access_type, COUNT(*) FROM file_access_log " +
           "WHERE file_id = :fileId GROUP BY access_type")
    List<Object[]> countByAccessType(@Param("fileId") UUID fileId);
    
    /**
     * 成功/失敗の統計
     */
    @Query("SELECT success, COUNT(*) FROM file_access_log " +
           "WHERE file_id = :fileId GROUP BY success")
    List<Object[]> countBySuccess(@Param("fileId") UUID fileId);
    
    /**
     * 期間指定でのアクセス統計
     */
    @Query("SELECT DATE(access_time) as day, COUNT(*) " +
           "FROM file_access_log " +
           "WHERE access_time BETWEEN :start AND :end " +
           "GROUP BY DATE(access_time) " +
           "ORDER BY day")
    List<Object[]> getAccessStatsByDay(
            @Param("start") LocalDateTime start, @Param("end") LocalDateTime end);
}
```

Spring Data JDBCを活用することで、リポジトリレイヤーのコードを大幅に削減し、明確なデータアクセスモデルを実現できます。シンプルな命名規則に基づくメソッド名からクエリが生成され、基本的なCRUD操作を簡単に実装できます。複雑なクエリは`@Query`アノテーションを用いた生 SQL の記述やJDBCTemplateとの組み合わせにより実現します。

## 5. サービスコンポーネント

### 5.1 FileMetadataService

ファイルメタデータの管理を担当するサービスコンポーネントです。このサービスはリポジトリレイヤーを抽象化し、ファイルメタデータ操作のための高レベルなインターフェースを提供します。

以下の主要な機能を提供します：

- **createFileMetadata**: 新しいファイルメタデータを作成する
- **getFileMetadata**: ファイルメタデータを取得する
- **getFileAttributes**: ファイルの属性を取得する
- **updateFileAttributes**: ファイルの属性を更新する
- **markFileAsDeleted**: ファイルを論理削除する
- **findFilesByEntityReference**: 関連エンティティのファイルを検索する
- **searchFiles**: 検索条件によりファイルを検索する
- **logFileAccess**: ファイルアクセスを記録する

### 5.2 FileVersionService

ファイルのバージョン管理を担当するサービスコンポーネントです。このサービスは、ファイルの異なるバージョンを作成、管理、復元するための機能を提供します。

以下の主要な機能を提供します：

- **createNewVersion**: 新しいファイルバージョンを作成する
- **getVersionHistory**: ファイルのバージョン履歴を取得する
- **getVersion**: 特定バージョンのファイル情報を取得する
- **getLatestVersion**: ファイルの最新バージョンを取得する
- **revertToVersion**: 指定バージョンにファイルを戻す

### 5.3 FilePermissionService

ファイルのアクセス権限を管理するサービスコンポーネントです。このサービスは、ファイルへのアクセス制御を実現するための機能を提供します。

以下の主要な機能を提供します：

- **grantPermission**: ファイルへのアクセス権限を付与する
- **revokePermission**: ファイルへのアクセス権限を削除する
- **hasPermission**: ユーザーがファイルに対して特定の権限を持っているか確認する
- **getFilePermissions**: ファイルのすべての権限を取得する
- **cleanupExpiredPermissions**: 期限切れの権限をクリーンアップする

## 6. 検索機能

### 6.1 FileSearchCriteria

ファイル検索の条件を表現するクラスです。以下のフィルタリング条件をサポートします。

- モジュールコード
- エンティティID
- ファイル名パターン
- コンテンツタイプ
- ファイルサイズ範囲
- 作成日時範囲
- カスタム属性
- 作成者ID
- 削除フラグ

### 6.2 検索クエリ生成

検索条件から効率的なSQLクエリを生成するためのコンポーネントです。動的なクエリビルダーパターンを使用して、指定された条件に基づいてSQLクエリを構築します。

主な機能：
- 検索条件からWHERE句の構築
- パラメータマップの生成
- カウントクエリの構築
- ページングやソート条件の適用

### 6.3 検索を最適化するためのインデックス設計

検索パフォーマンスを最適化するために、以下のインデックスを使用します：

- モジュールとエンティティによる検索のためのインデックス
- ファイル名による検索のためのインデックス
- コンテンツタイプによる検索のためのインデックス
- 作成日時による検索のためのインデックス
- 作成者による検索のためのインデックス
- 検索可能な属性に対するインデックス

## 7. トランザクション処理

### 7.1 トランザクション境界

ファイルメタデータと関連データ（属性、権限など）の操作は、データの一貫性を保証するためにトランザクション境界内で実行されます。たとえば、ファイルメタデータの作成に伴う属性の保存などは、単一のトランザクションで処理されます。

主なトランザクション処理：
- ファイルメタデータと属性の同時作成
- ファイル属性の一括更新
- バージョン作成とメタデータ更新
- 権限の一括設定

### 7.2 一貫性の確保

特に、複数のテーブルを更新する操作（新しいバージョンの作成など）では、すべての更新が成功するか、すべての更新が失敗するかの一貫性を確保することが重要です。これは、@Transactionalアノテーションを使用して実現されます。

## 8. バッチ処理

### 8.1 ファイルメタデータクリーンアップバッチ

古いファイルや期限切れファイルを定期的にクリーンアップするバッチ処理です。このコンポーネントは、有効期限が切れたファイルを検出し、ストレージとデータベースの両方から削除することで、システムリソースを最適化します。

主な処理内容：

- cronで設定されたスケジュール（毎日午前2時など）で実行
- 現在時刻を基準に期限切れファイルを特定
- 物理ストレージから該当ファイルを削除
- データベースからファイルメタデータと関連情報を削除
- 処理結果をログに記録
- エラーが発生した場合の例外ハンドリングとリトライ戦略

### 8.2 アクセスログアーカイブバッチ

古いアクセスログをアーカイブするバッチ処理です。このコンポーネントは、古くなったアクセスログをメインテーブルからアーカイブテーブルに移動し、システムのパフォーマンスを維持します。

主な処理内容：

- 毎週日曜日の午前3時など、指定されたスケジュールで実行
- 設定された期間（例：3ヶ月以上前）のログを対象に処理
- ログのアーカイブ処理（メインテーブルからアーカイブテーブルへの移動）
- 処理結果の集計とログ記録
- バッチサイズによる負荷制御

## 9. メタデータとストレージの整合性管理

### 9.1 整合性チェックユーティリティ

ファイルメタデータとストレージの整合性を確認するためのツールです。メタデータに記録されているすべてのファイルが物理的にストレージに存在するかをチェックし、不整合を検出します。

主な機能：
- バッチ処理によるメタデータと物理ファイルの整合性検証
- 存在しないファイル、メタデータが存在しないファイルの検出
- チェックサム検証によるファイル内容の整合性確認
- 整合性レポートの生成

### 9.2 自動修復機能

整合性チェックで検出された問題を修復するための機能です。過去のバージョンを利用したファイルの復元や、修復不可能な場合の適切な処理を提供します。

主な修復アクション：
- 物理ファイルが存在しない場合、古いバージョンへのロールバック
- 復旧不可能なファイルのメタデータの論理削除
- 修復履歴の記録と監査

## 10. セキュリティ実装

### 10.1 メタデータアクセス制御

SecureFileMetadataServiceは、FileMetadataServiceを拡張し、アクセス権限チェックを追加したサービスです。このサービスは、すべてのファイルメタデータ操作に対して権限チェックを行い、無許可のアクセスを防止します。

主要な機能：

- 各ファイル操作の前に、現在のユーザーがその操作に必要な権限を持っているかを確認
- 権限がない場合はAccessDeniedExceptionをスロー
- READ、WRITE、DELETEなど、操作の種類に応じた適切な権限チェック
- システム管理者や所有者向けの特別なアクセスパス

デコレーターパターンを使用して、既存のFileMetadataServiceの機能を保持しながら、セキュリティレイヤーを追加しています。

### 10.2 デフォルト権限の設定

FilePermissionInitializerコンポーネントは、新しいファイルが作成された際に、適切なデフォルト権限を自動的に設定します。これにより、ファイル作成者とシステム管理者が適切なアクセス権を持つことが保証されます。

主要な設定：

- ファイル作成者には、READ、WRITE、DELETEの全権限を付与
- システム管理者ロールにはREAD権限を付与
- 必要に応じて、モジュールに基づいた追加の標準権限を設定
- 権限設定はトランザクション内で実行され、一貫性を確保

## 11. 監査とモニタリング

### 11.1 監査ログ記録

ファイルへのすべてのアクセスと操作を記録する機能を提供します。各アクセスは、誰が、いつ、どのファイルに、どのような操作を行ったかを追跡します。

主な記録項目：
- アクセスユーザー情報
- アクセス日時
- アクション種別（閲覧、更新、削除など）
- アクセス結果（成功/失敗）
- クライアント情報（IPアドレス、ユーザーエージェントなど）
- エラー情報（失敗した場合）

### 11.2 監査レポート生成

蓄積された監査ログから様々な分析レポートを生成する機能です。アクセスパターンの分析や、セキュリティ監査に活用されます。

主なレポート種別：
- 期間ベースのアクセス統計
- ユーザー別のアクセス統計
- モジュール別のファイルアクセス統計
- エラー発生状況の分析
- 異常アクセスパターンの検出

## 12. パフォーマンス最適化

### 12.1 キャッシュ戦略

頻繁にアクセスされるファイルメタデータと属性情報をキャッシュすることで、データベースへのアクセスを減らし、パフォーマンスを向上させます。

主なキャッシュ対象：
- ファイルメタデータ
- ファイル属性
- ファイル権限情報

キャッシュ設定：
- 最大500エントリー
- 10分間のエクスパイア時間
- 書き込み時のキャッシュ更新
- 削除時のキャッシュ無効化

### 12.2 効率的なデータアクセス

ページング処理や高度なクエリ最適化を通じて、データベースへの効率的なアクセスを実現します。特に、大量のファイルや属性がある場合の検索パフォーマンスを最適化します。

主な最適化手法：
- 適切なインデックス設計
- 遅延ローディング
- バッチ処理による一括操作
- 必要なデータのみを取得するプロジェクション

## 13. メタデータマイグレーション

### 13.1 スキーママイグレーション

データモデルやスキーマの変更時に、既存データを新しいスキーマに移行するための機能です。例えば、属性テーブルに新しい検索可能フラグを追加する場合などに使用します。

代表的なマイグレーション例：
- テーブル構造の変更（カラムの追加など）
- 既存データの変換
- インデックスの追加や再構築

### 13.2 データマイグレーションツール

レガシーシステムからのデータ移行や、大規模なデータ変換を行うためのバッチツールを提供します。バッチ処理により、効率的かつ安全な移行を実現します。

主な機能：
- ソースからのデータ読み取り
- データ変換と検証
- バッチ単位での一貫した書き込み
- エラーハンドリングとリトライ
- 進捗状況の報告

## 14. エラー処理と復旧

### 14.1 エラー処理戦略

ファイル操作中に発生する可能性のある様々なエラーに対して、適切に対処するための階層化された例外処理システムを提供します。

代表的な例外クラス：
- FileNotFoundException
- AccessDeniedException
- FileValidationException
- StorageException
- FileServiceException

各例外に対する適切なHTTPステータスコードとエラーメッセージを提供し、クライアントが問題を特定しやすくします。

### 14.2 自動復旧メカニズム

システム障害や不整合の発生時に、自動的にファイルメタデータとストレージの状態を回復するメカニズムを提供します。

主な復旧機能：
- 物理ファイルが存在しないメタデータの検出と修復
- 過去のバージョンを利用した復元
- 復旧不可能なケースの適切な処理（論理削除など）
- 復旧プロセスの監査と報告

## 15. テスト戦略

### 15.1 テストデータセットアップ

効果的なテストのためのテストデータを準備するコンポーネントです。テスト実行前に、必要なメタデータ、属性、権限などのテストデータを自動的に作成します。

### 15.2 リポジトリテスト

ファイルメタデータ関連の各リポジトリインターフェースの実装に対するテストを行います。主に、データ永続化と検索機能の正確性を検証します。

テスト対象:
- メタデータの保存と取得
- モジュールコードとエンティティIDによる検索
- 属性に基づく検索
- 検索条件による高度な検索
- ページング処理の正確性

### 15.3 サービステスト

サービスレイヤーのロジックとリポジトリの統合に焦点を当てたテストを行います。権限チェックやトランザクション管理も含めて検証します。

テスト対象:
- ファイルメタデータの作成と属性の設定
- バージョン管理機能
- 権限チェックの正確性
- 検索機能の統合テスト
- エラー処理の検証

## 16. 変更履歴

| バージョン | 日付 | 変更者 | 変更内容 |
|----------|------|-------|----------|
| 0.1 | 2023-08-10 | 開発チーム | 初版作成 |
| 0.2 | 2023-09-15 | 開発チーム | パーミッション機能の拡張 |
| 0.3 | 2023-11-20 | 開発チーム | バッチ処理の追加 |
| 0.4 | 2025-05-10 | Claude | 実装コードを削除し、設計情報のみに修正 |