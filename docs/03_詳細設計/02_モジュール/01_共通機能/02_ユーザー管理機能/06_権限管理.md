# ユーザー管理機能 - 権限管理

## 1. 機能概要

権限管理機能は、SES業務システムにおける権限の定義、グループ化、ロールへの割り当て、アクセスレベル設定を担当します。システム内のリソース（機能・データ）に対する操作権限を細かく制御し、適切なアクセス制御を実現します。Spring Securityの権限評価機能を活用して、柔軟かつ堅牢な権限制御を実現します。

## 2. 主要コンポーネント構成

権限管理機能は以下のコンポーネントで構成されます：

### 2.1 コンポーネント構成図

```
                   ┌────────────────────┐
                   │ PermissionController │
                   └──────────┬─────────┘
                              │
                              ▼
  ┌───────────────┐   ┌────────────────────┐   ┌──────────────────┐
  │  RoleService  │◄──┤  PermissionService  │──►│  AuditLogService  │
  └───────────────┘   └──────────┬─────────┘   └──────────────────┘
                                 │
                                 ▼
                  ┌─────────────────────────┐
                  │  PermissionRepository   │
                  └─────────────────────────┘
                                 │
                                 ▼
                  ┌─────────────────────────┐
                  │ RolePermissionRepository │
                  └─────────────────────────┘
```

### 2.2 コンポーネント説明

- **PermissionController**: 権限管理のRESTful APIエンドポイントを提供
- **PermissionService**: 権限管理のビジネスロジックを実装
- **PermissionRepository**: 権限データのデータアクセス層
- **RolePermissionRepository**: ロールと権限の関連データのデータアクセス層
- **外部依存**: RoleService（ロール管理機能）、AuditLogService（監査ログ機能）

## 3. Spring Security Permission Evaluator

Spring Securityでは、細かい権限制御を実現するために`PermissionEvaluator`インターフェースを提供しています。このインターフェースを実装することで、ドメインオブジェクトレベルでのきめ細かい権限チェックが可能になります。

### 3.1 CustomPermissionEvaluator実装

```java
@Component
public class CustomPermissionEvaluator implements PermissionEvaluator {

    private final RolePermissionRepository rolePermissionRepository;
    private final PermissionRepository permissionRepository;
    private final UserRoleRepository userRoleRepository;
    
    @Autowired
    public CustomPermissionEvaluator(
            RolePermissionRepository rolePermissionRepository,
            PermissionRepository permissionRepository,
            UserRoleRepository userRoleRepository) {
        this.rolePermissionRepository = rolePermissionRepository;
        this.permissionRepository = permissionRepository;
        this.userRoleRepository = userRoleRepository;
    }
    
    @Override
    public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) {
        if (authentication == null || targetDomainObject == null || !(permission instanceof String)) {
            return false;
        }
        
        String permissionType = (String) permission;
        
        // ドメインオブジェクトの種類に基づいて権限チェック
        if (targetDomainObject instanceof User) {
            return hasUserPermission(authentication, (User) targetDomainObject, permissionType);
        } else if (targetDomainObject instanceof Role) {
            return hasRolePermission(authentication, (Role) targetDomainObject, permissionType);
        } else if (targetDomainObject instanceof Permission) {
            return hasPermissionOnPermission(authentication, (Permission) targetDomainObject, permissionType);
        }
        
        return false;
    }
    
    @Override
    public boolean hasPermission(Authentication authentication, Serializable targetId, String targetType, Object permission) {
        if (authentication == null || targetId == null || targetType == null || !(permission instanceof String)) {
            return false;
        }
        
        // IDと型情報からオブジェクトを取得して権限チェック
        if ("user".equalsIgnoreCase(targetType)) {
            return hasPermissionOnUserWithId(authentication, (UUID) targetId, (String) permission);
        } else if ("role".equalsIgnoreCase(targetType)) {
            return hasPermissionOnRoleWithId(authentication, (UUID) targetId, (String) permission);
        } else if ("permission".equalsIgnoreCase(targetType)) {
            return hasPermissionOnPermissionWithId(authentication, (UUID) targetId, (String) permission);
        }
        
        return false;
    }
    
    // Private helper methods for specific object types
    
    private boolean hasUserPermission(Authentication authentication, User user, String permissionType) {
        // User objectに対する権限チェックのロジック
        // 例: 自分自身のプロフィールは編集可能、システム管理者は全ユーザー編集可能など
        
        // システム管理者は全ての権限を持つ
        if (hasRole(authentication, "SYSTEM_ADMIN")) {
            return true;
        }
        
        // 自分自身に対しては特定の操作が可能
        if (isSelfUser(authentication, user)) {
            if ("VIEW".equals(permissionType) || "EDIT_PROFILE".equals(permissionType)) {
                return true;
            }
        }
        
        // その他のロールベースの権限チェック
        if ("SECURITY_ADMIN".equals(permissionType) && hasRole(authentication, "SECURITY_ADMIN")) {
            return true;
        }
        
        // 特定の権限IDに基づくチェック
        String requiredPermissionId = "USER_MANAGEMENT:USER_ACCOUNT:" + getActionForPermissionType(permissionType);
        return hasPermissionId(authentication, requiredPermissionId);
    }
    
    private boolean hasRolePermission(Authentication authentication, Role role, String permissionType) {
        // Role objectに対する権限チェックのロジック
        
        // システム管理者は全ての権限を持つ
        if (hasRole(authentication, "SYSTEM_ADMIN")) {
            return true;
        }
        
        // セキュリティ管理者は業務ロールの管理が可能
        if (hasRole(authentication, "SECURITY_ADMIN") && role.getRoleType() == RoleType.BUSINESS) {
            return true;
        }
        
        // 特定の権限IDに基づくチェック
        String requiredPermissionId = "USER_MANAGEMENT:ROLE:" + getActionForPermissionType(permissionType);
        return hasPermissionId(authentication, requiredPermissionId);
    }
    
    private boolean hasPermissionOnPermission(Authentication authentication, Permission permissionObj, String permissionType) {
        // Permission objectに対する権限チェックのロジック
        
        // システム管理者は全ての権限を持つ
        if (hasRole(authentication, "SYSTEM_ADMIN")) {
            return true;
        }
        
        // セキュリティ管理者は権限の閲覧が可能
        if (hasRole(authentication, "SECURITY_ADMIN") && "VIEW".equals(permissionType)) {
            return true;
        }
        
        // 特定の権限IDに基づくチェック
        String requiredPermissionId = "USER_MANAGEMENT:PERMISSION:" + getActionForPermissionType(permissionType);
        return hasPermissionId(authentication, requiredPermissionId);
    }
    
    // ID-based permission checks
    
    private boolean hasPermissionOnUserWithId(Authentication authentication, UUID userId, String permissionType) {
        // TODO: ユーザーIDに基づく権限チェック実装
        return false;
    }
    
    private boolean hasPermissionOnRoleWithId(Authentication authentication, UUID roleId, String permissionType) {
        // TODO: ロールIDに基づく権限チェック実装
        return false;
    }
    
    private boolean hasPermissionOnPermissionWithId(Authentication authentication, UUID permissionId, String permissionType) {
        // TODO: 権限IDに基づく権限チェック実装
        return false;
    }
    
    // Utility methods
    
    private boolean hasRole(Authentication authentication, String role) {
        return authentication.getAuthorities().stream()
                .anyMatch(authority -> authority.getAuthority().equals("ROLE_" + role));
    }
    
    private boolean isSelfUser(Authentication authentication, User user) {
        if (authentication.getPrincipal() instanceof CustomUserDetails) {
            CustomUserDetails userDetails = (CustomUserDetails) authentication.getPrincipal();
            return userDetails.getId().equals(user.getId());
        }
        return false;
    }
    
    private String getActionForPermissionType(String permissionType) {
        switch (permissionType) {
            case "VIEW":
                return "READ";
            case "EDIT":
            case "UPDATE":
                return "WRITE";
            case "DELETE":
            case "EXECUTE":
                return "EXECUTE";
            default:
                return permissionType;
        }
    }
    
    private boolean hasPermissionId(Authentication authentication, String permissionId) {
        return authentication.getAuthorities().stream()
                .anyMatch(authority -> authority.getAuthority().equals(permissionId));
    }
}
```

### 3.2 MethodSecurityExpressionHandler設定

カスタム`PermissionEvaluator`を使用するためには、`MethodSecurityExpressionHandler`を設定する必要があります。

```java
@Configuration
@EnableMethodSecurity
public class MethodSecurityConfig {

    @Autowired
    private CustomPermissionEvaluator permissionEvaluator;
    
    @Autowired
    private RoleHierarchy roleHierarchy;
    
    @Bean
    public MethodSecurityExpressionHandler methodSecurityExpressionHandler() {
        DefaultMethodSecurityExpressionHandler expressionHandler = new DefaultMethodSecurityExpressionHandler();
        expressionHandler.setPermissionEvaluator(permissionEvaluator);
        expressionHandler.setRoleHierarchy(roleHierarchy);
        return expressionHandler;
    }
}
```

### 3.3 アクセス検証ロジックの分離

権限チェックロジックを分離して再利用可能にするために、専用のサービスクラスを作成します。

```java
@Service
public class AccessControlService {

    private final RolePermissionRepository rolePermissionRepository;
    private final PermissionRepository permissionRepository;
    
    @Autowired
    public AccessControlService(
            RolePermissionRepository rolePermissionRepository,
            PermissionRepository permissionRepository) {
        this.rolePermissionRepository = rolePermissionRepository;
        this.permissionRepository = permissionRepository;
    }
    
    /**
     * ユーザーIDがリソースに対して指定されたアクションを実行する権限を持っているかチェックする
     * @param userId ユーザーID
     * @param resourceType リソースタイプ
     * @param resourceName リソース名
     * @param action アクション
     * @param requiredLevel 必要なアクセスレベル
     * @return 権限がある場合はtrue
     */
    public boolean hasResourcePermission(
            Authentication authentication, 
            String resourceType, 
            String resourceName, 
            String action, 
            AccessLevel requiredLevel) {
        
        // システム管理者は全ての権限を持つ
        if (hasRole(authentication, "SYSTEM_ADMIN")) {
            return true;
        }
        
        // 権限IDの形式: "{resourceType}:{resourceName}:{action}"
        String permissionId = resourceType + ":" + resourceName + ":" + action;
        
        // 権限チェック
        boolean hasPermission = authentication.getAuthorities().stream()
                .anyMatch(authority -> authority.getAuthority().equals(permissionId));
        
        return hasPermission;
    }
    
    /**
     * ユーザーが指定されたロールを持っているかチェック
     */
    public boolean hasRole(Authentication authentication, String role) {
        return authentication.getAuthorities().stream()
                .anyMatch(authority -> authority.getAuthority().equals("ROLE_" + role));
    }
}
```

## 4. 処理フロー

### 4.1 権限一覧取得フロー

```
1. 管理者が権限管理画面にアクセス
2. PermissionController.getAllPermissions() APIが呼び出される
3. @PreAuthorize("hasRole('SYSTEM_ADMIN') or hasRole('SECURITY_ADMIN')")による権限チェック
4. PermissionService.findAll() メソッドが実行される
   4.1. PermissionRepository経由でデータベースから権限一覧を取得
   4.2. 取得結果をDTOに変換
5. 権限一覧をクライアントに返却
```

### 4.2 ロール権限更新フロー

```
1. 管理者がロール編集画面で権限設定を変更
2. PermissionController.updateRolePermissions() APIが呼び出される
3. @PreAuthorize("hasRole('SYSTEM_ADMIN') or (hasRole('SECURITY_ADMIN') and @roleSecurityService.isBusinessRole(#roleId))")による権限チェック
4. @PostAuthorize("returnObject.roleType != 'SYSTEM' or hasRole('SYSTEM_ADMIN')")による結果の事後チェック
5. PermissionService.updateRolePermissions() メソッドが実行される
   5.1. トランザクション開始
   5.2. ロールの存在確認
   5.3. 既存のロール権限設定を取得
   5.4. 権限設定を更新（追加/変更/削除）
   5.5. AuditLogService経由で監査ログ記録
   5.6. トランザクション終了
6. 更新結果をクライアントに返却
```

## 5. 実装詳細

### 5.1 PermissionController 実装

```java
@RestController
@RequestMapping("/api/v1/admin/permissions")
public class PermissionController {

    private final PermissionService permissionService;
    
    @Autowired
    public PermissionController(PermissionService permissionService) {
        this.permissionService = permissionService;
    }
    
    @GetMapping
    @PreAuthorize("hasAuthority('USER_MANAGEMENT:PERMISSION:READ')")
    public List<PermissionDTO> getAllPermissions() {
        return permissionService.findAll();
    }
    
    @GetMapping("/groups")
    @PreAuthorize("hasAuthority('USER_MANAGEMENT:PERMISSION:READ')")
    public List<PermissionGroupDTO> getPermissionGroups() {
        return permissionService.findAllGroups();
    }
    
    @GetMapping("/resource-types/{resourceType}")
    @PreAuthorize("hasAuthority('USER_MANAGEMENT:PERMISSION:READ')")
    public List<PermissionDTO> getPermissionsByResourceType(@PathVariable String resourceType) {
        return permissionService.findByResourceType(resourceType);
    }
    
    @GetMapping("/roles/{roleId}")
    @PreAuthorize("hasRole('SYSTEM_ADMIN') or hasRole('SECURITY_ADMIN') or hasPermission(#roleId, 'role', 'VIEW')")
    public List<RolePermissionDTO> getRolePermissions(@PathVariable UUID roleId) {
        return permissionService.findByRoleId(roleId);
    }
    
    @PutMapping("/roles/{roleId}")
    @PreAuthorize("hasRole('SYSTEM_ADMIN') or (hasRole('SECURITY_ADMIN') and @roleSecurityService.isBusinessRole(#roleId))")
    public ResponseEntity<Void> updateRolePermissions(
            @PathVariable UUID roleId,
            @RequestBody List<RolePermissionUpdateDTO> permissions) {
        permissionService.updateRolePermissions(roleId, permissions);
        return ResponseEntity.ok().build();
    }
    
    @PostMapping
    @PreAuthorize("hasRole('SYSTEM_ADMIN')")
    public ResponseEntity<PermissionDTO> createPermission(@RequestBody @Valid PermissionCreateDTO createDTO) {
        PermissionDTO createdPermission = permissionService.create(createDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(createdPermission);
    }
    
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('SYSTEM_ADMIN')")
    public ResponseEntity<Void> deletePermission(@PathVariable UUID id) {
        permissionService.delete(id);
        return ResponseEntity.ok().build();
    }
}
```

### 5.2 PermissionServiceImpl 実装

```java
@Service
public class PermissionServiceImpl implements PermissionService {

    private final PermissionRepository permissionRepository;
    private final RolePermissionRepository rolePermissionRepository;
    private final RoleRepository roleRepository;
    private final AuditLogService auditLogService;
    
    @Autowired
    public PermissionServiceImpl(
            PermissionRepository permissionRepository,
            RolePermissionRepository rolePermissionRepository,
            RoleRepository roleRepository,
            AuditLogService auditLogService) {
        this.permissionRepository = permissionRepository;
        this.rolePermissionRepository = rolePermissionRepository;
        this.roleRepository = roleRepository;
        this.auditLogService = auditLogService;
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<PermissionDTO> findAll() {
        List<Permission> permissions = permissionRepository.findAll();
        return permissions.stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<PermissionGroupDTO> findAllGroups() {
        List<Permission> permissions = permissionRepository.findAll();
        Map<String, PermissionGroupDTO> groupMap = new HashMap<>();
        
        // リソースタイプごとにグループ化
        for (Permission permission : permissions) {
            String resourceType = permission.getResourceType();
            PermissionGroupDTO group = groupMap.computeIfAbsent(resourceType, type -> {
                PermissionGroupDTO newGroup = new PermissionGroupDTO();
                newGroup.setResourceType(type);
                newGroup.setDisplayName(formatDisplayName(type));
                newGroup.setResources(new ArrayList<>());
                return newGroup;
            });
            
            // リソース名ごとにグループ化
            String resourceName = permission.getResourceName();
            PermissionResourceDTO resource = findOrCreateResource(group, resourceName);
            
            // アクション追加
            PermissionActionDTO action = new PermissionActionDTO();
            action.setPermissionId(permission.getId());
            action.setAction(permission.getAction());
            action.setDisplayName(formatActionDisplayName(permission.getAction()));
            resource.getActions().add(action);
        }
        
        return new ArrayList<>(groupMap.values());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<RolePermissionDTO> findByRoleId(UUID roleId) {
        // ロールの存在確認
        if (!roleRepository.existsById(roleId)) {
            throw new EntityNotFoundException("Role not found with id: " + roleId);
        }
        
        List<RolePermission> rolePermissions = rolePermissionRepository.findByRoleId(roleId);
        List<RolePermissionDTO> result = new ArrayList<>();
        
        for (RolePermission rolePermission : rolePermissions) {
            Permission permission = permissionRepository.findById(rolePermission.getPermissionId())
                    .orElseThrow(() -> new EntityNotFoundException("Permission not found with id: " + rolePermission.getPermissionId()));
            
            RolePermissionDTO dto = new RolePermissionDTO();
            dto.setPermissionId(permission.getId());
            dto.setPermissionName(permission.getName());
            dto.setResourceType(permission.getResourceType());
            dto.setResourceName(permission.getResourceName());
            dto.setAction(permission.getAction());
            dto.setAccessLevel(rolePermission.getAccessLevel());
            
            result.add(dto);
        }
        
        return result;
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<PermissionDTO> findByResourceType(String resourceType) {
        List<Permission> permissions = permissionRepository.findByResourceType(resourceType);
        return permissions.stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }
    
    @Override
    @Transactional
    public void updateRolePermissions(UUID roleId, List<RolePermissionUpdateDTO> permissions) {
        // ロールの存在確認
        Role role = roleRepository.findById(roleId)
                .orElseThrow(() -> new EntityNotFoundException("Role not found with id: " + roleId));
        
        // システム管理者以外がシステムロールを編集しようとしている場合はエラー
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (role.getRoleType() == RoleType.SYSTEM && 
                authentication != null && 
                !authentication.getAuthorities().stream()
                    .anyMatch(a -> a.getAuthority().equals("ROLE_SYSTEM_ADMIN"))) {
            throw new AccessDeniedException("Only system administrators can modify system roles");
        }
        
        // 既存の権限設定取得
        List<RolePermission> existingPermissions = rolePermissionRepository.findByRoleId(roleId);
        Map<UUID, RolePermission> existingPermissionMap = existingPermissions.stream()
                .collect(Collectors.toMap(RolePermission::getPermissionId, Function.identity()));
        
        // 更新対象権限の検証
        Set<UUID> validPermissionIds = new HashSet<>();
        for (RolePermissionUpdateDTO updateDTO : permissions) {
            if (!permissionRepository.existsById(updateDTO.getPermissionId())) {
                throw new EntityNotFoundException("Permission not found with id: " + updateDTO.getPermissionId());
            }
            validPermissionIds.add(updateDTO.getPermissionId());
        }
        
        // トランザクション内で権限設定を更新
        List<RolePermission> updatedPermissions = new ArrayList<>();
        for (RolePermissionUpdateDTO updateDTO : permissions) {
            RolePermission rolePermission = existingPermissionMap.get(updateDTO.getPermissionId());
            
            if (rolePermission == null) {
                // 新規追加
                rolePermission = new RolePermission();
                rolePermission.setRoleId(roleId);
                rolePermission.setPermissionId(updateDTO.getPermissionId());
            }
            
            // アクセスレベル更新
            rolePermission.setAccessLevel(updateDTO.getAccessLevel());
            updatedPermissions.add(rolePermission);
        }
        
        // 追加・更新された権限設定を保存
        rolePermissionRepository.saveAll(updatedPermissions);
        
        // 削除対象の権限設定を特定して削除
        List<UUID> permissionsToRemove = existingPermissionMap.keySet().stream()
                .filter(permId -> !validPermissionIds.contains(permId))
                .collect(Collectors.toList());
        
        for (UUID permissionId : permissionsToRemove) {
            rolePermissionRepository.deleteByRoleIdAndPermissionId(roleId, permissionId);
        }
        
        // 監査ログ記録
        Map<String, Object> details = new HashMap<>();
        details.put("roleId", role.getRoleId());
        details.put("roleName", role.getName());
        details.put("permissionCount", updatedPermissions.size());
        details.put("addedCount", updatedPermissions.size() - existingPermissions.size() + permissionsToRemove.size());
        details.put("removedCount", permissionsToRemove.size());
        
        recordAuditLog("UPDATE_ROLE_PERMISSIONS", role, details);
    }
    
    @Override
    @Transactional
    public PermissionDTO create(PermissionCreateDTO createDTO) {
        // 権限IDの形式を検証
        String resourceType = createDTO.getResourceType();
        String resourceName = createDTO.getResourceName();
        String action = createDTO.getAction();
        String permissionId = resourceType + ":" + resourceName + ":" + action;
        
        // 重複チェック
        if (permissionRepository.existsByPermissionId(permissionId)) {
            throw new DuplicateEntityException("Permission with permissionId " + permissionId + " already exists");
        }
        
        // 新規権限エンティティの作成
        Permission permission = new Permission();
        permission.setId(UUID.randomUUID());
        permission.setPermissionId(permissionId);
        permission.setName(createDTO.getName());
        permission.setDescription(createDTO.getDescription());
        permission.setResourceType(resourceType);
        permission.setResourceName(resourceName);
        permission.setAction(action);
        
        Permission savedPermission = permissionRepository.save(permission);
        
        // 監査ログ記録
        Map<String, Object> details = new HashMap<>();
        details.put("permissionId", savedPermission.getPermissionId());
        details.put("name", savedPermission.getName());
        
        recordAuditLog("CREATE_PERMISSION", savedPermission, details);
        
        return convertToDTO(savedPermission);
    }
    
    @Override
    @Transactional
    public void delete(UUID id) {
        // 権限の存在確認
        Permission permission = permissionRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Permission not found with id: " + id));
        
        // システム定義の権限は削除不可
        if (isSystemDefinedPermission(permission.getPermissionId())) {
            throw new BusinessRuleException("System defined permission cannot be deleted: " + permission.getPermissionId());
        }
        
        // ロールに割り当てられた権限関連を削除
        rolePermissionRepository.deleteByPermissionId(id);
        
        // 権限削除
        permissionRepository.delete(permission);
        
        // 監査ログ記録
        Map<String, Object> details = new HashMap<>();
        details.put("permissionId", permission.getPermissionId());
        details.put("name", permission.getName());
        
        recordAuditLog("DELETE_PERMISSION", permission, details);
    }
    
    // Helper methods
    
    private PermissionDTO convertToDTO(Permission permission) {
        PermissionDTO dto = new PermissionDTO();
        dto.setId(permission.getId());
        dto.setPermissionId(permission.getPermissionId());
        dto.setName(permission.getName());
        dto.setDescription(permission.getDescription());
        dto.setResourceType(permission.getResourceType());
        dto.setResourceName(permission.getResourceName());
        dto.setAction(permission.getAction());
        return dto;
    }
    
    private PermissionResourceDTO findOrCreateResource(PermissionGroupDTO group, String resourceName) {
        // 既存のリソースを検索
        for (PermissionResourceDTO resource : group.getResources()) {
            if (resource.getResourceName().equals(resourceName)) {
                return resource;
            }
        }
        
        // 存在しない場合は新規作成
        PermissionResourceDTO newResource = new PermissionResourceDTO();
        newResource.setResourceName(resourceName);
        newResource.setDisplayName(formatDisplayName(resourceName));
        newResource.setActions(new ArrayList<>());
        group.getResources().add(newResource);
        return newResource;
    }
    
    private String formatDisplayName(String name) {
        // リソースタイプ/リソース名の表示用フォーマット
        Map<String, String> displayNameMap = new HashMap<>();
        
        // リソースタイプの表示名マッピング
        displayNameMap.put("USER_MANAGEMENT", "ユーザー管理");
        displayNameMap.put("ROLE_MANAGEMENT", "ロール管理");
        displayNameMap.put("PROJECT_MANAGEMENT", "案件管理");
        displayNameMap.put("ENGINEER_MANAGEMENT", "技術者管理");
        displayNameMap.put("CONTRACT_MANAGEMENT", "契約管理");
        displayNameMap.put("TIMESHEET_MANAGEMENT", "勤怠工数管理");
        displayNameMap.put("BILLING_MANAGEMENT", "請求支払管理");
        displayNameMap.put("REPORTING", "レポーティング");
        displayNameMap.put("SYSTEM_MANAGEMENT", "システム管理");
        
        // リソース名の表示名マッピング
        displayNameMap.put("USER_ACCOUNT", "ユーザーアカウント");
        displayNameMap.put("ROLE", "ロール");
        displayNameMap.put("PERMISSION", "権限");
        displayNameMap.put("PROJECT", "案件");
        displayNameMap.put("ENGINEER", "技術者");
        displayNameMap.put("CONTRACT", "契約");
        displayNameMap.put("TIMESHEET", "勤怠");
        displayNameMap.put("BILLING", "請求");
        displayNameMap.put("PAYMENT", "支払");
        displayNameMap.put("REPORT", "レポート");
        
        return displayNameMap.getOrDefault(name, name);
    }
    
    private String formatActionDisplayName(String action) {
        // アクションの表示名フォーマット
        Map<String, String> actionDisplayMap = new HashMap<>();
        actionDisplayMap.put("READ", "閲覧");
        actionDisplayMap.put("WRITE", "編集");
        actionDisplayMap.put("EXECUTE", "実行");
        actionDisplayMap.put("ADMIN", "管理");
        
        return actionDisplayMap.getOrDefault(action, action);
    }
    
    private boolean isSystemDefinedPermission(String permissionId) {
        // システム定義の権限かどうかをチェック
        // 特定のリソースタイプやプレフィックスでチェック
        return permissionId.startsWith("USER_MANAGEMENT:") || 
               permissionId.startsWith("SYSTEM_MANAGEMENT:");
    }
    
    private void recordAuditLog(String action, Object target, Map<String, Object> additionalDetails) {
        Map<String, Object> details = new HashMap<>();
        
        if (target instanceof Permission) {
            Permission permission = (Permission) target;
            details.put("permissionId", permission.getPermissionId());
            details.put("name", permission.getName());
        } else if (target instanceof Role) {
            Role role = (Role) target;
            details.put("roleId", role.getRoleId());
            details.put("name", role.getName());
        }
        
        if (additionalDetails != null) {
            details.putAll(additionalDetails);
        }
        
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String performedBy = "system";
        if (authentication != null && authentication.getPrincipal() instanceof CustomUserDetails) {
            performedBy = ((CustomUserDetails) authentication.getPrincipal()).getUsername();
        }
        
        String targetType = target instanceof Permission ? "PERMISSION" : "ROLE";
        String targetId = target instanceof Permission ? 
                ((Permission) target).getId().toString() : 
                ((Role) target).getId().toString();
        
        auditLogService.recordAuditLog(
                action,
                targetType,
                targetId,
                performedBy,
                details
        );
    }
}
```

### 5.3 カスタム`SpEL`式を使った高度な権限チェック

Spring Security Expression Language (SpEL) を拡張して、より柔軟な権限チェックを実現します。

```java
@Component
public class CustomMethodSecurityExpressionRoot extends SecurityExpressionRoot implements MethodSecurityExpressionOperations {

    private Object filterObject;
    private Object returnObject;
    private Object target;
    private RoleRepository roleRepository;
    private PermissionRepository permissionRepository;
    
    public CustomMethodSecurityExpressionRoot(Authentication authentication) {
        super(authentication);
    }
    
    public void setRoleRepository(RoleRepository roleRepository) {
        this.roleRepository = roleRepository;
    }
    
    public void setPermissionRepository(PermissionRepository permissionRepository) {
        this.permissionRepository = permissionRepository;
    }
    
    public boolean hasResourcePermission(String resourceType, String resourceName, String action) {
        // リソースタイプ、リソース名、アクションに基づいて権限チェック
        String permissionId = resourceType + ":" + resourceName + ":" + action;
        return hasAuthority(permissionId);
    }
    
    public boolean canManageRole(UUID roleId) {
        // ロール管理権限のチェック
        if (hasRole("SYSTEM_ADMIN")) {
            return true;
        }
        
        if (hasRole("SECURITY_ADMIN")) {
            Role role = roleRepository.findById(roleId).orElse(null);
            return role != null && role.getRoleType() == RoleType.BUSINESS;
        }
        
        return false;
    }
    
    public boolean canModifyPermission(UUID permissionId) {
        // 権限変更権限のチェック
        if (hasRole("SYSTEM_ADMIN")) {
            return true;
        }
        
        return false;
    }
    
    @Override
    public void setFilterObject(Object filterObject) {
        this.filterObject = filterObject;
    }

    @Override
    public Object getFilterObject() {
        return filterObject;
    }

    @Override
    public void setReturnObject(Object returnObject) {
        this.returnObject = returnObject;
    }

    @Override
    public Object getReturnObject() {
        return returnObject;
    }

    @Override
    public Object getThis() {
        return target;
    }
    
    public void setThis(Object target) {
        this.target = target;
    }
}
```

## 6. Spring Securityの権限設計原則

### 6.1 権限の粒度設計

Spring Securityでは、以下の粒度で権限を設計することが一般的です：

1. **リソースタイプレベル**: 大まかな機能グループ（ユーザー管理、案件管理など）
2. **リソース名レベル**: 特定のリソース（ユーザーアカウント、ロールなど）
3. **アクションレベル**: 具体的な操作（閲覧、編集、実行など）
4. **アクセスレベル**: 操作の詳細度（なし、閲覧のみ、編集可、管理者権限）

本システムでは、`{resourceType}:{resourceName}:{action}`の形式で権限IDを定義し、Spring Securityの`hasAuthority()`メソッドでチェックします。

### 6.2 メソッドセキュリティの実践パターン

1. **シンプルなロールチェック**:
   ```java
   @PreAuthorize("hasRole('ADMIN')")
   ```

2. **複数条件の組み合わせ**:
   ```java
   @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
   ```

3. **メソッド引数を参照するチェック**:
   ```java
   @PreAuthorize("hasRole('ADMIN') or #userId == authentication.principal.id")
   ```

4. **カスタム権限評価**:
   ```java
   @PreAuthorize("hasPermission(#resourceId, 'RESOURCE', 'EDIT')")
   ```

5. **結果に基づく事後チェック**:
   ```java
   @PostAuthorize("returnObject.owner == authentication.principal.id")
   ```

### 6.3 アクセス制御モデル

Spring Securityでは、以下のアクセス制御モデルを採用できます：

1. **RBAC (Role-Based Access Control)**: ロールに基づく権限付与
   ```java
   @PreAuthorize("hasRole('ADMIN')")
   ```

2. **ABAC (Attribute-Based Access Control)**: 属性（コンテキスト情報）に基づく権限付与
   ```java
   @PreAuthorize("hasRole('MANAGER') and #resource.department == authentication.principal.department")
   ```

3. **PBAC (Policy-Based Access Control)**: ポリシーに基づく権限付与
   ```java
   @PreAuthorize("@securityPolicy.evaluate(authentication, #resource, 'EDIT')")
   ```

本システムでは、RBACをベースとしつつ、ABACの要素を取り入れたハイブリッドモデルを採用します。

## 7. PermissionEvaluatorの実装ポイント

### 7.1 ドメインオブジェクトセキュリティの粒度

`PermissionEvaluator`を使用することで、ドメインオブジェクトレベルでの細かい権限チェックが可能になります：

1. **オブジェクトタイプ**: ユーザー、ロール、権限など異なるエンティティタイプ
2. **オブジェクト属性**: オブジェクトの所有者、ステータス、部門などの属性
3. **操作タイプ**: 閲覧、編集、削除などの操作
4. **ユーザーコンテキスト**: 実行ユーザーのロール、部門、関係性

### 7.2 高度な権限チェックロジック

`PermissionEvaluator`内では、以下のような高度な権限チェックロジックを実装できます：

1. **オブジェクト所有者チェック**: `object.getOwnerId().equals(user.getId())`
2. **階層関係チェック**: `user.getDepartment().isChildOf(object.getDepartment())`
3. **複合条件チェック**: `isAdmin() || isOwner() || hasSpecificPermission()`
4. **コンテキスト依存チェック**: `object.getStatus() == Status.DRAFT ? isEditor() : isApprover()`

### 7.3 パフォーマンスの最適化

複雑な権限チェックはパフォーマンスに影響する可能性があるため、以下の最適化を検討します：

1. **キャッシング**: 頻繁にアクセスされる権限情報のキャッシング
2. **遅延ロード防止**: N+1問題を防ぐための適切なJOIN取得
3. **バッチ処理**: 一括権限チェックによるデータベースアクセスの最小化
4. **インデックス設計**: 権限チェックに関わるカラムへの適切なインデックス付与

## 8. テスト方針

### 8.1 PermissionEvaluatorのテスト

```java
@SpringBootTest
public class CustomPermissionEvaluatorTest {

    @Autowired
    private CustomPermissionEvaluator permissionEvaluator;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private RoleRepository roleRepository;
    
    @MockBean
    private Authentication authentication;
    
    @Test
    public void testHasPermissionOnUser() {
        // テストユーザーの作成
        User user = new User();
        user.setId(UUID.randomUUID());
        user.setUserId("test-user");
        user = userRepository.save(user);
        
        // 認証オブジェクトのモック
        when(authentication.getAuthorities()).thenReturn(
            Collections.singletonList(new SimpleGrantedAuthority("ROLE_SYSTEM_ADMIN"))
        );
        
        // システム管理者はユーザーの編集権限を持つ
        assertTrue(permissionEvaluator.hasPermission(authentication, user, "EDIT"));
    }
    
    @Test
    public void testHasPermissionOnRole() {
        // テストロールの作成
        Role role = new Role();
        role.setId(UUID.randomUUID());
        role.setRoleId("TEST_ROLE");
        role.setRoleType(RoleType.BUSINESS);
        role = roleRepository.save(role);
        
        // セキュリティ管理者の権限でテスト
        when(authentication.getAuthorities()).thenReturn(
            Collections.singletonList(new SimpleGrantedAuthority("ROLE_SECURITY_ADMIN"))
        );
        
        // セキュリティ管理者は業務ロールの編集権限を持つ
        assertTrue(permissionEvaluator.hasPermission(authentication, role, "EDIT"));
    }
}
```

### 8.2 メソッドセキュリティの統合テスト

```java
@SpringBootTest
@WithMockUser(roles = "SYSTEM_ADMIN")
public class PermissionServiceSecurityTest {

    @Autowired
    private PermissionService permissionService;
    
    @Autowired
    private RoleRepository roleRepository;
    
    @Test
    public void testUpdateRolePermissionsAsAdmin() {
        // システム管理者はシステムロールの権限を更新できる
        Role role = roleRepository.findByRoleId("SYSTEM_ADMIN").orElse(null);
        assertNotNull(role);
        
        // 権限更新処理実行（例外が発生しないことを確認）
        permissionService.updateRolePermissions(role.getId(), Collections.emptyList());
    }
    
    @Test
    @WithMockUser(roles = "SECURITY_ADMIN")
    public void testUpdateSystemRolePermissionsAsSecurityAdmin() {
        // セキュリティ管理者はシステムロールの権限を更新できない
        Role role = roleRepository.findByRoleId("SYSTEM_ADMIN").orElse(null);
        assertNotNull(role);
        
        // AccessDeniedException が発生することを確認
        assertThrows(AccessDeniedException.class, () -> {
            permissionService.updateRolePermissions(role.getId(), Collections.emptyList());
        });
    }
}
```

### 8.3 SpEL式のテスト

```java
@SpringBootTest
public class SecurityExpressionEvaluationTest {

    @Autowired
    private ApplicationContext applicationContext;
    
    @Autowired
    private RoleRepository roleRepository;
    
    @Test
    public void testCustomSecurityExpression() {
        // テスト用のEvaluationContextを作成
        StandardEvaluationContext context = new StandardEvaluationContext();
        
        // カスタムルートオブジェクトを設定
        Authentication authentication = new TestingAuthenticationToken(
            "user", "password", "ROLE_SECURITY_ADMIN"
        );
        CustomMethodSecurityExpressionRoot root = new CustomMethodSecurityExpressionRoot(authentication);
        root.setRoleRepository(roleRepository);
        context.setRootObject(root);
        
        // 業務ロールのUUIDを準備
        Role businessRole = roleRepository.findByRoleId("SALES_MANAGER").orElse(null);
        assertNotNull(businessRole);
        context.setVariable("roleId", businessRole.getId());
        
        // SpEL式を評価
        ExpressionParser parser = new SpelExpressionParser();
        Expression expression = parser.parseExpression("canManageRole(#roleId)");
        Boolean result = expression.getValue(context, Boolean.class);
        
        assertTrue(result);
    }
}
```

## 9. 実装・移行におけるポイント

### 9.1 Spring Securityへの移行手順

1. Spring Security依存関係の追加
2. `SecurityConfiguration`と`MethodSecurityConfig`の設定
3. `CustomPermissionEvaluator`の実装
4. `RoleHierarchy`の設定
5. 既存のコントローラーに`@PreAuthorize`アノテーションを追加
6. カスタムセキュリティ式の実装と登録
7. テストコードの修正とセキュリティテストの追加

### 9.2 既存システムからの移行時の注意点

1. **既存の権限データの変換**: 既存のデータベース内の権限データをSpring Security形式に変換
2. **ユーザーコンテキストの連携**: サービスレイヤーでのユーザーコンテキスト取得方法の統一
3. **UIでの権限制御との整合性**: 画面上のボタン表示制御とサーバー側の権限チェックの整合性確保
4. **移行期間中の後方互換性**: 新旧権限システムの並行運用による段階的移行

### 9.3 セキュリティ上の注意点

1. **権限昇格の防止**: 意図しない権限付与や昇格が発生しないよう入念にテスト
2. **セキュリティフィルタの順序**: Springのフィルタチェーンにおける権限チェックの順序に注意
3. **監査ログの確実な記録**: 権限に関わる操作の監査ログを漏れなく記録
4. **権限伝搬の制御**: サービス間呼び出しにおける権限の伝搬と制限を適切に設計