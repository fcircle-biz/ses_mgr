# ユーザー管理機能 - ロール管理

## 1. 機能概要

ロール管理機能は、SES業務システムにおけるロールの定義、編集、削除、権限設定を担当します。システム内での役割や権限の集合体としてのロールを管理し、ユーザーへの適切な権限割り当てを可能にします。Spring Securityのロールと権限の標準機能を活用して、より堅牢なセキュリティ機能を提供します。

## 2. 主要コンポーネント構成

ロール管理機能は以下のコンポーネントで構成されます：

### 2.1 コンポーネント構成図

```
                   ┌─────────────────┐
                   │  RoleController │
                   └────────┬────────┘
                            │
                            ▼
┌─────────────────┐  ┌─────────────────┐  ┌──────────────────┐
│ PermissionService │◄─┤   RoleService   │─►│  AuditLogService  │
└─────────────────┘  └────────┬────────┘  └──────────────────┘
                             │
                             ▼
                   ┌─────────────────┐
                   │  RoleRepository │
                   └─────────────────┘
```

### 2.2 コンポーネント説明

- **RoleController**: ロール管理のRESTful APIエンドポイントを提供
- **RoleService**: ロール管理のビジネスロジックを実装
- **RoleRepository**: ロールデータのデータアクセス層
- **外部依存**: PermissionService（権限管理機能）、AuditLogService（監査ログ機能）

## 3. Spring Security連携

### 3.1 Spring Securityのロールと権限

Spring Securityでは、ロールと権限（Authority）を以下のように区別して取り扱います：

- **ロール（Role）**: ユーザーのシステム内での役割を表す。通常`ROLE_`プレフィックスを持つ
- **権限（Authority）**: 特定の操作や機能に対する許可を表す

本システムでは、この仕組みを活用して以下のような設計を採用します：

```java
// ロールは SimpleGrantedAuthority として "ROLE_" プレフィックスを持つ
new SimpleGrantedAuthority("ROLE_SYSTEM_ADMIN");

// 権限は SimpleGrantedAuthority として特定操作に対する権限を表す
new SimpleGrantedAuthority("USER_MANAGEMENT:USER_ACCOUNT:READ");
```

### 3.2 RoleHierarchy（ロール階層）の導入

Spring Securityの`RoleHierarchy`を使用して、ロールの階層関係を定義します。上位ロールは下位ロールのすべての権限を継承します。

```java
@Bean
public RoleHierarchy roleHierarchy() {
    RoleHierarchyImpl hierarchy = new RoleHierarchyImpl();
    hierarchy.setHierarchy(
        "ROLE_SYSTEM_ADMIN > ROLE_SECURITY_ADMIN\n" +
        "ROLE_SECURITY_ADMIN > ROLE_AUDITOR\n" +
        "ROLE_SALES_MANAGER > ROLE_SALES_STAFF\n" +
        "ROLE_HR_MANAGER > ROLE_HR_STAFF\n" +
        "ROLE_FINANCE_MANAGER > ROLE_FINANCE_STAFF"
    );
    return hierarchy;
}
```

### 3.3 SecurityExpressionHandler設定

ロール階層を認可判断に組み込むために、`SecurityExpressionHandler`を設定します。

```java
@Bean
public SecurityExpressionHandler<FilterInvocation> webExpressionHandler() {
    DefaultWebSecurityExpressionHandler expressionHandler = new DefaultWebSecurityExpressionHandler();
    expressionHandler.setRoleHierarchy(roleHierarchy());
    return expressionHandler;
}
```

## 4. 処理フロー

### 4.1 ロール一覧取得フロー

```
1. 管理者がロール一覧画面にアクセス
2. RoleController.findRoles() APIが呼び出される
3. @PreAuthorize("hasRole('SYSTEM_ADMIN') or hasRole('SECURITY_ADMIN')")による権限チェック
4. RoleService.findAll() メソッドが実行される
   4.1. RoleRepository経由でデータベースからロール一覧を取得
   4.2. 各ロールに割り当てられたユーザー数を集計
   4.3. 取得結果をDTOに変換
5. ロール一覧をクライアントに返却
```

### 4.2 ロール新規作成フロー

```
1. 管理者がロール作成画面で情報入力
2. RoleController.createRole() APIが呼び出される
3. @PreAuthorize("hasRole('SYSTEM_ADMIN') or hasRole('SECURITY_ADMIN')")による権限チェック
4. RoleService.create() メソッドが実行される
   4.1. ロールIDの重複チェック
   4.2. バリデーション実行
   4.3. ロール作成
   4.4. AuditLogService経由で監査ログ記録
5. 作成結果をクライアントに返却
```

### 4.3 ロール情報更新フロー

```
1. 管理者がロール編集画面で情報更新
2. RoleController.updateRole() APIが呼び出される
3. @PreAuthorize("hasRole('SYSTEM_ADMIN') or (hasRole('SECURITY_ADMIN') and #roleUpdateDTO.roleType == 'BUSINESS')")による権限チェック
4. RoleService.update() メソッドが実行される
   4.1. ロールの存在確認
   4.2. システム定義ロールの場合は変更制限チェック
   4.3. バリデーション実行
   4.4. ロール情報更新
   4.5. AuditLogService経由で監査ログ記録
5. 更新結果をクライアントに返却
```

## 5. 実装詳細

### 5.1 RoleController 実装

Spring Securityのメソッドレベルセキュリティを使用して、権限に基づくアクセス制御を実装します。

```java
@RestController
@RequestMapping("/api/v1/admin/roles")
public class RoleController {

    private final RoleService roleService;
    
    @Autowired
    public RoleController(RoleService roleService) {
        this.roleService = roleService;
    }
    
    @GetMapping
    @PreAuthorize("hasAuthority('USER_MANAGEMENT:ROLE:READ')")
    public Page<RoleDTO> findRoles(Pageable pageable) {
        return roleService.findAll(pageable);
    }
    
    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('USER_MANAGEMENT:ROLE:READ')")
    public RoleDTO getRole(@PathVariable UUID id) {
        return roleService.findById(id);
    }
    
    @GetMapping("/types/{roleType}")
    @PreAuthorize("hasAuthority('USER_MANAGEMENT:ROLE:READ')")
    public List<RoleDTO> getRolesByType(@PathVariable RoleType roleType) {
        return roleService.findByRoleType(roleType);
    }
    
    @PostMapping
    @PreAuthorize("hasRole('SYSTEM_ADMIN') or (hasRole('SECURITY_ADMIN') and #roleCreateDTO.roleType == 'BUSINESS')")
    public ResponseEntity<RoleDTO> createRole(@RequestBody @Valid RoleCreateDTO roleCreateDTO) {
        RoleDTO createdRole = roleService.create(roleCreateDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(createdRole);
    }
    
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('SYSTEM_ADMIN') or (hasRole('SECURITY_ADMIN') and @roleSecurityService.isBuinessRole(#id))")
    public RoleDTO updateRole(@PathVariable UUID id, @RequestBody @Valid RoleUpdateDTO roleUpdateDTO) {
        return roleService.update(id, roleUpdateDTO);
    }
    
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('SYSTEM_ADMIN') or (hasRole('SECURITY_ADMIN') and @roleSecurityService.isBuinessRole(#id))")
    public ResponseEntity<Void> deleteRole(@PathVariable UUID id) {
        roleService.delete(id);
        return ResponseEntity.ok().build();
    }
    
    @PostMapping("/{id}/clone")
    @PreAuthorize("hasRole('SYSTEM_ADMIN') or hasRole('SECURITY_ADMIN')")
    public ResponseEntity<RoleDTO> cloneRole(@PathVariable UUID id, @RequestBody RoleCloneRequest request) {
        RoleDTO clonedRole = roleService.clone(id, request.getNewRoleId(), request.getNewRoleName());
        return ResponseEntity.status(HttpStatus.CREATED).body(clonedRole);
    }
}
```

### 5.2 RoleServiceImpl 実装

```java
@Service
public class RoleServiceImpl implements RoleService {

    private final RoleRepository roleRepository;
    private final RolePermissionRepository rolePermissionRepository;
    private final UserRoleRepository userRoleRepository;
    private final AuditLogService auditLogService;
    
    @Autowired
    public RoleServiceImpl(
            RoleRepository roleRepository,
            RolePermissionRepository rolePermissionRepository,
            UserRoleRepository userRoleRepository,
            AuditLogService auditLogService) {
        this.roleRepository = roleRepository;
        this.rolePermissionRepository = rolePermissionRepository;
        this.userRoleRepository = userRoleRepository;
        this.auditLogService = auditLogService;
    }
    
    @Override
    @Transactional
    public RoleDTO create(RoleCreateDTO roleCreateDTO) {
        // 重複チェック
        if (roleRepository.existsByRoleId(roleCreateDTO.getRoleId())) {
            throw new DuplicateEntityException("Role with roleId " + roleCreateDTO.getRoleId() + " already exists");
        }
        
        // 新規ロールエンティティの作成
        Role role = new Role();
        role.setId(UUID.randomUUID());
        role.setRoleId(roleCreateDTO.getRoleId());
        role.setName(roleCreateDTO.getName());
        role.setDescription(roleCreateDTO.getDescription());
        role.setRoleType(roleCreateDTO.getRoleType());
        
        LocalDateTime now = LocalDateTime.now();
        role.setCreatedAt(now);
        role.setUpdatedAt(now);
        
        Role savedRole = roleRepository.save(role);
        
        // 監査ログ記録
        recordAuditLog("CREATE_ROLE", savedRole, null);
        
        return convertToDTO(savedRole);
    }
    
    @Override
    @Transactional
    public RoleDTO update(UUID id, RoleUpdateDTO roleUpdateDTO) {
        Role role = roleRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Role not found with id: " + id));
        
        // システム定義ロールの場合、変更制限をチェック
        if (isSystemDefinedRole(role.getRoleId())) {
            validateSystemRoleUpdate(role, roleUpdateDTO);
        }
        
        // ロール情報更新
        role.setName(roleUpdateDTO.getName());
        role.setDescription(roleUpdateDTO.getDescription());
        role.setUpdatedAt(LocalDateTime.now());
        
        Role updatedRole = roleRepository.save(role);
        
        // 監査ログ記録
        recordAuditLog("UPDATE_ROLE", updatedRole, null);
        
        return convertToDTO(updatedRole);
    }
    
    @Override
    @Transactional
    public void delete(UUID id) {
        Role role = roleRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Role not found with id: " + id));
        
        // システム定義ロールは削除不可
        if (isSystemDefinedRole(role.getRoleId())) {
            throw new BusinessRuleException("System defined role cannot be deleted: " + role.getRoleId());
        }
        
        // ロールに割り当てられたユーザーの存在確認
        long userCount = userRoleRepository.countByRoleId(id);
        if (userCount > 0) {
            throw new BusinessRuleException("Role is still assigned to " + userCount + " users and cannot be deleted");
        }
        
        // ロールに関連する権限設定の削除
        rolePermissionRepository.deleteByRoleId(id);
        
        // ロール削除
        roleRepository.delete(role);
        
        // 監査ログ記録
        recordAuditLog("DELETE_ROLE", role, null);
    }
    
    @Override
    @Transactional
    public RoleDTO clone(UUID id, String newRoleId, String newRoleName) {
        Role sourceRole = roleRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Source role not found with id: " + id));
        
        // 新ロールIDの重複チェック
        if (roleRepository.existsByRoleId(newRoleId)) {
            throw new DuplicateEntityException("Role with roleId " + newRoleId + " already exists");
        }
        
        // 新規ロールエンティティの作成
        Role newRole = new Role();
        newRole.setId(UUID.randomUUID());
        newRole.setRoleId(newRoleId);
        newRole.setName(newRoleName);
        newRole.setDescription(sourceRole.getDescription() + " (Clone of " + sourceRole.getRoleId() + ")");
        newRole.setRoleType(sourceRole.getRoleType());
        
        LocalDateTime now = LocalDateTime.now();
        newRole.setCreatedAt(now);
        newRole.setUpdatedAt(now);
        
        Role savedRole = roleRepository.save(newRole);
        
        // 権限情報の複製
        List<RolePermission> sourcePermissions = rolePermissionRepository.findByRoleId(sourceRole.getId());
        List<RolePermission> newPermissions = new ArrayList<>();
        
        for (RolePermission sourcePermission : sourcePermissions) {
            RolePermission newPermission = new RolePermission();
            newPermission.setRoleId(savedRole.getId());
            newPermission.setPermissionId(sourcePermission.getPermissionId());
            newPermission.setAccessLevel(sourcePermission.getAccessLevel());
            newPermissions.add(newPermission);
        }
        
        rolePermissionRepository.saveAll(newPermissions);
        
        // 監査ログ記録
        Map<String, Object> details = new HashMap<>();
        details.put("sourceRoleId", sourceRole.getRoleId());
        
        recordAuditLog("CLONE_ROLE", savedRole, details);
        
        return convertToDTO(savedRole);
    }
    
    // 他のメソッド...
    
    // Helper methods
    
    private RoleDTO convertToDTO(Role role) {
        RoleDTO dto = new RoleDTO();
        dto.setId(role.getId());
        dto.setRoleId(role.getRoleId());
        dto.setName(role.getName());
        dto.setDescription(role.getDescription());
        dto.setRoleType(role.getRoleType());
        dto.setCreatedAt(role.getCreatedAt());
        dto.setUpdatedAt(role.getUpdatedAt());
        
        // ロールに割り当てられたユーザー数を取得
        long userCount = userRoleRepository.countByRoleId(role.getId());
        dto.setUserCount((int) userCount);
        
        return dto;
    }
    
    private boolean isSystemDefinedRole(String roleId) {
        // システム定義ロールかどうかをチェック
        Set<String> systemRoles = Set.of(
                "SYSTEM_ADMIN",
                "SECURITY_ADMIN",
                "AUDITOR"
        );
        return systemRoles.contains(roleId);
    }
    
    private void validateSystemRoleUpdate(Role role, RoleUpdateDTO updateDTO) {
        // システム定義ロールの変更可能項目をチェック
        // 例: 名前変更は許可するが、説明の変更は許可しない場合など
        // このサンプルでは、設計上の理由から変更を許可
    }
    
    private void recordAuditLog(String action, Role role, Map<String, Object> additionalDetails) {
        Map<String, Object> details = new HashMap<>();
        details.put("roleId", role.getRoleId());
        details.put("name", role.getName());
        details.put("roleType", role.getRoleType());
        
        if (additionalDetails != null) {
            details.putAll(additionalDetails);
        }
        
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String performedBy = "system";
        if (authentication != null && authentication.getPrincipal() instanceof CustomUserDetails) {
            performedBy = ((CustomUserDetails) authentication.getPrincipal()).getUsername();
        }
        
        auditLogService.recordAuditLog(
                action,
                "ROLE",
                role.getId().toString(),
                performedBy,
                details
        );
    }
}
```

### 5.3 RoleSecurityService 実装

Spring Security内でロールのセキュリティチェックを行うためのサービスを実装します。

```java
@Service
public class RoleSecurityService {

    private final RoleRepository roleRepository;
    
    @Autowired
    public RoleSecurityService(RoleRepository roleRepository) {
        this.roleRepository = roleRepository;
    }
    
    /**
     * 指定されたロールが業務ロールかどうかをチェックする
     * @PreAuthorizeアノテーション内で使用するためのメソッド
     */
    public boolean isBusinessRole(UUID roleId) {
        Role role = roleRepository.findById(roleId).orElse(null);
        if (role == null) {
            return false;
        }
        return role.getRoleType() == RoleType.BUSINESS;
    }
    
    /**
     * 指定されたロールがシステムロールかどうかをチェックする
     */
    public boolean isSystemRole(UUID roleId) {
        Role role = roleRepository.findById(roleId).orElse(null);
        if (role == null) {
            return false;
        }
        return role.getRoleType() == RoleType.SYSTEM;
    }
}
```

### 5.4 GrantedAuthorityLoader 実装

Spring Securityの`GrantedAuthority`を動的にロードするサービスを実装します。

```java
@Service
public class GrantedAuthorityLoader {

    private final RoleRepository roleRepository;
    private final RolePermissionRepository rolePermissionRepository;
    private final PermissionRepository permissionRepository;
    
    @Autowired
    public GrantedAuthorityLoader(
            RoleRepository roleRepository,
            RolePermissionRepository rolePermissionRepository,
            PermissionRepository permissionRepository) {
        this.roleRepository = roleRepository;
        this.rolePermissionRepository = rolePermissionRepository;
        this.permissionRepository = permissionRepository;
    }
    
    /**
     * ユーザーIDに基づいて権限情報を取得する
     */
    public Set<GrantedAuthority> getAuthoritiesForUser(UUID userId, Collection<UserRole> userRoles) {
        Set<GrantedAuthority> authorities = new HashSet<>();
        
        // ユーザーに割り当てられた各ロールの処理
        for (UserRole userRole : userRoles) {
            Role role = roleRepository.findById(userRole.getRoleId()).orElse(null);
            if (role == null) {
                continue;
            }
            
            // ロール自体を権限として追加（ROLE_プレフィックス付き）
            authorities.add(new SimpleGrantedAuthority("ROLE_" + role.getRoleId()));
            
            // ロールに割り当てられた権限を追加
            List<RolePermission> rolePermissions = rolePermissionRepository.findByRoleId(role.getId());
            for (RolePermission rolePermission : rolePermissions) {
                if (rolePermission.getAccessLevel() == AccessLevel.NONE) {
                    continue;
                }
                
                permissionRepository.findById(rolePermission.getPermissionId()).ifPresent(permission -> {
                    // 権限ID形式: "{resourceType}:{resourceName}:{action}"
                    String permissionId = permission.getPermissionId();
                    authorities.add(new SimpleGrantedAuthority(permissionId));
                    
                    // アクセスレベルに応じた追加権限
                    if (rolePermission.getAccessLevel() == AccessLevel.WRITE || 
                        rolePermission.getAccessLevel() == AccessLevel.ADMIN) {
                        // WRITE権限はREAD権限も含む
                        String readPermission = permissionId.replace(":WRITE", ":READ");
                        authorities.add(new SimpleGrantedAuthority(readPermission));
                    }
                    
                    if (rolePermission.getAccessLevel() == AccessLevel.ADMIN) {
                        // ADMIN権限はWRITEとEXECUTE権限も含む
                        String writePermission = permissionId.replace(":ADMIN", ":WRITE");
                        String executePermission = permissionId.replace(":ADMIN", ":EXECUTE");
                        authorities.add(new SimpleGrantedAuthority(writePermission));
                        authorities.add(new SimpleGrantedAuthority(executePermission));
                    }
                });
            }
        }
        
        return authorities;
    }
}
```

## 6. Spring Securityのロール階層と権限設計

### 6.1 ロール階層設計

Spring Securityの`RoleHierarchy`を使用してロールの階層関係を定義します：

```
ROLE_SYSTEM_ADMIN > ROLE_SECURITY_ADMIN
ROLE_SECURITY_ADMIN > ROLE_AUDITOR
ROLE_AUDITOR > ROLE_USER

ROLE_SALES_MANAGER > ROLE_SALES_STAFF
ROLE_HR_MANAGER > ROLE_HR_STAFF
ROLE_FINANCE_MANAGER > ROLE_FINANCE_STAFF
ROLE_MATCHING_MANAGER > ROLE_MATCHING_STAFF
```

この設定により、上位ロールは下位ロールのすべての権限を継承します。例えば、`ROLE_SYSTEM_ADMIN`は`ROLE_SECURITY_ADMIN`、`ROLE_AUDITOR`、`ROLE_USER`のすべての権限を持ちます。

### 6.2 メソッドセキュリティの活用

Spring Securityのメソッドセキュリティを使用して、権限に基づくアクセス制御を細かく設定できます：

```java
// ロールベースの権限チェック
@PreAuthorize("hasRole('SYSTEM_ADMIN')")

// 権限ベースの権限チェック
@PreAuthorize("hasAuthority('USER_MANAGEMENT:ROLE:READ')")

// 複合条件の権限チェック
@PreAuthorize("hasRole('SYSTEM_ADMIN') or (hasRole('SECURITY_ADMIN') and #roleCreateDTO.roleType == 'BUSINESS')")

// SpEL式を使った高度な条件
@PreAuthorize("hasRole('SYSTEM_ADMIN') or (hasPermission(#id, 'Role', 'EDIT'))")
```

### 6.3 カスタムセキュリティ式の定義

`SecurityExpressionRoot`を拡張して、カスタムセキュリティ式を定義することも可能です：

```java
public class CustomMethodSecurityExpressionRoot extends SecurityExpressionRoot {
    
    private RoleRepository roleRepository;
    
    public CustomMethodSecurityExpressionRoot(Authentication authentication) {
        super(authentication);
    }
    
    public void setRoleRepository(RoleRepository roleRepository) {
        this.roleRepository = roleRepository;
    }
    
    public boolean canManageRole(UUID roleId) {
        // システム管理者はすべてのロールを管理できる
        if (hasRole("SYSTEM_ADMIN")) {
            return true;
        }
        
        // セキュリティ管理者は業務ロールのみ管理できる
        if (hasRole("SECURITY_ADMIN")) {
            Role role = roleRepository.findById(roleId).orElse(null);
            return role != null && role.getRoleType() == RoleType.BUSINESS;
        }
        
        return false;
    }
}
```

## 7. プリセットロールのSpring Security対応実装

システムには以下のプリセットロールを実装し、Spring Securityと連携します：

```java
@Component
public class SystemRoleInitializer {
    
    private final RoleRepository roleRepository;
    private final PermissionRepository permissionRepository;
    private final RolePermissionRepository rolePermissionRepository;
    
    @Autowired
    public SystemRoleInitializer(
            RoleRepository roleRepository,
            PermissionRepository permissionRepository,
            RolePermissionRepository rolePermissionRepository) {
        this.roleRepository = roleRepository;
        this.permissionRepository = permissionRepository;
        this.rolePermissionRepository = rolePermissionRepository;
    }
    
    @PostConstruct
    @Transactional
    public void initializeSystemRoles() {
        // システム管理者ロール
        createRoleIfNotExists(
                "SYSTEM_ADMIN",
                "システム管理者",
                "システム全体の管理権限を持つロール",
                RoleType.SYSTEM
        );
        
        // セキュリティ管理者ロール
        createRoleIfNotExists(
                "SECURITY_ADMIN",
                "セキュリティ管理者",
                "セキュリティ関連の管理権限を持つロール",
                RoleType.SYSTEM
        );
        
        // 監査者ロール
        createRoleIfNotExists(
                "AUDITOR",
                "監査者",
                "監査・参照権限を持つロール",
                RoleType.SYSTEM
        );
        
        // 基本ユーザーロール（すべてのユーザーが持つ）
        createRoleIfNotExists(
                "USER",
                "一般ユーザー",
                "システムへのアクセスに必要な最低限の権限を持つロール",
                RoleType.SYSTEM
        );
        
        // 業務ロール（例）
        createRoleIfNotExists(
                "SALES_MANAGER",
                "営業管理者",
                "営業部門の管理権限を持つロール",
                RoleType.BUSINESS
        );
        
        // 各ロールに対する権限設定
        assignRolePermissions();
    }
    
    private void createRoleIfNotExists(String roleId, String name, String description, RoleType roleType) {
        if (!roleRepository.existsByRoleId(roleId)) {
            Role role = new Role();
            role.setId(UUID.randomUUID());
            role.setRoleId(roleId);
            role.setName(name);
            role.setDescription(description);
            role.setRoleType(roleType);
            
            LocalDateTime now = LocalDateTime.now();
            role.setCreatedAt(now);
            role.setUpdatedAt(now);
            
            roleRepository.save(role);
        }
    }
    
    private void assignRolePermissions() {
        // Spring SecurityのRoleHierarchyに合わせた権限設定
        
        // SYSTEM_ADMINには全権限を付与
        Role systemAdminRole = roleRepository.findByRoleId("SYSTEM_ADMIN")
                .orElseThrow(() -> new IllegalStateException("System Admin role not found"));
        
        assignAllPermissionsToRole(systemAdminRole.getId(), AccessLevel.ADMIN);
        
        // SECURITY_ADMINにはセキュリティ関連および業務ロール管理の権限を付与
        Role securityAdminRole = roleRepository.findByRoleId("SECURITY_ADMIN")
                .orElseThrow(() -> new IllegalStateException("Security Admin role not found"));
        
        assignSecurityPermissionsToRole(securityAdminRole.getId());
        
        // AUDITORには参照権限のみを付与
        Role auditorRole = roleRepository.findByRoleId("AUDITOR")
                .orElseThrow(() -> new IllegalStateException("Auditor role not found"));
        
        assignReadPermissionsToRole(auditorRole.getId());
        
        // 業務ロールには対応する業務機能の権限を付与
        assignBusinessRolePermissions();
    }
    
    private void assignAllPermissionsToRole(UUID roleId, AccessLevel accessLevel) {
        List<Permission> allPermissions = permissionRepository.findAll();
        List<RolePermission> rolePermissions = new ArrayList<>();
        
        for (Permission permission : allPermissions) {
            RolePermission rolePermission = new RolePermission();
            rolePermission.setRoleId(roleId);
            rolePermission.setPermissionId(permission.getId());
            rolePermission.setAccessLevel(accessLevel);
            rolePermissions.add(rolePermission);
        }
        
        rolePermissionRepository.saveAll(rolePermissions);
    }
    
    private void assignSecurityPermissionsToRole(UUID roleId) {
        // セキュリティ関連およびユーザー/ロール/権限管理の権限を付与
        List<Permission> permissions = permissionRepository.findByResourceTypeIn(
                Arrays.asList("USER_MANAGEMENT", "SECURITY", "AUDIT_LOG"));
        
        List<RolePermission> rolePermissions = new ArrayList<>();
        
        for (Permission permission : permissions) {
            AccessLevel accessLevel = AccessLevel.ADMIN;
            
            // システムロール管理はSECURITY_ADMINには参照のみ許可
            if (permission.getResourceName().equals("SYSTEM_ROLE") && 
                !permission.getAction().equals("READ")) {
                continue;
            }
            
            RolePermission rolePermission = new RolePermission();
            rolePermission.setRoleId(roleId);
            rolePermission.setPermissionId(permission.getId());
            rolePermission.setAccessLevel(accessLevel);
            rolePermissions.add(rolePermission);
        }
        
        rolePermissionRepository.saveAll(rolePermissions);
    }
    
    private void assignReadPermissionsToRole(UUID roleId) {
        // 全機能の参照権限のみを付与
        List<Permission> permissions = permissionRepository.findByAction("READ");
        
        List<RolePermission> rolePermissions = new ArrayList<>();
        
        for (Permission permission : permissions) {
            RolePermission rolePermission = new RolePermission();
            rolePermission.setRoleId(roleId);
            rolePermission.setPermissionId(permission.getId());
            rolePermission.setAccessLevel(AccessLevel.READ);
            rolePermissions.add(rolePermission);
        }
        
        rolePermissionRepository.saveAll(rolePermissions);
    }
    
    private void assignBusinessRolePermissions() {
        // 各業務ロールに対応する業務機能の権限を付与
        // 実装省略
    }
}
```

## 8. セキュリティ対策

### 8.1 メソッドレベルセキュリティの活用

- `@PreAuthorize`, `@PostAuthorize`アノテーションによる細かい権限チェック
- SpEL式を使った複雑な条件式の評価
- `@Secured`, `@RolesAllowed`などの標準アノテーションサポート

### 8.2 ロール階層による権限委譲の明確化

- `RoleHierarchy`を使用した権限の継承関係の明示
- 上位ロールによる下位ロールの権限の自動継承
- 権限関係の一元管理による保守性の向上

### 8.3 動的権限評価

- `PermissionEvaluator`を実装したカスタム権限評価
- `SecurityExpressionRoot`の拡張によるカスタムセキュリティ関数
- コンテキスト情報に基づいた権限の動的評価

## 9. テスト方針

### 9.1 Spring Securityを活用したテスト

```java
@WebMvcTest(RoleController.class)
@WithMockUser(roles = "SYSTEM_ADMIN")
public class RoleControllerTest {

    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private RoleService roleService;
    
    @Test
    public void testFindRoles() throws Exception {
        // テスト実装
        mockMvc.perform(get("/api/v1/admin/roles"))
               .andExpect(status().isOk());
    }
    
    @Test
    @WithMockUser(roles = "USER")
    public void testFindRolesWithInsufficientPermission() throws Exception {
        // 権限不足の場合のテスト
        mockMvc.perform(get("/api/v1/admin/roles"))
               .andExpect(status().isForbidden());
    }
}
```

### 9.2 ロール階層のテスト

```java
@SpringBootTest
public class RoleHierarchyTest {

    @Autowired
    private RoleHierarchy roleHierarchy;
    
    @Test
    public void testRoleHierarchy() {
        Collection<GrantedAuthority> authorities = new ArrayList<>();
        authorities.add(new SimpleGrantedAuthority("ROLE_SYSTEM_ADMIN"));
        
        Collection<? extends GrantedAuthority> reachableGrantedAuthorities = 
            roleHierarchy.getReachableGrantedAuthorities(authorities);
        
        assertThat(reachableGrantedAuthorities)
            .contains(new SimpleGrantedAuthority("ROLE_SECURITY_ADMIN"))
            .contains(new SimpleGrantedAuthority("ROLE_AUDITOR"))
            .contains(new SimpleGrantedAuthority("ROLE_USER"));
    }
}
```

### 9.3 カスタム権限評価のテスト

```java
@SpringBootTest
public class RoleSecurityServiceTest {

    @Autowired
    private RoleSecurityService roleSecurityService;
    
    @Autowired
    private RoleRepository roleRepository;
    
    @Test
    public void testIsBusinessRole() {
        // 業務ロールのテスト
        Role businessRole = new Role();
        businessRole.setId(UUID.randomUUID());
        businessRole.setRoleId("TEST_BUSINESS_ROLE");
        businessRole.setName("テスト業務ロール");
        businessRole.setRoleType(RoleType.BUSINESS);
        businessRole = roleRepository.save(businessRole);
        
        assertTrue(roleSecurityService.isBusinessRole(businessRole.getId()));
        assertFalse(roleSecurityService.isSystemRole(businessRole.getId()));
    }
}
```

## 10. Spring Securityへの移行手順

1. Spring Security依存関係の追加
2. `SecurityConfiguration`クラスの作成とロール階層の設定
3. `UserDetailsService`と`CustomUserDetails`の実装
4. `RoleHierarchy`と`SecurityExpressionHandler`の設定
5. メソッドレベルセキュリティの有効化と権限アノテーションの追加
6. カスタムセキュリティサービスの実装
7. 既存のロールと権限データの新しいSpring Security形式への変換
8. セキュリティテストの追加と検証