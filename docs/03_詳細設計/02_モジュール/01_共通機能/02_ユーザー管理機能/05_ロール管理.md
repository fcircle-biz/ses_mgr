# ユーザー管理機能 - ロール管理

## 1. 機能概要

ロール管理機能は、SES業務システムにおけるロールの定義、編集、削除、権限設定を担当します。システム内での役割や権限の集合体としてのロールを管理し、ユーザーへの適切な権限割り当てを可能にします。

## 2. 主要コンポーネント構成

ロール管理機能は以下のコンポーネントで構成されます：

### 2.1 コンポーネント構成図

```
                   ┌─────────────────┐
                   │  RoleController │
                   └────────┬────────┘
                            │
                            ▼
┌─────────────────┐  ┌─────────────────┐  ┌──────────────────┐
│ PermissionService │◄─┤   RoleService   │─►│  AuditLogService  │
└─────────────────┘  └────────┬────────┘  └──────────────────┘
                             │
                             ▼
                   ┌─────────────────┐
                   │  RoleRepository │
                   └─────────────────┘
```

### 2.2 コンポーネント説明

- **RoleController**: ロール管理のRESTful APIエンドポイントを提供
- **RoleService**: ロール管理のビジネスロジックを実装
- **RoleRepository**: ロールデータのデータアクセス層
- **外部依存**: PermissionService（権限管理機能）、AuditLogService（監査ログ機能）

## 3. 処理フロー

### 3.1 ロール一覧取得フロー

```
1. 管理者がロール一覧画面にアクセス
2. RoleController.findRoles() APIが呼び出される
3. RoleService.findAll() メソッドが実行される
   3.1. RoleRepository経由でデータベースからロール一覧を取得
   3.2. 各ロールに割り当てられたユーザー数を集計
   3.3. 取得結果をDTOに変換
4. ロール一覧をクライアントに返却
```

### 3.2 ロール新規作成フロー

```
1. 管理者がロール作成画面で情報入力
2. RoleController.createRole() APIが呼び出される
3. RoleService.create() メソッドが実行される
   3.1. ロールIDの重複チェック
   3.2. バリデーション実行
   3.3. ロール作成
   3.4. AuditLogService経由で監査ログ記録
4. 作成結果をクライアントに返却
```

### 3.3 ロール情報更新フロー

```
1. 管理者がロール編集画面で情報更新
2. RoleController.updateRole() APIが呼び出される
3. RoleService.update() メソッドが実行される
   3.1. ロールの存在確認
   3.2. システム定義ロールの場合は変更制限チェック
   3.3. バリデーション実行
   3.4. ロール情報更新
   3.5. AuditLogService経由で監査ログ記録
4. 更新結果をクライアントに返却
```

### 3.4 ロール削除フロー

```
1. 管理者がロール一覧からロールの削除を実行
2. RoleController.deleteRole() APIが呼び出される
3. RoleService.delete() メソッドが実行される
   3.1. ロールの存在確認
   3.2. システム定義ロールの場合は削除不可
   3.3. ロールに割り当てられたユーザーの存在確認
   3.4. ロール削除
   3.5. AuditLogService経由で監査ログ記録
4. 削除結果をクライアントに返却
```

### 3.5 ロール複製フロー

```
1. 管理者がロール一覧からロールの複製を実行
2. RoleController.cloneRole() APIが呼び出される
3. RoleService.clone() メソッドが実行される
   3.1. 元ロールの存在確認
   3.2. 新ロールIDの重複チェック
   3.3. 元ロールの権限情報取得
   3.4. 新ロール作成
   3.5. 権限情報の複製
   3.6. AuditLogService経由で監査ログ記録
4. 複製結果をクライアントに返却
```

## 4. 実装詳細

### 4.1 RoleController 実装

```java
@RestController
@RequestMapping("/api/v1/admin/roles")
public class RoleController {

    private final RoleService roleService;
    
    @Autowired
    public RoleController(RoleService roleService) {
        this.roleService = roleService;
    }
    
    @GetMapping
    public Page<RoleDTO> findRoles(Pageable pageable) {
        return roleService.findAll(pageable);
    }
    
    @GetMapping("/{id}")
    public RoleDTO getRole(@PathVariable UUID id) {
        return roleService.findById(id);
    }
    
    @GetMapping("/types/{roleType}")
    public List<RoleDTO> getRolesByType(@PathVariable RoleType roleType) {
        return roleService.findByRoleType(roleType);
    }
    
    @PostMapping
    public ResponseEntity<RoleDTO> createRole(@RequestBody @Valid RoleCreateDTO roleCreateDTO) {
        RoleDTO createdRole = roleService.create(roleCreateDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(createdRole);
    }
    
    @PutMapping("/{id}")
    public RoleDTO updateRole(@PathVariable UUID id, @RequestBody @Valid RoleUpdateDTO roleUpdateDTO) {
        return roleService.update(id, roleUpdateDTO);
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteRole(@PathVariable UUID id) {
        roleService.delete(id);
        return ResponseEntity.ok().build();
    }
    
    @PostMapping("/{id}/clone")
    public ResponseEntity<RoleDTO> cloneRole(@PathVariable UUID id, @RequestBody RoleCloneRequest request) {
        RoleDTO clonedRole = roleService.clone(id, request.getNewRoleId(), request.getNewRoleName());
        return ResponseEntity.status(HttpStatus.CREATED).body(clonedRole);
    }
}
```

### 4.2 RoleServiceImpl 実装

```java
@Service
public class RoleServiceImpl implements RoleService {

    private final RoleRepository roleRepository;
    private final RolePermissionRepository rolePermissionRepository;
    private final UserRoleRepository userRoleRepository;
    private final AuditLogService auditLogService;
    
    @Autowired
    public RoleServiceImpl(
            RoleRepository roleRepository,
            RolePermissionRepository rolePermissionRepository,
            UserRoleRepository userRoleRepository,
            AuditLogService auditLogService) {
        this.roleRepository = roleRepository;
        this.rolePermissionRepository = rolePermissionRepository;
        this.userRoleRepository = userRoleRepository;
        this.auditLogService = auditLogService;
    }
    
    @Override
    @Transactional(readOnly = true)
    public Page<RoleDTO> findAll(Pageable pageable) {
        Page<Role> roles = roleRepository.findAll(pageable);
        return roles.map(this::convertToDTO);
    }
    
    @Override
    @Transactional(readOnly = true)
    public RoleDTO findById(UUID id) {
        Role role = roleRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Role not found with id: " + id));
        return convertToDTO(role);
    }
    
    @Override
    @Transactional(readOnly = true)
    public RoleDTO findByRoleId(String roleId) {
        Role role = roleRepository.findByRoleId(roleId)
                .orElseThrow(() -> new EntityNotFoundException("Role not found with roleId: " + roleId));
        return convertToDTO(role);
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<RoleDTO> findByRoleType(RoleType roleType) {
        List<Role> roles = roleRepository.findByRoleType(roleType);
        return roles.stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }
    
    @Override
    @Transactional
    public RoleDTO create(RoleCreateDTO roleCreateDTO) {
        // 重複チェック
        if (roleRepository.existsByRoleId(roleCreateDTO.getRoleId())) {
            throw new DuplicateEntityException("Role with roleId " + roleCreateDTO.getRoleId() + " already exists");
        }
        
        // 新規ロールエンティティの作成
        Role role = new Role();
        role.setId(UUID.randomUUID());
        role.setRoleId(roleCreateDTO.getRoleId());
        role.setName(roleCreateDTO.getName());
        role.setDescription(roleCreateDTO.getDescription());
        role.setRoleType(roleCreateDTO.getRoleType());
        
        LocalDateTime now = LocalDateTime.now();
        role.setCreatedAt(now);
        role.setUpdatedAt(now);
        
        Role savedRole = roleRepository.save(role);
        
        // 監査ログ記録
        Map<String, Object> details = new HashMap<>();
        details.put("roleId", savedRole.getRoleId());
        details.put("name", savedRole.getName());
        details.put("roleType", savedRole.getRoleType());
        auditLogService.recordAuditLog(
                "CREATE_ROLE",
                "ROLE",
                savedRole.getId().toString(),
                SecurityContextHolder.getContext().getAuthentication().getPrincipal().getUserId(),
                details
        );
        
        return convertToDTO(savedRole);
    }
    
    @Override
    @Transactional
    public RoleDTO update(UUID id, RoleUpdateDTO roleUpdateDTO) {
        Role role = roleRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Role not found with id: " + id));
        
        // システム定義ロールの場合、変更制限をチェック
        if (isSystemDefinedRole(role.getRoleId())) {
            validateSystemRoleUpdate(role, roleUpdateDTO);
        }
        
        // ロール情報更新
        role.setName(roleUpdateDTO.getName());
        role.setDescription(roleUpdateDTO.getDescription());
        role.setUpdatedAt(LocalDateTime.now());
        
        Role updatedRole = roleRepository.save(role);
        
        // 監査ログ記録
        Map<String, Object> details = new HashMap<>();
        details.put("roleId", updatedRole.getRoleId());
        details.put("name", updatedRole.getName());
        auditLogService.recordAuditLog(
                "UPDATE_ROLE",
                "ROLE",
                updatedRole.getId().toString(),
                SecurityContextHolder.getContext().getAuthentication().getPrincipal().getUserId(),
                details
        );
        
        return convertToDTO(updatedRole);
    }
    
    @Override
    @Transactional
    public void delete(UUID id) {
        Role role = roleRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Role not found with id: " + id));
        
        // システム定義ロールは削除不可
        if (isSystemDefinedRole(role.getRoleId())) {
            throw new BusinessRuleException("System defined role cannot be deleted: " + role.getRoleId());
        }
        
        // ロールに割り当てられたユーザーの存在確認
        long userCount = userRoleRepository.countByRoleId(id);
        if (userCount > 0) {
            throw new BusinessRuleException("Role is still assigned to " + userCount + " users and cannot be deleted");
        }
        
        // ロールに関連する権限設定の削除
        rolePermissionRepository.deleteByRoleId(id);
        
        // ロール削除
        roleRepository.delete(role);
        
        // 監査ログ記録
        Map<String, Object> details = new HashMap<>();
        details.put("roleId", role.getRoleId());
        details.put("name", role.getName());
        auditLogService.recordAuditLog(
                "DELETE_ROLE",
                "ROLE",
                role.getId().toString(),
                SecurityContextHolder.getContext().getAuthentication().getPrincipal().getUserId(),
                details
        );
    }
    
    @Override
    @Transactional
    public RoleDTO clone(UUID id, String newRoleId, String newRoleName) {
        Role sourceRole = roleRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Source role not found with id: " + id));
        
        // 新ロールIDの重複チェック
        if (roleRepository.existsByRoleId(newRoleId)) {
            throw new DuplicateEntityException("Role with roleId " + newRoleId + " already exists");
        }
        
        // 新規ロールエンティティの作成
        Role newRole = new Role();
        newRole.setId(UUID.randomUUID());
        newRole.setRoleId(newRoleId);
        newRole.setName(newRoleName);
        newRole.setDescription(sourceRole.getDescription() + " (Clone of " + sourceRole.getRoleId() + ")");
        newRole.setRoleType(sourceRole.getRoleType());
        
        LocalDateTime now = LocalDateTime.now();
        newRole.setCreatedAt(now);
        newRole.setUpdatedAt(now);
        
        Role savedRole = roleRepository.save(newRole);
        
        // 権限情報の複製
        List<RolePermission> sourcePermissions = rolePermissionRepository.findByRoleId(sourceRole.getId());
        List<RolePermission> newPermissions = new ArrayList<>();
        
        for (RolePermission sourcePermission : sourcePermissions) {
            RolePermission newPermission = new RolePermission();
            newPermission.setRoleId(savedRole.getId());
            newPermission.setPermissionId(sourcePermission.getPermissionId());
            newPermission.setAccessLevel(sourcePermission.getAccessLevel());
            newPermissions.add(newPermission);
        }
        
        rolePermissionRepository.saveAll(newPermissions);
        
        // 監査ログ記録
        Map<String, Object> details = new HashMap<>();
        details.put("sourceRoleId", sourceRole.getRoleId());
        details.put("newRoleId", savedRole.getRoleId());
        details.put("newRoleName", savedRole.getName());
        auditLogService.recordAuditLog(
                "CLONE_ROLE",
                "ROLE",
                savedRole.getId().toString(),
                SecurityContextHolder.getContext().getAuthentication().getPrincipal().getUserId(),
                details
        );
        
        return convertToDTO(savedRole);
    }
    
    // Helper methods
    
    private RoleDTO convertToDTO(Role role) {
        RoleDTO dto = new RoleDTO();
        dto.setId(role.getId());
        dto.setRoleId(role.getRoleId());
        dto.setName(role.getName());
        dto.setDescription(role.getDescription());
        dto.setRoleType(role.getRoleType());
        dto.setCreatedAt(role.getCreatedAt());
        dto.setUpdatedAt(role.getUpdatedAt());
        
        // ロールに割り当てられたユーザー数を取得
        long userCount = userRoleRepository.countByRoleId(role.getId());
        dto.setUserCount((int) userCount);
        
        return dto;
    }
    
    private boolean isSystemDefinedRole(String roleId) {
        // システム定義ロールかどうかをチェック
        Set<String> systemRoles = Set.of(
                "SYSTEM_ADMIN",
                "SECURITY_ADMIN",
                "AUDITOR"
        );
        return systemRoles.contains(roleId);
    }
    
    private void validateSystemRoleUpdate(Role role, RoleUpdateDTO updateDTO) {
        // システム定義ロールの変更可能項目をチェック
        // 例: 名前変更は許可するが、説明の変更は許可しない場合など
        // このサンプルでは簡略化のため、単純に名前と説明の変更を許可
    }
}
```

### 4.3 RoleRepository 実装

```java
public interface RoleRepository extends JpaRepository<Role, UUID> {
    
    Optional<Role> findByRoleId(String roleId);
    
    boolean existsByRoleId(String roleId);
    
    List<Role> findByRoleType(RoleType roleType);
}
```

### 4.4 RolePermissionRepository 実装

```java
public interface RolePermissionRepository extends JpaRepository<RolePermission, Long> {
    
    List<RolePermission> findByRoleId(UUID roleId);
    
    void deleteByRoleId(UUID roleId);
    
    void deleteByRoleIdAndPermissionId(UUID roleId, UUID permissionId);
}
```

### 4.5 UserRoleRepository 実装

```java
public interface UserRoleRepository extends JpaRepository<UserRole, Long> {
    
    List<UserRole> findByUserId(UUID userId);
    
    List<UserRole> findByRoleId(UUID roleId);
    
    Optional<UserRole> findByUserIdAndRoleId(UUID userId, UUID roleId);
    
    void deleteByUserIdAndRoleId(UUID userId, UUID roleId);
    
    long countByRoleId(UUID roleId);
}
```

## 5. 例外処理

ロール管理機能では、以下の例外処理を実装します：

### 5.1 例外クラス

```java
// 例外クラスはユーザーアカウント管理機能と共通で使用
public class EntityNotFoundException extends RuntimeException { /* ... */ }
public class DuplicateEntityException extends RuntimeException { /* ... */ }
public class BusinessRuleException extends RuntimeException { /* ... */ }
public class ValidationException extends RuntimeException { /* ... */ }
```

### 5.2 例外ハンドリング

```java
// 例外ハンドラーはユーザーアカウント管理機能と共通で使用
@ControllerAdvice
public class GlobalExceptionHandler { /* ... */ }
```

## 6. プリセットロールの実装

システムには以下のプリセットロールを実装します：

### 6.1 システムロール

```java
// システムロールの初期化データ
public class SystemRoleInitializer {
    
    private final RoleRepository roleRepository;
    private final PermissionRepository permissionRepository;
    private final RolePermissionRepository rolePermissionRepository;
    
    @Autowired
    public SystemRoleInitializer(
            RoleRepository roleRepository,
            PermissionRepository permissionRepository,
            RolePermissionRepository rolePermissionRepository) {
        this.roleRepository = roleRepository;
        this.permissionRepository = permissionRepository;
        this.rolePermissionRepository = rolePermissionRepository;
    }
    
    @PostConstruct
    @Transactional
    public void initializeSystemRoles() {
        // システム管理者ロール
        createRoleIfNotExists(
                "SYSTEM_ADMIN",
                "システム管理者",
                "システム全体の管理権限を持つロール",
                RoleType.SYSTEM
        );
        
        // セキュリティ管理者ロール
        createRoleIfNotExists(
                "SECURITY_ADMIN",
                "セキュリティ管理者",
                "セキュリティ関連の管理権限を持つロール",
                RoleType.SYSTEM
        );
        
        // 監査者ロール
        createRoleIfNotExists(
                "AUDITOR",
                "監査者",
                "監査・参照権限を持つロール",
                RoleType.SYSTEM
        );
        
        // 業務ロール
        createRoleIfNotExists(
                "SALES_MANAGER",
                "営業管理者",
                "営業部門の管理権限を持つロール",
                RoleType.BUSINESS
        );
        
        createRoleIfNotExists(
                "HR_MANAGER",
                "人事管理者",
                "人事部門の管理権限を持つロール",
                RoleType.BUSINESS
        );
        
        createRoleIfNotExists(
                "FINANCE_MANAGER",
                "経理管理者",
                "経理部門の管理権限を持つロール",
                RoleType.BUSINESS
        );
        
        createRoleIfNotExists(
                "SALES_STAFF",
                "営業担当者",
                "営業担当の基本権限を持つロール",
                RoleType.BUSINESS
        );
        
        createRoleIfNotExists(
                "HR_STAFF",
                "人事担当者",
                "人事担当の基本権限を持つロール",
                RoleType.BUSINESS
        );
        
        createRoleIfNotExists(
                "FINANCE_STAFF",
                "経理担当者",
                "経理担当の基本権限を持つロール",
                RoleType.BUSINESS
        );
        
        createRoleIfNotExists(
                "MATCHING_STAFF",
                "マッチング担当者",
                "マッチング担当の基本権限を持つロール",
                RoleType.BUSINESS
        );
        
        // 各ロールに対する権限設定
        assignSystemAdminPermissions();
        assignSecurityAdminPermissions();
        assignAuditorPermissions();
        assignBusinessRolePermissions();
    }
    
    private void createRoleIfNotExists(String roleId, String name, String description, RoleType roleType) {
        if (!roleRepository.existsByRoleId(roleId)) {
            Role role = new Role();
            role.setId(UUID.randomUUID());
            role.setRoleId(roleId);
            role.setName(name);
            role.setDescription(description);
            role.setRoleType(roleType);
            
            LocalDateTime now = LocalDateTime.now();
            role.setCreatedAt(now);
            role.setUpdatedAt(now);
            
            roleRepository.save(role);
        }
    }
    
    private void assignSystemAdminPermissions() {
        Role role = roleRepository.findByRoleId("SYSTEM_ADMIN")
                .orElseThrow(() -> new IllegalStateException("System Admin role not found"));
        
        // すべての権限を付与
        List<Permission> allPermissions = permissionRepository.findAll();
        for (Permission permission : allPermissions) {
            RolePermission rolePermission = new RolePermission();
            rolePermission.setRoleId(role.getId());
            rolePermission.setPermissionId(permission.getId());
            rolePermission.setAccessLevel(AccessLevel.ADMIN);
            rolePermissionRepository.save(rolePermission);
        }
    }
    
    private void assignSecurityAdminPermissions() {
        // セキュリティ管理者に対する権限設定
        // 例: ユーザー管理、ロール管理、監査ログ閲覧の権限
    }
    
    private void assignAuditorPermissions() {
        // 監査者に対する権限設定
        // 例: 全機能の参照権限
    }
    
    private void assignBusinessRolePermissions() {
        // 業務ロールに対する権限設定
        // 例: 営業管理者には案件管理の全権限、営業担当者には案件情報の登録/更新権限
    }
}
```

## 7. セキュリティ対策

### 7.1 ロール管理のセキュリティ

- システム定義ロールの変更・削除制限
- 重要なロール操作（作成、更新、削除）の監査ログ記録
- ロール操作権限の厳格な制限（システム管理者、セキュリティ管理者のみ）

### 7.2 ロール階層のセキュリティ

- システムロールと業務ロールの明確な区分
- システムロールの操作はシステム管理者のみ許可
- 業務ロールの操作はセキュリティ管理者にも許可

### 7.3 権限委譲のセキュリティ

- 上位権限の委譲は制限（原則として同等以下の権限のみ委譲可能）
- システム管理者ロールの付与はシステム管理者のみ可能
- ロール権限変更時の影響範囲の表示と確認

## 8. テスト方針

### 8.1 単体テスト

- RoleServiceの各メソッドの正常系テスト
- RoleServiceの各メソッドの異常系テスト（例外発生パターン）
- システム定義ロールの制約テスト
- ロール複製機能のテスト

### 8.2 結合テスト

- RoleControllerとRoleServiceの連携テスト
- RoleServiceとRoleRepository/RolePermissionRepositoryの連携テスト
- RoleServiceとAuditLogServiceの連携テスト（モック利用）

### 8.3 シナリオテスト

- ロール作成→権限設定→ユーザー割り当て→ロール編集→ロール削除の一連のフロー
- システム定義ロールの変更・削除制限の確認
- ロール複製と権限の正確な複製確認