# ユーザー管理機能 - ユーザーアカウント管理

## 1. 機能概要

ユーザーアカウント管理機能は、SES業務システムにおけるユーザーの登録、編集、検索、ステータス管理、セキュリティ管理を担当します。本機能により、システム管理者はユーザーのライフサイクル全体を適切に管理できます。

## 2. 主要コンポーネント構成

ユーザーアカウント管理機能は以下のコンポーネントで構成されます：

### 2.1 コンポーネント構成図

```
                  ┌─────────────────┐
                  │  UserController │
                  └────────┬────────┘
                           │
                           ▼
┌─────────────┐    ┌─────────────────┐    ┌──────────────────┐
│ PasswordUtil │◄───│   UserService   │───►│ NotificationService │
└─────────────┘    └────────┬────────┘    └──────────────────┘
                           │
                           ▼
                  ┌─────────────────┐    ┌──────────────────┐
                  │  UserRepository │───►│  AuditLogService  │
                  └─────────────────┘    └──────────────────┘
```

### 2.2 コンポーネント説明

- **UserController**: ユーザー管理のRESTful APIエンドポイントを提供
- **UserService**: ユーザー管理のビジネスロジックを実装
- **UserRepository**: ユーザーデータのデータアクセス層
- **PasswordUtil**: パスワード生成、検証、ハッシュ化などの機能を提供
- **外部依存**: NotificationService（通知機能）、AuditLogService（監査ログ機能）

## 3. 処理フロー

### 3.1 ユーザー新規登録フロー

```
1. システム管理者がユーザー登録画面で情報入力
2. UserController.createUser() APIが呼び出される
3. UserService.create() メソッドが実行される
   3.1. ユーザーID、メールアドレスの重複チェック
   3.2. バリデーション実行
   3.3. 初期パスワード生成（指定されていない場合）
   3.4. パスワードのハッシュ化
   3.5. ユーザー作成（ステータス: PENDING）
   3.6. AuditLogService経由で監査ログ記録
4. NotificationService経由で初期パスワードをメール通知
5. 作成結果をクライアントに返却
```

### 3.2 ユーザー検索フロー

```
1. システム管理者がユーザー検索条件を入力
2. UserController.findUsers() APIが呼び出される
3. UserService.findAll() メソッドが実行される
   3.1. 検索条件をクエリに変換
   3.2. UserRepository経由でデータベースから検索
   3.3. 検索結果をDTOに変換
4. 検索結果をクライアントに返却
```

### 3.3 ユーザー情報更新フロー

```
1. システム管理者がユーザー編集画面で情報更新
2. UserController.updateUser() APIが呼び出される
3. UserService.update() メソッドが実行される
   3.1. ユーザーの存在確認
   3.2. メールアドレス重複チェック（変更時）
   3.3. バリデーション実行
   3.4. ユーザー情報更新
   3.5. AuditLogService経由で監査ログ記録
4. 更新結果をクライアントに返却
```

### 3.4 パスワードリセットフロー

```
1. システム管理者がユーザーのパスワードリセットを実行
2. UserController.resetPassword() APIが呼び出される
3. UserService.resetPassword() メソッドが実行される
   3.1. ユーザーの存在確認
   3.2. 一時パスワード生成
   3.3. パスワードのハッシュ化
   3.4. パスワード情報更新（パスワード有効期限: 24時間）
   3.5. ユーザーステータスを「EXPIRED」に変更
   3.6. AuditLogService経由で監査ログ記録
4. NotificationService経由で一時パスワードをメール通知
5. 処理結果をクライアントに返却
```

### 3.5 アカウントロック解除フロー

```
1. システム管理者がユーザーのアカウントロック解除を実行
2. UserController.unlockAccount() APIが呼び出される
3. UserService.unlockAccount() メソッドが実行される
   3.1. ユーザーの存在確認
   3.2. ユーザーステータスが「LOCKED」かを確認
   3.3. ログイン失敗カウンターをリセット
   3.4. ユーザーステータスを「ACTIVE」に変更
   3.5. AuditLogService経由で監査ログ記録
4. NotificationService経由でロック解除通知
5. 処理結果をクライアントに返却
```

### 3.6 一括ステータス更新フロー

```
1. システム管理者が複数ユーザーを選択してステータス一括更新を実行
2. UserController.bulkUpdateStatus() APIが呼び出される
3. UserService.bulkUpdateStatus() メソッドが実行される
   3.1. トランザクション開始
   3.2. ユーザーごとに順次処理
      3.2.1. ユーザーの存在確認
      3.2.2. ビジネスルールチェック（最後の管理者を無効化不可など）
      3.2.3. ステータス更新
      3.2.4. AuditLogService経由で監査ログ記録
   3.3. トランザクション終了
4. 処理結果をクライアントに返却
```

## 4. 実装詳細

### 4.1 UserController 実装

```java
@RestController
@RequestMapping("/api/v1/admin/users")
public class UserController {

    private final UserService userService;
    
    @Autowired
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    @GetMapping
    public Page<UserDTO> findUsers(UserSearchCriteria criteria, Pageable pageable) {
        return userService.findAll(criteria, pageable);
    }
    
    @GetMapping("/{id}")
    public UserDTO getUser(@PathVariable UUID id) {
        return userService.findById(id);
    }
    
    @PostMapping
    public ResponseEntity<UserDTO> createUser(@RequestBody @Valid UserCreateDTO userCreateDTO) {
        UserDTO createdUser = userService.create(userCreateDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(createdUser);
    }
    
    @PutMapping("/{id}")
    public UserDTO updateUser(@PathVariable UUID id, @RequestBody @Valid UserUpdateDTO userUpdateDTO) {
        return userService.update(id, userUpdateDTO);
    }
    
    @PutMapping("/{id}/status")
    public ResponseEntity<Void> updateStatus(@PathVariable UUID id, @RequestBody StatusUpdateRequest request) {
        userService.updateStatus(id, request.getStatus());
        return ResponseEntity.ok().build();
    }
    
    @PostMapping("/{id}/password/reset")
    public ResponseEntity<Void> resetPassword(@PathVariable UUID id) {
        userService.resetPassword(id);
        return ResponseEntity.ok().build();
    }
    
    @PostMapping("/{id}/unlock")
    public ResponseEntity<Void> unlockAccount(@PathVariable UUID id) {
        userService.unlockAccount(id);
        return ResponseEntity.ok().build();
    }
    
    @PutMapping("/bulk-status")
    public ResponseEntity<Void> bulkUpdateStatus(@RequestBody BulkStatusUpdateRequest request) {
        userService.bulkUpdateStatus(request.getUserIds(), request.getStatus());
        return ResponseEntity.ok().build();
    }
    
    @PutMapping("/{id}/password")
    public ResponseEntity<Void> changePassword(@PathVariable UUID id, @RequestBody PasswordChangeRequest request) {
        userService.changePassword(id, request.getCurrentPassword(), request.getNewPassword());
        return ResponseEntity.ok().build();
    }
    
    @PutMapping("/{id}/mfa")
    public ResponseEntity<Void> updateMfaSettings(@PathVariable UUID id, @RequestBody MfaUpdateRequest request) {
        userService.updateMfaSettings(id, request.isEnabled());
        return ResponseEntity.ok().build();
    }
}
```

### 4.2 UserServiceImpl 実装

```java
@Service
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final NotificationService notificationService;
    private final AuditLogService auditLogService;
    
    @Autowired
    public UserServiceImpl(
            UserRepository userRepository,
            PasswordEncoder passwordEncoder,
            NotificationService notificationService,
            AuditLogService auditLogService) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.notificationService = notificationService;
        this.auditLogService = auditLogService;
    }
    
    @Override
    @Transactional(readOnly = true)
    public Page<UserDTO> findAll(UserSearchCriteria criteria, Pageable pageable) {
        Page<User> users = userRepository.findAll(buildSpecification(criteria), pageable);
        return users.map(this::convertToDTO);
    }
    
    @Override
    @Transactional(readOnly = true)
    public UserDTO findById(UUID id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("User not found with id: " + id));
        return convertToDTO(user);
    }
    
    @Override
    @Transactional(readOnly = true)
    public UserDTO findByUserId(String userId) {
        User user = userRepository.findByUserId(userId)
                .orElseThrow(() -> new EntityNotFoundException("User not found with userId: " + userId));
        return convertToDTO(user);
    }
    
    @Override
    @Transactional(readOnly = true)
    public UserDTO findByEmail(String email) {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new EntityNotFoundException("User not found with email: " + email));
        return convertToDTO(user);
    }
    
    @Override
    @Transactional
    public UserDTO create(UserCreateDTO userCreateDTO) {
        // 重複チェック
        if (userRepository.existsByUserId(userCreateDTO.getUserId())) {
            throw new DuplicateEntityException("User with userId " + userCreateDTO.getUserId() + " already exists");
        }
        
        if (userRepository.existsByEmail(userCreateDTO.getEmail())) {
            throw new DuplicateEntityException("User with email " + userCreateDTO.getEmail() + " already exists");
        }
        
        // 新規ユーザーエンティティの作成
        User user = new User();
        user.setId(UUID.randomUUID());
        user.setUserId(userCreateDTO.getUserId());
        user.setEmail(userCreateDTO.getEmail());
        user.setName(userCreateDTO.getName());
        user.setDepartment(userCreateDTO.getDepartment());
        user.setPosition(userCreateDTO.getPosition());
        user.setPhone(userCreateDTO.getPhone());
        user.setMfaEnabled(userCreateDTO.isMfaEnabled());
        
        // 初期パスワード処理
        String initialPassword = userCreateDTO.getInitialPassword();
        if (initialPassword == null || initialPassword.isEmpty()) {
            initialPassword = generateRandomPassword();
        }
        
        user.setPasswordHash(passwordEncoder.encode(initialPassword));
        user.setStatus(UserStatus.PENDING);
        user.setLoginAttempts(0);
        
        // パスワード有効期限設定
        LocalDateTime now = LocalDateTime.now();
        user.setPasswordExpiresAt(now.plusDays(1));  // 初回ログイン時にパスワード変更を強制
        user.setCreatedAt(now);
        user.setUpdatedAt(now);
        
        // ユーザー保存
        User savedUser = userRepository.save(user);
        
        // 監査ログ記録
        Map<String, Object> details = new HashMap<>();
        details.put("userId", savedUser.getUserId());
        details.put("email", savedUser.getEmail());
        auditLogService.recordAuditLog(
                "CREATE_USER",
                "USER",
                savedUser.getId().toString(),
                SecurityContextHolder.getContext().getAuthentication().getPrincipal().getUserId(),
                details
        );
        
        // 初期パスワード通知
        Map<String, Object> templateParams = new HashMap<>();
        templateParams.put("userName", savedUser.getName());
        templateParams.put("initialPassword", initialPassword);
        templateParams.put("systemUrl", getSystemBaseUrl());
        
        notificationService.sendEmail(
                savedUser.getEmail(),
                "SES業務システム - アカウント作成のお知らせ",
                "user-account-created",
                templateParams
        );
        
        return convertToDTO(savedUser);
    }
    
    @Override
    @Transactional
    public UserDTO update(UUID id, UserUpdateDTO userUpdateDTO) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("User not found with id: " + id));
        
        // メールアドレス重複チェック（変更がある場合のみ）
        if (!user.getEmail().equals(userUpdateDTO.getEmail()) &&
                userRepository.existsByEmail(userUpdateDTO.getEmail())) {
            throw new DuplicateEntityException("User with email " + userUpdateDTO.getEmail() + " already exists");
        }
        
        // ユーザー情報更新
        user.setEmail(userUpdateDTO.getEmail());
        user.setName(userUpdateDTO.getName());
        user.setDepartment(userUpdateDTO.getDepartment());
        user.setPosition(userUpdateDTO.getPosition());
        user.setPhone(userUpdateDTO.getPhone());
        user.setMfaEnabled(userUpdateDTO.isMfaEnabled());
        user.setUpdatedAt(LocalDateTime.now());
        
        User updatedUser = userRepository.save(user);
        
        // 監査ログ記録
        Map<String, Object> details = new HashMap<>();
        details.put("userId", updatedUser.getUserId());
        details.put("email", updatedUser.getEmail());
        auditLogService.recordAuditLog(
                "UPDATE_USER",
                "USER",
                updatedUser.getId().toString(),
                SecurityContextHolder.getContext().getAuthentication().getPrincipal().getUserId(),
                details
        );
        
        return convertToDTO(updatedUser);
    }
    
    @Override
    @Transactional
    public void updateStatus(UUID id, UserStatus status) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("User not found with id: " + id));
        
        // ビジネスルールチェック（システム管理者ロールの最後のユーザーを無効化しようとしている場合）
        if (status == UserStatus.INACTIVE && isLastSystemAdminUser(user)) {
            throw new BusinessRuleException("Cannot deactivate the last system admin user");
        }
        
        UserStatus previousStatus = user.getStatus();
        user.setStatus(status);
        user.setUpdatedAt(LocalDateTime.now());
        
        if (status == UserStatus.ACTIVE && previousStatus == UserStatus.LOCKED) {
            user.setLoginAttempts(0);
        }
        
        userRepository.save(user);
        
        // 監査ログ記録
        Map<String, Object> details = new HashMap<>();
        details.put("userId", user.getUserId());
        details.put("previousStatus", previousStatus);
        details.put("newStatus", status);
        auditLogService.recordAuditLog(
                "UPDATE_USER_STATUS",
                "USER",
                user.getId().toString(),
                SecurityContextHolder.getContext().getAuthentication().getPrincipal().getUserId(),
                details
        );
        
        // ステータス変更通知
        if (previousStatus != status) {
            Map<String, Object> templateParams = new HashMap<>();
            templateParams.put("userName", user.getName());
            templateParams.put("status", status.name());
            templateParams.put("systemUrl", getSystemBaseUrl());
            
            notificationService.sendEmail(
                    user.getEmail(),
                    "SES業務システム - アカウントステータス変更のお知らせ",
                    "user-status-changed",
                    templateParams
            );
        }
    }
    
    @Override
    @Transactional
    public String resetPassword(UUID id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("User not found with id: " + id));
        
        // 一時パスワード生成
        String temporaryPassword = generateRandomPassword();
        
        // パスワード更新
        user.setPasswordHash(passwordEncoder.encode(temporaryPassword));
        user.setPasswordExpiresAt(LocalDateTime.now().plusDays(1));  // 1日間の有効期限
        user.setStatus(UserStatus.EXPIRED);  // パスワード変更を強制
        user.setLoginAttempts(0);
        user.setUpdatedAt(LocalDateTime.now());
        
        userRepository.save(user);
        
        // 監査ログ記録
        Map<String, Object> details = new HashMap<>();
        details.put("userId", user.getUserId());
        auditLogService.recordAuditLog(
                "RESET_PASSWORD",
                "USER",
                user.getId().toString(),
                SecurityContextHolder.getContext().getAuthentication().getPrincipal().getUserId(),
                details
        );
        
        // パスワードリセット通知
        Map<String, Object> templateParams = new HashMap<>();
        templateParams.put("userName", user.getName());
        templateParams.put("temporaryPassword", temporaryPassword);
        templateParams.put("systemUrl", getSystemBaseUrl());
        
        notificationService.sendEmail(
                user.getEmail(),
                "SES業務システム - パスワードリセットのお知らせ",
                "user-password-reset",
                templateParams
        );
        
        return temporaryPassword;
    }
    
    @Override
    @Transactional
    public void unlockAccount(UUID id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("User not found with id: " + id));
        
        if (user.getStatus() != UserStatus.LOCKED) {
            throw new BusinessRuleException("User account is not locked");
        }
        
        user.setStatus(UserStatus.ACTIVE);
        user.setLoginAttempts(0);
        user.setUpdatedAt(LocalDateTime.now());
        
        userRepository.save(user);
        
        // 監査ログ記録
        Map<String, Object> details = new HashMap<>();
        details.put("userId", user.getUserId());
        auditLogService.recordAuditLog(
                "UNLOCK_ACCOUNT",
                "USER",
                user.getId().toString(),
                SecurityContextHolder.getContext().getAuthentication().getPrincipal().getUserId(),
                details
        );
        
        // アカウントロック解除通知
        Map<String, Object> templateParams = new HashMap<>();
        templateParams.put("userName", user.getName());
        templateParams.put("systemUrl", getSystemBaseUrl());
        
        notificationService.sendEmail(
                user.getEmail(),
                "SES業務システム - アカウントロック解除のお知らせ",
                "user-account-unlocked",
                templateParams
        );
    }
    
    @Override
    @Transactional
    public void bulkUpdateStatus(List<UUID> ids, UserStatus status) {
        // システム管理者ロールの最後のユーザーが含まれていないか確認
        if (status == UserStatus.INACTIVE) {
            for (UUID id : ids) {
                User user = userRepository.findById(id)
                        .orElseThrow(() -> new EntityNotFoundException("User not found with id: " + id));
                
                if (isLastSystemAdminUser(user)) {
                    throw new BusinessRuleException("Cannot deactivate the last system admin user");
                }
            }
        }
        
        // 一括更新
        for (UUID id : ids) {
            User user = userRepository.findById(id)
                    .orElseThrow(() -> new EntityNotFoundException("User not found with id: " + id));
            
            UserStatus previousStatus = user.getStatus();
            user.setStatus(status);
            user.setUpdatedAt(LocalDateTime.now());
            
            if (status == UserStatus.ACTIVE && previousStatus == UserStatus.LOCKED) {
                user.setLoginAttempts(0);
            }
            
            userRepository.save(user);
            
            // 監査ログ記録
            Map<String, Object> details = new HashMap<>();
            details.put("userId", user.getUserId());
            details.put("previousStatus", previousStatus);
            details.put("newStatus", status);
            auditLogService.recordAuditLog(
                    "BULK_UPDATE_USER_STATUS",
                    "USER",
                    user.getId().toString(),
                    SecurityContextHolder.getContext().getAuthentication().getPrincipal().getUserId(),
                    details
            );
            
            // ステータス変更通知（任意）
            if (previousStatus != status) {
                sendStatusChangeNotification(user, status);
            }
        }
    }
    
    @Override
    @Transactional
    public void changePassword(UUID id, String currentPassword, String newPassword) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("User not found with id: " + id));
        
        // 現在のパスワード検証
        if (!passwordEncoder.matches(currentPassword, user.getPasswordHash())) {
            throw new AuthenticationException("Current password is incorrect");
        }
        
        // 新しいパスワードの検証
        validatePassword(newPassword);
        
        // 過去のパスワード再利用チェック（実装省略）
        
        // パスワード更新
        user.setPasswordHash(passwordEncoder.encode(newPassword));
        user.setPasswordExpiresAt(LocalDateTime.now().plusDays(90));  // 90日間の有効期限
        user.setStatus(UserStatus.ACTIVE);
        user.setUpdatedAt(LocalDateTime.now());
        
        userRepository.save(user);
        
        // 監査ログ記録（パスワード自体は記録しない）
        Map<String, Object> details = new HashMap<>();
        details.put("userId", user.getUserId());
        auditLogService.recordAuditLog(
                "CHANGE_PASSWORD",
                "USER",
                user.getId().toString(),
                user.getId(),  // 自分自身が変更
                details
        );
    }
    
    @Override
    @Transactional
    public void updateMfaSettings(UUID id, boolean enabled) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("User not found with id: " + id));
        
        user.setMfaEnabled(enabled);
        user.setUpdatedAt(LocalDateTime.now());
        
        userRepository.save(user);
        
        // 監査ログ記録
        Map<String, Object> details = new HashMap<>();
        details.put("userId", user.getUserId());
        details.put("mfaEnabled", enabled);
        auditLogService.recordAuditLog(
                "UPDATE_MFA_SETTINGS",
                "USER",
                user.getId().toString(),
                SecurityContextHolder.getContext().getAuthentication().getPrincipal().getUserId(),
                details
        );
    }
    
    // Helper methods
    
    private UserDTO convertToDTO(User user) {
        UserDTO dto = new UserDTO();
        dto.setId(user.getId());
        dto.setUserId(user.getUserId());
        dto.setEmail(user.getEmail());
        dto.setName(user.getName());
        dto.setDepartment(user.getDepartment());
        dto.setPosition(user.getPosition());
        dto.setPhone(user.getPhone());
        dto.setMfaEnabled(user.isMfaEnabled());
        dto.setStatus(user.getStatus());
        dto.setLastLoginAt(user.getLastLoginAt());
        dto.setPasswordExpiresAt(user.getPasswordExpiresAt());
        dto.setCreatedAt(user.getCreatedAt());
        dto.setUpdatedAt(user.getUpdatedAt());
        return dto;
    }
    
    private String generateRandomPassword() {
        // 12文字のランダムパスワード生成
        return RandomStringUtils.randomAlphanumeric(12);
    }
    
    private void validatePassword(String password) {
        if (password == null || password.length() < 8) {
            throw new ValidationException("Password must be at least 8 characters long");
        }
        
        // パスワード強度チェック（大文字、小文字、数字、特殊文字を含む）
        if (!password.matches("^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$")) {
            throw new ValidationException("Password must include at least one uppercase letter, one lowercase letter, one number, and one special character");
        }
    }
    
    private boolean isLastSystemAdminUser(User user) {
        // システム管理者ロールの最後のユーザーかどうかを確認する実装
        // 具体的な実装はロール管理サービスとの連携が必要なため、実装詳細は省略
        return false;
    }
    
    private String getSystemBaseUrl() {
        // システムのベースURLを取得（設定から読み込むなど）
        return "https://ses-system.example.com";
    }
    
    private void sendStatusChangeNotification(User user, UserStatus status) {
        Map<String, Object> templateParams = new HashMap<>();
        templateParams.put("userName", user.getName());
        templateParams.put("status", status.name());
        templateParams.put("systemUrl", getSystemBaseUrl());
        
        notificationService.sendEmail(
                user.getEmail(),
                "SES業務システム - アカウントステータス変更のお知らせ",
                "user-status-changed",
                templateParams
        );
    }
    
    private Specification<User> buildSpecification(UserSearchCriteria criteria) {
        // 検索条件からSpecificationを構築する実装
        // JPA Criteriaを利用した動的クエリ生成（省略）
        return null;
    }
}
```

### 4.3 UserRepository 実装

```java
public interface UserRepository extends JpaRepository<User, UUID>, JpaSpecificationExecutor<User> {
    
    Optional<User> findByUserId(String userId);
    
    Optional<User> findByEmail(String email);
    
    boolean existsByUserId(String userId);
    
    boolean existsByEmail(String email);
    
    @Query("SELECT u FROM User u WHERE u.status = :status")
    List<User> findByStatus(UserStatus status);
    
    @Query("SELECT u FROM User u WHERE u.passwordExpiresAt < :date")
    List<User> findByPasswordExpired(LocalDateTime date);
    
    @Modifying
    @Query("UPDATE User u SET u.status = :status WHERE u.id IN :ids")
    int bulkUpdateStatus(List<UUID> ids, UserStatus status);
}
```

## 5. 例外処理

ユーザーアカウント管理機能では、以下の例外処理を実装します：

### 5.1 例外クラス

```java
// エンティティが存在しない場合の例外
public class EntityNotFoundException extends RuntimeException {
    public EntityNotFoundException(String message) {
        super(message);
    }
}

// エンティティが重複する場合の例外
public class DuplicateEntityException extends RuntimeException {
    public DuplicateEntityException(String message) {
        super(message);
    }
}

// ビジネスルール違反の例外
public class BusinessRuleException extends RuntimeException {
    public BusinessRuleException(String message) {
        super(message);
    }
}

// バリデーションエラーの例外
public class ValidationException extends RuntimeException {
    public ValidationException(String message) {
        super(message);
    }
}

// 認証エラーの例外
public class AuthenticationException extends RuntimeException {
    public AuthenticationException(String message) {
        super(message);
    }
}
```

### 5.2 例外ハンドラー

```java
@ControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleEntityNotFoundException(EntityNotFoundException ex) {
        ErrorResponse error = new ErrorResponse("NOT_FOUND", ex.getMessage());
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }
    
    @ExceptionHandler(DuplicateEntityException.class)
    public ResponseEntity<ErrorResponse> handleDuplicateEntityException(DuplicateEntityException ex) {
        ErrorResponse error = new ErrorResponse("CONFLICT", ex.getMessage());
        return new ResponseEntity<>(error, HttpStatus.CONFLICT);
    }
    
    @ExceptionHandler(BusinessRuleException.class)
    public ResponseEntity<ErrorResponse> handleBusinessRuleException(BusinessRuleException ex) {
        ErrorResponse error = new ErrorResponse("BUSINESS_RULE_VIOLATION", ex.getMessage());
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }
    
    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(ValidationException ex) {
        ErrorResponse error = new ErrorResponse("VALIDATION_ERROR", ex.getMessage());
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }
    
    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleAuthenticationException(AuthenticationException ex) {
        ErrorResponse error = new ErrorResponse("AUTHENTICATION_ERROR", ex.getMessage());
        return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleMethodArgumentNotValidException(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> 
                errors.put(error.getField(), error.getDefaultMessage()));
        
        ErrorResponse error = new ErrorResponse("VALIDATION_ERROR", "Validation failed", errors);
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }
}
```

## 6. セキュリティ対策

### 6.1 パスワードセキュリティ

- パスワードハッシュ化にbcryptを使用
- 強力なパスワードポリシーの適用（8文字以上、大文字・小文字・数字・特殊文字を含む）
- パスワード有効期限の設定（90日間）
- パスワードリセット時は一時パスワードを生成し24時間の有効期限を設定
- パスワード変更時の過去のパスワード再利用防止（過去5回分）

### 6.2 アカウントセキュリティ

- 連続ログイン失敗回数の監視と自動ロック（5回でロック）
- アカウントロック解除は管理者のみ実行可能
- 不正アクセス検知時のアカウント自動ロック
- アカウント重要操作（ステータス変更、パスワードリセット）の監査ログ記録

### 6.3 通知セキュリティ

- パスワードリセット時の安全な通知方法（メール）
- アカウントロック/ロック解除時のユーザー通知
- ステータス変更時のユーザー通知

## 7. テスト方針

### 7.1 単体テスト

- UserServiceの各メソッドの正常系テスト
- UserServiceの各メソッドの異常系テスト（例外発生パターン）
- パスワード生成・検証ロジックのテスト
- バリデーションロジックのテスト

### 7.2 結合テスト

- UserControllerとUserServiceの連携テスト
- UserServiceとUserRepositoryの連携テスト
- UserServiceと外部サービス（NotificationService, AuditLogService）の連携テスト（モック利用）

### 7.3 シナリオテスト

- ユーザー登録→編集→パスワードリセット→ロック→ロック解除→無効化の一連のフロー
- 複数ユーザーの一括ステータス変更処理
- 最後の管理者ユーザーの無効化が防止されることの確認