# ユーザー管理機能 - ユーザーアカウント管理

## 1. 機能概要

ユーザーアカウント管理機能は、SES業務システムにおけるユーザーの登録、編集、検索、ステータス管理、セキュリティ管理を担当します。本機能により、システム管理者はユーザーのライフサイクル全体を適切に管理できます。Spring Security標準機能を活用することで、セキュリティ品質の向上と開発効率の改善を図ります。

## 2. 主要コンポーネント構成

ユーザーアカウント管理機能は以下のコンポーネントで構成されます：

### 2.1 コンポーネント構成図

```
                  ┌─────────────────┐
                  │  UserController │
                  └────────┬────────┘
                           │
                           ▼
┌────────────────┐  ┌─────────────────┐  ┌──────────────────┐
│ UserDetailsService │◄─┤   UserService   │─►│ NotificationService │
└────────────────┘  └────────┬────────┘  └──────────────────┘
                           │
                           ▼
                  ┌─────────────────┐    ┌──────────────────┐
                  │  UserRepository │───►│  AuditLogService  │
                  └─────────────────┘    └──────────────────┘
```

### 2.2 コンポーネント説明

- **UserController**: ユーザー管理のRESTful APIエンドポイントを提供
- **UserService**: ユーザー管理のビジネスロジックを実装
- **UserRepository**: ユーザーデータのデータアクセス層
- **UserDetailsService**: Spring Securityの認証情報サービスインターフェースを実装
- **外部依存**: NotificationService（通知機能）、AuditLogService（監査ログ機能）

## 3. Spring Security連携

### 3.1 UserDetailsService実装

Spring Securityの認証フローと連携するために、`UserDetailsService`インターフェースを実装します。

```java
@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;
    
    @Autowired
    public CustomUserDetailsService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUserId(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with userId: " + username));
        
        // ユーザーのステータスチェック
        if (user.getStatus() != UserStatus.ACTIVE) {
            throw new DisabledException("User account is not active");
        }
        
        // 権限情報の取得
        Collection<GrantedAuthority> authorities = getUserAuthorities(user);
        
        return new CustomUserDetails(user, authorities);
    }
    
    private Collection<GrantedAuthority> getUserAuthorities(User user) {
        // ユーザーに割り当てられたロール・権限を取得する処理
        // 実際の実装ではUserRoleRepositoryとRolePermissionRepositoryを使用
        Set<GrantedAuthority> authorities = new HashSet<>();
        
        // ROLE_プレフィックスを持つロール権限（Spring Securityの標準）
        authorities.add(new SimpleGrantedAuthority("ROLE_USER"));
        
        // 実際のアプリケーションでは、以下のようにユーザーのロールを動的に追加
        // userRoleRepository.findByUserId(user.getId()).forEach(userRole -> {
        //     Role role = roleRepository.findById(userRole.getRoleId()).orElse(null);
        //     if (role != null) {
        //         authorities.add(new SimpleGrantedAuthority("ROLE_" + role.getRoleId()));
        //     }
        // });
        
        return authorities;
    }
}
```

### 3.2 CustomUserDetails実装

Spring Securityのユーザー情報を拡張して、アプリケーション固有の情報を持たせます。

```java
public class CustomUserDetails implements UserDetails {

    private final User user;
    private final Collection<? extends GrantedAuthority> authorities;
    
    public CustomUserDetails(User user, Collection<? extends GrantedAuthority> authorities) {
        this.user = user;
        this.authorities = authorities;
    }
    
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }
    
    @Override
    public String getPassword() {
        return user.getPasswordHash();
    }
    
    @Override
    public String getUsername() {
        return user.getUserId();
    }
    
    @Override
    public boolean isAccountNonExpired() {
        return user.getStatus() != UserStatus.EXPIRED;
    }
    
    @Override
    public boolean isAccountNonLocked() {
        return user.getStatus() != UserStatus.LOCKED;
    }
    
    @Override
    public boolean isCredentialsNonExpired() {
        return user.getPasswordExpiresAt() == null || 
               user.getPasswordExpiresAt().isAfter(LocalDateTime.now());
    }
    
    @Override
    public boolean isEnabled() {
        return user.getStatus() == UserStatus.ACTIVE;
    }
    
    // アプリケーション固有の情報へのアクセサ
    public User getUser() {
        return user;
    }
    
    public UUID getId() {
        return user.getId();
    }
    
    public String getEmail() {
        return user.getEmail();
    }
    
    public String getName() {
        return user.getName();
    }
}
```

### 3.3 SecurityConfiguration設定

Spring Securityの設定クラスで、パスワードエンコーダや認証マネージャーを構成します。

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfiguration {

    private final CustomUserDetailsService userDetailsService;
    
    @Autowired
    public SecurityConfiguration(CustomUserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())  // RESTful APIの場合、必要に応じて調整
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/v1/auth/**").permitAll()
                .requestMatchers("/api/v1/public/**").permitAll()
                .requestMatchers("/api/v1/admin/**").hasRole("SYSTEM_ADMIN")
                .anyRequest().authenticated()
            )
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            // JWTフィルターをUsernamePasswordAuthenticationFilterの前に追加
            .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public JwtAuthenticationFilter jwtAuthenticationFilter() {
        return new JwtAuthenticationFilter();
    }
}
```

## 4. 処理フロー

### 4.1 ユーザー新規登録フロー

```
1. システム管理者がユーザー登録画面で情報入力
2. UserController.createUser() APIが呼び出される
3. UserService.create() メソッドが実行される
   3.1. ユーザーID、メールアドレスの重複チェック
   3.2. バリデーション実行
   3.3. 初期パスワード生成（指定されていない場合）
   3.4. Spring Securityのパスワードエンコーダーでハッシュ化
   3.5. ユーザー作成（ステータス: PENDING）
   3.6. AuditLogService経由で監査ログ記録
4. NotificationService経由で初期パスワードをメール通知
5. 作成結果をクライアントに返却
```

### 4.2 認証フロー（Spring Security標準）

```
1. ユーザーがログイン情報を送信
2. JWTAuthenticationFilterがリクエストを処理
3. AuthenticationManagerがCustomUserDetailsServiceを呼び出し
   3.1. CustomUserDetailsService.loadUserByUsername()がユーザー情報取得
   3.2. ユーザーステータスとパスワード有効期限チェック
   3.3. ユーザーの権限情報を取得
4. AuthenticationManagerがパスワードを検証
   4.1. Spring Securityのパスワードエンコーダーでハッシュ比較
   4.2. ログイン成功/失敗の処理
5. 認証成功時にJWTトークン生成
6. レスポンスヘッダーまたはボディにトークン返却
```

### 4.3 パスワードリセットフロー

```
1. システム管理者がユーザーのパスワードリセットを実行
2. UserController.resetPassword() APIが呼び出される
3. UserService.resetPassword() メソッドが実行される
   3.1. ユーザーの存在確認
   3.2. 一時パスワード生成
   3.3. Spring Securityのパスワードエンコーダーでハッシュ化
   3.4. パスワード情報更新（パスワード有効期限: 24時間）
   3.5. ユーザーステータスを「EXPIRED」に変更
   3.6. AuditLogService経由で監査ログ記録
4. NotificationService経由で一時パスワードをメール通知
5. 処理結果をクライアントに返却
```

## 5. 実装詳細

### 5.1 UserServiceImpl 実装

```java
@Service
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final NotificationService notificationService;
    private final AuditLogService auditLogService;
    
    @Autowired
    public UserServiceImpl(
            UserRepository userRepository,
            PasswordEncoder passwordEncoder,
            NotificationService notificationService,
            AuditLogService auditLogService) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.notificationService = notificationService;
        this.auditLogService = auditLogService;
    }
    
    @Override
    @Transactional
    public UserDTO create(UserCreateDTO userCreateDTO) {
        // 重複チェック
        if (userRepository.existsByUserId(userCreateDTO.getUserId())) {
            throw new DuplicateEntityException("User with userId " + userCreateDTO.getUserId() + " already exists");
        }
        
        // 新規ユーザーエンティティの作成
        User user = new User();
        user.setId(UUID.randomUUID());
        user.setUserId(userCreateDTO.getUserId());
        user.setEmail(userCreateDTO.getEmail());
        user.setName(userCreateDTO.getName());
        user.setDepartment(userCreateDTO.getDepartment());
        user.setPosition(userCreateDTO.getPosition());
        user.setPhone(userCreateDTO.getPhone());
        user.setMfaEnabled(userCreateDTO.isMfaEnabled());
        
        // 初期パスワード処理
        String initialPassword = userCreateDTO.getInitialPassword();
        if (initialPassword == null || initialPassword.isEmpty()) {
            initialPassword = generateRandomPassword();
        }
        
        // Spring Securityのパスワードエンコーダーを使用
        user.setPasswordHash(passwordEncoder.encode(initialPassword));
        user.setStatus(UserStatus.PENDING);
        user.setLoginAttempts(0);
        
        // パスワード有効期限設定
        LocalDateTime now = LocalDateTime.now();
        user.setPasswordExpiresAt(now.plusDays(1));  // 初回ログイン時にパスワード変更を強制
        user.setCreatedAt(now);
        user.setUpdatedAt(now);
        
        // ユーザー保存
        User savedUser = userRepository.save(user);
        
        // 監査ログ記録
        recordAuditLog("CREATE_USER", savedUser, null);
        
        // 初期パスワード通知
        sendInitialPasswordNotification(savedUser, initialPassword);
        
        return convertToDTO(savedUser);
    }
    
    @Override
    @Transactional
    public String resetPassword(UUID id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("User not found with id: " + id));
        
        // 一時パスワード生成
        String temporaryPassword = generateRandomPassword();
        
        // Spring Securityのパスワードエンコーダーを使用
        user.setPasswordHash(passwordEncoder.encode(temporaryPassword));
        user.setPasswordExpiresAt(LocalDateTime.now().plusDays(1));  // 1日間の有効期限
        user.setStatus(UserStatus.EXPIRED);  // パスワード変更を強制
        user.setLoginAttempts(0);
        user.setUpdatedAt(LocalDateTime.now());
        
        userRepository.save(user);
        
        // 監査ログ記録
        recordAuditLog("RESET_PASSWORD", user, null);
        
        // パスワードリセット通知
        sendPasswordResetNotification(user, temporaryPassword);
        
        return temporaryPassword;
    }
    
    @Override
    @Transactional
    public void changePassword(UUID id, String currentPassword, String newPassword) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("User not found with id: " + id));
        
        // Spring Securityのパスワードエンコーダーでパスワード検証
        if (!passwordEncoder.matches(currentPassword, user.getPasswordHash())) {
            throw new BadCredentialsException("Current password is incorrect");
        }
        
        // 新しいパスワードの検証
        validatePassword(newPassword);
        
        // 過去のパスワード再利用チェック（実装省略）
        
        // パスワード更新
        user.setPasswordHash(passwordEncoder.encode(newPassword));
        user.setPasswordExpiresAt(LocalDateTime.now().plusDays(90));  // 90日間の有効期限
        user.setStatus(UserStatus.ACTIVE);
        user.setUpdatedAt(LocalDateTime.now());
        
        userRepository.save(user);
        
        // 監査ログ記録
        recordAuditLog("CHANGE_PASSWORD", user, null);
    }
    
    @Override
    @Transactional
    public void unlockAccount(UUID id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("User not found with id: " + id));
        
        if (user.getStatus() != UserStatus.LOCKED) {
            throw new BusinessRuleException("User account is not locked");
        }
        
        user.setStatus(UserStatus.ACTIVE);
        user.setLoginAttempts(0);
        user.setUpdatedAt(LocalDateTime.now());
        
        userRepository.save(user);
        
        // 監査ログ記録
        recordAuditLog("UNLOCK_ACCOUNT", user, null);
        
        // アカウントロック解除通知
        sendAccountUnlockNotification(user);
    }
    
    // 他のメソッド...
    
    // Helper methods
    
    private String generateRandomPassword() {
        // Spring Securityのランダムパスワード生成を使用
        return RandomStringUtils.randomAlphanumeric(12);
    }
    
    private void validatePassword(String password) {
        // Spring Securityのパスワードバリデーションルールを使用
        if (password == null || password.length() < 8) {
            throw new ValidationException("Password must be at least 8 characters long");
        }
        
        if (!password.matches("^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$")) {
            throw new ValidationException("Password must include at least one uppercase letter, one lowercase letter, one number, and one special character");
        }
    }
    
    private void recordAuditLog(String action, User user, Map<String, Object> additionalDetails) {
        Map<String, Object> details = new HashMap<>();
        details.put("userId", user.getUserId());
        details.put("email", user.getEmail());
        
        if (additionalDetails != null) {
            details.putAll(additionalDetails);
        }
        
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String performedBy = "system";
        if (authentication != null && authentication.getPrincipal() instanceof CustomUserDetails) {
            performedBy = ((CustomUserDetails) authentication.getPrincipal()).getUsername();
        }
        
        auditLogService.recordAuditLog(
                action,
                "USER",
                user.getId().toString(),
                performedBy,
                details
        );
    }
    
    // その他のヘルパーメソッド...
}
```

### 5.2 認証失敗ハンドラーの実装

Spring Securityの認証失敗イベントを捕捉して、アカウントロックなどのセキュリティ機能を実装します。

```java
@Component
public class CustomAuthenticationFailureHandler implements AuthenticationFailureHandler {

    private final UserRepository userRepository;
    private final AuditLogService auditLogService;
    
    @Value("${security.login.max-attempts:5}")
    private int maxLoginAttempts;
    
    @Autowired
    public CustomAuthenticationFailureHandler(
            UserRepository userRepository,
            AuditLogService auditLogService) {
        this.userRepository = userRepository;
        this.auditLogService = auditLogService;
    }
    
    @Override
    @Transactional
    public void onAuthenticationFailure(
            HttpServletRequest request, 
            HttpServletResponse response, 
            AuthenticationException exception) throws IOException, ServletException {
        
        String username = request.getParameter("username");
        
        // ユーザーが存在する場合、ログイン失敗回数をインクリメント
        userRepository.findByUserId(username).ifPresent(user -> {
            int loginAttempts = user.getLoginAttempts() + 1;
            user.setLoginAttempts(loginAttempts);
            
            // 最大ログイン失敗回数を超えた場合、アカウントをロック
            if (loginAttempts >= maxLoginAttempts) {
                user.setStatus(UserStatus.LOCKED);
                
                // 監査ログ記録
                Map<String, Object> details = new HashMap<>();
                details.put("userId", user.getUserId());
                details.put("reason", "Maximum login attempts exceeded");
                
                auditLogService.recordAuditLog(
                        "ACCOUNT_LOCKED",
                        "USER",
                        user.getId().toString(),
                        "system",
                        details
                );
            }
            
            userRepository.save(user);
        });
        
        // 標準的なJSON形式でエラーレスポンスを返す
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        
        Map<String, Object> errorDetails = new HashMap<>();
        errorDetails.put("timestamp", new Date());
        errorDetails.put("status", HttpStatus.UNAUTHORIZED.value());
        errorDetails.put("error", "Unauthorized");
        errorDetails.put("message", exception.getMessage());
        errorDetails.put("path", request.getRequestURI());
        
        ObjectMapper mapper = new ObjectMapper();
        mapper.writeValue(response.getWriter(), errorDetails);
    }
}
```

### 5.3 認証成功ハンドラーの実装

```java
@Component
public class CustomAuthenticationSuccessHandler implements AuthenticationSuccessHandler {

    private final UserRepository userRepository;
    private final AuditLogService auditLogService;
    
    @Autowired
    public CustomAuthenticationSuccessHandler(
            UserRepository userRepository,
            AuditLogService auditLogService) {
        this.userRepository = userRepository;
        this.auditLogService = auditLogService;
    }
    
    @Override
    @Transactional
    public void onAuthenticationSuccess(
            HttpServletRequest request, 
            HttpServletResponse response, 
            Authentication authentication) throws IOException, ServletException {
        
        if (authentication.getPrincipal() instanceof CustomUserDetails) {
            CustomUserDetails userDetails = (CustomUserDetails) authentication.getPrincipal();
            User user = userDetails.getUser();
            
            // ログイン失敗回数をリセット
            user.setLoginAttempts(0);
            
            // 最終ログイン日時を更新
            user.setLastLoginAt(LocalDateTime.now());
            
            userRepository.save(user);
            
            // 監査ログ記録
            Map<String, Object> details = new HashMap<>();
            details.put("userId", user.getUserId());
            details.put("ipAddress", request.getRemoteAddr());
            
            auditLogService.recordAuditLog(
                    "LOGIN_SUCCESS",
                    "USER",
                    user.getId().toString(),
                    user.getUserId(),
                    details
            );
        }
        
        // JWT認証の場合は、ここでトークンを生成して返却
    }
}
```

## 6. Spring Securityの特徴と利点

### 6.1 認証・認可の標準化

- **UserDetailsService**: ユーザー情報の取得方法を標準化
- **PasswordEncoder**: 安全なパスワードハッシュ化を提供
- **AuthenticationManager**: 認証処理の標準フローを提供
- **SecurityFilterChain**: リクエスト単位のセキュリティ制御

### 6.2 柔軟な認証メカニズム

- **フォーム認証**: 標準的なフォームベース認証
- **HTTP Basic認証**: APIアクセス用の基本認証
- **JWT認証**: ステートレスなトークンベース認証
- **OAuth2/OIDC**: 外部IdPとの連携
- **多要素認証**: 追加認証要素のサポート

### 6.3 細かい権限制御

- **URL単位の権限制御**: antMatcherやmvcMatcherによるパス単位の制御
- **メソッドレベルのセキュリティ**: @PreAuthorize, @PostAuthorizeによるメソッド単位の制御
- **SpEL式のサポート**: 複雑な条件式による権限チェック
- **ドメインオブジェクトセキュリティ**: データレベルのアクセス制御

### 6.4 セキュリティ機能の充実

- **CSRF対策**: Cross-Site Request Forgery対策
- **XSS対策**: Content Security Policyのサポート
- **セッション管理**: セッションフィクセーション対策
- **ブルートフォース対策**: 認証失敗ハンドラーによる実装

## 7. セキュリティ対策

### 7.1 パスワードセキュリティ

- Spring Securityの**BCryptPasswordEncoder**を使用したセキュアなハッシュ化
- 強力なパスワードポリシーの適用（8文字以上、大文字・小文字・数字・特殊文字）
- パスワード有効期限の管理
- 過去のパスワード再利用防止

### 7.2 アカウントセキュリティ

- Spring Securityの認証失敗ハンドラーを活用した自動アカウントロック機能
- ユーザーステータス管理をSpring SecurityのisEnabled(), isAccountNonLocked()などと連携
- 監査ログの自動記録（Spring Security Auditingの活用）

### 7.3 多要素認証(MFA)

- Spring Security MFAモジュールの活用
- TOTP（Time-based One-Time Password）によるワンタイムパスワード生成
- カスタム認証プロバイダーによる複数認証ステップの実現

## 8. テスト方針

### 8.1 単体テスト

- Spring Security Test機能を活用したセキュリティコンテキストのモック
- `@WithMockUser`, `@WithUserDetails`アノテーションによる認証状態のテスト
- SecurityContextHolderへのテストユーザー登録

### 8.2 結合テスト

- Spring Security Testのモック認証機能を活用したコントローラーテスト
- 実際のデータベースと連携したUserDetailsServiceのテスト

### 8.3 セキュリティテスト

- パスワードエンコーダーの動作検証
- 認証失敗時のアカウントロック機能検証
- 権限による機能アクセス制限の検証

## 9. Spring Securityへの移行手順

1. Spring Securityライブラリの導入
2. SecurityConfiguration設定クラスの作成
3. UserDetailsServiceインターフェースの実装
4. 既存のUserServiceの改修（パスワードエンコーディング部分など）
5. 認証ハンドラー（成功/失敗）の実装
6. 既存の権限チェックロジックをSpring Securityのメソッドセキュリティに移行
7. JWT認証フィルターの実装（APIの場合）
8. テストケースの更新