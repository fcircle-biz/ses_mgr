# SES業務システム 監査ログ機能詳細設計：収集

## 1. 監査ログ収集の概要

### 1.1 目的

本ドキュメントは、SES業務システムにおける監査ログの収集メカニズムの詳細設計を定義する。アプリケーション内の各所で発生するイベントを適切に捕捉し、統一されたフォーマットで監査ログとして記録するための仕組みについて詳述する。

### 1.2 収集アーキテクチャ

監査ログ収集は以下の3つの方式を組み合わせて実現する：

1. **アスペクト指向アプローチ（AOP）**
   - 特定のアノテーションが付与されたメソッドの実行を自動的に監査
   - 宣言的な監査ポイントの定義が可能

2. **明示的API呼び出し**
   - 監査ログサービスを直接呼び出して監査イベントを記録
   - 複雑なビジネスロジック内での柔軟な監査が可能

3. **フィルターベースの収集**
   - HTTPリクエスト/レスポンスを傍受して監査
   - ログイン/ログアウトなどのセキュリティイベントの監査に使用

## 2. アスペクト指向の監査ログ収集

### 2.1 監査アノテーション

メソッドレベルの監査を実現するためのアノテーション：

```java
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Audited {
    
    /**
     * 監査イベントの種別
     */
    AuditEventType eventType();
    
    /**
     * 監査対象リソースの種別
     */
    String resourceType() default "";
    
    /**
     * 監査対象リソースIDを取得するための式
     * SpELサポート
     */
    String resourceIdExpression() default "";
    
    /**
     * 実行される操作
     */
    AuditAction action();
    
    /**
     * イベントの重要度
     */
    AuditSeverity severity() default AuditSeverity.INFO;
    
    /**
     * 監査の有効/無効
     */
    boolean enabled() default true;
}
```

```java
public enum AuditEventType {
    AUTHENTICATION("認証"),
    AUTHORIZATION("認可"),
    DATA_ACCESS("データアクセス"),
    DATA_MODIFICATION("データ変更"),
    CONFIGURATION("設定変更"),
    BUSINESS_PROCESS("業務処理"),
    SYSTEM("システム");
    
    private final String description;
    
    AuditEventType(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}

public enum AuditAction {
    CREATE("作成"),
    READ("参照"),
    UPDATE("更新"),
    DELETE("削除"),
    EXECUTE("実行"),
    LOGIN("ログイン"),
    LOGOUT("ログアウト"),
    APPROVE("承認"),
    REJECT("却下"),
    EXPORT("エクスポート"),
    IMPORT("インポート");
    
    private final String description;
    
    AuditAction(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}

public enum AuditSeverity {
    INFO,
    WARNING,
    ERROR,
    CRITICAL
}
```

### 2.2 監査アスペクト

アノテーションが付与されたメソッドの実行を監査するアスペクト：

```java
@Aspect
@Component
@Order(Ordered.HIGHEST_PRECEDENCE + 100)
public class AuditAspect {
    
    private static final Logger log = LoggerFactory.getLogger(AuditAspect.class);
    
    @Autowired
    private AuditLogService auditLogService;
    
    @Autowired
    private ExpressionParser expressionParser;
    
    @Autowired
    private RequestContextHolder requestContextHolder;
    
    /**
     * @Audited アノテーションが付与されたメソッドの実行を監査
     */
    @Around("@annotation(audited)")
    public Object auditMethod(ProceedingJoinPoint joinPoint, Audited audited) throws Throwable {
        if (!audited.enabled()) {
            return joinPoint.proceed();
        }
        
        long startTime = System.currentTimeMillis();
        
        // 監査イベントの共通項目を設定
        AuditEvent event = new AuditEvent();
        event.setEventId(UUID.randomUUID().toString());
        event.setTimestamp(LocalDateTime.now());
        event.setEventType(audited.eventType());
        event.setSeverity(audited.severity());
        
        // 現在の認証情報から主体（サブジェクト）情報を設定
        setSubjectInfo(event);
        
        // リソース情報の設定
        String resourceType = audited.resourceType();
        if (StringUtils.isEmpty(resourceType)) {
            // リソース種別が指定されていない場合は、対象クラス名をリソース種別とする
            resourceType = joinPoint.getTarget().getClass().getSimpleName();
        }
        event.setResourceType(resourceType);
        
        // リソースIDをSpEL式から解決
        if (StringUtils.hasText(audited.resourceIdExpression())) {
            String resourceId = resolveResourceId(audited.resourceIdExpression(), joinPoint);
            event.setResourceId(resourceId);
        }
        
        event.setAction(audited.action());
        
        // HTTPリクエスト情報の設定
        setRequestInfo(event);
        
        // 実行前の監査ログ記録（開始イベント）
        if (audited.severity() == AuditSeverity.CRITICAL) {
            // 重要度が最高の場合は実行前にもログを記録
            event.setOutcome("STARTED");
            auditLogService.logAuditEvent(event);
        }
        
        Object result = null;
        try {
            // メソッド実行
            result = joinPoint.proceed();
            
            // 成功結果の記録
            event.setOutcome("SUCCESS");
            
            // 成功時の追加情報
            Map<String, Object> details = new HashMap<>();
            if (result != null) {
                // 戻り値からIDを抽出（可能な場合）
                Object id = extractIdFromResult(result);
                if (id != null && StringUtils.isEmpty(event.getResourceId())) {
                    event.setResourceId(id.toString());
                }
                
                // 戻り値の情報を詳細に追加（設定に応じて）
                addResultDetails(details, result);
            }
            
            if (!details.isEmpty()) {
                event.setDetails(details);
            }
            
            return result;
        } catch (Exception e) {
            // 例外発生時の記録
            event.setOutcome("FAILURE");
            
            // 例外情報の追加
            Map<String, Object> details = new HashMap<>();
            details.put("exceptionType", e.getClass().getName());
            details.put("exceptionMessage", e.getMessage());
            event.setDetails(details);
            
            throw e;
        } finally {
            // 処理時間の記録
            long processingTime = System.currentTimeMillis() - startTime;
            event.addDetail("processingTimeMs", processingTime);
            
            // 監査ログの記録
            auditLogService.logAuditEvent(event);
        }
    }
    
    /**
     * 現在の認証情報から主体情報を設定
     */
    private void setSubjectInfo(AuditEvent event) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        
        if (authentication != null && authentication.isAuthenticated() && 
                !(authentication instanceof AnonymousAuthenticationToken)) {
            // 認証済みユーザー
            event.setSubjectType("USER");
            event.setSubjectId(authentication.getName());
            
            // 認証ユーザーの詳細情報
            if (authentication.getPrincipal() instanceof UserDetails) {
                UserDetails userDetails = (UserDetails) authentication.getPrincipal();
                Map<String, Object> subjectDetails = new HashMap<>();
                subjectDetails.put("username", userDetails.getUsername());
                
                // 権限情報
                List<String> authorities = userDetails.getAuthorities().stream()
                    .map(GrantedAuthority::getAuthority)
                    .collect(Collectors.toList());
                subjectDetails.put("authorities", authorities);
                
                event.addDetail("subject", subjectDetails);
            }
        } else {
            // 未認証またはシステム
            event.setSubjectType("SYSTEM");
            event.setSubjectId("SYSTEM");
        }
    }
    
    /**
     * HTTPリクエスト情報を設定
     */
    private void setRequestInfo(AuditEvent event) {
        ServletRequestAttributes requestAttributes = 
            (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
            
        if (requestAttributes != null) {
            HttpServletRequest request = requestAttributes.getRequest();
            
            // クライアントIP
            String clientIp = request.getRemoteAddr();
            if (request.getHeader("X-Forwarded-For") != null) {
                clientIp = request.getHeader("X-Forwarded-For");
            }
            event.setClientIp(clientIp);
            
            // ユーザーエージェント
            event.setUserAgent(request.getHeader("User-Agent"));
            
            // セッションID（存在する場合）
            HttpSession session = request.getSession(false);
            if (session != null) {
                event.setSessionId(session.getId());
            }
            
            // リクエストID
            String requestId = (String) request.getAttribute("requestId");
            if (requestId != null) {
                event.setRequestId(requestId);
            }
            
            // リクエスト情報の詳細
            Map<String, Object> requestDetails = new HashMap<>();
            requestDetails.put("method", request.getMethod());
            requestDetails.put("uri", request.getRequestURI());
            
            if (request.getQueryString() != null) {
                requestDetails.put("query", request.getQueryString());
            }
            
            event.addDetail("request", requestDetails);
        }
    }
    
    /**
     * SpEL式からリソースIDを解決
     */
    private String resolveResourceId(String expression, ProceedingJoinPoint joinPoint) {
        try {
            MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
            Method method = methodSignature.getMethod();
            Object[] args = joinPoint.getArgs();
            String[] paramNames = methodSignature.getParameterNames();
            
            // 評価コンテキストの構築
            StandardEvaluationContext context = new StandardEvaluationContext();
            
            // メソッド引数をコンテキストに追加
            for (int i = 0; i < args.length; i++) {
                context.setVariable(paramNames[i], args[i]);
            }
            
            // ターゲットオブジェクトをコンテキストに追加
            context.setVariable("target", joinPoint.getTarget());
            
            // 式を評価
            Object value = expressionParser.parseExpression(expression).getValue(context);
            return value != null ? value.toString() : null;
        } catch (Exception e) {
            log.warn("リソースID式の評価中にエラーが発生しました: " + expression, e);
            return null;
        }
    }
    
    /**
     * 戻り値からIDを抽出
     */
    private Object extractIdFromResult(Object result) {
        try {
            // エンティティまたはDTOからIDを抽出
            if (result != null) {
                Method getIdMethod = null;
                
                try {
                    getIdMethod = result.getClass().getMethod("getId");
                } catch (NoSuchMethodException e) {
                    try {
                        getIdMethod = result.getClass().getMethod("id");
                    } catch (NoSuchMethodException e2) {
                        // IDメソッドが見つからない場合は何もしない
                    }
                }
                
                if (getIdMethod != null) {
                    return getIdMethod.invoke(result);
                }
            }
        } catch (Exception e) {
            log.debug("結果からIDの抽出に失敗しました", e);
        }
        
        return null;
    }
    
    /**
     * 結果の詳細情報を追加
     */
    private void addResultDetails(Map<String, Object> details, Object result) {
        // 結果の型
        details.put("resultType", result.getClass().getName());
        
        // コレクションの場合はサイズを記録
        if (result instanceof Collection) {
            details.put("resultSize", ((Collection<?>) result).size());
        }
        
        // ページ付け結果の場合はページ情報を記録
        if (result instanceof Page) {
            Page<?> page = (Page<?>) result;
            Map<String, Object> pageInfo = new HashMap<>();
            pageInfo.put("pageNumber", page.getNumber());
            pageInfo.put("pageSize", page.getSize());
            pageInfo.put("totalElements", page.getTotalElements());
            pageInfo.put("totalPages", page.getTotalPages());
            
            details.put("pagination", pageInfo);
        }
    }
}
```

### 2.3 アノテーション使用例

```java
@Service
public class EngineerService {
    
    @Autowired
    private EngineerRepository engineerRepository;
    
    /**
     * 技術者の詳細情報を取得
     */
    @Audited(
        eventType = AuditEventType.DATA_ACCESS,
        resourceType = "ENGINEER",
        resourceIdExpression = "#id",
        action = AuditAction.READ
    )
    public EngineerDto findById(Long id) {
        Engineer engineer = engineerRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("技術者が見つかりません: " + id));
        
        return convertToDto(engineer);
    }
    
    /**
     * 技術者情報を更新
     */
    @Audited(
        eventType = AuditEventType.DATA_MODIFICATION,
        resourceType = "ENGINEER",
        resourceIdExpression = "#id",
        action = AuditAction.UPDATE,
        severity = AuditSeverity.WARNING
    )
    public EngineerDto update(Long id, EngineerUpdateDto updateDto) {
        Engineer engineer = engineerRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("技術者が見つかりません: " + id));
        
        // 更新前の値を監査ログに記録するためのカスタム詳細情報
        Map<String, Object> beforeUpdate = new HashMap<>();
        beforeUpdate.put("name", engineer.getFullName());
        beforeUpdate.put("email", engineer.getEmail());
        beforeUpdate.put("phone", engineer.getPhoneNumber());
        
        // カスタム監査情報を記録
        AuditContextHolder.setCustomDetails("beforeUpdate", beforeUpdate);
        
        // エンティティを更新
        updateEngineerEntity(engineer, updateDto);
        
        // 保存
        engineer = engineerRepository.save(engineer);
        
        return convertToDto(engineer);
    }
    
    // その他のメソッド...
}
```

## 3. 明示的API呼び出しによる監査ログ収集

### 3.1 監査ログサービス

監査ログを記録するためのサービスインターフェース：

```java
public interface AuditLogService {
    
    /**
     * 監査イベントをログに記録
     *
     * @param event 監査イベント
     */
    void logAuditEvent(AuditEvent event);
    
    /**
     * セキュリティイベントをログに記録する簡易メソッド
     *
     * @param eventType イベント種別
     * @param subjectId 主体ID
     * @param resourceId 対象リソースID
     * @param message メッセージ
     */
    void logSecurityEvent(String eventType, String subjectId, String resourceId, String message);
    
    /**
     * データアクセスイベントをログに記録する簡易メソッド
     *
     * @param action 操作（READ, EXPORT等）
     * @param resourceType リソース種別
     * @param resourceId リソースID
     * @param fields アクセスされたフィールド
     */
    void logDataAccess(AuditAction action, String resourceType, String resourceId, String... fields);
    
    /**
     * データ変更イベントをログに記録する簡易メソッド
     *
     * @param action 操作（CREATE, UPDATE, DELETE等）
     * @param resourceType リソース種別
     * @param resourceId リソースID
     * @param changedFields 変更されたフィールド
     * @param oldValues 変更前の値
     * @param newValues 変更後の値
     */
    void logDataChange(AuditAction action, String resourceType, String resourceId, 
                     String[] changedFields, Map<String, Object> oldValues, Map<String, Object> newValues);
}
```

### 3.2 監査ログサービスの実装

```java
@Service
public class AuditLogServiceImpl implements AuditLogService {
    
    private static final Logger log = LoggerFactory.getLogger("AUDIT_LOG");
    
    @Autowired
    private AuditEventRepository auditEventRepository;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Value("${app.security.audit.enabled:true}")
    private boolean auditEnabled;
    
    @Override
    public void logAuditEvent(AuditEvent event) {
        if (!auditEnabled) {
            return;
        }
        
        try {
            // カスタム詳細情報があれば追加
            Map<String, Object> customDetails = AuditContextHolder.getCustomDetails();
            if (customDetails != null && !customDetails.isEmpty()) {
                for (Map.Entry<String, Object> entry : customDetails.entrySet()) {
                    event.addDetail(entry.getKey(), entry.getValue());
                }
                // 使用後はクリア
                AuditContextHolder.clear();
            }
            
            // 監査イベントをJSON形式に変換してログに記録
            String eventJson = objectMapper.writeValueAsString(event);
            log.info(eventJson);
            
            // DBにも保存
            AuditEventEntity entity = convertToEntity(event);
            auditEventRepository.save(entity);
            
        } catch (Exception e) {
            log.error("監査ログの記録に失敗しました: " + e.getMessage(), e);
        }
    }
    
    @Override
    public void logSecurityEvent(String eventType, String subjectId, String resourceId, String message) {
        AuditEvent event = new AuditEvent();
        event.setEventId(UUID.randomUUID().toString());
        event.setTimestamp(LocalDateTime.now());
        event.setEventType(AuditEventType.valueOf(eventType));
        event.setSeverity(AuditSeverity.WARNING); // セキュリティイベントは警告レベル
        event.setSubjectType("USER");
        event.setSubjectId(subjectId);
        event.setResourceId(resourceId);
        event.setOutcome("INFO");
        
        // 現在の認証情報がある場合は設定
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.isAuthenticated()) {
            event.setSubjectId(authentication.getName());
        }
        
        // HTTPリクエスト情報がある場合は設定
        ServletRequestAttributes requestAttributes = 
            (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        if (requestAttributes != null) {
            HttpServletRequest request = requestAttributes.getRequest();
            event.setClientIp(request.getRemoteAddr());
            event.setUserAgent(request.getHeader("User-Agent"));
        }
        
        // メッセージを詳細情報に追加
        event.addDetail("message", message);
        
        // ログに記録
        logAuditEvent(event);
    }
    
    @Override
    public void logDataAccess(AuditAction action, String resourceType, String resourceId, String... fields) {
        AuditEvent event = new AuditEvent();
        event.setEventId(UUID.randomUUID().toString());
        event.setTimestamp(LocalDateTime.now());
        event.setEventType(AuditEventType.DATA_ACCESS);
        event.setSeverity(AuditSeverity.INFO);
        event.setAction(action);
        event.setResourceType(resourceType);
        event.setResourceId(resourceId);
        event.setOutcome("SUCCESS");
        
        // 現在の認証情報から主体情報を設定
        setSubjectInfoFromContext(event);
        
        // HTTPリクエスト情報を設定
        setRequestInfoFromContext(event);
        
        // データアクセス詳細
        Map<String, Object> dataAccessDetails = new HashMap<>();
        dataAccessDetails.put("fields", fields);
        event.addDetail("dataAccess", dataAccessDetails);
        
        // ログに記録
        logAuditEvent(event);
    }
    
    @Override
    public void logDataChange(AuditAction action, String resourceType, String resourceId, 
                            String[] changedFields, Map<String, Object> oldValues, 
                            Map<String, Object> newValues) {
        AuditEvent event = new AuditEvent();
        event.setEventId(UUID.randomUUID().toString());
        event.setTimestamp(LocalDateTime.now());
        event.setEventType(AuditEventType.DATA_MODIFICATION);
        event.setSeverity(AuditSeverity.WARNING);
        event.setAction(action);
        event.setResourceType(resourceType);
        event.setResourceId(resourceId);
        event.setOutcome("SUCCESS");
        
        // 現在の認証情報から主体情報を設定
        setSubjectInfoFromContext(event);
        
        // HTTPリクエスト情報を設定
        setRequestInfoFromContext(event);
        
        // データ変更詳細
        Map<String, Object> dataChangeDetails = new HashMap<>();
        dataChangeDetails.put("changedFields", changedFields);
        
        // 古い値と新しい値をマスキングして記録
        Map<String, Object> maskedOldValues = maskSensitiveData(oldValues);
        Map<String, Object> maskedNewValues = maskSensitiveData(newValues);
        dataChangeDetails.put("oldValues", maskedOldValues);
        dataChangeDetails.put("newValues", maskedNewValues);
        
        event.addDetail("dataChange", dataChangeDetails);
        
        // ログに記録
        logAuditEvent(event);
    }
    
    // 現在のコンテキストから主体情報を設定するヘルパーメソッド
    private void setSubjectInfoFromContext(AuditEvent event) {
        // 実装略（前述のAuditAspectのsetSubjectInfoメソッドと同様）
    }
    
    // 現在のコンテキストからリクエスト情報を設定するヘルパーメソッド
    private void setRequestInfoFromContext(AuditEvent event) {
        // 実装略（前述のAuditAspectのsetRequestInfoメソッドと同様）
    }
    
    // 機密データをマスキングするヘルパーメソッド
    private Map<String, Object> maskSensitiveData(Map<String, Object> data) {
        if (data == null) {
            return null;
        }
        
        Map<String, Object> maskedData = new HashMap<>();
        
        for (Map.Entry<String, Object> entry : data.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();
            
            // 機密フィールドのマスキング
            if (isSensitiveField(key)) {
                maskedData.put(key, "********");
            } else {
                maskedData.put(key, value);
            }
        }
        
        return maskedData;
    }
    
    // 機密フィールドかどうかを判定するヘルパーメソッド
    private boolean isSensitiveField(String fieldName) {
        Set<String> sensitiveFields = Set.of(
            "password", "secret", "token", "key", "creditCard", "ssn", "nationalId",
            "passportNumber", "bankAccount", "securityAnswer"
        );
        
        return sensitiveFields.contains(fieldName.toLowerCase()) ||
               fieldName.toLowerCase().contains("password") ||
               fieldName.toLowerCase().contains("secret") ||
               fieldName.toLowerCase().contains("token") ||
               fieldName.toLowerCase().contains("key") ||
               fieldName.toLowerCase().contains("credit") ||
               fieldName.toLowerCase().contains("card");
    }
    
    // AuditEventをエンティティに変換するヘルパーメソッド
    private AuditEventEntity convertToEntity(AuditEvent event) {
        AuditEventEntity entity = new AuditEventEntity();
        entity.setEventId(event.getEventId());
        entity.setTimestamp(event.getTimestamp());
        entity.setEventType(event.getEventType().name());
        entity.setSeverity(event.getSeverity().name());
        entity.setSubjectType(event.getSubjectType());
        entity.setSubjectId(event.getSubjectId());
        entity.setAction(event.getAction() != null ? event.getAction().name() : null);
        entity.setResourceType(event.getResourceType());
        entity.setResourceId(event.getResourceId());
        entity.setOutcome(event.getOutcome());
        entity.setClientIp(event.getClientIp());
        entity.setSessionId(event.getSessionId());
        entity.setRequestId(event.getRequestId());
        
        // 詳細情報をJSON形式に変換して保存
        try {
            if (event.getDetails() != null && !event.getDetails().isEmpty()) {
                entity.setDetailsJson(objectMapper.writeValueAsString(event.getDetails()));
            }
        } catch (JsonProcessingException e) {
            log.error("監査イベントの詳細情報のJSON変換に失敗しました", e);
        }
        
        return entity;
    }
}
```

### 3.3 監査コンテキストホルダー

監査に関連する追加情報を保持するためのスレッドローカルホルダー：

```java
public class AuditContextHolder {
    
    private static final ThreadLocal<Map<String, Object>> CONTEXT = new ThreadLocal<>();
    
    /**
     * カスタム詳細情報を設定
     */
    public static void setCustomDetails(String key, Object value) {
        Map<String, Object> details = CONTEXT.get();
        if (details == null) {
            details = new HashMap<>();
            CONTEXT.set(details);
        }
        details.put(key, value);
    }
    
    /**
     * カスタム詳細情報を追加
     */
    public static void addCustomDetails(Map<String, Object> detailsToAdd) {
        Map<String, Object> details = CONTEXT.get();
        if (details == null) {
            details = new HashMap<>();
            CONTEXT.set(details);
        }
        details.putAll(detailsToAdd);
    }
    
    /**
     * カスタム詳細情報を取得
     */
    public static Map<String, Object> getCustomDetails() {
        return CONTEXT.get();
    }
    
    /**
     * コンテキストをクリア
     */
    public static void clear() {
        CONTEXT.remove();
    }
}
```

### 3.4 API使用例

```java
@Service
public class ContractService {
    
    @Autowired
    private ContractRepository contractRepository;
    
    @Autowired
    private AuditLogService auditLogService;
    
    /**
     * 契約書を承認
     */
    public ContractDto approveContract(Long contractId, ApprovalRequest approvalRequest) {
        // 契約情報を取得
        Contract contract = contractRepository.findById(contractId)
            .orElseThrow(() -> new ResourceNotFoundException("契約が見つかりません: " + contractId));
        
        // 変更前の状態を記録
        ContractStatus oldStatus = contract.getStatus();
        
        // 契約を承認
        contract.setStatus(ContractStatus.APPROVED);
        contract.setApprovedBy(getCurrentUsername());
        contract.setApprovedAt(LocalDateTime.now());
        contract.setApprovalComment(approvalRequest.getComment());
        
        // 保存
        contract = contractRepository.save(contract);
        
        // 監査ログに記録
        auditLogService.logDataChange(
            AuditAction.APPROVE,
            "CONTRACT",
            contractId.toString(),
            new String[]{"status", "approvedBy", "approvedAt", "approvalComment"},
            Map.of("status", oldStatus),
            Map.of(
                "status", contract.getStatus(),
                "approvedBy", contract.getApprovedBy(),
                "approvedAt", contract.getApprovedAt(),
                "approvalComment", contract.getApprovalComment()
            )
        );
        
        return convertToDto(contract);
    }
    
    /**
     * 契約書を一括エクスポート
     */
    public List<ContractExportDto> exportContracts(ContractExportRequest exportRequest) {
        // 検索条件に基づいて契約を取得
        List<Contract> contracts = contractRepository.findByExportCriteria(
            exportRequest.getStartDate(),
            exportRequest.getEndDate(),
            exportRequest.getStatus(),
            exportRequest.getClientId()
        );
        
        // 監査ログに記録
        auditLogService.logDataAccess(
            AuditAction.EXPORT,
            "CONTRACT",
            "BULK", // 一括操作
            "id", "number", "client", "engineer", "startDate", "endDate", "amount", "status"
        );
        
        // エクスポート用DTOに変換して返却
        return contracts.stream()
            .map(this::convertToExportDto)
            .collect(Collectors.toList());
    }
    
    // ヘルパーメソッド
    private String getCurrentUsername() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return authentication != null ? authentication.getName() : "system";
    }
}
```

## 4. フィルターベースの監査ログ収集

### 4.1 認証イベント監査フィルター

ログイン/ログアウトなどの認証イベントを監査するフィルター：

```java
@Component
@Order(Ordered.HIGHEST_PRECEDENCE + 30)
public class AuthenticationAuditFilter extends OncePerRequestFilter {
    
    @Autowired
    private AuditLogService auditLogService;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        
        // 認証エンドポイントのみ処理対象とする
        String uri = request.getRequestURI();
        boolean isAuthEndpoint = uri.contains("/api/v1/auth/") || 
                                uri.equals("/login") || 
                                uri.equals("/logout");
        
        if (isAuthEndpoint) {
            // 認証イベントの種別を判定
            AuditEventType eventType = AuditEventType.AUTHENTICATION;
            AuditAction action = determineAuthAction(request);
            
            if (action != null) {
                // リクエスト処理前の認証状態を記録
                Authentication authBefore = SecurityContextHolder.getContext().getAuthentication();
                boolean isAuthenticatedBefore = authBefore != null && 
                                             authBefore.isAuthenticated() && 
                                             !(authBefore instanceof AnonymousAuthenticationToken);
                String usernameBefore = isAuthenticatedBefore ? authBefore.getName() : null;
                
                // レスポンスラッパーを作成して認証結果を監視
                ContentCachingResponseWrapper responseWrapper = new ContentCachingResponseWrapper(response);
                
                try {
                    // フィルターチェーンを続行
                    filterChain.doFilter(request, responseWrapper);
                    
                    // リクエスト処理後の認証状態を確認
                    Authentication authAfter = SecurityContextHolder.getContext().getAuthentication();
                    boolean isAuthenticatedAfter = authAfter != null && 
                                               authAfter.isAuthenticated() && 
                                               !(authAfter instanceof AnonymousAuthenticationToken);
                    String usernameAfter = isAuthenticatedAfter ? authAfter.getName() : null;
                    
                    // 認証結果を判定
                    boolean isSuccess = isAuthSuccess(request, responseWrapper, isAuthenticatedBefore, isAuthenticatedAfter);
                    String outcome = isSuccess ? "SUCCESS" : "FAILURE";
                    
                    // 対象ユーザーを特定
                    String username = determineUsername(request, usernameBefore, usernameAfter);
                    
                    // 監査イベントを作成
                    AuditEvent event = new AuditEvent();
                    event.setEventId(UUID.randomUUID().toString());
                    event.setTimestamp(LocalDateTime.now());
                    event.setEventType(eventType);
                    event.setSeverity(isSuccess ? AuditSeverity.INFO : AuditSeverity.WARNING);
                    event.setSubjectType("USER");
                    event.setSubjectId(username);
                    event.setAction(action);
                    event.setResourceType("USER_ACCOUNT");
                    event.setResourceId(username);
                    event.setOutcome(outcome);
                    event.setClientIp(request.getRemoteAddr());
                    event.setUserAgent(request.getHeader("User-Agent"));
                    
                    HttpSession session = request.getSession(false);
                    if (session != null) {
                        event.setSessionId(session.getId());
                    }
                    
                    // 認証メソッドなどの詳細情報
                    Map<String, Object> authDetails = new HashMap<>();
                    authDetails.put("method", determineAuthMethod(request));
                    
                    if (!isSuccess) {
                        authDetails.put("failureReason", determineFailureReason(responseWrapper));
                    }
                    
                    event.addDetail("auth", authDetails);
                    
                    // 監査ログに記録
                    auditLogService.logAuditEvent(event);
                    
                } finally {
                    // レスポンスコンテンツを復元してクライアントに送信
                    responseWrapper.copyBodyToResponse();
                }
            } else {
                // 認証アクションではない場合は通常のフィルター処理を続行
                filterChain.doFilter(request, response);
            }
        } else {
            // 認証エンドポイントでない場合は通常のフィルター処理を続行
            filterChain.doFilter(request, response);
        }
    }
    
    /**
     * 認証アクションを判定
     */
    private AuditAction determineAuthAction(HttpServletRequest request) {
        String uri = request.getRequestURI();
        String method = request.getMethod();
        
        if ((uri.equals("/login") || uri.contains("/api/v1/auth/login")) && method.equals("POST")) {
            return AuditAction.LOGIN;
        } else if (uri.equals("/logout") || uri.contains("/api/v1/auth/logout")) {
            return AuditAction.LOGOUT;
        } else if (uri.contains("/api/v1/auth/refresh") && method.equals("POST")) {
            return AuditAction.EXECUTE; // トークン更新
        } else if (uri.contains("/api/v1/auth/password") && 
                 (method.equals("POST") || method.equals("PUT"))) {
            return AuditAction.UPDATE; // パスワード変更
        }
        
        return null;
    }
    
    /**
     * 認証が成功したかどうかを判定
     */
    private boolean isAuthSuccess(HttpServletRequest request, ContentCachingResponseWrapper response,
                                boolean isAuthenticatedBefore, boolean isAuthenticatedAfter) {
        String uri = request.getRequestURI();
        int status = response.getStatus();
        
        if (uri.contains("/login") || uri.contains("/api/v1/auth/login")) {
            // ログイン: 200 OKかつ認証された場合に成功
            return status == HttpStatus.OK.value() && isAuthenticatedAfter;
        } else if (uri.equals("/logout") || uri.contains("/api/v1/auth/logout")) {
            // ログアウト: 成功コードかつ認証状態が変化（または匿名）
            return (status >= 200 && status < 400) && 
                  (!isAuthenticatedAfter || isAuthenticatedBefore != isAuthenticatedAfter);
        } else {
            // その他の認証操作: 成功コードを返した場合に成功
            return status >= 200 && status < 400;
        }
    }
    
    /**
     * 対象ユーザー名を特定
     */
    private String determineUsername(HttpServletRequest request, String usernameBefore, String usernameAfter) {
        // リクエストパラメータからユーザー名を取得（フォームログイン）
        String usernameParam = request.getParameter("username");
        
        // リクエストボディからユーザー名を取得（JSON APIログイン）
        String username = null;
        if (usernameParam != null) {
            username = usernameParam;
        } else if (request.getContentType() != null && 
                  request.getContentType().contains("application/json")) {
            try {
                // リクエストボディが既に読み取られている可能性があるため
                // この方法は完全ではないが、できる限り試みる
                BufferedReader reader = request.getReader();
                if (reader != null) {
                    String body = reader.lines().collect(Collectors.joining());
                    if (StringUtils.hasText(body)) {
                        JsonNode jsonNode = new ObjectMapper().readTree(body);
                        if (jsonNode.has("username")) {
                            username = jsonNode.get("username").asText();
                        }
                    }
                }
            } catch (Exception e) {
                // リクエストボディの読み取りに失敗した場合は無視
            }
        }
        
        // リクエストから取得できなかった場合は認証状態のユーザー名を使用
        if (username == null) {
            username = usernameAfter != null ? usernameAfter : usernameBefore;
        }
        
        // それでも取得できない場合は「unknown」とする
        return username != null ? username : "unknown";
    }
    
    /**
     * 認証方法を判定
     */
    private String determineAuthMethod(HttpServletRequest request) {
        // ヘッダーやリクエストパラメータから認証方法を判定
        if (request.getHeader("Authorization") != null && 
            request.getHeader("Authorization").startsWith("Bearer ")) {
            return "TOKEN";
        } else if (request.getParameter("mfaCode") != null || 
                  request.getRequestURI().contains("/mfa")) {
            return "MFA";
        } else {
            return "PASSWORD";
        }
    }
    
    /**
     * 認証失敗理由を判定
     */
    private String determineFailureReason(ContentCachingResponseWrapper response) {
        try {
            // レスポンスボディからエラー情報を抽出
            byte[] content = response.getContentAsByteArray();
            if (content.length > 0) {
                String contentStr = new String(content, StandardCharsets.UTF_8);
                JsonNode jsonNode = new ObjectMapper().readTree(contentStr);
                
                if (jsonNode.has("error")) {
                    return jsonNode.get("error").asText();
                } else if (jsonNode.has("message")) {
                    return jsonNode.get("message").asText();
                }
            }
        } catch (Exception e) {
            // JSONの解析に失敗した場合は無視
        }
        
        // エラー情報を特定できない場合はHTTPステータスコードを使用
        int status = response.getStatus();
        if (status == HttpStatus.UNAUTHORIZED.value()) {
            return "INVALID_CREDENTIALS";
        } else if (status == HttpStatus.FORBIDDEN.value()) {
            return "ACCESS_DENIED";
        } else if (status == HttpStatus.LOCKED.value()) {
            return "ACCOUNT_LOCKED";
        } else {
            return "UNKNOWN_ERROR";
        }
    }
}
```

### 4.2 HTTP通信監査フィルター

API呼び出しなどのHTTP通信を監査するフィルター：

```java
@Component
@Order(Ordered.HIGHEST_PRECEDENCE + 40)
public class HttpAuditFilter extends OncePerRequestFilter {
    
    private static final Logger log = LoggerFactory.getLogger("HTTP_AUDIT");
    
    @Value("${app.security.audit.http.enabled:true}")
    private boolean httpAuditEnabled;
    
    @Value("${app.security.audit.http.include-patterns:/**}")
    private String[] includePatterns;
    
    @Value("${app.security.audit.http.exclude-patterns:/static/**,/assets/**,/actuator/health,/favicon.ico}")
    private String[] excludePatterns;
    
    @Value("${app.security.audit.http.include-response-body:false}")
    private boolean includeResponseBody;
    
    @Value("${app.security.audit.http.max-response-body-size:1024}")
    private int maxResponseBodySize;
    
    private final AntPathMatcher pathMatcher = new AntPathMatcher();
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        
        if (!httpAuditEnabled) {
            filterChain.doFilter(request, response);
            return;
        }
        
        // リクエストURIがパターンに一致するか確認
        String uri = request.getRequestURI();
        if (!isIncluded(uri)) {
            filterChain.doFilter(request, response);
            return;
        }
        
        // リクエスト情報を収集
        long startTime = System.currentTimeMillis();
        String method = request.getMethod();
        String query = request.getQueryString();
        String fullUrl = query != null ? uri + "?" + query : uri;
        String clientIp = request.getRemoteAddr();
        String userAgent = request.getHeader("User-Agent");
        String contentType = request.getContentType();
        
        // レスポンスをラップして内容を取得可能にする
        ContentCachingResponseWrapper responseWrapper = new ContentCachingResponseWrapper(response);
        
        // リクエストボディを取得可能にするためにラップ
        ContentCachingRequestWrapper requestWrapper = new ContentCachingRequestWrapper(request);
        
        try {
            // フィルターチェーンを続行
            filterChain.doFilter(requestWrapper, responseWrapper);
        } finally {
            // 処理時間を計算
            long duration = System.currentTimeMillis() - startTime;
            
            // 現在の認証ユーザーを取得
            String username = "anonymous";
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            if (authentication != null && authentication.isAuthenticated() && 
                !(authentication instanceof AnonymousAuthenticationToken)) {
                username = authentication.getName();
            }
            
            // セッションID（存在する場合）
            String sessionId = null;
            HttpSession session = request.getSession(false);
            if (session != null) {
                sessionId = session.getId();
            }
            
            // レスポンス情報
            int status = responseWrapper.getStatus();
            String responseContentType = responseWrapper.getContentType();
            long contentLength = responseWrapper.getContentSize();
            
            // JSONオブジェクトを構築
            Map<String, Object> auditData = new HashMap<>();
            auditData.put("timestamp", LocalDateTime.now().toString());
            auditData.put("method", method);
            auditData.put("url", fullUrl);
            auditData.put("status", status);
            auditData.put("duration", duration);
            auditData.put("username", username);
            auditData.put("clientIp", clientIp);
            auditData.put("userAgent", userAgent);
            
            if (sessionId != null) {
                auditData.put("sessionId", sessionId);
            }
            
            // リクエスト情報
            Map<String, Object> requestInfo = new HashMap<>();
            requestInfo.put("contentType", contentType);
            
            // リクエストヘッダー（機密情報を除く）
            Map<String, String> headers = new HashMap<>();
            Enumeration<String> headerNames = request.getHeaderNames();
            while (headerNames.hasMoreElements()) {
                String headerName = headerNames.nextElement();
                if (!isExcludedHeader(headerName)) {
                    headers.put(headerName, request.getHeader(headerName));
                }
            }
            requestInfo.put("headers", headers);
            
            // リクエストボディ（設定に応じて）
            if (shouldLogRequestBody(request)) {
                String requestBody = getRequestBody(requestWrapper);
                if (requestBody != null) {
                    requestInfo.put("body", maskSensitiveData(requestBody));
                }
            }
            
            auditData.put("request", requestInfo);
            
            // レスポンス情報
            Map<String, Object> responseInfo = new HashMap<>();
            responseInfo.put("contentType", responseContentType);
            responseInfo.put("contentLength", contentLength);
            
            // レスポンスボディ（設定に応じて）
            if (includeResponseBody && shouldLogResponseBody(responseContentType, status)) {
                String responseBody = getResponseBody(responseWrapper);
                if (responseBody != null) {
                    responseInfo.put("body", responseBody.length() > maxResponseBodySize ? 
                                          responseBody.substring(0, maxResponseBodySize) + "..." : 
                                          responseBody);
                }
            }
            
            auditData.put("response", responseInfo);
            
            // JSON形式でログに記録
            log.info(new ObjectMapper().writeValueAsString(auditData));
            
            // レスポンスコンテンツを復元してクライアントに送信
            responseWrapper.copyBodyToResponse();
        }
    }
    
    /**
     * URIが監査対象に含まれるかどうかを判定
     */
    private boolean isIncluded(String uri) {
        // 除外パターンに一致する場合は対象外
        for (String pattern : excludePatterns) {
            if (pathMatcher.match(pattern, uri)) {
                return false;
            }
        }
        
        // 含めるパターンに一致する場合は対象
        for (String pattern : includePatterns) {
            if (pathMatcher.match(pattern, uri)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * 除外すべきヘッダーかどうかを判定
     */
    private boolean isExcludedHeader(String headerName) {
        String headerNameLower = headerName.toLowerCase();
        return headerNameLower.contains("authorization") || 
               headerNameLower.contains("cookie") || 
               headerNameLower.contains("token") || 
               headerNameLower.contains("secret") || 
               headerNameLower.contains("password");
    }
    
    /**
     * リクエストボディをログに記録すべきかどうかを判定
     */
    private boolean shouldLogRequestBody(HttpServletRequest request) {
        String method = request.getMethod();
        String contentType = request.getContentType();
        
        // POSTまたはPUTリクエストで、JSONまたはフォームデータの場合にのみ記録
        return ("POST".equals(method) || "PUT".equals(method)) && 
               contentType != null && 
               (contentType.contains("application/json") || 
                contentType.contains("application/x-www-form-urlencoded"));
    }
    
    /**
     * レスポンスボディをログに記録すべきかどうかを判定
     */
    private boolean shouldLogResponseBody(String contentType, int status) {
        // JSONレスポンスのみ記録
        return contentType != null && 
               contentType.contains("application/json") && 
               status != HttpStatus.NO_CONTENT.value();
    }
    
    /**
     * リクエストボディを取得
     */
    private String getRequestBody(ContentCachingRequestWrapper request) {
        byte[] content = request.getContentAsByteArray();
        if (content.length > 0) {
            try {
                return new String(content, request.getCharacterEncoding());
            } catch (UnsupportedEncodingException e) {
                return new String(content, StandardCharsets.UTF_8);
            }
        }
        return null;
    }
    
    /**
     * レスポンスボディを取得
     */
    private String getResponseBody(ContentCachingResponseWrapper response) {
        byte[] content = response.getContentAsByteArray();
        if (content.length > 0) {
            try {
                return new String(content, response.getCharacterEncoding());
            } catch (UnsupportedEncodingException e) {
                return new String(content, StandardCharsets.UTF_8);
            }
        }
        return null;
    }
    
    /**
     * 機密データをマスク
     */
    private String maskSensitiveData(String data) {
        if (data == null) {
            return null;
        }
        
        try {
            // JSONデータの場合
            if (data.trim().startsWith("{") || data.trim().startsWith("[")) {
                ObjectMapper mapper = new ObjectMapper();
                JsonNode rootNode = mapper.readTree(data);
                if (rootNode.isObject()) {
                    maskJsonNode((ObjectNode) rootNode);
                    return mapper.writeValueAsString(rootNode);
                } else {
                    return data;
                }
            } else {
                // フォームデータの場合
                return maskFormData(data);
            }
        } catch (Exception e) {
            // JSONパースに失敗した場合は元のデータを返す
            return data;
        }
    }
    
    /**
     * JSONノードの機密データをマスク
     */
    private void maskJsonNode(ObjectNode node) {
        Iterator<Map.Entry<String, JsonNode>> fields = node.fields();
        while (fields.hasNext()) {
            Map.Entry<String, JsonNode> field = fields.next();
            String fieldName = field.getKey().toLowerCase();
            JsonNode fieldValue = field.getValue();
            
            if (isSensitiveFieldName(fieldName)) {
                node.put(field.getKey(), "********");
            } else if (fieldValue.isObject()) {
                maskJsonNode((ObjectNode) fieldValue);
            } else if (fieldValue.isArray()) {
                ArrayNode arrayNode = (ArrayNode) fieldValue;
                for (int i = 0; i < arrayNode.size(); i++) {
                    if (arrayNode.get(i).isObject()) {
                        maskJsonNode((ObjectNode) arrayNode.get(i));
                    }
                }
            }
        }
    }
    
    /**
     * フォームデータの機密情報をマスク
     */
    private String maskFormData(String formData) {
        StringBuilder masked = new StringBuilder();
        String[] pairs = formData.split("&");
        for (String pair : pairs) {
            String[] keyValue = pair.split("=", 2);
            if (keyValue.length == 2) {
                String key = keyValue[0];
                String value = keyValue[1];
                
                if (isSensitiveFieldName(key.toLowerCase())) {
                    masked.append(key).append("=********");
                } else {
                    masked.append(key).append("=").append(value);
                }
                
                masked.append("&");
            } else {
                masked.append(pair).append("&");
            }
        }
        
        if (masked.length() > 0 && masked.charAt(masked.length() - 1) == '&') {
            masked.deleteCharAt(masked.length() - 1);
        }
        
        return masked.toString();
    }
    
    /**
     * 機密フィールド名かどうかを判定
     */
    private boolean isSensitiveFieldName(String fieldName) {
        return fieldName.contains("password") || 
               fieldName.contains("secret") || 
               fieldName.contains("token") || 
               fieldName.contains("key") || 
               fieldName.contains("credit") || 
               fieldName.contains("card") || 
               fieldName.contains("cvv") || 
               fieldName.contains("ssn") || 
               fieldName.contains("national_id") || 
               fieldName.contains("passport");
    }
}
```

## 5. 設定

### 5.1 Logback設定

監査ログやアプリケーションログの設定（logback-spring.xml）：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- デフォルトの設定をインポート -->
    <include resource="org/springframework/boot/logging/logback/defaults.xml"/>
    
    <!-- アプリケーション名 -->
    <property name="APP_NAME" value="sesapp"/>
    
    <!-- ログディレクトリ -->
    <property name="LOG_DIR" value="${LOG_PATH:-/var/log/sesapp}"/>
    
    <!-- コンソール出力設定 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>${CONSOLE_LOG_PATTERN}</pattern>
            <charset>utf8</charset>
        </encoder>
    </appender>
    
    <!-- アプリケーションログ設定 -->
    <appender name="APPLICATION" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_DIR}/application.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_DIR}/application-%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory> <!-- 30日間保持 -->
            <totalSizeCap>3GB</totalSizeCap> <!-- 合計サイズ上限 -->
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            <charset>utf8</charset>
        </encoder>
    </appender>
    
    <!-- 監査ログ設定（JSON形式） -->
    <appender name="AUDIT" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_DIR}/audit.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_DIR}/audit-%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>1095</maxHistory> <!-- 3年間保持 -->
            <totalSizeCap>20GB</totalSizeCap> <!-- 合計サイズ上限 -->
        </rollingPolicy>
        <encoder class="net.logstash.logback.encoder.LogstashEncoder">
            <!-- JSONフォーマット設定 -->
            <timeZone>Asia/Tokyo</timeZone>
            <fieldNames>
                <timestamp>timestamp</timestamp>
                <message>message</message>
                <logger>logger</logger>
                <thread>thread</thread>
                <level>level</level>
            </fieldNames>
            <customFields>{"application":"${APP_NAME}"}</customFields>
        </encoder>
    </appender>
    
    <!-- HTTP通信監査ログ設定（JSON形式） -->
    <appender name="HTTP_AUDIT" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_DIR}/http-audit.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_DIR}/http-audit-%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>180</maxHistory> <!-- 6ヶ月間保持 -->
            <totalSizeCap>10GB</totalSizeCap> <!-- 合計サイズ上限 -->
        </rollingPolicy>
        <encoder class="net.logstash.logback.encoder.LogstashEncoder">
            <timeZone>Asia/Tokyo</timeZone>
            <customFields>{"application":"${APP_NAME}"}</customFields>
        </encoder>
    </appender>
    
    <!-- エラーログ設定 -->
    <appender name="ERROR" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_DIR}/error.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_DIR}/error-%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory> <!-- 30日間保持 -->
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            <charset>utf8</charset>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>ERROR</level>
        </filter>
    </appender>
    
    <!-- 非同期処理のためのアペンダー -->
    <appender name="ASYNC_APPLICATION" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="APPLICATION" />
        <queueSize>512</queueSize>
        <discardingThreshold>0</discardingThreshold>
        <includeCallerData>false</includeCallerData>
        <neverBlock>true</neverBlock>
    </appender>
    
    <appender name="ASYNC_AUDIT" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="AUDIT" />
        <queueSize>512</queueSize>
        <discardingThreshold>0</discardingThreshold>
        <includeCallerData>false</includeCallerData>
        <neverBlock>false</neverBlock> <!-- 監査ログは破棄しない -->
    </appender>
    
    <appender name="ASYNC_HTTP_AUDIT" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="HTTP_AUDIT" />
        <queueSize>512</queueSize>
        <discardingThreshold>0</discardingThreshold>
        <includeCallerData>false</includeCallerData>
        <neverBlock>true</neverBlock>
    </appender>
    
    <!-- ロガー設定 -->
    <logger name="AUDIT_LOG" level="INFO" additivity="false">
        <appender-ref ref="ASYNC_AUDIT" />
        <appender-ref ref="CONSOLE" />
    </logger>
    
    <logger name="HTTP_AUDIT" level="INFO" additivity="false">
        <appender-ref ref="ASYNC_HTTP_AUDIT" />
    </logger>
    
    <!-- Spring Frameworkのログレベル -->
    <logger name="org.springframework" level="INFO" />
    <logger name="org.springframework.security" level="INFO" />
    
    <!-- Hibernateのログレベル -->
    <logger name="org.hibernate" level="INFO" />
    <logger name="org.hibernate.SQL" level="DEBUG" />
    <logger name="org.hibernate.type.descriptor.sql" level="TRACE" />
    
    <!-- アプリケーションのパッケージ -->
    <logger name="jp.co.example.sesapp" level="DEBUG" />
    
    <!-- ルートロガー -->
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="ASYNC_APPLICATION" />
        <appender-ref ref="ERROR" />
    </root>
</configuration>
```

### 5.2 アプリケーション設定

監査ログ機能の設定（application.yml）：

```yaml
app:
  security:
    audit:
      enabled: true
      max-events-in-memory: 1000
      database-retention-days: 1095  # 3年間
      file-retention-days: 1095      # 3年間
      http:
        enabled: true
        include-patterns: "/**"
        exclude-patterns: "/static/**,/assets/**,/actuator/health,/favicon.ico"
        include-response-body: false
        max-response-body-size: 1024
      data:
        mask-sensitive-fields:
          - "password"
          - "secret"
          - "token"
          - "key"
          - "creditCard"
          - "ssn"
          - "nationalId"
          - "passportNumber"
          - "bankAccount"
          - "securityAnswer"
      monitoring:
        real-time-alerts: true
        alert-recipients: "security@example.com"
```

## 6. 参照情報

- [OWASP Logging Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)
- [Spring AOP Documentation](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop)
- [Logback Documentation](http://logback.qos.ch/documentation.html)
- [Spring Security Audit](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#audit)