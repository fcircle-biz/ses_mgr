# SES業務システム 脆弱性対策詳細設計

## 1. 概要

### 1.1 目的

本ドキュメントは、SES業務システムにおける脆弱性対策の詳細設計を定義するものである。OWASP Top 10をはじめとする一般的な脆弱性への対策方針と具体的な実装方法を提供し、システム全体のセキュリティレベルを向上させることを目的とする。

### 1.2 対象範囲

本設計では、以下の脆弱性対策を対象とする：

1. **OWASP Top 10 (2021/2023)対策**：Webアプリケーションにおける主要な脆弱性への対策
2. **入力検証と出力エンコード**：すべての外部入力に対する検証と安全な出力生成
3. **SQLインジェクション対策**：データベースアクセスにおける安全な実装
4. **クロスサイトスクリプティング(XSS)対策**：ユーザー入力を含むHTMLの安全な生成
5. **クロスサイトリクエストフォージェリ(CSRF)対策**：リクエスト偽造攻撃への防御
6. **セキュアな設定と運用**：安全なデフォルト設定と運用プラクティス

### 1.3 関連ドキュメント

- [詳細設計：セキュリティ設計概要](/docs/03_詳細設計/05_セキュリティ/01_セキュリティ設計概要.md)
- [詳細設計：認証認可設計](/docs/03_詳細設計/05_セキュリティ/02_認証認可設計.md)
- [詳細設計：データ保護設計](/docs/03_詳細設計/05_セキュリティ/03_データ保護設計.md)
- [詳細設計：通信セキュリティ設計](/docs/03_詳細設計/05_セキュリティ/04_通信セキュリティ設計.md)
- [詳細設計：監査ログ設計](/docs/03_詳細設計/05_セキュリティ/05_監査ログ設計_01_概要.md)

## 2. OWASP Top 10 (2021) 対策

### 2.1 A01:2021 – アクセス制御の不備

#### 2.1.1 リスク概要

認証・認可などのアクセス制御機構が不適切に実装されている場合、権限のないユーザーがデータにアクセスしたり、権限のない操作を実行したりする可能性がある。

#### 2.1.2 対策方針

以下の対策を実装する：

1. **最小権限の原則**：ユーザーには必要最小限の権限のみを付与
2. **多層防御**：UI、API、コントローラー、サービスレイヤーの各層でアクセス制御を実施
3. **失敗安全**：デフォルトで拒否、明示的に許可したものだけを実行可能に

#### 2.1.3 実装詳細

```java
// 認可チェックのAOPアスペクト
@Aspect
@Component
public class AuthorizationAspect {
    
    @Autowired
    private PermissionEvaluator permissionEvaluator;
    
    @Around("@annotation(secured)")
    public Object checkAuthorization(ProceedingJoinPoint joinPoint, Secured secured) throws Throwable {
        // メソッド引数からリソースIDを取得
        Long resourceId = extractResourceId(joinPoint);
        String resourceType = secured.resourceType();
        String permission = secured.permission();
        
        // 現在の認証情報を取得
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        
        // 権限チェック
        if (!permissionEvaluator.hasPermission(authentication, resourceId, resourceType, permission)) {
            // 監査ログに記録
            auditLogService.logSecurityEvent("ACCESS_DENIED", 
                                           authentication.getName(),
                                           "リソースへのアクセス拒否: " + resourceType + ":" + resourceId);
            
            throw new AccessDeniedException("リソース " + resourceType + ":" + resourceId + 
                                          " への " + permission + " 権限がありません");
        }
        
        return joinPoint.proceed();
    }
    
    // メソッド引数からリソースIDを抽出するヘルパーメソッド
    private Long extractResourceId(ProceedingJoinPoint joinPoint) {
        // 実装省略
    }
}

// 使用例：メソッドレベルの認可チェック
@RestController
@RequestMapping("/api/v1/engineers")
public class EngineerController {
    
    @GetMapping("/{id}")
    @Secured(resourceType = "ENGINEER", permission = "VIEW")
    public ResponseEntity<EngineerDto> getEngineer(@PathVariable Long id) {
        // idに対するエンジニア情報取得処理
    }
    
    @PutMapping("/{id}")
    @Secured(resourceType = "ENGINEER", permission = "EDIT")
    public ResponseEntity<EngineerDto> updateEngineer(@PathVariable Long id, 
                                                      @Valid @RequestBody EngineerUpdateDto dto) {
        // エンジニア情報更新処理
    }
}
```

### 2.2 A02:2021 – 暗号化の失敗

#### 2.2.1 リスク概要

機密データが適切に保護されていない場合、データ漏洩やプライバシー侵害、法的問題などが発生する可能性がある。

#### 2.2.2 対策方針

以下の対策を実装する：

1. **転送時の暗号化**：すべての通信をTLS 1.3で保護
2. **保存時の暗号化**：機密データはデータベースレベルで暗号化
3. **強力な暗号アルゴリズム**：業界標準のアルゴリズムを使用（AES-256-GCM等）
4. **適切なキー管理**：キーの安全な生成、保存、更新、破棄のライフサイクル管理

#### 2.2.3 実装詳細

詳細は[データ保護設計](/docs/03_詳細設計/05_セキュリティ/03_データ保護設計.md)を参照。主要な実装方針は以下の通り：

```java
// JPA/Hibernateエンティティでの暗号化実装例
@Entity
@Table(name = "sensitive_data")
public class SensitiveData {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "public_data")
    private String publicData;
    
    @Convert(converter = StringEncryptionConverter.class)
    @Column(name = "sensitive_data_1")
    private String sensitiveData1;
    
    @Convert(converter = StringEncryptionConverter.class)
    @Column(name = "sensitive_data_2")
    private String sensitiveData2;
    
    // getters, setters
}

// 暗号化コンバーター
@Converter
public class StringEncryptionConverter implements AttributeConverter<String, String> {
    
    @Autowired
    private EncryptionService encryptionService;
    
    @Override
    public String convertToDatabaseColumn(String attribute) {
        if (attribute == null) {
            return null;
        }
        return encryptionService.encrypt(attribute);
    }
    
    @Override
    public String convertToEntityAttribute(String dbData) {
        if (dbData == null) {
            return null;
        }
        return encryptionService.decrypt(dbData);
    }
}

// 暗号化サービス（詳細は省略、データ保護設計を参照）
@Service
public class EncryptionServiceImpl implements EncryptionService {
    
    @Autowired
    private KeyManagementService keyManagementService;
    
    @Override
    public String encrypt(String plaintext) {
        // AES-GCMによる暗号化の実装
    }
    
    @Override
    public String decrypt(String ciphertext) {
        // AES-GCMによる復号化の実装
    }
}
```

### 2.3 A03:2021 – インジェクション

#### 2.3.1 リスク概要

SQLインジェクション、コマンドインジェクション、XSSなど、信頼できないデータが処理フローの一部として解釈される場合に発生する。

#### 2.3.2 対策方針

以下の対策を実装する：

1. **パラメータ化クエリ**：すべてのSQLクエリをパラメータ化
2. **ORM活用**：可能な限りORMを使用してSQLインジェクションを防止
3. **入力検証**：すべての入力に対する構文的および意味的検証
4. **コンテキスト別エスケープ**：出力コンテキストに応じた適切なエスケープ処理

#### 2.3.3 SQLインジェクション対策の実装詳細

```java
// 安全なデータアクセス実装
@Repository
public class EngineerRepositoryImpl implements EngineerRepositoryCustom {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    // 悪い例（脆弱なコード、使用禁止）
    public List<Engineer> findByNameUnsafe(String name) {
        // 危険: SQL文字列を直接連結
        String sql = "SELECT * FROM engineers WHERE name LIKE '%" + name + "%'";
        return jdbcTemplate.query(sql, new EngineerRowMapper());
    }
    
    // 良い例（安全な実装）
    public List<Engineer> findByName(String name) {
        // 安全: パラメータ化クエリを使用
        String sql = "SELECT * FROM engineers WHERE name LIKE ?";
        return jdbcTemplate.query(sql, new EngineerRowMapper(), "%" + name + "%");
    }
    
    // Spring Data JPAを使用した安全な実装
    @Override
    public List<Engineer> findByNameContaining(String name) {
        // JPA/Hibernateが自動的にパラメータ化クエリを使用
        return engineerRepository.findByNameContaining(name);
    }
    
    // 動的クエリが必要な場合はQueryDSLを使用
    @Override
    public List<Engineer> findByComplexCriteria(EngineerSearchCriteria criteria) {
        QEngineer engineer = QEngineer.engineer;
        
        BooleanBuilder builder = new BooleanBuilder();
        
        if (criteria.getName() != null) {
            builder.and(engineer.name.containsIgnoreCase(criteria.getName()));
        }
        
        if (criteria.getSkills() != null && !criteria.getSkills().isEmpty()) {
            builder.and(engineer.skills.any().in(criteria.getSkills()));
        }
        
        // 他の条件も同様に追加
        
        return queryFactory.selectFrom(engineer)
                         .where(builder)
                         .fetch();
    }
}
```

#### 2.3.4 XSSインジェクション対策の実装詳細

```java
// XSS対策のフィルター実装
@Component
public class XssFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        
        chain.doFilter(new XssRequestWrapper((HttpServletRequest) request), response);
    }
    
    // 内部クラス: XSS対策リクエストラッパー
    private static class XssRequestWrapper extends HttpServletRequestWrapper {
        
        public XssRequestWrapper(HttpServletRequest request) {
            super(request);
        }
        
        @Override
        public String[] getParameterValues(String parameter) {
            String[] values = super.getParameterValues(parameter);
            
            if (values == null) {
                return null;
            }
            
            int count = values.length;
            String[] encodedValues = new String[count];
            for (int i = 0; i < count; i++) {
                encodedValues[i] = cleanXSS(values[i]);
            }
            
            return encodedValues;
        }
        
        @Override
        public String getParameter(String parameter) {
            String value = super.getParameter(parameter);
            return cleanXSS(value);
        }
        
        @Override
        public String getHeader(String name) {
            String value = super.getHeader(name);
            return cleanXSS(value);
        }
        
        // XSSクリーニング処理
        private String cleanXSS(String value) {
            if (value == null) {
                return null;
            }
            
            // 以下は単純な例。実際にはESAPIなどのライブラリを使用することを推奨
            String cleanValue = value
                .replaceAll("<", "&lt;")
                .replaceAll(">", "&gt;")
                .replaceAll("\\(", "&#40;")
                .replaceAll("\\)", "&#41;")
                .replaceAll("'", "&#39;")
                .replaceAll("\"", "&quot;")
                .replaceAll("eval\\((.*)\\)", "")
                .replaceAll("[\\\"\\\'][\\s]*javascript:(.*)[\\\"\\\']", "\"\"");
                
            return cleanValue;
        }
    }
}

// Spring MVCでのXSS対策（Thymeleafテンプレートエンジン使用時）
@Controller
public class WebController {
    
    @GetMapping("/example")
    public String example(Model model) {
        // Thymeleafは自動的にHTMLエスケープ処理を行う
        model.addAttribute("userInput", "<script>alert('XSS');</script>");
        
        // HTML属性など特定コンテキストでのエスケープ例
        // Thymeleafテンプレート側:
        // <div th:attr="data-content=${userInput}">...</div>
        
        return "example";
    }
}

// REST APIでのXSS対策
@RestController
@RequestMapping("/api/v1")
public class ApiController {
    
    @GetMapping("/data")
    public Map<String, Object> getData(@RequestParam String input) {
        // すでにXssFilterでクリーニング済みの入力を使用
        
        Map<String, Object> result = new HashMap<>();
        result.put("input", input);
        result.put("processedTime", new Date());
        
        return result;
    }
}
```

### 2.4 A04:2021 – 安全でない設計

#### 2.4.1 リスク概要

初期の設計段階でセキュリティが考慮されていない場合、後からセキュリティ対策を追加することが難しく、システム全体が脆弱なままになる可能性がある。

#### 2.4.2 対策方針

以下の対策を実装する：

1. **セキュアバイデザイン**：設計段階からセキュリティ要件を組み込む
2. **脅威モデリング**：攻撃者視点でのリスク分析と対策
3. **セキュリティユースケース**：通常の機能要件と共にセキュリティ要件も明文化

#### 2.4.3 実装詳細

セキュアバイデザインの原則に基づき、以下のセキュリティ設計パターンを採用：

```java
// 防御的プログラミングパターン例
@Service
public class BusinessService {
    
    // 前提条件の検証
    public void processData(DataRequest request) {
        // null検証
        Objects.requireNonNull(request, "リクエストがnullです");
        Objects.requireNonNull(request.getData(), "データがnullです");
        
        // ビジネスルール検証
        if (request.getData().size() > Constants.MAX_ITEMS) {
            throw new ValidationException("データ項目数が上限を超えています");
        }
        
        // 実際の処理
        // ...
    }
    
    // 戻り値の保証
    public Optional<ResultData> findData(String id) {
        try {
            // 処理...
            ResultData data = repository.findById(id);
            return Optional.ofNullable(data);
        } catch (Exception e) {
            log.error("データ検索中にエラーが発生しました", e);
            return Optional.empty(); // nullを返さない
        }
    }
}

// イミュータブルオブジェクトパターン例
@Value // Lombokの@Valueアノテーション：イミュータブルクラスを生成
public class UserCredential {
    String username;
    String hashedPassword;
    Set<String> roles;
    
    // すべてのフィールドを初期化するコンストラクタが自動生成される
    
    // ディープコピーを確保する場合の防御策
    public Set<String> getRoles() {
        return Collections.unmodifiableSet(roles);
    }
}
```

### 2.5 A05:2021 – セキュリティ設定の誤り

#### 2.5.1 リスク概要

デフォルト設定の使用、不完全な設定、オープンクラウドストレージ、詳細なエラーメッセージなど、不適切な設定がセキュリティリスクをもたらす可能性がある。

#### 2.5.2 対策方針

以下の対策を実装する：

1. **安全なデフォルト設定**：セキュアなデフォルト値を使用
2. **最小特権の原則**：必要最小限の権限のみを付与
3. **環境別の設定管理**：開発・テスト・本番環境ごとに最適な設定
4. **不要な機能・サービスの無効化**：使用しない機能やAPIを無効化

#### 2.5.3 実装詳細

```java
// 環境別のセキュリティ設定
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Autowired
    private Environment env;
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        // 共通セキュリティ設定
        http
            .headers(headers -> headers
                .contentSecurityPolicy(csp -> csp.policyDirectives("default-src 'self'"))
                .frameOptions(frame -> frame.deny())
                .xssProtection(xss -> xss.block(true))
                .contentTypeOptions(contentType -> contentType.disable())
            )
            .csrf(csrf -> csrf.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()))
            .sessionManagement(session -> session
                .sessionFixation().migrateSession()
                .maximumSessions(1)
                .expiredUrl("/login?expired")
            );
        
        // 環境別の設定
        if (isProductionEnvironment()) {
            // 本番環境設定
            http
                .requiresChannel(channel -> channel
                    .anyRequest().requiresSecure() // HTTPS強制
                )
                .headers(headers -> headers
                    .httpStrictTransportSecurity(hsts -> hsts
                        .includeSubDomains(true)
                        .maxAgeInSeconds(31536000) // 1年
                    )
                );
        } else {
            // 開発環境設定
            // 開発環境ではHTTPSを強制しない、等
        }
        
        return http.build();
    }
    
    // エラーハンドリング設定
    @Bean
    public ErrorAttributes errorAttributes() {
        return new DefaultErrorAttributes() {
            @Override
            public Map<String, Object> getErrorAttributes(WebRequest webRequest, 
                                                          ErrorAttributeOptions options) {
                Map<String, Object> errorAttributes = super.getErrorAttributes(webRequest, options);
                
                // 本番環境では詳細なエラー情報を非表示に
                if (isProductionEnvironment()) {
                    errorAttributes.remove("exception");
                    errorAttributes.remove("trace");
                }
                
                return errorAttributes;
            }
        };
    }
    
    private boolean isProductionEnvironment() {
        String[] activeProfiles = env.getActiveProfiles();
        return Arrays.asList(activeProfiles).contains("prod");
    }
}

// アプリケーション設定のバリデーション
@Configuration
public class AppConfig {
    
    @Value("${app.security.password-strength:10}")
    private int passwordStrength;
    
    @Value("${app.security.jwt.expiration:1800}")
    private int jwtExpiration;
    
    @Value("${app.security.allowed-origins}")
    private List<String> allowedOrigins;
    
    @PostConstruct
    public void validateSecurityConfig() {
        // パスワード強度のバリデーション（BCryptの強度）
        if (passwordStrength < 10 || passwordStrength > 16) {
            throw new IllegalStateException(
                "パスワード強度の設定が不適切です。10から16の間で設定してください。現在: " + passwordStrength);
        }
        
        // JWTトークン有効期限のバリデーション
        if (jwtExpiration > 3600) {
            throw new IllegalStateException(
                "JWT有効期限が長すぎます。1時間（3600秒）以内に設定してください。現在: " + jwtExpiration);
        }
        
        // 許可オリジンのバリデーション
        if (allowedOrigins == null || allowedOrigins.isEmpty()) {
            throw new IllegalStateException("許可オリジンが設定されていません");
        }
        
        for (String origin : allowedOrigins) {
            if (!origin.startsWith("https://") && !origin.equals("localhost")) {
                throw new IllegalStateException(
                    "安全でないオリジンが許可されています: " + origin + "。httpsのみを使用してください");
            }
        }
    }
}
```

### 2.6 A06:2021 – 脆弱で古いコンポーネント

#### 2.6.1 リスク概要

脆弱性を持つコンポーネント（ライブラリ、フレームワーク、その他のソフトウェアモジュール）を使用した場合、それらの脆弱性がアプリケーションにも影響する可能性がある。

#### 2.6.2 対策方針

以下の対策を実装する：

1. **依存関係の定期的な監査**：使用するすべてのライブラリの脆弱性を定期的に確認
2. **コンポーネントの最新化**：セキュリティパッチが当たった最新バージョンを使用
3. **依存関係の最小化**：必要最小限のライブラリのみを使用
4. **脆弱性スキャンの自動化**：CI/CDパイプラインに組み込む

#### 2.6.3 実装詳細

```xml
<!-- OWASP Dependency Check Pluginの設定例（pom.xml） -->
<plugin>
    <groupId>org.owasp</groupId>
    <artifactId>dependency-check-maven</artifactId>
    <version>7.4.4</version>
    <configuration>
        <failBuildOnCVSS>7</failBuildOnCVSS> <!-- CVSS 7以上の脆弱性でビルド失敗 -->
        <suppressionFiles>
            <suppressionFile>owasp-suppressions.xml</suppressionFile>
        </suppressionFiles>
    </configuration>
    <executions>
        <execution>
            <goals>
                <goal>check</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

CI/CDパイプラインでの脆弱性スキャン設定例（GitHub Actions）：

```yaml
# GitHub Actionsワークフロー例
name: Security Scan

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 0 * * 0' # 毎週日曜日に実行

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: '21'
          distribution: 'temurin'
          
      - name: Run OWASP Dependency Check
        run: mvn org.owasp:dependency-check-maven:check
      
      - name: Run SpotBugs
        run: mvn com.github.spotbugs:spotbugs-maven-plugin:check
      
      - name: Run SonarQube Analysis
        run: mvn sonar:sonar -Dsonar.projectKey=ses-system -Dsonar.host.url=${{ secrets.SONAR_URL }} -Dsonar.login=${{ secrets.SONAR_TOKEN }}
```

ライブラリ管理とバージョン統一のためのBOM（Bill of Materials）例：

```xml
<!-- pom.xml -->
<dependencyManagement>
    <dependencies>
        <!-- Spring Boot BOM -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>3.2.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        
        <!-- 自社定義のセキュアコンポーネントBOM -->
        <dependency>
            <groupId>jp.co.example</groupId>
            <artifactId>secure-components-bom</artifactId>
            <version>1.0.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

### 2.7 A07:2021 – 識別と認証の失敗

#### 2.7.1 リスク概要

ユーザー認証や識別に関する機能が不適切に実装されている場合、アカウント乗っ取りやなりすましなどのリスクが高まる。

#### 2.7.2 対策方針

以下の対策を実装する：

1. **多要素認証**：ユーザー認証の強化
2. **強力なパスワードポリシー**：強力なパスワードの強制
3. **アカウントロックアウト**：ブルートフォース攻撃の緩和
4. **安全なパスワード保存**：BCryptなどの強力なハッシュアルゴリズムの使用

#### 2.7.3 実装詳細

詳細は[認証認可設計](/docs/03_詳細設計/05_セキュリティ/02_認証認可設計.md)を参照。主要な実装方針は以下の通り：

```java
// パスワード強度バリデーション
@Component
public class PasswordValidator {
    
    private static final String PASSWORD_PATTERN = 
        "^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=!])(?=\\S+$).{10,}$";
    
    private static final Pattern pattern = Pattern.compile(PASSWORD_PATTERN);
    
    public boolean isValid(String password) {
        if (password == null) {
            return false;
        }
        
        Matcher matcher = pattern.matcher(password);
        return matcher.matches();
    }
    
    public List<String> getValidationErrors(String password) {
        List<String> errors = new ArrayList<>();
        
        if (password == null || password.length() < 10) {
            errors.add("パスワードは10文字以上である必要があります");
        }
        
        if (password != null) {
            if (!password.matches(".*[0-9].*")) {
                errors.add("パスワードは少なくとも1つの数字を含む必要があります");
            }
            
            if (!password.matches(".*[a-z].*")) {
                errors.add("パスワードは少なくとも1つの小文字を含む必要があります");
            }
            
            if (!password.matches(".*[A-Z].*")) {
                errors.add("パスワードは少なくとも1つの大文字を含む必要があります");
            }
            
            if (!password.matches(".*[@#$%^&+=!].*")) {
                errors.add("パスワードは少なくとも1つの特殊文字を含む必要があります");
            }
            
            if (password.matches(".*\\s.*")) {
                errors.add("パスワードに空白文字を含めることはできません");
            }
        }
        
        return errors;
    }
}

// ログイン試行の制限とアカウントロックアウト
@Service
public class LoginAttemptService {
    
    private final int MAX_ATTEMPT = 5;
    private final int LOCK_TIME_MINUTES = 30;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private AuditLogService auditLogService;
    
    public void loginSucceeded(String username) {
        User user = userRepository.findByUsername(username).orElse(null);
        if (user != null) {
            user.setFailedLoginAttempts(0);
            user.setLastLoginTime(new Date());
            userRepository.save(user);
        }
    }
    
    public void loginFailed(String username) {
        User user = userRepository.findByUsername(username).orElse(null);
        if (user != null) {
            int attempts = user.getFailedLoginAttempts() + 1;
            user.setFailedLoginAttempts(attempts);
            
            if (attempts >= MAX_ATTEMPT) {
                lockAccount(user);
            }
            
            userRepository.save(user);
        }
    }
    
    private void lockAccount(User user) {
        user.setAccountLocked(true);
        user.setLockTime(new Date());
        
        // 監査ログに記録
        auditLogService.logSecurityEvent("ACCOUNT_LOCKED", 
                                       user.getUsername(),
                                       "連続ログイン失敗によるアカウントロック");
    }
    
    public boolean isAccountLocked(String username) {
        User user = userRepository.findByUsername(username).orElse(null);
        if (user != null && user.isAccountLocked()) {
            // ロック時間をチェック
            Date lockTime = user.getLockTime();
            Date now = new Date();
            
            long diffInMinutes = TimeUnit.MILLISECONDS.toMinutes(now.getTime() - lockTime.getTime());
            
            if (diffInMinutes >= LOCK_TIME_MINUTES) {
                // ロック時間が経過した場合はロック解除
                user.setAccountLocked(false);
                user.setFailedLoginAttempts(0);
                user.setLockTime(null);
                userRepository.save(user);
                return false;
            }
            
            return true;
        }
        
        return false;
    }
}

// 多要素認証の実装
@Service
public class TotpService {
    
    private static final int CODE_DIGITS = 6;
    private static final int TIME_STEP_SECONDS = 30;
    
    // ユーザーごとのTOTPシークレットを生成
    public String generateTotpSecret() {
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[20];
        random.nextBytes(bytes);
        return Base32.encode(bytes);
    }
    
    // TOTPコードの検証
    public boolean verifyCode(String secret, String code) {
        if (StringUtils.isBlank(secret) || StringUtils.isBlank(code)) {
            return false;
        }
        
        Base32 base32 = new Base32();
        byte[] bytes = base32.decode(secret);
        
        try {
            int timeWindowSize = 2; // 前後のウィンドウもチェック
            
            // 現在の30秒間隔の値
            long timeIndex = System.currentTimeMillis() / 1000L / TIME_STEP_SECONDS;
            
            // 前後のタイムウィンドウも含めて検証
            for (int i = -timeWindowSize; i <= timeWindowSize; i++) {
                String expectedCode = generateCode(bytes, timeIndex + i);
                if (expectedCode.equals(code)) {
                    return true;
                }
            }
            
            return false;
        } catch (Exception e) {
            return false;
        }
    }
    
    // 指定されたタイムインデックスに対するコードを生成
    private String generateCode(byte[] key, long timeIndex) throws NoSuchAlgorithmException, InvalidKeyException {
        // HMAC-SHA1アルゴリズムを使用
        Mac mac = Mac.getInstance("HmacSHA1");
        SecretKeySpec keySpec = new SecretKeySpec(key, "HmacSHA1");
        mac.init(keySpec);
        
        // タイムインデックスをバイト配列に変換
        byte[] timeBytes = ByteBuffer.allocate(8).putLong(timeIndex).array();
        
        // HMACを計算
        byte[] hash = mac.doFinal(timeBytes);
        
        // 動的切り捨てを実行
        int offset = hash[hash.length - 1] & 0xf;
        int binary =
            ((hash[offset] & 0x7f) << 24) |
            ((hash[offset + 1] & 0xff) << 16) |
            ((hash[offset + 2] & 0xff) << 8) |
            (hash[offset + 3] & 0xff);
        
        // 指定桁数のコードを生成
        int otp = binary % (int) Math.pow(10, CODE_DIGITS);
        
        // 桁数を揃える
        return String.format("%0" + CODE_DIGITS + "d", otp);
    }
}
```

### 2.8 A08:2021 – ソフトウェアとデータの整合性の不具合

#### 2.8.1 リスク概要

整合性のチェックが不十分な場合、信頼できないソースからのソフトウェアやデータの使用によって、悪意のあるコードやデータがシステムに取り込まれる可能性がある。

#### 2.8.2 対策方針

以下の対策を実装する：

1. **デジタル署名の検証**：使用するライブラリやコードの署名を検証
2. **信頼できるソースからの取得**：公式リポジトリのみを使用
3. **CI/CDパイプラインのセキュリティ強化**：コード検証とセキュリティスキャンの実施
4. **整合性チェックの自動化**：チェックサムやハッシュの検証

#### 2.8.3 実装詳細

```java
// ファイルの整合性検証
@Service
public class FileIntegrityService {
    
    public boolean verifyFileIntegrity(String filePath, String expectedHash) throws IOException {
        // ファイルのハッシュ値を計算
        String actualHash = calculateFileHash(filePath);
        
        // 期待されるハッシュ値と比較
        return expectedHash.equalsIgnoreCase(actualHash);
    }
    
    public String calculateFileHash(String filePath) throws IOException {
        // SHA-256ハッシュを計算
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        try (InputStream is = new FileInputStream(filePath)) {
            byte[] buffer = new byte[8192];
            int read;
            while ((read = is.read(buffer)) > 0) {
                digest.update(buffer, 0, read);
            }
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("SHA-256アルゴリズムが利用できません", e);
        }
        
        // ハッシュ値を16進数文字列に変換
        byte[] hash = digest.digest();
        StringBuilder hexString = new StringBuilder();
        for (byte b : hash) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }
        return hexString.toString();
    }
}

// JSONデータの整合性検証
@Component
public class JsonIntegrityValidator {
    
    private final ObjectMapper objectMapper;
    
    public JsonIntegrityValidator() {
        this.objectMapper = new ObjectMapper();
    }
    
    public <T> T validateAndDeserialize(String json, Class<T> targetType, String signature, 
                                        PublicKey publicKey) throws Exception {
        // 署名の検証
        if (!verifySignature(json, signature, publicKey)) {
            throw new SecurityException("JSONデータの署名が無効です");
        }
        
        // スキーマ検証（例：JSON Schema）
        JsonSchemaFactory factory = JsonSchemaFactory.byDefault();
        JsonSchema schema = factory.getJsonSchema("schema/my-schema.json");
        
        JsonNode jsonNode = objectMapper.readTree(json);
        ProcessingReport report = schema.validate(jsonNode);
        
        if (!report.isSuccess()) {
            throw new ValidationException("JSONデータがスキーマに適合しません: " + report);
        }
        
        // デシリアライズ
        return objectMapper.readValue(json, targetType);
    }
    
    private boolean verifySignature(String data, String signature, PublicKey publicKey) {
        try {
            Signature sig = Signature.getInstance("SHA256withRSA");
            sig.initVerify(publicKey);
            sig.update(data.getBytes());
            return sig.verify(Base64.getDecoder().decode(signature));
        } catch (Exception e) {
            return false;
        }
    }
}
```

Maven設定での整合性チェック：

```xml
<!-- Maven Enforcer Pluginを使用した整合性検証 -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-enforcer-plugin</artifactId>
    <version>3.2.1</version>
    <executions>
        <execution>
            <id>enforce</id>
            <goals>
                <goal>enforce</goal>
            </goals>
            <configuration>
                <rules>
                    <!-- バナー付きプラグインを禁止 -->
                    <bannedPlugins>
                        <excludes>
                            <exclude>org.codehaus.mojo:findbugs-maven-plugin</exclude>
                        </excludes>
                    </bannedPlugins>
                    
                    <!-- 依存関係の収束を確認 -->
                    <dependencyConvergence/>
                    
                    <!-- 重複クラスの検出 -->
                    <banDuplicateClasses>
                        <ignoreClasses>
                            <ignoreClass>module-info</ignoreClass>
                        </ignoreClasses>
                    </banDuplicateClasses>
                </rules>
            </configuration>
        </execution>
    </executions>
</plugin>
```

### 2.9 A09:2021 – セキュリティログとモニタリングの不備

#### 2.9.1 リスク概要

適切なログ記録やモニタリングがない場合、攻撃を検出できず、侵害が長期間にわたって気付かれない可能性がある。

#### 2.9.2 対策方針

以下の対策を実装する：

1. **セキュリティイベントのログ記録**：認証、認可、データアクセスなどのイベントを記録
2. **ログの改ざん防止**：ログの完全性確保
3. **アラートの設定**：異常パターンの検出と通知
4. **ログの一元管理**：集中管理によるモニタリングと分析

#### 2.9.3 実装詳細

詳細は[監査ログ設計](/docs/03_詳細設計/05_セキュリティ/05_監査ログ設計_01_概要.md)を参照。主要な実装方針は以下の通り：

```java
// セキュリティイベントのログ記録
@Service
public class AuditLogServiceImpl implements AuditLogService {
    
    @Autowired
    private AuditEventRepository auditEventRepository;
    
    @Autowired
    private HttpServletRequest request;
    
    @Override
    public void logSecurityEvent(String eventType, String subjectId, String details) {
        AuditEvent event = new AuditEvent();
        event.setEventId(UUID.randomUUID().toString());
        event.setTimestamp(new Date());
        event.setEventType(eventType);
        event.setSeverity(determineSeverity(eventType));
        event.setSubjectType("USER");
        event.setSubjectId(subjectId);
        
        // リクエスト情報を取得
        if (request != null) {
            event.setClientIp(getClientIp(request));
            event.setUserAgent(request.getHeader("User-Agent"));
            event.setRequestUri(request.getRequestURI());
            event.setSessionId(request.getSession(false) != null ? 
                             request.getSession().getId() : null);
        }
        
        event.setDetails(details);
        
        // 保存
        auditEventRepository.save(event);
        
        // 重大なイベントの場合はアラート
        if ("CRITICAL".equals(event.getSeverity())) {
            alertService.sendSecurityAlert(event);
        }
    }
    
    private String determineSeverity(String eventType) {
        // イベントタイプに基づいて重要度を決定
        switch (eventType) {
            case "AUTH_FAILED":
            case "ACCESS_DENIED":
                return "WARNING";
            case "ACCOUNT_LOCKED":
            case "PERMISSION_CHANGE":
            case "SENSITIVE_DATA_ACCESS":
                return "CRITICAL";
            default:
                return "INFO";
        }
    }
    
    private String getClientIp(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }
        return request.getRemoteAddr();
    }
}

// AOPを使用した監査ログの自動記録
@Aspect
@Component
public class AuditLogAspect {
    
    @Autowired
    private AuditLogService auditLogService;
    
    @Around("@annotation(Audited)")
    public Object logAuditedOperation(ProceedingJoinPoint joinPoint) throws Throwable {
        // メソッド名とクラス名を取得
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getSimpleName();
        
        // 監査対象メソッドの引数を取得
        Object[] args = joinPoint.getArgs();
        String argsStr = Arrays.toString(args);
        
        // 操作前の監査ログ
        auditLogService.logSecurityEvent(
            "OPERATION_START",
            SecurityUtils.getCurrentUsername(),
            className + "." + methodName + " 開始: " + argsStr
        );
        
        Object result;
        try {
            // メソッド実行
            result = joinPoint.proceed();
            
            // 成功時の監査ログ
            auditLogService.logSecurityEvent(
                "OPERATION_SUCCESS",
                SecurityUtils.getCurrentUsername(),
                className + "." + methodName + " 成功"
            );
            
            return result;
        } catch (Exception e) {
            // 失敗時の監査ログ
            auditLogService.logSecurityEvent(
                "OPERATION_FAILURE",
                SecurityUtils.getCurrentUsername(),
                className + "." + methodName + " 失敗: " + e.getMessage()
            );
            
            throw e;
        }
    }
}
```

### 2.10 A10:2021 – サーバーサイドリクエストフォージェリ (SSRF)

#### 2.10.1 リスク概要

サーバー側でのURLフェッチやリソースアクセスを外部から制御できる場合、内部ネットワークやシステムへの不正アクセスが可能になる可能性がある。

#### 2.10.2 対策方針

以下の対策を実装する：

1. **URLホワイトリスト**：許可されたドメインやIPアドレスのみにアクセスを制限
2. **内部ネットワークへのアクセス禁止**：プライベートIPアドレス範囲へのアクセスを禁止
3. **リダイレクト制限**：許可されていないリダイレクト先へのフォローを制限
4. **レスポンス制限**：サーバーからクライアントへ返すレスポンスを制限

#### 2.10.3 実装詳細

```java
// SSRFを防止するURLバリデーションユーティリティ
@Component
public class UrlValidator {
    
    // 許可されたドメインのリスト
    @Value("#{'${app.security.allowed-domains}'.split(',')}")
    private List<String> allowedDomains;
    
    // プライベートIPアドレス範囲のパターン
    private static final Pattern PRIVATE_IP_PATTERN = Pattern.compile(
        "^(127\\.|10\\.|172\\.1[6-9]\\.|172\\.2[0-9]\\.|172\\.3[0-1]\\.|192\\.168\\.|0\\.|::1|[fF][cCdD])"
    );
    
    /**
     * URLが安全かどうかを検証
     */
    public boolean isUrlSafe(String url) {
        if (StringUtils.isBlank(url)) {
            return false;
        }
        
        try {
            // URLの解析
            URL parsedUrl = new URL(url);
            String host = parsedUrl.getHost();
            
            // プロトコルのチェック
            if (!parsedUrl.getProtocol().equals("https")) {
                return false;
            }
            
            // ホスト名のチェック
            if (isPrivateIP(host)) {
                return false;
            }
            
            // ドメインのチェック
            return isAllowedDomain(host);
            
        } catch (MalformedURLException e) {
            return false;
        }
    }
    
    /**
     * プライベートIPアドレスかどうかを判定
     */
    private boolean isPrivateIP(String host) {
        if (host == null) {
            return true;
        }
        
        // IPアドレスに解決
        try {
            InetAddress addr = InetAddress.getByName(host);
            
            // ループバックアドレスをチェック
            if (addr.isLoopbackAddress()) {
                return true;
            }
            
            // プライベートIPパターンのチェック
            String ipStr = addr.getHostAddress();
            if (PRIVATE_IP_PATTERN.matcher(ipStr).find()) {
                return true;
            }
            
            // リンクローカルアドレスをチェック
            if (addr.isLinkLocalAddress() || addr.isSiteLocalAddress()) {
                return true;
            }
            
            return false;
        } catch (UnknownHostException e) {
            // 名前解決できない場合は安全でないと判断
            return true;
        }
    }
    
    /**
     * 許可されたドメインかどうかを判定
     */
    private boolean isAllowedDomain(String host) {
        if (host == null) {
            return false;
        }
        
        // 許可ドメインリストとの照合
        for (String domain : allowedDomains) {
            if (host.equals(domain) || host.endsWith("." + domain)) {
                return true;
            }
        }
        
        return false;
    }
}

// 外部リソース取得の安全な実装
@Service
public class ExternalResourceService {
    
    @Autowired
    private UrlValidator urlValidator;
    
    @Autowired
    private RestTemplate restTemplate;
    
    /**
     * 安全な外部リソース取得
     */
    public String fetchExternalResource(String url) {
        // URLの検証
        if (!urlValidator.isUrlSafe(url)) {
            throw new SecurityException("安全でないURLへのアクセスは許可されていません: " + url);
        }
        
        // 監査ログに記録
        auditLogService.logSecurityEvent("EXTERNAL_RESOURCE_ACCESS", 
                                       SecurityUtils.getCurrentUsername(),
                                       "外部リソースアクセス: " + url);
        
        // リソース取得
        try {
            ResponseEntity<String> response = restTemplate.getForEntity(url, String.class);
            
            // レスポンスコードのチェック
            if (response.getStatusCode().is3xxRedirection()) {
                throw new SecurityException("リダイレクトは許可されていません");
            }
            
            return response.getBody();
        } catch (RestClientException e) {
            throw new ServiceException("外部リソースの取得に失敗しました: " + e.getMessage(), e);
        }
    }
}
```

## 3. 脆弱性スキャンと自動化

### 3.1 静的解析（SAST）

#### 3.1.1 使用ツール

- SonarQube
- SpotBugs
- PMD
- FindSecBugs（Javaセキュリティ特化）

#### 3.1.2 実装方針

CI/CDパイプラインに組み込み、自動的に静的解析を実行する：

```yaml
# CI/CDパイプラインでのSASTの例（GitHub Actions）
name: SAST

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  sast:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: '21'
          distribution: 'temurin'
          
      - name: Run SpotBugs with FindSecBugs
        run: mvn com.github.spotbugs:spotbugs-maven-plugin:4.7.3.0:check
        
      - name: Run PMD Analysis
        run: mvn pmd:pmd
        
      - name: Run SonarQube Analysis
        run: mvn sonar:sonar -Dsonar.projectKey=ses-system -Dsonar.host.url=${{ secrets.SONAR_URL }} -Dsonar.login=${{ secrets.SONAR_TOKEN }}
```

### 3.2 動的解析（DAST）

#### 3.2.1 使用ツール

- OWASP ZAP
- Burp Suite（商用ライセンス）

#### 3.2.2 実装方針

テスト環境にデプロイ後、自動的に動的解析を実行する：

```yaml
# CI/CDパイプラインでのDASTの例（GitHub Actions）
name: DAST

on:
  workflow_run:
    workflows: ["Deploy to Test"]
    types:
      - completed

jobs:
  dast:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: ZAP Scan
        uses: zaproxy/action-baseline@v0.9.0
        with:
          target: 'https://test-env.example.com'
          rules_file_name: 'zap-rules.tsv'
          cmd_options: '-a'
```

### 3.3 依存関係チェック

#### 3.3.1 使用ツール

- OWASP Dependency Check
- Snyk
- GitHub Dependabot

#### 3.3.2 実装方針

定期的に依存関係の脆弱性をチェックし、更新を自動化する：

```yaml
# GitHub Dependabotの設定例（.github/dependabot.yml）
version: 2
updates:
  - package-ecosystem: "maven"
    directory: "/"
    schedule:
      interval: "daily"
    open-pull-requests-limit: 10
    labels:
      - "dependencies"
      - "security"
    commit-message:
      prefix: "chore"
      include: "scope"
```

## 4. 脆弱性対応プロセス

### 4.1 脆弱性スコアリング

脆弱性の評価にはCVSS（Common Vulnerability Scoring System）を採用し、以下の基準でスコアリングを行う：

| CVSS スコア | 重大度 | 対応期限 |
|------------|-------|---------|
| 9.0 - 10.0 | 緊急 | 即時（24時間以内） |
| 7.0 - 8.9 | 高 | 3日以内 |
| 4.0 - 6.9 | 中 | 2週間以内 |
| 0.1 - 3.9 | 低 | 1ヶ月以内 |

### 4.2 脆弱性対応ワークフロー

1. **検出**：自動スキャンや手動テストによる脆弱性の検出
2. **評価**：CVSSによる重大度評価と対応優先度の決定
3. **修正**：脆弱性の根本原因の分析と修正
4. **テスト**：修正の有効性を確認するテスト
5. **リリース**：修正内容の本番環境へのリリース
6. **検証**：本番環境での最終確認

### 4.3 セキュリティパッチ管理

セキュリティパッチの適用プロセス：

1. **定期的なスキャン**：週次で脆弱性スキャンを実施
2. **パッチ評価**：パッチの影響範囲と副作用を評価
3. **テスト環境での検証**：パッチ適用後の動作確認
4. **本番適用計画**：計画的なパッチ適用スケジュールの策定
5. **適用実施**：メンテナンス時間内でのパッチ適用
6. **結果確認**：適用後の動作確認とログ監視

## 5. 参照情報

- [OWASP Top 10 - 2021](https://owasp.org/Top10/)
- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)
- [Spring Security Documentation](https://docs.spring.io/spring-security/reference/index.html)
- [NIST Secure Software Development Framework (SSDF)](https://csrc.nist.gov/Projects/ssdf)
- [Mozilla Web Security Guidelines](https://infosec.mozilla.org/guidelines/web_security)