# SES業務システム 標準設計パターン

## 1. 概要

本ドキュメントでは、SES業務システムの開発で採用する標準的な設計パターンと実装方針を定義します。これにより、コードの一貫性、保守性、拡張性を向上させることを目的としています。

## 2. アーキテクチャパターン

### 2.1 レイヤードアーキテクチャ

SES業務システムは、明確に分離された責務を持つ4つの主要レイヤーで構成されます。

```
┌───────────────────┐
│  Presentation     │ ← ユーザーインターフェース、API
├───────────────────┤
│  Application      │ ← ユースケース実装、トランザクション制御
├───────────────────┤
│  Domain           │ ← ビジネスルール、ドメインモデル
├───────────────────┤
│  Infrastructure   │ ← データアクセス、外部システム連携
└───────────────────┘
```

#### 2.1.1 Presentationレイヤー
- **責務**: ユーザーリクエストの受付、レスポンス生成、入力検証
- **主要コンポーネント**: Controller、ViewModel、Validator
- **実装方針**:
  ```java
  @RestController
  @RequestMapping("/api/v1/engineers")
  public class EngineerController {
      private final EngineerService engineerService;
      
      @GetMapping("/{id}")
      public ResponseEntity<EngineerResponse> getEngineer(@PathVariable Long id) {
          EngineerResponse engineer = engineerService.findById(id);
          return ResponseEntity.ok(engineer);
      }
      
      @PostMapping
      public ResponseEntity<EngineerResponse> createEngineer(
              @Valid @RequestBody CreateEngineerRequest request) {
          EngineerResponse created = engineerService.create(request);
          URI location = ServletUriComponentsBuilder.fromCurrentRequest()
              .path("/{id}").buildAndExpand(created.getId()).toUri();
          return ResponseEntity.created(location).body(created);
      }
      
      // 他のエンドポイント...
  }
  ```

#### 2.1.2 Applicationレイヤー
- **責務**: ユースケースの実装、トランザクション境界、認可、イベント発行
- **主要コンポーネント**: Service、UseCase、Assembler/Mapper
- **実装方針**:
  ```java
  @Service
  @Transactional
  public class EngineerServiceImpl implements EngineerService {
      private final EngineerRepository engineerRepository;
      private final EngineerMapper engineerMapper;
      private final ApplicationEventPublisher eventPublisher;
      
      @Override
      @Transactional(readOnly = true)
      public EngineerResponse findById(Long id) {
          Engineer engineer = engineerRepository.findById(id)
              .orElseThrow(() -> new ResourceNotFoundException("Engineer not found"));
          return engineerMapper.toResponse(engineer);
      }
      
      @Override
      public EngineerResponse create(CreateEngineerRequest request) {
          // ビジネスルールの検証
          if (engineerRepository.existsByEmail(request.getEmail())) {
              throw new BusinessException("Engineer with this email already exists");
          }
          
          // エンティティ作成とマッピング
          Engineer engineer = engineerMapper.toEntity(request);
          
          // 保存
          Engineer saved = engineerRepository.save(engineer);
          
          // イベント発行
          eventPublisher.publishEvent(new EngineerCreatedEvent(saved));
          
          return engineerMapper.toResponse(saved);
      }
      
      // 他のメソッド...
  }
  ```

#### 2.1.3 Domainレイヤー
- **責務**: ビジネスルールの実装、ドメインモデル定義
- **主要コンポーネント**: Entity、ValueObject、Repository（インターフェース）、Domain Service
- **実装方針**:
  ```java
  // エンティティ
  @Entity
  @Table(name = "engineers")
  public class Engineer {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      
      @NotBlank
      @Size(max = 100)
      private String firstName;
      
      @NotBlank
      @Size(max = 100)
      private String lastName;
      
      @Email
      @NotBlank
      @Column(unique = true)
      private String email;
      
      @Embedded
      private Address address;
      
      @Enumerated(EnumType.STRING)
      private EmploymentStatus employmentStatus;
      
      // スキルセットの追加（メソッド）
      public void addSkill(Skill skill) {
          // ビジネスルールを含むメソッド
      }
      
      // 稼働状況の更新（メソッド）
      public void updateAvailability(boolean isAvailable, LocalDate nextAvailableDate) {
          // ビジネスルールを含むメソッド
      }
      
      // Getter, Setter, etc.
  }
  
  // バリューオブジェクト
  @Embeddable
  public class Address {
      @NotBlank
      @Size(max = 100)
      private String postalCode;
      
      @NotBlank
      @Size(max = 200)
      private String prefecture;
      
      @NotBlank
      @Size(max = 200)
      private String city;
      
      @NotBlank
      @Size(max = 200)
      private String street;
      
      @Size(max = 200)
      private String building;
      
      // Getter, Setter, equals(), hashCode(), etc.
  }
  
  // リポジトリインターフェース
  public interface EngineerRepository {
      Optional<Engineer> findById(Long id);
      List<Engineer> findBySkills(List<String> skills);
      boolean existsByEmail(String email);
      Engineer save(Engineer engineer);
      void deleteById(Long id);
      // 他のクエリメソッド...
  }
  ```

#### 2.1.4 Infrastructureレイヤー
- **責務**: データアクセス実装、外部システム連携、技術的関心事の実装
- **主要コンポーネント**: RepositoryImpl、外部サービスAdapter、設定クラス
- **実装方針**:
  ```java
  // リポジトリ実装（Spring Data JDBC使用）
  public interface EngineerJdbcRepository extends CrudRepository<Engineer, Long>, 
                                                 EngineerRepository {
      @Query("SELECT * FROM engineers e WHERE e.email = :email")
      Optional<Engineer> findByEmail(String email);
      
      @Override
      default boolean existsByEmail(String email) {
          return findByEmail(email).isPresent();
      }
      
      // デフォルト実装やカスタムクエリ...
  }
  
  // 外部サービスアダプター
  @Service
  public class EmailNotificationAdapter implements NotificationService {
      private final EmailClient emailClient;
      
      @Override
      public void sendNotification(String recipient, String subject, String content) {
          EmailRequest request = new EmailRequest(recipient, subject, content);
          emailClient.sendEmail(request);
      }
  }
  ```

### 2.2 クリーンアーキテクチャの要素適用

レイヤードアーキテクチャをベースとしながら、以下のクリーンアーキテクチャの原則を採用します：

- **依存関係の方向**: 内側のレイヤー（ドメイン）は外側のレイヤーに依存しない
- **インターフェース分離**: 外部システムとの連携はインターフェースを介して行う
- **ユースケース中心**: 業務ロジックはユースケースとして明示的に定義

```
外側レイヤー → 内側レイヤー（依存の方向）
Infrastructure → Domain ← Application ← Presentation
```

## 3. デザインパターン

### 3.1 DTO（Data Transfer Object）パターン

- **用途**: レイヤー間のデータ転送、外部APIとのインターフェース
- **実装方針**:
  - Request/Response DTOのペアで実装
  - Lombokを活用した簡潔な実装
  - バリデーション制約はDTOに定義

```java
// リクエストDTO
@Data
public class CreateEngineerRequest {
    @NotBlank
    @Size(max = 100)
    private String firstName;
    
    @NotBlank
    @Size(max = 100)
    private String lastName;
    
    @Email
    @NotBlank
    private String email;
    
    @NotNull
    private AddressDto address;
    
    @NotEmpty
    private List<String> skills;
    
    // ネストされたDTOクラス
    @Data
    public static class AddressDto {
        @NotBlank
        private String postalCode;
        
        @NotBlank
        private String prefecture;
        
        @NotBlank
        private String city;
        
        @NotBlank
        private String street;
        
        private String building;
    }
}

// レスポンスDTO
@Data
public class EngineerResponse {
    private Long id;
    private String firstName;
    private String lastName;
    private String email;
    private AddressDto address;
    private List<String> skills;
    private boolean available;
    private LocalDate nextAvailableDate;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // ネストされたDTOクラス
    @Data
    public static class AddressDto {
        private String postalCode;
        private String prefecture;
        private String city;
        private String street;
        private String building;
    }
}
```

### 3.2 Factory パターン

- **用途**: 複雑なオブジェクトの生成
- **実装方針**:
  - 複雑なビジネスエンティティの生成に使用
  - バリデーションロジックを集約

```java
@Component
public class EngineerFactory {
    public Engineer createEngineer(String firstName, String lastName, String email, Address address) {
        // バリデーションロジック
        if (firstName == null || firstName.isBlank()) {
            throw new IllegalArgumentException("First name cannot be empty");
        }
        
        // エンティティ作成
        Engineer engineer = new Engineer();
        engineer.setFirstName(firstName);
        engineer.setLastName(lastName);
        engineer.setEmail(email);
        engineer.setAddress(address);
        engineer.setEmploymentStatus(EmploymentStatus.ACTIVE);
        engineer.setAvailable(false);
        engineer.setCreatedAt(LocalDateTime.now());
        engineer.setUpdatedAt(LocalDateTime.now());
        
        return engineer;
    }
}
```

### 3.3 Mapper/Assembler パターン

- **用途**: オブジェクト間の変換（DTO ⇔ エンティティ）
- **実装方針**:
  - MapStructを使用した宣言的マッピング
  - 複雑なマッピングはカスタムメソッドで実装

```java
@Mapper(componentModel = "spring")
public interface EngineerMapper {
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    Engineer toEntity(CreateEngineerRequest request);
    
    EngineerResponse toResponse(Engineer engineer);
    
    // カスタムマッピング
    default List<String> skillsToStringList(Set<Skill> skills) {
        if (skills == null) {
            return Collections.emptyList();
        }
        return skills.stream()
            .map(Skill::getName)
            .collect(Collectors.toList());
    }
}
```

### 3.4 Repository パターン

- **用途**: データアクセスの抽象化
- **実装方針**:
  - ドメインレイヤーにインターフェースを定義
  - インフラレイヤーに実装を提供
  - Spring Data JDBCを活用

```java
// ドメインレイヤーのインターフェース
public interface EngineerRepository {
    Optional<Engineer> findById(Long id);
    List<Engineer> findByName(String name);
    Engineer save(Engineer engineer);
    void deleteById(Long id);
}

// インフラレイヤーの実装
@Repository
public class EngineerRepositoryImpl implements EngineerRepository {
    private final EngineerJdbcRepository jdbcRepository;
    
    @Override
    public Optional<Engineer> findById(Long id) {
        return jdbcRepository.findById(id);
    }
    
    @Override
    public List<Engineer> findByName(String name) {
        return jdbcRepository.findByFirstNameContainingOrLastNameContaining(name, name);
    }
    
    @Override
    public Engineer save(Engineer engineer) {
        return jdbcRepository.save(engineer);
    }
    
    @Override
    public void deleteById(Long id) {
        jdbcRepository.deleteById(id);
    }
}

// Spring Data JDBCリポジトリ
public interface EngineerJdbcRepository extends CrudRepository<Engineer, Long> {
    List<Engineer> findByFirstNameContainingOrLastNameContaining(String firstName, String lastName);
}
```

### 3.5 Service パターン

- **用途**: ビジネスロジックのカプセル化、トランザクション境界の定義
- **実装方針**:
  - インターフェースと実装の分離
  - 責務の明確化
  - トランザクション制御のアノテーション

```java
// サービスインターフェース
public interface EngineerService {
    EngineerResponse findById(Long id);
    List<EngineerResponse> findByName(String name);
    EngineerResponse create(CreateEngineerRequest request);
    EngineerResponse update(Long id, UpdateEngineerRequest request);
    void delete(Long id);
}

// サービス実装
@Service
@Transactional
public class EngineerServiceImpl implements EngineerService {
    private final EngineerRepository engineerRepository;
    private final EngineerMapper engineerMapper;
    
    @Override
    @Transactional(readOnly = true)
    public EngineerResponse findById(Long id) {
        Engineer engineer = engineerRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Engineer not found"));
        return engineerMapper.toResponse(engineer);
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<EngineerResponse> findByName(String name) {
        return engineerRepository.findByName(name).stream()
            .map(engineerMapper::toResponse)
            .collect(Collectors.toList());
    }
    
    @Override
    public EngineerResponse create(CreateEngineerRequest request) {
        Engineer engineer = engineerMapper.toEntity(request);
        Engineer saved = engineerRepository.save(engineer);
        return engineerMapper.toResponse(saved);
    }
    
    // 他のメソッド...
}
```

### 3.6 Strategy パターン

- **用途**: アルゴリズムの切り替え、条件に応じた処理の分岐
- **実装方針**:
  - 共通インターフェースの定義
  - バリエーションの実装
  - 適切な戦略の選択ロジック

```java
// 戦略インターフェース
public interface MatchingStrategy {
    List<Project> findMatchingProjects(Engineer engineer);
}

// 戦略実装
@Component
public class SkillBasedMatchingStrategy implements MatchingStrategy {
    private final ProjectRepository projectRepository;
    
    @Override
    public List<Project> findMatchingProjects(Engineer engineer) {
        Set<String> engineerSkills = engineer.getSkills().stream()
            .map(Skill::getName)
            .collect(Collectors.toSet());
        
        return projectRepository.findByRequiredSkillsIn(engineerSkills);
    }
}

@Component
public class LocationBasedMatchingStrategy implements MatchingStrategy {
    private final ProjectRepository projectRepository;
    
    @Override
    public List<Project> findMatchingProjects(Engineer engineer) {
        return projectRepository.findByLocation(engineer.getAddress().getPrefecture());
    }
}

// 戦略選択ロジック
@Service
public class MatchingService {
    private final Map<String, MatchingStrategy> strategies;
    
    public MatchingService(List<MatchingStrategy> strategyList) {
        strategies = strategyList.stream()
            .collect(Collectors.toMap(
                strategy -> strategy.getClass().getSimpleName(),
                strategy -> strategy
            ));
    }
    
    public List<Project> findMatches(Engineer engineer, String strategyName) {
        MatchingStrategy strategy = strategies.getOrDefault(
            strategyName,
            strategies.get("SkillBasedMatchingStrategy") // デフォルト戦略
        );
        
        return strategy.findMatchingProjects(engineer);
    }
}
```

### 3.7 Decorator パターン

- **用途**: 既存機能の拡張、横断的関心事の追加
- **実装方針**:
  - 共通インターフェースの実装
  - デコレートする機能の追加

```java
// 基本インターフェース
public interface NotificationService {
    void sendNotification(String recipient, String subject, String content);
}

// 基本実装
@Service
@Primary
public class EmailNotificationService implements NotificationService {
    private final JavaMailSender mailSender;
    
    @Override
    public void sendNotification(String recipient, String subject, String content) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(recipient);
        message.setSubject(subject);
        message.setText(content);
        mailSender.send(message);
    }
}

// デコレータ実装（ロギング追加）
@Service
public class LoggingNotificationDecorator implements NotificationService {
    private final NotificationService delegate;
    private final Logger logger = LoggerFactory.getLogger(LoggingNotificationDecorator.class);
    
    public LoggingNotificationDecorator(
            @Qualifier("emailNotificationService") NotificationService delegate) {
        this.delegate = delegate;
    }
    
    @Override
    public void sendNotification(String recipient, String subject, String content) {
        logger.info("Sending notification to {}: {}", recipient, subject);
        long startTime = System.currentTimeMillis();
        
        try {
            delegate.sendNotification(recipient, subject, content);
            logger.info("Notification sent successfully in {}ms", 
                    System.currentTimeMillis() - startTime);
        } catch (Exception e) {
            logger.error("Failed to send notification: {}", e.getMessage(), e);
            throw e;
        }
    }
}
```

### 3.8 Observer パターン（イベント駆動設計）

- **用途**: コンポーネント間の疎結合な連携、副作用の分離
- **実装方針**:
  - Spring ApplicationEventの活用
  - イベントクラスの定義
  - リスナーの実装

```java
// イベントクラス
@Getter
public class EngineerCreatedEvent extends ApplicationEvent {
    private final Engineer engineer;
    
    public EngineerCreatedEvent(Engineer engineer) {
        super(engineer);
        this.engineer = engineer;
    }
}

// イベント発行
@Service
public class EngineerServiceImpl implements EngineerService {
    private final EngineerRepository engineerRepository;
    private final ApplicationEventPublisher eventPublisher;
    
    @Override
    public EngineerResponse create(CreateEngineerRequest request) {
        Engineer engineer = engineerMapper.toEntity(request);
        Engineer saved = engineerRepository.save(engineer);
        
        // イベント発行
        eventPublisher.publishEvent(new EngineerCreatedEvent(saved));
        
        return engineerMapper.toResponse(saved);
    }
}

// イベントリスナー
@Component
public class EngineerEventListener {
    private final NotificationService notificationService;
    
    @EventListener
    public void handleEngineerCreated(EngineerCreatedEvent event) {
        Engineer engineer = event.getEngineer();
        
        // 通知処理
        notificationService.sendNotification(
            engineer.getEmail(),
            "Welcome to SES Manager",
            "Your account has been created successfully."
        );
    }
}
```

## 4. エラー処理パターン

### 4.1 例外階層

全てのビジネス例外は共通の基底クラスを継承し、適切な階層構造を持ちます。

```java
// 基底例外クラス
public abstract class BaseException extends RuntimeException {
    private final String errorCode;
    
    protected BaseException(String message, String errorCode) {
        super(message);
        this.errorCode = errorCode;
    }
    
    public String getErrorCode() {
        return errorCode;
    }
}

// ビジネス例外（業務ルール違反）
public class BusinessException extends BaseException {
    public BusinessException(String message) {
        super(message, "BUSINESS_ERROR");
    }
    
    public BusinessException(String message, String errorCode) {
        super(message, errorCode);
    }
}

// リソース未検出例外
public class ResourceNotFoundException extends BaseException {
    public ResourceNotFoundException(String message) {
        super(message, "RESOURCE_NOT_FOUND");
    }
}

// 認証例外
public class AuthenticationException extends BaseException {
    public AuthenticationException(String message) {
        super(message, "AUTHENTICATION_ERROR");
    }
}

// 認可例外
public class AuthorizationException extends BaseException {
    public AuthorizationException(String message) {
        super(message, "AUTHORIZATION_ERROR");
    }
}

// バリデーション例外
public class ValidationException extends BaseException {
    private final Map<String, String> errors;
    
    public ValidationException(String message, Map<String, String> errors) {
        super(message, "VALIDATION_ERROR");
        this.errors = errors;
    }
    
    public Map<String, String> getErrors() {
        return errors;
    }
}
```

### 4.2 グローバル例外ハンドラー

統一的な例外処理とエラーレスポンスを提供します。

```java
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    // API共通のエラーレスポンス形式
    @Data
    @AllArgsConstructor
    public static class ErrorResponse {
        private String errorCode;
        private String message;
        private int status;
        private LocalDateTime timestamp;
        private Map<String, String> errors;
        
        public ErrorResponse(String errorCode, String message, int status) {
            this(errorCode, message, status, LocalDateTime.now(), Collections.emptyMap());
        }
    }
    
    // リソース未検出例外
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFound(ResourceNotFoundException ex) {
        ErrorResponse error = new ErrorResponse(
            ex.getErrorCode(),
            ex.getMessage(),
            HttpStatus.NOT_FOUND.value()
        );
        log.warn("リソースが見つかりません: {}", ex.getMessage());
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }
    
    // ビジネス例外
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException ex) {
        ErrorResponse error = new ErrorResponse(
            ex.getErrorCode(),
            ex.getMessage(),
            HttpStatus.BAD_REQUEST.value()
        );
        log.warn("ビジネス例外が発生しました: {}", ex.getMessage());
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }
    
    // バリデーション例外（Spring標準）
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage())
        );
        
        ErrorResponse response = new ErrorResponse(
            "VALIDATION_ERROR",
            "入力値が不正です",
            HttpStatus.BAD_REQUEST.value(),
            LocalDateTime.now(),
            errors
        );
        
        log.warn("バリデーションエラーが発生しました: {}", errors);
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }
    
    // その他の例外ハンドラー
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleAllUncaughtException(Exception ex) {
        ErrorResponse error = new ErrorResponse(
            "SYSTEM_ERROR",
            "システムエラーが発生しました",
            HttpStatus.INTERNAL_SERVER_ERROR.value()
        );
        log.error("未処理の例外が発生しました: ", ex);
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

## 5. ビジネスルール実装パターン

### 5.1 ドメインサービス

複数のエンティティに跨るビジネスロジックはドメインサービスとして実装します。

```java
// ドメインサービスインターフェース
public interface MatchingDomainService {
    MatchingResult matchEngineerToProject(Engineer engineer, Project project);
    List<Project> findSuitableProjects(Engineer engineer);
}

// ドメインサービス実装
@Service
public class MatchingDomainServiceImpl implements MatchingDomainService {
    @Override
    public MatchingResult matchEngineerToProject(Engineer engineer, Project project) {
        // エンジニアと案件のマッチング判定ロジック
        int score = calculateMatchingScore(engineer, project);
        boolean isMatched = score >= 70; // 70点以上でマッチング
        
        return new MatchingResult(engineer, project, isMatched, score);
    }
    
    @Override
    public List<Project> findSuitableProjects(Engineer engineer) {
        // 適合案件検索ロジック
        // ...
    }
    
    private int calculateMatchingScore(Engineer engineer, Project project) {
        // スキルマッチング度（60%）
        int skillScore = calculateSkillMatchingScore(engineer, project);
        
        // 稼働可能時期マッチング（30%）
        int availabilityScore = calculateAvailabilityScore(engineer, project);
        
        // 地域マッチング（10%）
        int locationScore = calculateLocationScore(engineer, project);
        
        return (int)(skillScore * 0.6 + availabilityScore * 0.3 + locationScore * 0.1);
    }
    
    // 各スコア計算メソッド...
}

// 結果値オブジェクト
@Value
public class MatchingResult {
    Engineer engineer;
    Project project;
    boolean matched;
    int score;
}
```

### 5.2 仕様（Specification）パターン

複雑な条件判定ロジックは仕様（Specification）パターンを用いて実装します。

```java
// 仕様インターフェース
public interface Specification<T> {
    boolean isSatisfiedBy(T t);
}

// エンジニア検索条件の仕様実装
public class AvailableEngineerSpecification implements Specification<Engineer> {
    private final LocalDate startDate;
    private final LocalDate endDate;
    
    public AvailableEngineerSpecification(LocalDate startDate, LocalDate endDate) {
        this.startDate = startDate;
        this.endDate = endDate;
    }
    
    @Override
    public boolean isSatisfiedBy(Engineer engineer) {
        return engineer.isAvailable() && 
               (engineer.getNextAvailableDate() == null || 
                !engineer.getNextAvailableDate().isAfter(startDate));
    }
}

public class SkillMatchSpecification implements Specification<Engineer> {
    private final Set<String> requiredSkills;
    
    public SkillMatchSpecification(Set<String> requiredSkills) {
        this.requiredSkills = requiredSkills;
    }
    
    @Override
    public boolean isSatisfiedBy(Engineer engineer) {
        Set<String> engineerSkills = engineer.getSkills().stream()
            .map(Skill::getName)
            .collect(Collectors.toSet());
        
        return engineerSkills.containsAll(requiredSkills);
    }
}

// 仕様の組み合わせ
public class AndSpecification<T> implements Specification<T> {
    private final List<Specification<T>> specifications;
    
    @SafeVarargs
    public AndSpecification(Specification<T>... specifications) {
        this.specifications = Arrays.asList(specifications);
    }
    
    @Override
    public boolean isSatisfiedBy(T t) {
        return specifications.stream().allMatch(spec -> spec.isSatisfiedBy(t));
    }
}

// 仕様の使用例
@Service
public class EngineerSearchService {
    private final EngineerRepository engineerRepository;
    
    public List<Engineer> searchEngineers(EngineerSearchCriteria criteria) {
        // 仕様の組み立て
        Specification<Engineer> spec = new AndSpecification<>(
            new AvailableEngineerSpecification(criteria.getStartDate(), criteria.getEndDate()),
            new SkillMatchSpecification(criteria.getRequiredSkills())
        );
        
        // 検索結果のフィルタリング
        return engineerRepository.findAll().stream()
            .filter(spec::isSatisfiedBy)
            .collect(Collectors.toList());
    }
}
```

## 6. パフォーマンス最適化パターン

### 6.1 キャッシュパターン

頻繁にアクセスされ、更新頻度の低いデータはキャッシュを使用します。

```java
@Service
@CacheConfig(cacheNames = "engineers")
public class EngineerServiceImpl implements EngineerService {
    private final EngineerRepository engineerRepository;
    private final EngineerMapper engineerMapper;
    
    @Override
    @Transactional(readOnly = true)
    @Cacheable(key = "#id")
    public EngineerResponse findById(Long id) {
        return engineerRepository.findById(id)
            .map(engineerMapper::toResponse)
            .orElseThrow(() -> new ResourceNotFoundException("Engineer not found"));
    }
    
    @Override
    @CacheEvict(key = "#id")
    public EngineerResponse update(Long id, UpdateEngineerRequest request) {
        Engineer engineer = engineerRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Engineer not found"));
        
        // エンジニア情報の更新
        engineerMapper.updateEntityFromRequest(request, engineer);
        
        Engineer updated = engineerRepository.save(engineer);
        return engineerMapper.toResponse(updated);
    }
    
    @Override
    @CacheEvict(key = "#id")
    public void delete(Long id) {
        if (!engineerRepository.existsById(id)) {
            throw new ResourceNotFoundException("Engineer not found");
        }
        engineerRepository.deleteById(id);
    }
}
```

### 6.2 ページネーションパターン

大量のデータを返す可能性のあるAPIでは、ページネーションを必ず実装します。

```java
@RestController
@RequestMapping("/api/v1/engineers")
public class EngineerController {
    private final EngineerService engineerService;
    
    @GetMapping
    public ResponseEntity<Page<EngineerResponse>> getEngineers(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(required = false) String name,
            @RequestParam(required = false) List<String> skills) {
        
        EngineerSearchCriteria criteria = new EngineerSearchCriteria();
        criteria.setName(name);
        criteria.setSkills(skills);
        
        Page<EngineerResponse> engineers = engineerService.search(criteria, PageRequest.of(page, size));
        return ResponseEntity.ok(engineers);
    }
}

@Service
public class EngineerServiceImpl implements EngineerService {
    private final EngineerRepository engineerRepository;
    private final EngineerMapper engineerMapper;
    
    @Override
    @Transactional(readOnly = true)
    public Page<EngineerResponse> search(EngineerSearchCriteria criteria, Pageable pageable) {
        Page<Engineer> engineers;
        
        if (criteria.isEmpty()) {
            engineers = engineerRepository.findAll(pageable);
        } else {
            engineers = engineerRepository.search(
                criteria.getName(),
                criteria.getSkills(),
                criteria.getAvailableFrom(),
                pageable
            );
        }
        
        return engineers.map(engineerMapper::toResponse);
    }
}
```

## 7. セキュリティ実装パターン

### 7.1 認証・認可パターン

JWT認証とSpring Securityを組み合わせた認証・認可の実装パターンを採用します。

```java
// セキュリティ設定
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final JwtTokenProvider jwtTokenProvider;
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .authorizeHttpRequests(authorize -> authorize
                .requestMatchers("/api/v1/auth/**").permitAll()
                .requestMatchers("/api/v1/public/**").permitAll()
                .requestMatchers("/api/v1/admin/**").hasRole("ADMIN")
                .requestMatchers(HttpMethod.GET, "/api/v1/engineers/**").hasAnyRole("USER", "ADMIN")
                .requestMatchers(HttpMethod.POST, "/api/v1/engineers/**").hasRole("ADMIN")
                .requestMatchers(HttpMethod.PUT, "/api/v1/engineers/**").hasRole("ADMIN")
                .requestMatchers(HttpMethod.DELETE, "/api/v1/engineers/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .addFilterBefore(new JwtAuthenticationFilter(jwtTokenProvider), 
                UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    // その他のセキュリティ設定...
}

// メソッドレベルのセキュリティ
@Service
public class ProjectServiceImpl implements ProjectService {
    private final ProjectRepository projectRepository;
    
    @Override
    @PreAuthorize("hasRole('ADMIN') or @projectSecurityService.canViewProject(#id, authentication)")
    public ProjectResponse findById(Long id) {
        // プロジェクト取得ロジック
    }
    
    @Override
    @PreAuthorize("hasRole('ADMIN')")
    public ProjectResponse create(CreateProjectRequest request) {
        // プロジェクト作成ロジック
    }
}

// カスタムセキュリティチェック
@Service
public class ProjectSecurityService {
    private final ProjectRepository projectRepository;
    
    public boolean canViewProject(Long projectId, Authentication authentication) {
        // 認証情報から現在のユーザーを取得
        UserDetails userDetails = (UserDetails) authentication.getPrincipal();
        String username = userDetails.getUsername();
        
        // プロジェクトの参照権限をチェック
        return projectRepository.isUserAssignedToProject(username, projectId);
    }
}
```

## 8. 標準パターン適用ガイドライン

### 8.1 パターン選択基準

- **単純性**: 可能な限り単純な設計を選択
- **保守性**: コードの保守と変更が容易である
- **テスト容易性**: ユニットテストが書きやすい設計
- **一貫性**: プロジェクト全体で一貫したパターンの適用

### 8.2 アンチパターン

以下のパターンは避けるべきです：

- **God Object**: 責務の集中した巨大クラス
- **Anemic Domain Model**: 振る舞いを持たないドメインモデル
- **Excessive Layering**: 過剰なレイヤーによる複雑化
- **Premature Optimization**: 過度に早期の最適化
- **Magic Strings/Numbers**: コード中のハードコードされた値

### 8.3 コードレビュー観点

コードレビュー時は、以下の観点でパターンの適用を確認します：

- 単一責任の原則は守られているか
- 適切なレイヤーに実装されているか
- 標準パターンとの一貫性があるか
- 例外処理は適切か
- テストカバレッジは十分か

## 9. 参照情報

- [詳細設計：アーキテクチャ概要](/docs/03_詳細設計/01_アーキテクチャ/アーキテクチャ概要.md)
- [詳細設計：テクノロジースタック](/docs/03_詳細設計/01_アーキテクチャ/テクノロジースタック.md)
- [ADR-001: レイヤードアーキテクチャ採用](/docs/03_詳細設計/08_ADR/adr-001-レイヤードアーキテクチャ採用.md)
- [Spring Framework Documentation](https://docs.spring.io/spring-framework/docs/current/reference/html/)