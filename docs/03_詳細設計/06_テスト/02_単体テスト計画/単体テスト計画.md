# SES業務システム 単体テスト計画

## 1. はじめに

### 1.1 目的

本ドキュメントは、SES業務システムの単体テストに関する詳細な計画を定義する。単体テストの範囲、アプローチ、実施方法、責任分担、成功基準などを明確にし、品質の高いコンポーネントを確実に開発するための指針とする。

### 1.2 適用範囲

本単体テスト計画は、SES業務システムの全モジュールのクラス・メソッドレベルのテストに適用される。具体的な対象範囲は以下の通り：

- 認証・認可モジュール
- 技術者管理モジュール
- 案件管理モジュール
- マッチングモジュール
- 契約管理モジュール
- 勤怠工数管理モジュール
- 請求支払管理モジュール
- レポーティングモジュール
- 共通基盤モジュール

### 1.3 参照ドキュメント

- [テスト方針概要](/docs/03_詳細設計/06_テスト/01_テスト方針/テスト方針概要.md)
- [アーキテクチャ概要](/docs/03_詳細設計/01_アーキテクチャ/アーキテクチャ概要.md)
- [各モジュール詳細設計書](/docs/03_詳細設計/02_モジュール/)
- [コーディング規約とガイドライン](/docs/00_ガイドライン/詳細設計ガイドライン.md)

## 2. 単体テスト戦略

### 2.1 単体テストの定義と範囲

単体テストとは以下を対象とする最小粒度のテスト：

- 個々のクラスとそのパブリックメソッド
- インターフェース実装
- ユーティリティ関数
- 特定のビジネスロジック実装

外部依存（データベース、ファイルシステム、外部API等）は原則としてモック・スタブに置き換える。

### 2.2 テスト設計アプローチ

#### 2.2.1 テスト技法

以下のテスト技法を活用して単体テストを設計する：

- **同値分割**: 有効・無効なデータクラスに入力値を分類
- **境界値分析**: 境界条件（最小値、最大値、境界直前・直後）での動作確認
- **デシジョンテーブル**: 複雑な条件分岐の組み合わせを表形式でテスト
- **状態ベーステスト**: 状態を持つオブジェクトの状態遷移確認
- **例外テスト**: 異常系処理と例外スローの確認

#### 2.2.2 テストケース設計の原則

単体テストケース設計の基本原則：

1. **AAA (Arrange-Act-Assert)パターン**の適用
   - Arrange: テストの前提条件を設定
   - Act: テスト対象の処理を実行
   - Assert: 結果を検証

2. **FIRST原則**の遵守
   - Fast（高速）: テストは短時間で実行可能であること
   - Independent（独立）: テスト間の依存がないこと
   - Repeatable（再現性）: 何度実行しても同じ結果となること
   - Self-validating（自己検証）: 自動的に成功/失敗が判定できること
   - Timely（適時性）: コードと並行またはコード前に書かれること

3. **1テスト1アサート**の原則を基本とし、関連する検証は適切にグループ化

4. テスト名は「テスト対象\_条件\_期待結果」の形式で明確に記述

### 2.3 モックとスタブの使用方針

外部依存のモック/スタブ化方針：

- **データベース**: リポジトリ層をモック化
- **外部API**: HttpClient/RestTemplate等をモック化
- **ファイルシステム**: ファイル操作クラスをモック化
- **時間依存処理**: 時計・タイマーをモック化
- **認証**: SecurityContextやAuthenticationManagerをモック化

内部依存コンポーネントの取り扱い：
- 単純な機能の内部コンポーネントは実装をそのまま使用
- 複雑な依存関係を持つ内部コンポーネントはモック化

### 2.4 コードカバレッジ目標

以下のコードカバレッジ目標を設定：

| カバレッジ種別 | 目標値 | 優先度 |
|--------------|-------|-------|
| ライン（行）カバレッジ | 80%以上 | 最重要 |
| 分岐カバレッジ | 75%以上 | 重要 |
| 関数カバレッジ | 90%以上 | 重要 |
| クラスカバレッジ | 90%以上 | 重要 |

特に以下の領域は、より高いカバレッジ（90%以上）を目指す：
- 認証・認可関連機能
- 金銭計算ロジック
- データ変換・変換ロジック
- 入力検証ロジック
- 複雑なビジネスルール

### 2.5 テスト対象外範囲

以下は単体テストの対象外とする：

- 自動生成されたコード（Lombokアノテーションによるgetter/setter等）
- フレームワーク機能の動作確認（Spring Bootの設定動作等）
- GUIコンポーネント（Thymeleafテンプレート自体の検証）
- パブリックアクセサメソッド（特にロジックを含まない単純なもの）
- プライベートメソッド（パブリックAPIのテストを通じて間接的に検証）

## 3. テスト環境とツール

### 3.1 テストフレームワークとライブラリ

| ツール/ライブラリ | バージョン | 用途 |
|-----------------|-----------|-----|
| JUnit 5 (Jupiter) | 5.9.x | テスト実行フレームワーク |
| Mockito | 5.x | モック作成・検証 |
| AssertJ | 3.24.x | 読みやすいアサーション |
| JaCoCo | 0.8.x | コードカバレッジ測定 |
| TestContainers | 1.18.x | 統合テスト用のコンテナ管理 |
| JsonPath | 2.x | JSON検証 |
| XMLUnit | 2.x | XML検証 |
| Awaitility | 4.x | 非同期処理のテスト |
| ArchUnit | 1.0.x | アーキテクチャルールのテスト |

### 3.2 テスト実行環境

単体テストは以下の環境で実行：

1. **開発者ローカル環境**:
   - OS: Windows 10/11, macOS, Linux
   - JDK: Oracle JDK 21 または OpenJDK 21
   - メモリ: 最低8GB以上推奨
   - IDE: IntelliJ IDEA または Eclipse
   - ビルドツール: Maven 3.9.x

2. **CI環境** (GitHub Actions):
   - OS: Ubuntu最新LTS
   - JDK: OpenJDK 21
   - メモリ: 7GB (GitHub Actions標準)
   - ビルドツール: Maven 3.9.x

### 3.3 設定と構成

テスト実行のための主な設定：

1. **Maven設定**:
```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>3.1.2</version>
    <configuration>
        <includes>
            <include>**/*Test.java</include>
        </includes>
        <excludes>
            <exclude>**/*IntegrationTest.java</exclude>
            <exclude>**/*E2ETest.java</exclude>
        </excludes>
    </configuration>
</plugin>

<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.10</version>
    <executions>
        <execution>
            <goals>
                <goal>prepare-agent</goal>
            </goals>
        </execution>
        <execution>
            <id>report</id>
            <phase>test</phase>
            <goals>
                <goal>report</goal>
            </goals>
        </execution>
        <execution>
            <id>check</id>
            <goals>
                <goal>check</goal>
            </goals>
            <configuration>
                <rules>
                    <rule>
                        <element>BUNDLE</element>
                        <limits>
                            <limit>
                                <counter>LINE</counter>
                                <value>COVEREDRATIO</value>
                                <minimum>0.8</minimum>
                            </limit>
                        </limits>
                    </rule>
                </rules>
            </configuration>
        </execution>
    </executions>
</plugin>
```

2. **JUnit 5設定**:
```
junit.jupiter.execution.parallel.enabled = true
junit.jupiter.execution.parallel.mode.default = same_thread
junit.jupiter.execution.parallel.mode.classes.default = concurrent
```

3. **テストリソース管理**:
   - テストデータは`src/test/resources`に配置
   - 環境固有の設定は`application-test.properties`で管理
   - センシティブな情報はテストコードにハードコードしない

## 4. テスト実施

### 4.1 テストコード構成と命名規則

#### 4.1.1 ディレクトリ構造

```
src/
 ├── main/java/com/example/sesapp/
 │   ├── module1/
 │   ├── module2/
 │   └── ...
 └── test/
     ├── java/com/example/sesapp/
     │   ├── module1/
     │   │   ├── controller/
     │   │   ├── service/
     │   │   └── repository/
     │   ├── module2/
     │   │   └── ...
     │   └── common/
     │       └── testutil/  # テスト用ユーティリティ
     └── resources/
         ├── testdata/      # JSONやXMLのテストデータ
         ├── mockresponses/ # モックレスポンス
         └── application-test.properties
```

#### 4.1.2 命名規則

- テストクラス名: `<テスト対象クラス名>Test.java`
  - 例: `EngineerServiceTest.java`
- テストメソッド名: `should<期待される動作>_when<条件>`
  - 例: `shouldReturnEngineerList_whenSearchBySkill`
- モック/スタブクラス名: `Mock<クラス名>` or `<クラス名>Stub`
  - 例: `MockEngineerRepository`, `EngineerServiceStub`

#### 4.1.3 テストフィクスチャー管理

- テストデータ生成用のファクトリメソッドを作成
- `@BeforeEach` / `@BeforeAll`で共通の前提条件を設定
- 複数のテストで共有するオブジェクトは明示的に独立化

### 4.2 モック/スタブの実装例

```java
@ExtendWith(MockitoExtension.class)
class EngineerServiceTest {

    @Mock
    private EngineerRepository engineerRepository;
    
    @Mock
    private SkillRepository skillRepository;
    
    @InjectMocks
    private EngineerServiceImpl engineerService;
    
    @Test
    void shouldReturnEngineerList_whenSearchBySkill() {
        // Arrange
        List<Engineer> expectedEngineers = createTestEngineers(3);
        when(engineerRepository.findBySkillIds(any())).thenReturn(expectedEngineers);
        
        // Act
        List<EngineerDto> result = engineerService.searchBySkill(List.of("Java", "Spring"));
        
        // Assert
        assertThat(result).hasSize(3);
        verify(engineerRepository).findBySkillIds(any());
    }
    
    private List<Engineer> createTestEngineers(int count) {
        return IntStream.range(0, count)
            .mapToObj(i -> {
                Engineer engineer = new Engineer();
                engineer.setId((long) i);
                engineer.setName("Engineer " + i);
                return engineer;
            })
            .collect(Collectors.toList());
    }
}
```

### 4.3 例外ケースのテスト例

```java
@Test
void shouldThrowNotFoundException_whenEngineerNotExist() {
    // Arrange
    Long nonExistingId = 999L;
    when(engineerRepository.findById(nonExistingId)).thenReturn(Optional.empty());
    
    // Act & Assert
    assertThatThrownBy(() -> engineerService.getEngineerById(nonExistingId))
        .isInstanceOf(ResourceNotFoundException.class)
        .hasMessageContaining("Engineer not found");
    
    verify(engineerRepository).findById(nonExistingId);
}
```

### 4.4 ビジネスロジックテスト例

```java
@Test
void shouldCalculateCorrectBillingAmount_whenValidTimesheet() {
    // Arrange
    Timesheet timesheet = createTestTimesheet(8.0, 5); // 8時間 x 5日
    Engineer engineer = createTestEngineer(80000); // 月額単価80,000円
    Project project = createTestProject();
    
    when(timesheetRepository.findById(any())).thenReturn(Optional.of(timesheet));
    when(engineerRepository.findById(any())).thenReturn(Optional.of(engineer));
    when(projectRepository.findById(any())).thenReturn(Optional.of(project));
    
    // Act
    BillingDto result = billingService.calculateBilling(1L, 2L, 3L);
    
    // Assert
    // 8時間 x 5日 = 40時間, 月間160時間として計算
    // 80,000円 ÷ 160時間 = 500円/時
    // 500円 x 40時間 = 20,000円
    assertThat(result.getTotalAmount()).isEqualByComparingTo(new BigDecimal("20000"));
    assertThat(result.getHours()).isEqualTo(40.0);
    assertThat(result.getHourlyRate()).isEqualByComparingTo(new BigDecimal("500"));
}
```

### 4.5 パラメータ化テスト例

```java
@ParameterizedTest
@CsvSource({
    "80000, 20, 160, 10000", // 月額80,000円、20時間、月間想定160時間、予想10,000円
    "96000, 40, 160, 24000", // 月額96,000円、40時間、月間想定160時間、予想24,000円
    "100000, 15, 150, 10000" // 月額100,000円、15時間、月間想定150時間、予想10,000円
})
void shouldCalculateCorrectAmountForVariousRates(
        int monthlyRate, double hours, int totalHoursPerMonth, int expectedAmount) {
    
    // Arrange
    RateCalculator calculator = new RateCalculator(totalHoursPerMonth);
    
    // Act
    BigDecimal result = calculator.calculateAmount(new BigDecimal(monthlyRate), hours);
    
    // Assert
    assertThat(result).isEqualByComparingTo(new BigDecimal(expectedAmount));
}
```

## 5. レビューとバグ管理

### 5.1 コードレビュー基準

単体テストのコードレビューでは以下の観点を確認する：

1. **テストの構造と可読性**
   - AAA (Arrange-Act-Assert) パターンに従っているか
   - テストメソッド名は目的を明確に表しているか
   - テストケースが適切に独立しているか

2. **テストの網羅性**
   - 主要なケース・エッジケースがカバーされているか
   - 異常系（例外発生）のテストがあるか
   - 境界値がテストされているか

3. **アサーションの品質**
   - アサーションは具体的で明確か
   - 複数の検証がある場合、すべて必要か
   - 失敗時のメッセージは有用か

4. **モック/スタブの使用**
   - 外部依存が適切にモック化されているか
   - スタブ/モックの設定は意図通りか
   - 必要なモックのみ使用しているか

5. **保守性**
   - テストは実装詳細ではなく動作をテストしているか
   - テストデータの生成ロジックは再利用可能か
   - テストはシンプルで理解しやすいか

### 5.2 バグ対応プロセス

単体テスト中に発見されたバグの対応プロセス：

1. バグの再現と確認
2. 単体テストケースでバグを再現するテストを作成
3. 修正実装
4. テストで修正を検証
5. コードレビュー
6. マージ

### 5.3 テスト結果の報告

単体テストの結果報告には以下の情報を含める：

1. 実行したテスト数
2. 成功/失敗テスト数
3. テスト実行時間
4. コードカバレッジ指標（行、分岐、メソッド、クラス）
5. 未解決の問題点

## 6. モジュール別テスト戦略

### 6.1 認証・認可モジュール

#### 6.1.1 テスト重点領域
- JWTトークン生成・検証ロジック
- ロールベースアクセス制御
- 属性ベースアクセス制御
- パスワードポリシー検証
- 認証フロー

#### 6.1.2 特記事項
- セキュリティ関連の設定は実際の値ではなくテスト用設定を使用
- 秘密鍵やパスワードなどの機密情報はテストコードにハードコードしない
- Spring Securityのコンテキストを適切にモック化

### 6.2 技術者管理モジュール

#### 6.2.1 テスト重点領域
- 技術者情報のCRUD操作
- スキル検索ロジック
- 稼働状況管理ロジック
- スキルマッチングアルゴリズム

#### 6.2.2 特記事項
- 複雑な検索条件のテストケースを網羅
- 大量データ処理のパフォーマンス考慮

### 6.3 案件管理モジュール

#### 6.3.1 テスト重点領域
- 案件登録・更新ロジック
- 案件検索・フィルタリングロジック
- ステータス管理と状態遷移

#### 6.3.2 特記事項
- 案件状態遷移のバリデーションテストを重視
- 日付関連ロジックのエッジケースを確認

### 6.4 マッチングモジュール

#### 6.4.1 テスト重点領域
- マッチングアルゴリズム
- 技術者・案件のスコアリングロジック
- 優先順位付けロジック

#### 6.4.2 特記事項
- 様々なスキルセットでのマッチングテスト
- 境界条件の検証を重視

### 6.5 契約管理モジュール

#### 6.5.1 テスト重点領域
- 契約生成ロジック
- 電子署名検証
- 契約状態管理
- 契約書テンプレート処理

#### 6.5.2 特記事項
- 日付計算と契約期間の検証を重視
- 契約書生成処理の外部依存をモック化

### 6.6 勤怠工数管理モジュール

#### 6.6.1 テスト重点領域
- 勤怠入力検証ロジック
- 工数集計ロジック
- 承認フロー管理
- 稼働率計算

#### 6.6.2 特記事項
- 日付・時間計算の精度を重視
- 様々な勤務形態のテストケースを網羅

### 6.7 請求支払管理モジュール

#### 6.7.1 テスト重点領域
- 請求金額計算ロジック
- 消費税計算
- 支払処理フロー
- 入金管理ロジック

#### 6.7.2 特記事項
- 金額計算の精度と丸め処理を重視
- 請求書番号生成ロジックのテスト
- 消費税率変更への対応をテスト

### 6.8 レポーティングモジュール

#### 6.8.1 テスト重点領域
- データ集計ロジック
- KPI計算アルゴリズム
- グラフデータ生成処理

#### 6.8.2 特記事項
- 大量データでの集計処理テスト
- 日付範囲指定のエッジケースを検証

### 6.9 共通基盤モジュール

#### 6.9.1 テスト重点領域
- エラーハンドリング
- 入力検証ユーティリティ
- 日付・時間ユーティリティ
- ファイル操作ユーティリティ

#### 6.9.2 特記事項
- 再利用性の高いコンポーネントの徹底テスト
- 国際化対応の検証

## 7. 実施計画とスケジュール

### 7.1 実施スケジュール

単体テストは以下のスケジュールで実施する：

1. **開発中**: 機能実装と同時に単体テストを開発
2. **コードレビュー前**: カバレッジ基準を満たすことを確認
3. **継続的実行**: CIパイプラインでの自動実行
4. **リリース前**: 全単体テストの一括実行と最終確認

### 7.2 責任分担

| 役割 | 責任者 | 責任範囲 |
|-----|-------|---------|
| 開発者 | 各機能担当者 | 担当機能の単体テスト作成・実行 |
| テックリード | モジュールリード | テスト品質レビュー、テスト戦略調整 |
| QAエンジニア | QAチーム | テストカバレッジ分析、テスト品質評価 |
| DevOpsエンジニア | インフラチーム | CI環境でのテスト自動化、結果レポート |

## 8. 品質指標と成功基準

### 8.1 品質メトリクス

以下の指標で単体テストの品質を評価する：

| メトリクス | 説明 | 目標値 |
|----------|------|-------|
| テスト成功率 | 成功したテストの割合 | 100% |
| コードカバレッジ | テストでカバーされたコードの割合 | 80%以上 |
| テスト実行時間 | 全単体テストの実行にかかる時間 | 5分以内 |
| テスト密度 | 1000行のコードあたりのテスト数 | 最低25テスト |
| サイクロマティック複雑度カバレッジ | 複雑な条件分岐のカバレッジ | 75%以上 |

### 8.2 成功基準

単体テスト完了の判断基準：

1. すべての単体テストが成功していること
2. コードカバレッジ基準（80%以上）を満たしていること
3. 重大度「高」以上の未解決バグがないこと
4. コードレビューでテスト品質が承認されていること
5. テスト実行が安定していること（フラッキーテストがないこと）

## 9. 参考情報と補足資料

### 9.1 単体テストのベストプラクティス

1. **テストの独立性を保つ**
   - テスト間の依存を排除
   - 共有状態を避ける
   - テストの実行順序に依存しない

2. **テストを簡潔に保つ**
   - 1テストにつき1つの概念を検証
   - テストコードは本番コードより単純であるべき
   - 過度に複雑なセットアップは抽出する

3. **テストデータの管理**
   - テストフィクスチャを効果的に活用
   - ファクトリメソッドやビルダーパターンでテストデータ作成
   - 必要最小限のデータセットで検証

4. **モックの適切な使用**
   - モックは必要な場合のみ使用
   - 実装の詳細ではなくコントラクトをモック
   - モックの乱用を避ける

### 9.2 JUnit 5 特有の機能活用例

```java
// タグ付けによるテストのグループ化
@Tag("fast")
@Tag("model")
class EngineerTest { /* ... */ }

// 条件付きテスト
@EnabledOnOs(OS.LINUX)
@Test
void testLinuxSpecificFeature() { /* ... */ }

// 繰り返しテスト
@RepeatedTest(10)
void repeatedTest() { /* ... */ }

// テスト順序の指定
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class OrderedTest {
    @Test
    @Order(1)
    void firstTest() { /* ... */ }

    @Test
    @Order(2)
    void secondTest() { /* ... */ }
}

// ネストされたテスト
@Nested
class WhenLoggedIn {
    @BeforeEach
    void setup() {
        // ログイン状態のセットアップ
    }
    
    @Test
    void shouldAllowAccess() { /* ... */ }
}
```

### 9.3 モック活用例

```java
// ArgumentCaptorの使用
@Test
void shouldPassCorrectArgumentsToRepository() {
    // Arrange
    Engineer engineer = createTestEngineer();
    
    // ArgumentCaptorのセットアップ
    ArgumentCaptor<Engineer> engineerCaptor = ArgumentCaptor.forClass(Engineer.class);
    
    // Act
    engineerService.updateEngineer(engineer);
    
    // Assert
    verify(engineerRepository).save(engineerCaptor.capture());
    Engineer capturedEngineer = engineerCaptor.getValue();
    assertThat(capturedEngineer.getName()).isEqualTo(engineer.getName());
}

// スパイの使用
@Test
void shouldNotifyWhenEngineerCreated() {
    // スパイの作成
    NotificationService notificationSpy = spy(new NotificationServiceImpl());
    
    // テスト対象にスパイを注入
    EngineerService engineerService = new EngineerServiceImpl(engineerRepository, notificationSpy);
    
    // Act
    engineerService.createEngineer(createTestEngineer());
    
    // スパイの検証
    verify(notificationSpy).sendNotification(any(), any());
}
```

## 10. 付録

### 10.1 単体テストテンプレート

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.*;

/**
 * <クラス名>のユニットテスト
 */
@ExtendWith(MockitoExtension.class)
class XxxServiceTest {

    // モックの定義
    @Mock
    private XxxRepository xxxRepository;
    
    // テスト対象
    private XxxService xxxService;
    
    @BeforeEach
    void setUp() {
        xxxService = new XxxServiceImpl(xxxRepository);
    }
    
    @Test
    void shouldXxx_whenYyy() {
        // Arrange
        // テストデータのセットアップ
        
        // Act
        // テスト対象メソッドの実行
        
        // Assert
        // 結果の検証
    }
}
```

### 10.2 一般的な課題と対応策

| 課題 | 対応策 |
|-----|-------|
| フラッキーテスト | ・テストの独立性を確保<br>・共有リソースへの依存を排除<br>・非同期処理の適切な待機 |
| テスト実行時間の長さ | ・並列実行の活用<br>・テストスコープの適切な分離<br>・不要な処理の最小化 |
| 環境依存テスト | ・環境変数のモック化<br>・テストコンテナの活用<br>・プラットフォーム固有ロジックの分離 |
| メンテナンスコスト | ・実装の詳細ではなく動作をテスト<br>・テストユーティリティの再利用<br>・自動化の活用 |
| レガシーコードのテスト | ・リファクタリングと並行してテスト追加<br>・境界を特定してモック<br>・クリティカルパスの優先的テスト |