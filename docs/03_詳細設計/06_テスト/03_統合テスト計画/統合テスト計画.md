# SES業務システム 統合テスト計画

## 1. はじめに

### 1.1 目的

本ドキュメントは、SES業務システムの統合テストに関する詳細な計画を定義する。コンポーネント間の連携、モジュール間の通信、外部システムとの連携など、システムの統合ポイントを検証するためのアプローチ、方法、および基準を提供する。統合テストによって、単体テストでは検出できない複数コンポーネント間の相互作用に関する問題を早期に発見し、修正することを目指す。

### 1.2 適用範囲

本統合テスト計画は、SES業務システムの以下の対象をカバーする：

- モジュール間の内部インターフェース
- コントローラーとサービス層の統合
- サービスとリポジトリ層の統合
- データベースとのインタラクション
- 外部APIとの連携
- バッチ処理・非同期処理の連携
- マイクロサービス間の通信（将来拡張時）

### 1.3 参照ドキュメント

- [テスト方針概要](/docs/03_詳細設計/06_テスト/01_テスト方針/テスト方針概要.md)
- [単体テスト計画](/docs/03_詳細設計/06_テスト/02_単体テスト計画/単体テスト計画.md)
- [アーキテクチャ概要](/docs/03_詳細設計/01_アーキテクチャ/アーキテクチャ概要.md)
- [各モジュール詳細設計書](/docs/03_詳細設計/02_モジュール/)
- [API設計仕様書](/docs/03_詳細設計/04_API/API概要.md)

## 2. 統合テスト戦略

### 2.1 統合テストのアプローチ

SES業務システムの統合テストでは、以下のアプローチを採用する：

1. **ボトムアップアプローチ**
   - 下位レベルのコンポーネントから統合を開始
   - データアクセス層→サービス層→コントローラー層の順に統合
   - 基盤となるコンポーネントを先に検証

2. **API主導型テスト**
   - 定義されたAPIを中心にテストを設計
   - コントラクト（契約）を検証
   - REST APIの入出力と動作を検証

3. **実際のデータベースを使用したテスト**
   - インメモリデータベースとの切り替えを可能に
   - 実際のSQLの実行を検証
   - データベースとのインタラクションを検証

4. **外部システムの選択的モック**
   - 制御できない外部システムはモック化
   - 必要に応じてサードパーティサービスをスタブ化
   - 機能テストの場合はモック、接続テストの場合は実際のサービスを使用

### 2.2 統合テストの分類

統合テストを以下のカテゴリに分類して管理する：

#### 2.2.1 コンポーネント統合テスト

- サービス層とリポジトリ層の連携
- コントローラー層とサービス層の連携
- ビジネスロジック層内の複数コンポーネントの連携

#### 2.2.2 サブシステム統合テスト

- 各機能モジュール内の全レイヤーの統合
- 例：認証認可モジュール、技術者管理モジュール、案件管理モジュールなど

#### 2.2.3 データベース統合テスト

- SQL実行とマッピングの検証
- トランザクション管理の検証
- データ永続化と取得の検証

#### 2.2.4 外部システム連携テスト

- 外部API呼び出しの検証
- メール送信機能の検証
- ファイルストレージとの連携

#### 2.2.5 非同期処理統合テスト

- メッセージキュー連携の検証
- バッチ処理の検証
- 非同期イベント処理の検証

### 2.3 重点テスト領域

以下の領域を統合テストの重点対象とする：

| 領域 | 重要度 | 理由 |
|-----|-------|------|
| 認証・認可連携 | 高 | セキュリティの中核であり、横断的に影響するため |
| マッチングエンジン連携 | 高 | 複雑なビジネスロジックを含み、システムの中核機能のため |
| 請求・支払い処理連携 | 高 | 金銭関連処理で高い精度が要求されるため |
| 外部APIとの通信 | 高 | 外部依存があり、接続問題が発生しやすいため |
| バッチ処理連携 | 中 | システム全体のデータ整合性に影響するため |
| 通知サービス連携 | 中 | 複数モジュールから利用される共通機能のため |
| レポート生成連携 | 中 | 複数データソースを組み合わせた処理を含むため |

## 3. テスト環境と準備

### 3.1 テスト環境

#### 3.1.1 統合テスト専用環境

統合テスト用に以下の環境を準備する：

| 項目 | 仕様・設定 |
|-----|----------|
| データベース | テスト専用PostgreSQL 17（テスト毎にスキーマ分離） |
| アプリケーションサーバー | テスト専用Spring Bootアプリケーション |
| 外部サービスモック | WireMock/MockServerによる模擬サービス |
| コンテナ化 | TestContainersを使用した一時的なコンテナ環境 |
| ストレージ | MinIOによるS3互換テスト用ストレージ |
| メッセージブローカー | テスト用RabbitMQ/Kafka |

#### 3.1.2 環境構成図

```
+--------------------+       +------------------+       +-------------------+
|  テスト用APIクライアント  |------>|  アプリケーション  |------>|  PostgreSQLデータベース  |
+--------------------+       +------------------+       +-------------------+
                                     |
                                     |
                                     v
+--------------------+       +------------------+       +-------------------+
|   WireMock Server  |<------|  外部システム連携  |------>|   MinIO (S3互換)   |
+--------------------+       +------------------+       +-------------------+
                                     |
                                     |
                                     v
                             +------------------+
                             |  テスト用メッセージブローカー  |
                             +------------------+
```

### 3.2 テストフレームワークとツール

| ツール | 用途 | バージョン |
|-------|------|----------|
| JUnit 5 | テスト実行フレームワーク | 5.9.x |
| Spring Test | Spring連携テスト | Spring Boot 3.2.x付属 |
| TestContainers | コンテナ化されたテスト環境 | 1.18.x |
| REST Assured | RESTful API検証 | 5.3.x |
| WireMock | 外部APIモック | 3.x |
| Mockito | モックフレームワーク | 5.x |
| DBUnit | データベーステスト支援 | 2.7.x |
| Awaitility | 非同期処理検証 | 4.2.x |
| Flyway | データベースマイグレーション | 9.x |

### 3.3 テストデータ管理

#### 3.3.1 テストデータ戦略

統合テストで使用するテストデータは以下の方針で管理する：

1. **データセット分離**
   - テスト間で影響し合わないようにデータを分離
   - テストメソッド・クラス単位でのデータ管理

2. **SQLスクリプトベース**
   - テストデータをSQL形式で管理
   - バージョン管理システムで追跡可能に

3. **プログラム的データ生成**
   - テストファクトリクラスによるデータ生成
   - 必要に応じてランダムデータも活用

4. **データクリーンアップ**
   - テスト終了後の確実なデータクリーンアップ
   - トランザクションロールバックの活用

#### 3.3.2 テストデータセット

主要なテストデータセットは以下の通り：

| データセット | 用途 | 規模 |
|------------|------|------|
| 基本マスタデータ | すべてのテストの基盤となるマスタデータ | 小 |
| 技術者サンプル | 技術者関連テスト用データ | 中 |
| 案件サンプル | 案件関連テスト用データ | 中 |
| 契約サンプル | 契約関連テスト用データ | 中 |
| 勤怠・工数サンプル | 勤怠管理テスト用データ | 大 |
| 請求・支払いサンプル | 経理処理テスト用データ | 大 |
| レポートサンプル | レポート生成テスト用データ | 大 |

#### 3.3.3 データ生成ユーティリティ

```java
@Component
public class TestDataFactory {
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EngineerRepository engineerRepository;
    
    @Autowired
    private ProjectRepository projectRepository;
    
    /**
     * 技術者テストデータを生成
     */
    public Engineer createTestEngineer(String namePrefix, List<String> skills) {
        // ユーザーの作成
        User user = new User();
        user.setUsername(namePrefix + "_user");
        user.setEmail(namePrefix + "@example.com");
        user.setPassword(passwordEncoder.encode("password"));
        user = userRepository.save(user);
        
        // 技術者の作成
        Engineer engineer = new Engineer();
        engineer.setFirstName(namePrefix);
        engineer.setLastName("テスト");
        engineer.setFirstNameKana("テスト");
        engineer.setLastNameKana("テスト");
        engineer.setEmail(namePrefix + "@example.com");
        engineer.setPhoneNumber("03-1234-5678");
        engineer.setBirthDate(LocalDate.of(1990, 1, 1));
        engineer.setUser(user);
        
        // スキル情報の追加
        if (skills != null && !skills.isEmpty()) {
            Set<EngineerSkill> skillSet = new HashSet<>();
            for (String skillName : skills) {
                EngineerSkill skill = new EngineerSkill();
                skill.setName(skillName);
                skill.setYears(3);
                skill.setLevel(3);
                skill.setEngineer(engineer);
                skillSet.add(skill);
            }
            engineer.setSkills(skillSet);
        }
        
        return engineerRepository.save(engineer);
    }
    
    /**
     * 案件テストデータを生成
     */
    public Project createTestProject(String projectName, List<String> requiredSkills) {
        Project project = new Project();
        project.setName(projectName);
        project.setDescription(projectName + " の説明文");
        project.setStartDate(LocalDate.now().plusDays(30));
        project.setEndDate(LocalDate.now().plusMonths(6));
        project.setStatus(ProjectStatus.OPEN);
        
        // スキル要件の追加
        if (requiredSkills != null && !requiredSkills.isEmpty()) {
            Set<ProjectSkill> skillRequirements = new HashSet<>();
            for (String skillName : requiredSkills) {
                ProjectSkill skill = new ProjectSkill();
                skill.setName(skillName);
                skill.setRequired(true);
                skill.setMinYears(2);
                skill.setProject(project);
                skillRequirements.add(skill);
            }
            project.setSkillRequirements(skillRequirements);
        }
        
        return projectRepository.save(project);
    }
    
    // 他のテストデータ生成メソッド...
}
```

## 4. テスト実施計画

### 4.1 モジュール統合テスト

各機能モジュール内のコンポーネント間の連携を検証するテスト。

#### 4.1.1 認証・認可モジュール統合テスト

| ID | テスト名 | 概要 | 優先度 |
|----|--------|------|-------|
| AUTH-IT-01 | JWT認証処理統合テスト | JWT生成、検証、および認証フィルターの連携を検証 | 高 |
| AUTH-IT-02 | ロールベースアクセス制御統合テスト | ロール管理とAPIアクセス制御の連携を検証 | 高 |
| AUTH-IT-03 | 多要素認証統合テスト | MFA生成、検証、ユーザーサービスの連携を検証 | 中 |
| AUTH-IT-04 | パスワードリセット統合テスト | パスワードリセットフローの連携を検証 | 中 |
| AUTH-IT-05 | アカウントロック統合テスト | 認証失敗とアカウントロック機能の連携を検証 | 中 |

**テスト例**：

```java
@SpringBootTest
public class JwtAuthenticationIntegrationTest {
    
    @Autowired
    private AuthenticationManager authenticationManager;
    
    @Autowired
    private JwtTokenProvider jwtTokenProvider;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Test
    @DisplayName("正常なログイン・認証・APIアクセスフローのテスト")
    void testAuthenticationFlow() {
        // テスト準備：ユーザー作成
        User user = createTestUser("testuser", "password", "ROLE_USER");
        
        // ログインリクエスト
        LoginRequest loginRequest = new LoginRequest("testuser", "password");
        ResponseEntity<JwtAuthenticationResponse> response = restTemplate.postForEntity(
                "/api/v1/auth/login", loginRequest, JwtAuthenticationResponse.class);
        
        // レスポンス検証
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().getAccessToken()).isNotEmpty();
        
        // 取得したトークンでAPI呼び出し
        String token = response.getBody().getAccessToken();
        HttpHeaders headers = new HttpHeaders();
        headers.setBearerAuth(token);
        HttpEntity<String> entity = new HttpEntity<>(headers);
        
        ResponseEntity<String> protectedResponse = restTemplate.exchange(
                "/api/v1/user/me", HttpMethod.GET, entity, String.class);
        
        // 保護されたAPIへのアクセス検証
        assertThat(protectedResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(protectedResponse.getBody()).contains("testuser");
    }
    
    @Test
    @DisplayName("不正なトークンでの認証失敗を検証")
    void testInvalidTokenAuthentication() {
        // 不正なトークンでリクエスト
        HttpHeaders headers = new HttpHeaders();
        headers.setBearerAuth("invalid.token.here");
        HttpEntity<String> entity = new HttpEntity<>(headers);
        
        ResponseEntity<String> response = restTemplate.exchange(
                "/api/v1/user/me", HttpMethod.GET, entity, String.class);
        
        // 認証失敗の検証
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
    }
    
    // ヘルパーメソッド
    private User createTestUser(String username, String password, String role) {
        User user = new User();
        user.setUsername(username);
        user.setPassword(passwordEncoder.encode(password));
        user.setEmail(username + "@example.com");
        user.setEnabled(true);
        
        Role userRole = roleRepository.findByName(role)
                .orElseThrow(() -> new RuntimeException("Role not found"));
        user.setRoles(Collections.singleton(userRole));
        
        return userRepository.save(user);
    }
}
```

#### 4.1.2 技術者管理モジュール統合テスト

| ID | テスト名 | 概要 | 優先度 |
|----|--------|------|-------|
| ENG-IT-01 | 技術者登録更新統合テスト | 技術者情報の登録・更新の連携を検証 | 高 |
| ENG-IT-02 | スキル管理統合テスト | 技術者とスキル情報の連携を検証 | 高 |
| ENG-IT-03 | 技術者検索統合テスト | 複合条件での技術者検索機能の連携を検証 | 高 |
| ENG-IT-04 | スキルシート生成統合テスト | スキルシート生成とファイル出力の連携を検証 | 中 |
| ENG-IT-05 | 稼働状況管理統合テスト | 稼働状況の更新と照会の連携を検証 | 中 |

#### 4.1.3 案件管理モジュール統合テスト

| ID | テスト名 | 概要 | 優先度 |
|----|--------|------|-------|
| PRJ-IT-01 | 案件登録更新統合テスト | 案件情報の登録・更新の連携を検証 | 高 |
| PRJ-IT-02 | 案件検索統合テスト | 複合条件での案件検索機能の連携を検証 | 高 |
| PRJ-IT-03 | 案件ステータス管理統合テスト | ステータス変更と権限の連携を検証 | 高 |
| PRJ-IT-04 | 案件関連ファイル管理統合テスト | ファイル添付と取得の連携を検証 | 中 |
| PRJ-IT-05 | 案件承認フロー統合テスト | 承認プロセスの連携を検証 | 中 |

#### 4.1.4 マッチングモジュール統合テスト

| ID | テスト名 | 概要 | 優先度 |
|----|--------|------|-------|
| MAT-IT-01 | マッチングエンジン統合テスト | マッチングアルゴリズムとDBアクセスの連携を検証 | 高 |
| MAT-IT-02 | 提案管理統合テスト | 提案作成・承認フローの連携を検証 | 高 |
| MAT-IT-03 | マッチング検索統合テスト | 条件指定マッチング検索の連携を検証 | 高 |
| MAT-IT-04 | マッチングスコア計算統合テスト | スコア計算ロジックの連携を検証 | 中 |
| MAT-IT-05 | 提案書生成統合テスト | 提案書生成とファイル出力の連携を検証 | 中 |

#### 4.1.5 契約管理モジュール統合テスト

| ID | テスト名 | 概要 | 優先度 |
|----|--------|------|-------|
| CON-IT-01 | 契約作成統合テスト | 契約情報作成と保存の連携を検証 | 高 |
| CON-IT-02 | 電子署名統合テスト | 電子署名処理の連携を検証 | 高 |
| CON-IT-03 | 契約書生成統合テスト | 契約書テンプレートと生成処理の連携を検証 | 高 |
| CON-IT-04 | 契約承認フロー統合テスト | 承認プロセスの連携を検証 | 中 |
| CON-IT-05 | 契約条件変更統合テスト | 契約条件変更と履歴管理の連携を検証 | 中 |

#### 4.1.6 勤怠工数管理モジュール統合テスト

| ID | テスト名 | 概要 | 優先度 |
|----|--------|------|-------|
| TMS-IT-01 | 勤怠登録統合テスト | 勤怠情報登録と保存の連携を検証 | 高 |
| TMS-IT-02 | 勤怠承認フロー統合テスト | 承認プロセスの連携を検証 | 高 |
| TMS-IT-03 | 工数集計統合テスト | 工数集計処理の連携を検証 | 高 |
| TMS-IT-04 | 月次集計統合テスト | 月次集計処理の連携を検証 | 中 |
| TMS-IT-05 | 勤怠データエクスポート統合テスト | データ出力機能の連携を検証 | 中 |

#### 4.1.7 請求支払管理モジュール統合テスト

| ID | テスト名 | 概要 | 優先度 |
|----|--------|------|-------|
| BIL-IT-01 | 請求書生成統合テスト | 請求書生成処理の連携を検証 | 高 |
| BIL-IT-02 | 請求承認フロー統合テスト | 承認プロセスの連携を検証 | 高 |
| BIL-IT-03 | 入金管理統合テスト | 入金登録と確認の連携を検証 | 高 |
| BIL-IT-04 | 支払処理統合テスト | 支払い処理の連携を検証 | 高 |
| BIL-IT-05 | 請求書PDF生成統合テスト | PDF生成処理の連携を検証 | 中 |

#### 4.1.8 レポーティングモジュール統合テスト

| ID | テスト名 | 概要 | 優先度 |
|----|--------|------|-------|
| REP-IT-01 | KPI集計統合テスト | KPIデータ集計処理の連携を検証 | 高 |
| REP-IT-02 | 売上レポート統合テスト | 売上データ集計と表示の連携を検証 | 高 |
| REP-IT-03 | 稼働率レポート統合テスト | 稼働率計算と表示の連携を検証 | 中 |
| REP-IT-04 | カスタムレポート統合テスト | カスタム集計条件と処理の連携を検証 | 中 |
| REP-IT-05 | レポートエクスポート統合テスト | データ出力機能の連携を検証 | 中 |

### 4.2 クロスモジュール統合テスト

複数の機能モジュールにまたがる統合ポイントを検証するテスト。

| ID | テスト名 | 概要 | 優先度 |
|----|--------|------|-------|
| CM-IT-01 | マッチング〜提案〜契約フロー統合テスト | マッチングから契約までの一連の流れを検証 | 高 |
| CM-IT-02 | 契約〜勤怠〜請求フロー統合テスト | 契約から請求までの一連の流れを検証 | 高 |
| CM-IT-03 | 技術者〜マッチング連携テスト | 技術者情報とマッチングの連携を検証 | 高 |
| CM-IT-04 | 案件〜マッチング連携テスト | 案件情報とマッチングの連携を検証 | 高 |
| CM-IT-05 | 勤怠〜請求連携テスト | 勤怠データと請求生成の連携を検証 | 高 |
| CM-IT-06 | 契約〜レポート連携テスト | 契約データとレポート生成の連携を検証 | 中 |
| CM-IT-07 | 全モジュール〜権限連携テスト | 各モジュールの権限制御の連携を検証 | 中 |

**テスト例**：

```java
@SpringBootTest
@Transactional
public class MatchingToContractIntegrationTest {
    
    @Autowired
    private EngineerService engineerService;
    
    @Autowired
    private ProjectService projectService;
    
    @Autowired
    private MatchingService matchingService;
    
    @Autowired
    private ProposalService proposalService;
    
    @Autowired
    private ContractService contractService;
    
    @Autowired
    private TestDataFactory testDataFactory;
    
    @Test
    @DisplayName("マッチングから契約までのエンドツーエンドフロー検証")
    void testMatchingToContractFlow() {
        // 1. テストデータ準備
        Engineer engineer = testDataFactory.createTestEngineer("統合テスト", Arrays.asList("Java", "Spring"));
        Project project = testDataFactory.createTestProject("統合テスト案件", Arrays.asList("Java", "Spring"));
        
        // 2. マッチング検索
        List<MatchingResult> matchingResults = matchingService.findMatches(project.getId());
        assertThat(matchingResults).isNotEmpty();
        
        // マッチング結果に期待する技術者が含まれているか検証
        Optional<MatchingResult> engineerMatch = matchingResults.stream()
                .filter(m -> m.getEngineerId().equals(engineer.getId()))
                .findFirst();
        assertThat(engineerMatch).isPresent();
        assertThat(engineerMatch.get().getMatchingScore()).isGreaterThanOrEqualTo(70.0); // 70%以上のマッチング
        
        // 3. 提案作成
        ProposalRequest proposalRequest = new ProposalRequest();
        proposalRequest.setProjectId(project.getId());
        proposalRequest.setEngineerId(engineer.getId());
        proposalRequest.setProposedRate(new BigDecimal("800000")); // 80万円/月
        proposalRequest.setProposedStartDate(LocalDate.now().plusDays(14));
        
        Proposal proposal = proposalService.createProposal(proposalRequest);
        assertThat(proposal.getId()).isNotNull();
        assertThat(proposal.getStatus()).isEqualTo(ProposalStatus.PENDING);
        
        // 4. 提案承認
        proposalService.approveProposal(proposal.getId());
        Proposal approvedProposal = proposalService.getProposalById(proposal.getId());
        assertThat(approvedProposal.getStatus()).isEqualTo(ProposalStatus.APPROVED);
        
        // 5. 契約作成
        ContractRequest contractRequest = new ContractRequest();
        contractRequest.setProposalId(proposal.getId());
        contractRequest.setContractType(ContractType.OUTSOURCING);
        contractRequest.setStartDate(proposalRequest.getProposedStartDate());
        contractRequest.setEndDate(proposalRequest.getProposedStartDate().plusMonths(3));
        contractRequest.setMonthlyRate(proposalRequest.getProposedRate());
        
        Contract contract = contractService.createContract(contractRequest);
        assertThat(contract.getId()).isNotNull();
        assertThat(contract.getStatus()).isEqualTo(ContractStatus.DRAFT);
        
        // 6. 契約書生成
        byte[] contractDocument = contractService.generateContractDocument(contract.getId());
        assertThat(contractDocument).isNotEmpty();
        
        // 7. 契約承認
        contractService.approveContract(contract.getId());
        Contract approvedContract = contractService.getContractById(contract.getId());
        assertThat(approvedContract.getStatus()).isEqualTo(ContractStatus.APPROVED);
        
        // 8. 関連データの検証
        // 案件ステータスの確認
        Project updatedProject = projectService.getProjectById(project.getId());
        assertThat(updatedProject.getAssignedEngineers()).contains(engineer);
        
        // 技術者の稼働状況確認
        Engineer updatedEngineer = engineerService.getEngineerById(engineer.getId());
        assertThat(updatedEngineer.isAvailable()).isFalse();
        assertThat(updatedEngineer.getCurrentAssignment()).isNotNull();
        assertThat(updatedEngineer.getCurrentAssignment().getProjectId()).isEqualTo(project.getId());
    }
}
```

### 4.3 外部システム連携テスト

外部システムとの連携ポイントを検証するテスト。

| ID | テスト名 | 概要 | 優先度 |
|----|--------|------|-------|
| EXT-IT-01 | 電子署名サービス連携テスト | 電子署名サービスとの連携を検証 | 高 |
| EXT-IT-02 | メール送信連携テスト | メール送信機能との連携を検証 | 高 |
| EXT-IT-03 | ファイルストレージ連携テスト | S3等のストレージサービスとの連携を検証 | 高 |
| EXT-IT-04 | 会計システム連携テスト | 会計システムとのデータ連携を検証 | 中 |
| EXT-IT-05 | 認証サービス連携テスト | SAML/OIDCなどの認証サービスとの連携を検証 | 中 |

**テスト例**：

```java
@SpringBootTest
public class EmailServiceIntegrationTest {

    @Autowired
    private EmailService emailService;
    
    @Autowired
    private UserRepository userRepository;
    
    @MockBean
    private JavaMailSender javaMailSender;
    
    @Captor
    private ArgumentCaptor<MimeMessage> mimeMessageCaptor;
    
    @Test
    @DisplayName("パスワードリセット通知メールの送信テスト")
    void testSendPasswordResetEmail() throws Exception {
        // テスト用ユーザー
        User user = new User();
        user.setUsername("testuser");
        user.setEmail("test@example.com");
        user = userRepository.save(user);
        
        // パスワードリセットトークン
        String resetToken = "test-reset-token-12345";
        
        // メール送信
        emailService.sendPasswordResetEmail(user, resetToken);
        
        // メール送信の検証
        verify(javaMailSender).send(mimeMessageCaptor.capture());
        MimeMessage sentMessage = mimeMessageCaptor.getValue();
        
        // 送信内容の検証
        assertThat(sentMessage.getSubject()).contains("パスワードリセット");
        assertThat(sentMessage.getAllRecipients()[0].toString()).isEqualTo("test@example.com");
        
        // メール本文の検証（MimeMessage解析）
        Object content = sentMessage.getContent();
        assertThat(content).isInstanceOf(MimeMultipart.class);
        MimeMultipart mimeMultipart = (MimeMultipart) content;
        BodyPart bodyPart = mimeMultipart.getBodyPart(0);
        String body = (String) bodyPart.getContent();
        
        assertThat(body).contains(resetToken);
        assertThat(body).contains(user.getUsername());
    }
}
```

```java
@SpringBootTest
public class S3StorageServiceIntegrationTest {

    @Autowired
    private StorageService storageService;
    
    @Test
    @DisplayName("ファイルのアップロードと取得テスト")
    void testFileUploadAndRetrieve() throws IOException {
        // テスト用のファイル内容
        String content = "This is a test file content";
        byte[] contentBytes = content.getBytes();
        InputStream inputStream = new ByteArrayInputStream(contentBytes);
        
        // ファイルアップロード
        String path = "test-files/test-file-" + System.currentTimeMillis() + ".txt";
        storageService.storeFile(path, inputStream, contentBytes.length, "text/plain");
        
        // ファイル取得
        StorageFile storedFile = storageService.getFile(path);
        
        // 検証
        assertThat(storedFile).isNotNull();
        assertThat(storedFile.getContentType()).isEqualTo("text/plain");
        assertThat(storedFile.getSize()).isEqualTo(contentBytes.length);
        
        // 内容の検証
        byte[] retrievedContent = IOUtils.toByteArray(storedFile.getInputStream());
        assertThat(new String(retrievedContent)).isEqualTo(content);
        
        // クリーンアップ
        storageService.deleteFile(path);
        
        // 削除の確認
        assertThatThrownBy(() -> storageService.getFile(path))
                .isInstanceOf(StorageFileNotFoundException.class);
    }
}
```

### 4.4 バッチ処理統合テスト

バッチ処理と関連コンポーネントの連携を検証するテスト。

| ID | テスト名 | 概要 | 優先度 |
|----|--------|------|-------|
| BAT-IT-01 | 請求書生成バッチ統合テスト | 請求書生成処理の連携を検証 | 高 |
| BAT-IT-02 | 月次集計バッチ統合テスト | 月次レポート集計処理の連携を検証 | 高 |
| BAT-IT-03 | データクリーンアップバッチ統合テスト | 不要データの削除処理の連携を検証 | 中 |
| BAT-IT-04 | メール通知バッチ統合テスト | 定期メール通知処理の連携を検証 | 中 |
| BAT-IT-05 | バックアップバッチ統合テスト | データバックアップ処理の連携を検証 | 中 |

### 4.5 REST API統合テスト

REST APIエンドポイントと関連コンポーネントの連携を検証するテスト。

| ID | テスト名 | 概要 | 優先度 |
|----|--------|------|-------|
| API-IT-01 | 認証API統合テスト | 認証関連APIの連携を検証 | 高 |
| API-IT-02 | 技術者API統合テスト | 技術者管理APIの連携を検証 | 高 |
| API-IT-03 | 案件API統合テスト | 案件管理APIの連携を検証 | 高 |
| API-IT-04 | マッチングAPI統合テスト | マッチング関連APIの連携を検証 | 高 |
| API-IT-05 | 契約API統合テスト | 契約管理APIの連携を検証 | 高 |
| API-IT-06 | 勤怠API統合テスト | 勤怠管理APIの連携を検証 | 高 |
| API-IT-07 | 請求API統合テスト | 請求管理APIの連携を検証 | 高 |
| API-IT-08 | レポートAPI統合テスト | レポート関連APIの連携を検証 | 中 |

**テスト例**：

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class EngineerApiIntegrationTest {

    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private TestDataFactory testDataFactory;
    
    @Autowired
    private JwtTokenProvider jwtTokenProvider;
    
    private HttpHeaders headers;
    
    @BeforeEach
    void setUp() {
        // テスト用のJWTトークンを作成
        String token = jwtTokenProvider.createTestToken("admin", Collections.singletonList("ROLE_ADMIN"));
        headers = new HttpHeaders();
        headers.setBearerAuth(token);
    }
    
    @Test
    @DisplayName("技術者の作成と取得APIテスト")
    void testCreateAndGetEngineer() {
        // 技術者作成リクエスト
        EngineerCreateDto createDto = new EngineerCreateDto();
        createDto.setFirstName("太郎");
        createDto.setLastName("山田");
        createDto.setFirstNameKana("タロウ");
        createDto.setLastNameKana("ヤマダ");
        createDto.setEmail("taro@example.com");
        createDto.setPhoneNumber("03-1234-5678");
        createDto.setBirthDate(LocalDate.of(1990, 1, 1));
        
        List<EngineerSkillDto> skills = new ArrayList<>();
        skills.add(new EngineerSkillDto("Java", 5, 4));
        skills.add(new EngineerSkillDto("Spring", 3, 3));
        createDto.setSkills(skills);
        
        // POST リクエスト
        HttpEntity<EngineerCreateDto> requestEntity = new HttpEntity<>(createDto, headers);
        ResponseEntity<EngineerDto> createResponse = restTemplate.exchange(
                "/api/v1/engineers",
                HttpMethod.POST,
                requestEntity,
                EngineerDto.class);
        
        // レスポンス検証
        assertThat(createResponse.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        assertThat(createResponse.getBody()).isNotNull();
        assertThat(createResponse.getBody().getId()).isNotNull();
        
        // 作成された技術者のID
        Long engineerId = createResponse.getBody().getId();
        
        // GET リクエスト
        HttpEntity<Void> getRequestEntity = new HttpEntity<>(headers);
        ResponseEntity<EngineerDto> getResponse = restTemplate.exchange(
                "/api/v1/engineers/" + engineerId,
                HttpMethod.GET,
                getRequestEntity,
                EngineerDto.class);
        
        // レスポンス検証
        assertThat(getResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(getResponse.getBody()).isNotNull();
        
        EngineerDto retrievedEngineer = getResponse.getBody();
        assertThat(retrievedEngineer.getFirstName()).isEqualTo("太郎");
        assertThat(retrievedEngineer.getLastName()).isEqualTo("山田");
        assertThat(retrievedEngineer.getEmail()).isEqualTo("taro@example.com");
        
        // スキル情報の検証
        assertThat(retrievedEngineer.getSkills()).hasSize(2);
        assertThat(retrievedEngineer.getSkills().stream().map(EngineerSkillDto::getName))
                .containsExactlyInAnyOrder("Java", "Spring");
    }
    
    @Test
    @DisplayName("技術者の検索APIテスト")
    void testSearchEngineer() {
        // テストデータ準備
        testDataFactory.createTestEngineer("Java太郎", Arrays.asList("Java", "Spring"));
        testDataFactory.createTestEngineer("Python次郎", Arrays.asList("Python", "Django"));
        
        // 検索リクエスト
        HttpEntity<Void> requestEntity = new HttpEntity<>(headers);
        ResponseEntity<List<EngineerDto>> response = restTemplate.exchange(
                "/api/v1/engineers/search?skill=Java",
                HttpMethod.GET,
                requestEntity,
                new ParameterizedTypeReference<List<EngineerDto>>() {});
        
        // レスポンス検証
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody()).isNotNull();
        
        // 検索結果の検証
        List<EngineerDto> results = response.getBody();
        assertThat(results).isNotEmpty();
        assertThat(results.stream().map(EngineerDto::getLastName))
                .contains("Java太郎")
                .doesNotContain("Python次郎");
    }
}
```

## 5. テスト実行とレポート

### 5.1 テスト実行プロセス

#### 5.1.1 テスト実行フロー

1. **テスト環境準備**
   - テストデータベースのセットアップ
   - 必要なコンテナの起動
   - 初期データのロード

2. **テスト実行準備**
   - テストデータの準備
   - モック/スタブの設定
   - 必要な認証情報の取得

3. **テスト実行**
   - JUnit 5とSpring Testによる実行
   - TestContainersによるコンテナ管理
   - CI/CDパイプラインでの自動実行

4. **テスト後処理**
   - テストデータのクリーンアップ
   - コンテナの停止
   - テスト結果の収集

#### 5.1.2 実行コマンド例

```bash
# 統合テスト全体の実行
./mvnw test -Pintegration-test

# 特定のクラスのみテスト
./mvnw test -Dtest=AuthenticationIntegrationTest

# 特定のカテゴリのテストのみ実行
./mvnw test -Dgroups=api-integration

# テスト結果のレポート生成
./mvnw site -DgenerateReports=true
```

### 5.2 テスト結果レポート

#### 5.2.1 レポート内容

テスト結果レポートには以下の情報を含める：

1. **サマリー情報**
   - 実行したテスト数
   - 成功/失敗数
   - スキップ数
   - 実行時間

2. **詳細結果**
   - テストクラス/メソッド毎の結果
   - 失敗したテストの詳細情報と原因
   - スタックトレース

3. **トレンド情報**
   - 前回との比較
   - 時系列での成功率推移

4. **カバレッジ情報**
   - メソッド/クラスカバレッジ
   - ライン/ブランチカバレッジ

#### 5.2.2 レポートフォーマット

1. **HTML形式**
   - 開発者向け詳細レポート
   - ナビゲーション可能な対話式レポート

2. **XML形式**
   - CI/CDツール連携用
   - 自動化処理用

3. **PDF形式**
   - マネジメント向け要約レポート
   - プロジェクト成果物として保存

### 5.3 障害管理プロセス

統合テスト中に発見された問題の管理プロセス：

1. **問題の記録**
   - 問題内容の詳細な記録
   - 再現手順の記載
   - 関連するテストケースの特定

2. **優先度/重要度の判断**
   - 影響範囲による優先度付け
   - ビジネスリスクによる重要度付け

3. **原因分析**
   - 問題の根本原因の特定
   - 関連コンポーネントの調査

4. **対応計画**
   - 修正担当者のアサイン
   - 修正期限の設定

5. **再テスト**
   - 修正後の機能確認
   - 関連領域への影響確認

## 6. 特殊なテスト条件

### 6.1 データベース統合テスト

実際のデータベースを使用した統合テストのアプローチ：

#### 6.1.1 トランザクション管理

```java
@SpringBootTest
@Transactional
public class EngineerRepositoryIntegrationTest {

    @Autowired
    private EngineerRepository engineerRepository;
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    @DisplayName("技術者情報の永続化と取得テスト")
    void testEngineerPersistenceAndRetrieval() {
        // ユーザー情報作成
        User user = new User();
        user.setUsername("testuser");
        user.setEmail("test@example.com");
        user.setPassword("password");
        userRepository.save(user);
        
        // 技術者情報作成
        Engineer engineer = new Engineer();
        engineer.setFirstName("太郎");
        engineer.setLastName("テスト");
        engineer.setEmail("test@example.com");
        engineer.setUser(user);
        
        // 永続化
        Engineer savedEngineer = engineerRepository.save(engineer);
        
        // ID確認
        assertThat(savedEngineer.getId()).isNotNull();
        
        // 取得して検証
        Engineer retrievedEngineer = engineerRepository.findById(savedEngineer.getId()).orElse(null);
        assertThat(retrievedEngineer).isNotNull();
        assertThat(retrievedEngineer.getFirstName()).isEqualTo("太郎");
        assertThat(retrievedEngineer.getLastName()).isEqualTo("テスト");
        
        // ユーザー関連の検証
        assertThat(retrievedEngineer.getUser()).isNotNull();
        assertThat(retrievedEngineer.getUser().getUsername()).isEqualTo("testuser");
    }
}
```

#### 6.1.2 TestContainersの活用

```java
@SpringBootTest
@Testcontainers
public class DatabaseIntegrationTest {

    @Container
    private static final PostgreSQLContainer<?> postgresContainer = 
            new PostgreSQLContainer<>("postgres:17")
                .withDatabaseName("testdb")
                .withUsername("test")
                .withPassword("test");
    
    @DynamicPropertySource
    static void postgresProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgresContainer::getJdbcUrl);
        registry.add("spring.datasource.username", postgresContainer::getUsername);
        registry.add("spring.datasource.password", postgresContainer::getPassword);
    }
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Test
    void testDatabaseConnection() {
        Integer result = jdbcTemplate.queryForObject("SELECT 1", Integer.class);
        assertThat(result).isEqualTo(1);
    }
    
    @Test
    void testTableCreation() {
        // テーブル存在チェック
        boolean tableExists = jdbcTemplate.queryForObject(
                "SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'engineers')",
                Boolean.class);
        assertThat(tableExists).isTrue();
    }
}
```

### 6.2 非同期処理テスト

非同期処理や待機が必要なケースのテスト：

#### 6.2.1 Awaitilityの活用

```java
@SpringBootTest
public class AsyncNotificationServiceIntegrationTest {

    @Autowired
    private NotificationService notificationService;
    
    @Autowired
    private NotificationRepository notificationRepository;
    
    @Test
    @DisplayName("非同期通知処理の統合テスト")
    void testAsyncNotificationProcessing() {
        // テスト対象の非同期処理を実行
        notificationService.sendNotificationAsync("test-user", "テスト通知", "これはテスト通知です");
        
        // 結果が反映されるまで待機
        await()
            .atMost(5, TimeUnit.SECONDS)
            .pollInterval(500, TimeUnit.MILLISECONDS)
            .until(() -> {
                // 通知が保存されているか確認
                List<Notification> notifications = notificationRepository.findByUserId("test-user");
                return notifications != null && !notifications.isEmpty();
            });
        
        // 結果の検証
        List<Notification> notifications = notificationRepository.findByUserId("test-user");
        assertThat(notifications).hasSize(1);
        assertThat(notifications.get(0).getTitle()).isEqualTo("テスト通知");
        assertThat(notifications.get(0).getContent()).isEqualTo("これはテスト通知です");
    }
}
```

#### 6.2.2 バッチ処理のテスト

```java
@SpringBootTest
public class MonthlyInvoiceBatchIntegrationTest {

    @Autowired
    private JobLauncherTestUtils jobLauncherTestUtils;
    
    @Autowired
    private InvoiceRepository invoiceRepository;
    
    @Autowired
    private TestDataFactory testDataFactory;
    
    @BeforeEach
    void setupTestData() {
        // テスト用の契約データを作成
        testDataFactory.createTestContractsForInvoicing();
    }
    
    @Test
    @DisplayName("月次請求書生成バッチの統合テスト")
    void testMonthlyInvoiceGeneration() throws Exception {
        // 処理前の請求書数を記録
        long initialCount = invoiceRepository.count();
        
        // バッチジョブを実行
        JobExecution jobExecution = jobLauncherTestUtils.launchJob();
        
        // ジョブ実行結果の検証
        assertThat(jobExecution.getStatus()).isEqualTo(BatchStatus.COMPLETED);
        
        // 新しい請求書が生成されたか確認
        long finalCount = invoiceRepository.count();
        assertThat(finalCount).isGreaterThan(initialCount);
        
        // 生成された請求書の内容検証
        List<Invoice> generatedInvoices = invoiceRepository.findByCreatedDateBetween(
                LocalDateTime.now().minusHours(1), 
                LocalDateTime.now());
        
        assertThat(generatedInvoices).isNotEmpty();
        
        // 請求書の詳細検証
        Invoice invoice = generatedInvoices.get(0);
        assertThat(invoice.getStatus()).isEqualTo(InvoiceStatus.DRAFT);
        assertThat(invoice.getTotalAmount()).isNotNull();
        assertThat(invoice.getInvoiceItems()).isNotEmpty();
    }
}
```

### 6.3 外部API連携テスト

外部APIとの連携テストアプローチ：

#### 6.3.1 WireMockを使用したAPIモック

```java
@SpringBootTest
@AutoConfigureWireMock(port = 0)
public class ExternalSignatureServiceIntegrationTest {

    @Autowired
    private SignatureService signatureService;
    
    @Value("${wiremock.server.port}")
    private int wireMockPort;
    
    @BeforeEach
    void setupMocks() {
        // WireMockでの外部API応答設定
        stubFor(post(urlEqualTo("/api/v1/signatures"))
                .willReturn(aResponse()
                        .withHeader("Content-Type", "application/json")
                        .withBody("{\"signature_id\": \"test-sig-12345\", \"status\": \"PENDING\"}")
                        .withStatus(200)));
        
        stubFor(get(urlEqualTo("/api/v1/signatures/test-sig-12345"))
                .willReturn(aResponse()
                        .withHeader("Content-Type", "application/json")
                        .withBody("{\"signature_id\": \"test-sig-12345\", \"status\": \"COMPLETED\"}")
                        .withStatus(200)));
    }
    
    @Test
    @DisplayName("電子署名サービスとの連携テスト")
    void testExternalSignatureServiceIntegration() {
        // 署名リクエスト作成
        SignatureRequest request = new SignatureRequest();
        request.setDocumentId("test-doc-123");
        request.setSignerEmail("signer@example.com");
        request.setSignerName("署名 太郎");
        
        // 署名サービス呼び出し
        SignatureResponse response = signatureService.requestSignature(request);
        
        // レスポンス検証
        assertThat(response).isNotNull();
        assertThat(response.getSignatureId()).isEqualTo("test-sig-12345");
        assertThat(response.getStatus()).isEqualTo(SignatureStatus.PENDING);
        
        // 署名ステータス取得
        SignatureStatus status = signatureService.getSignatureStatus("test-sig-12345");
        assertThat(status).isEqualTo(SignatureStatus.COMPLETED);
        
        // WireMockへのリクエスト検証
        verify(postRequestedFor(urlEqualTo("/api/v1/signatures"))
                .withHeader("Content-Type", equalTo("application/json"))
                .withRequestBody(containing("test-doc-123")));
        
        verify(getRequestedFor(urlEqualTo("/api/v1/signatures/test-sig-12345")));
    }
}
```

#### 6.3.2 HTTPクライアントのモック

```java
@SpringBootTest
public class RestClientIntegrationTest {

    @MockBean
    private RestClient restClient;
    
    @Autowired
    private ExternalServiceClient externalServiceClient;
    
    @Test
    @DisplayName("外部サービスクライアントの統合テスト")
    void testExternalServiceClientIntegration() {
        // レスポンスのモック
        ExternalApiResponse mockResponse = new ExternalApiResponse();
        mockResponse.setSuccess(true);
        mockResponse.setData("テストデータ");
        
        // RestClientの振る舞いを設定
        when(restClient.executeGet(anyString(), any()))
                .thenReturn(mockResponse);
        
        // テスト対象メソッド呼び出し
        ExternalApiResponse response = externalServiceClient.fetchData("12345");
        
        // 検証
        assertThat(response).isNotNull();
        assertThat(response.isSuccess()).isTrue();
        assertThat(response.getData()).isEqualTo("テストデータ");
        
        // RestClientの呼び出し検証
        verify(restClient).executeGet(contains("12345"), any());
    }
}
```

## 7. 品質指標とレポーティング

### 7.1 品質指標

統合テストの品質を測定するための指標：

| 指標 | 説明 | 目標値 |
|-----|------|-------|
| 合格率 | テスト合格数 / 全テスト数 | 100% |
| 重大不具合数 | 統合テストで発見された重大な不具合数 | 0件 (リリース前) |
| 未対応バグ数 | 未修正の不具合数 | 0件 (優先度高) |
| 統合テストカバレッジ | モジュール統合ポイントのテストカバレッジ | 90%以上 |
| テスト実行時間 | 全統合テストの実行にかかる時間 | 15分以内 |
| フレーキーテスト率 | 不安定なテストの割合 | 5%未満 |

### 7.2 継続的インテグレーション連携

CI/CDパイプラインでの統合テスト実行とレポート：

1. **GitHub Actionsでの実装例**

```yaml
name: Integration Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  integration-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: 'maven'
      
      - name: Build with Maven
        run: mvn -B clean verify -DskipUnitTests
      
      - name: Run Integration Tests
        run: mvn -B test -Pintegration-test
      
      - name: Publish Test Results
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: Integration Test Results
          path: target/surefire-reports/*.xml
          reporter: java-junit
      
      - name: Upload Detailed Reports
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: integration-test-reports
          path: target/site/surefire-report.html
```

2. **テスト結果の分析と可視化**

- SonarQubeとの統合
- テスト結果の時系列トラッキング
- チーム通知（Slack等）との連携

### 7.3 成功基準

統合テスト完了の判断基準：

1. **全テスト成功**
   - 全ての統合テストが成功している
   - フレーキーテストがない、または対応済み

2. **バグ修正完了**
   - 優先度「高」以上の不具合が全て修正されている
   - 残存する既知の不具合に対応計画がある

3. **パフォーマンス目標達成**
   - 全テスト実行が時間目標内に完了している
   - リソース使用量が許容範囲内である

4. **カバレッジ目標達成**
   - 統合テストカバレッジが目標を達成している
   - 主要な統合ポイントが全てカバーされている

## 8. リスクと対策

統合テスト実施における主なリスクと対策：

| リスク | 影響 | 確率 | 対策 |
|-------|------|-----|------|
| 環境依存の問題 | 高 | 中 | ・コンテナ技術の活用<br>・環境設定の自動化<br>・環境依存パラメーターの外部化 |
| テスト実行時間の長期化 | 中 | 高 | ・並列テスト実行<br>・テスト最適化<br>・テスト分割と選択的実行 |
| 外部システム連携の不安定性 | 高 | 中 | ・堅牢なモック実装<br>・再試行メカニズム<br>・障害時のグレースフルデグラデーション |
| データ依存関係の複雑化 | 中 | 中 | ・テストの独立性確保<br>・独立したテストデータセット<br>・確実なクリーンアップ |
| ロードバランサー/ネットワーク依存 | 中 | 低 | ・直接接続テスト<br>・ネットワーク設定の標準化<br>・ネットワーク問題の切り分け手順策定 |

## 9. スケジュールと実施計画

### 9.1 マイルストーンとスケジュール

| マイルストーン | 期間 | 主な成果物 |
|--------------|------|----------|
| 準備フェーズ | 2025/07/20 - 2025/07/31 | テスト環境構築、テスト計画完成 |
| モジュール統合テスト実装 | 2025/08/01 - 2025/08/31 | 各モジュールの統合テスト実装 |
| クロスモジュールテスト実装 | 2025/09/01 - 2025/09/15 | モジュール間連携テスト実装 |
| 外部連携テスト実装 | 2025/09/16 - 2025/09/30 | 外部システム連携テスト実装 |
| テスト実行・評価 | 2025/10/01 - 2025/10/15 | テスト実行、結果分析、修正 |
| 最終検証 | 2025/10/16 - 2025/10/31 | 最終テスト、レポート作成 |

### 9.2 責任者と役割

| 役割 | 担当者 | 主な責任 |
|-----|-------|---------|
| 統合テストリード | - | 全体計画、進捗管理、課題解決 |
| モジュールテスト担当 | - | 各モジュールの統合テスト実装 |
| クロスモジュールテスト担当 | - | モジュール間連携テスト実装 |
| 外部連携テスト担当 | - | 外部システム連携テスト実装 |
| テスト環境担当 | - | テスト環境構築・管理 |
| 品質保証担当 | - | テスト結果評価、品質指標管理 |

## 10. 参考資料と付録

### 10.1 テストケーステンプレート

```java
@SpringBootTest
class [機能名]IntegrationTest {
    
    // 依存コンポーネント
    @Autowired
    private [主要サービス] primaryService;
    
    @Autowired
    private [関連リポジトリ] relatedRepository;
    
    @MockBean  // 必要に応じて
    private [外部依存] externalDependency;
    
    @BeforeEach
    void setUp() {
        // テストデータのセットアップ
        // モックの設定（必要な場合）
    }
    
    @Test
    @DisplayName("[テスト内容の簡単な説明]")
    void test[テスト対象機能]() {
        // 前提条件
        
        // テスト対象処理の実行
        
        // 結果の検証
    }
    
    @AfterEach
    void tearDown() {
        // テストデータのクリーンアップ
    }
}
```

### 10.2 ベストプラクティス

1. **テストの独立性を保つ**
   - テスト間の依存関係を作らない
   - 各テストは自己完結型に設計
   - テスト順序に依存しない実装

2. **テストデータの管理**
   - テストごとに必要なデータを明示的に作成
   - 共有データへの依存を避ける
   - テスト後のクリーンアップを確実に行う

3. **モック/スタブの適切な使用**
   - 外部依存は基本的にモック化
   - ただし検証が目的の場合は実際のコンポーネントを使用
   - モックの過剰使用を避け、実際の連携も検証

4. **エラーケースのテスト**
   - 正常系だけでなく異常系もテスト
   - 境界条件での動作を確認
   - エラーハンドリングの適切な処理を検証

5. **テスト可読性の向上**
   - 明確なテスト名と説明
   - 論理的なセクション分け（準備・実行・検証）
   - 複雑なテストのステップ分割

### 10.3 参考リソース

- [Spring Boot Testing Documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing)
- [TestContainers Documentation](https://www.testcontainers.org/)
- [REST Assured Documentation](https://rest-assured.io/)
- [JUnit 5 User Guide](https://junit.org/junit5/docs/current/user-guide/)
- [Martin Fowler on Integration Tests](https://martinfowler.com/bliki/IntegrationTest.html)
- [Mockito Documentation](https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html)
- [WireMock Documentation](http://wiremock.org/docs/)