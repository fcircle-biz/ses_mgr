# 共通モジュール - 認証認可テーブル定義補足

## 1. テーブル概要

認証認可モジュールは、システム全体のユーザー認証と権限管理を担当する重要な共通基盤である。このモジュールでは、ユーザーのログイン情報、セッション管理、権限定義、アクセス制御などの機能を提供する。

### 1.1 テーブル一覧

| テーブル名 | 説明 | 主要列 |
|----------|------|-------|
| `common.auth_user` | ユーザー認証情報 | `id`, `username`, `password_hash`, `email`, `status` |
| `common.auth_session` | セッション情報 | `id`, `user_id`, `token`, `expires_at` |
| `common.auth_permission` | 権限定義 | `id`, `code`, `name`, `description` |
| `common.auth_role` | ロール定義 | `id`, `code`, `name`, `description` |
| `common.auth_role_permission` | ロールと権限の関連 | `role_id`, `permission_id` |
| `common.auth_user_role` | ユーザーとロールの関連 | `user_id`, `role_id` |
| `common.auth_login_history` | ログイン履歴 | `id`, `user_id`, `login_datetime`, `ip_address`, `user_agent` |
| `common.auth_password_reset` | パスワードリセット情報 | `id`, `user_id`, `token`, `expires_at` |
| `common.auth_access_log` | アクセスログ | `id`, `user_id`, `resource_type`, `resource_id`, `action_type`, `access_datetime` |

## 2. 主要テーブル詳細

### 2.1 auth_user テーブル

ユーザーの認証情報を格納するテーブル。パスワードはハッシュ化して保存する。

#### テーブル定義

```sql
CREATE TABLE common.auth_user (
    id serial PRIMARY KEY,
    username varchar(50) NOT NULL UNIQUE,
    password_hash varchar(128) NOT NULL,
    email varchar(255) NOT NULL UNIQUE,
    first_name varchar(50) NOT NULL,
    last_name varchar(50) NOT NULL,
    status smallint NOT NULL DEFAULT 1,
    require_password_change boolean NOT NULL DEFAULT false,
    last_login_datetime timestamptz,
    last_password_change timestamptz,
    login_failure_count smallint NOT NULL DEFAULT 0,
    account_locked_until timestamptz,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer,
    updated_at timestamptz,
    updated_by integer,
    CONSTRAINT ck_auth_user_status CHECK (status IN (0, 1, 2, 9))  -- 0:無効, 1:有効, 2:一時停止, 9:削除
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_auth_user` | PRIMARY KEY | `id` | 主キー |
| `uix_auth_user_username` | UNIQUE | `username` | ユーザー名一意性 |
| `uix_auth_user_email` | UNIQUE | `email` | メールアドレス一意性 |
| `ix_auth_user_status` | B-tree | `status` | ステータスによる検索 |
| `ix_auth_user_name` | B-tree | `last_name`, `first_name` | 氏名による検索 |

#### 特記事項

- パスワードハッシュ化には、pgcrypto拡張の`crypt`関数とbcrypt（`blowfish`）アルゴリズムを使用
- アカウントロック機能として、連続ログイン失敗回数と一時ロック期間を管理
- 論理削除方式を採用し、物理削除は行わない
- メールアドレスの大文字小文字を区別しない一意性を担保するため、`citext`型を使用

### 2.2 auth_session テーブル

ユーザーのセッション情報を管理するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.auth_session (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id integer NOT NULL REFERENCES common.auth_user(id),
    token varchar(255) NOT NULL UNIQUE,
    token_type varchar(20) NOT NULL DEFAULT 'Bearer',
    ip_address inet,
    user_agent text,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    expires_at timestamptz NOT NULL,
    revoked boolean NOT NULL DEFAULT false,
    revoked_at timestamptz,
    revoked_reason varchar(50),
    CONSTRAINT ck_auth_session_token_type CHECK (token_type IN ('Bearer', 'Refresh'))
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_auth_session` | PRIMARY KEY | `id` | 主キー |
| `uix_auth_session_token` | UNIQUE | `token` | トークン一意性 |
| `ix_auth_session_user_id` | B-tree | `user_id` | ユーザー別セッション検索 |
| `ix_auth_session_expires_at` | B-tree | `expires_at` | 有効期限による検索 |
| `ix_auth_session_revoked` | B-tree | `revoked` | 無効化されたセッション検索 |

#### 特記事項

- セッションIDにはUUID v4を使用
- トークンはJWTを採用し、暗号化署名付きで生成
- アクセストークンとリフレッシュトークンの2種類を管理
- セッションの期限切れ管理のため、定期的なクリーンアップジョブを実行
- IP制限機能も実装可能な設計

### 2.3 auth_permission テーブル

システム内の各リソースに対する操作権限を定義するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.auth_permission (
    id serial PRIMARY KEY,
    code varchar(100) NOT NULL UNIQUE,
    name varchar(100) NOT NULL,
    description text,
    resource_type varchar(50) NOT NULL,
    action_type varchar(20) NOT NULL,
    is_system boolean NOT NULL DEFAULT false,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer,
    updated_at timestamptz,
    updated_by integer,
    CONSTRAINT ck_auth_permission_action_type CHECK (
        action_type IN ('create', 'read', 'update', 'delete', 'execute', 'all')
    )
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_auth_permission` | PRIMARY KEY | `id` | 主キー |
| `uix_auth_permission_code` | UNIQUE | `code` | 権限コード一意性 |
| `ix_auth_permission_resource_action` | B-tree | `resource_type`, `action_type` | リソースとアクション組み合わせ検索 |

#### 特記事項

- 権限コードは`resource_type.action_type`形式で定義（例: `user.create`）
- システム権限フラグを持ち、システム運用に必須の権限を保護
- リソースタイプとアクションタイプの組み合わせに意味を持たせる設計

### 2.4 auth_role テーブル

ユーザーに割り当てるロール（役割）を定義するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.auth_role (
    id serial PRIMARY KEY,
    code varchar(50) NOT NULL UNIQUE,
    name varchar(100) NOT NULL,
    description text,
    is_system boolean NOT NULL DEFAULT false,
    is_default boolean NOT NULL DEFAULT false,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer,
    updated_at timestamptz,
    updated_by integer
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_auth_role` | PRIMARY KEY | `id` | 主キー |
| `uix_auth_role_code` | UNIQUE | `code` | ロールコード一意性 |

#### 特記事項

- システムロールフラグにより、システム運用に必須のロールを保護
- デフォルトロールフラグにより、新規ユーザー作成時の自動割り当てロールを指定可能
- 階層化ロールの実装も検討（親ロールを持つ設計）

### 2.5 auth_role_permission テーブル

ロールと権限の関連を定義する中間テーブル。

#### テーブル定義

```sql
CREATE TABLE common.auth_role_permission (
    role_id integer NOT NULL REFERENCES common.auth_role(id),
    permission_id integer NOT NULL REFERENCES common.auth_permission(id),
    granted_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    granted_by integer,
    PRIMARY KEY (role_id, permission_id)
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_auth_role_permission` | PRIMARY KEY | `role_id`, `permission_id` | 主キー（複合） |
| `ix_auth_role_permission_permission_id` | B-tree | `permission_id` | 権限からのロール検索 |

#### 特記事項

- ロールと権限の多対多の関連を表現
- 権限付与の監査証跡として、付与日時と付与者を記録

### 2.6 auth_user_role テーブル

ユーザーとロールの関連を定義する中間テーブル。

#### テーブル定義

```sql
CREATE TABLE common.auth_user_role (
    user_id integer NOT NULL REFERENCES common.auth_user(id),
    role_id integer NOT NULL REFERENCES common.auth_role(id),
    granted_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    granted_by integer,
    expires_at timestamptz,
    PRIMARY KEY (user_id, role_id)
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_auth_user_role` | PRIMARY KEY | `user_id`, `role_id` | 主キー（複合） |
| `ix_auth_user_role_role_id` | B-tree | `role_id` | ロールからのユーザー検索 |
| `ix_auth_user_role_expires_at` | B-tree | `expires_at` | 有効期限による検索 |

#### 特記事項

- ユーザーとロールの多対多の関連を表現
- 時限ロールの概念をサポート（`expires_at`による期限設定）
- ロール付与の監査証跡として、付与日時と付与者を記録

### 2.7 auth_login_history テーブル

ユーザーのログイン履歴を記録するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.auth_login_history (
    id bigserial PRIMARY KEY,
    user_id integer REFERENCES common.auth_user(id),
    username varchar(50) NOT NULL,
    login_datetime timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    logout_datetime timestamptz,
    ip_address inet,
    user_agent text,
    device_info jsonb,
    location_info jsonb,
    status varchar(20) NOT NULL,
    failure_reason varchar(50),
    CONSTRAINT ck_auth_login_history_status CHECK (
        status IN ('success', 'failure', 'locked', 'expired', 'invalid')
    )
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_auth_login_history` | PRIMARY KEY | `id` | 主キー |
| `ix_auth_login_history_user_id` | B-tree | `user_id` | ユーザー別ログイン履歴検索 |
| `ix_auth_login_history_login_datetime` | B-tree | `login_datetime` | 日時順検索 |
| `ix_auth_login_history_status` | B-tree | `status` | ステータスによる検索 |
| `ix_auth_login_history_ip_address` | B-tree | `ip_address` | IPアドレスによる検索 |

#### 特記事項

- ユーザー削除後もログイン履歴は保持するため、`user_id`にNULL許容
- ユーザー名も冗長に保存し、ユーザー削除後も追跡可能に
- 地理位置情報やデバイス情報はJSON形式で保存し、詳細な分析に活用
- パーティショニング候補テーブル（日付でのパーティショニングを推奨）

### 2.8 auth_password_reset テーブル

パスワードリセット機能のためのトークン管理テーブル。

#### テーブル定義

```sql
CREATE TABLE common.auth_password_reset (
    id serial PRIMARY KEY,
    user_id integer NOT NULL REFERENCES common.auth_user(id),
    token varchar(128) NOT NULL UNIQUE,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    expires_at timestamptz NOT NULL,
    used_at timestamptz,
    ip_address inet,
    user_agent text
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_auth_password_reset` | PRIMARY KEY | `id` | 主キー |
| `uix_auth_password_reset_token` | UNIQUE | `token` | トークン一意性 |
| `ix_auth_password_reset_user_id` | B-tree | `user_id` | ユーザー別検索 |
| `ix_auth_password_reset_expires_at` | B-tree | `expires_at` | 有効期限による検索 |

#### 特記事項

- トークンはランダムな文字列として生成
- 有効期限は通常24時間程度に設定
- 使用済みトークンも履歴として保持（セキュリティ監査用）
- 使用時のIPアドレスとユーザーエージェントも記録

### 2.9 auth_access_log テーブル

リソースへのアクセスログを記録するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.auth_access_log (
    id bigserial PRIMARY KEY,
    user_id integer,
    username varchar(50),
    session_id uuid,
    resource_type varchar(50) NOT NULL,
    resource_id varchar(100),
    action_type varchar(20) NOT NULL,
    access_datetime timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    ip_address inet,
    user_agent text,
    request_data jsonb,
    response_code smallint,
    processing_time integer,  -- ミリ秒
    CONSTRAINT ck_auth_access_log_action_type CHECK (
        action_type IN ('create', 'read', 'update', 'delete', 'execute', 'login', 'logout')
    )
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_auth_access_log` | PRIMARY KEY | `id` | 主キー |
| `ix_auth_access_log_user_id` | B-tree | `user_id` | ユーザー別検索 |
| `ix_auth_access_log_access_datetime` | B-tree | `access_datetime` | 日時順検索 |
| `ix_auth_access_log_resource_type` | B-tree | `resource_type` | リソースタイプ別検索 |
| `ix_auth_access_log_resource_id` | B-tree | `resource_id` | リソースID別検索 |
| `ix_auth_access_log_action_type` | B-tree | `action_type` | アクションタイプ別検索 |

#### 特記事項

- パーティショニング必須のテーブル（日付でのレンジパーティショニングを推奨）
- 高トラフィック時の書き込みパフォーマンスを考慮した設計
- 年月パーティションごとに適切なインデックスを作成
- 古いパーティションは定期的にアーカイブテーブルスペースに移動

## 3. クエリパターンと最適化

### 3.1 認証処理のクエリパターン

#### 3.1.1 ユーザーログイン認証

```sql
-- ユーザー認証（パスワード検証）
SELECT
    u.id,
    u.username,
    u.status,
    u.require_password_change,
    u.login_failure_count,
    u.account_locked_until
FROM common.auth_user u
WHERE u.username = $1
AND u.password_hash = crypt($2, u.password_hash)
AND u.status = 1
AND (u.account_locked_until IS NULL OR u.account_locked_until < CURRENT_TIMESTAMP);

-- 認証成功時のセッション作成
INSERT INTO common.auth_session
(user_id, token, ip_address, user_agent, expires_at)
VALUES
($1, $2, $3, $4, CURRENT_TIMESTAMP + interval '1 day')
RETURNING id, token, expires_at;

-- ログイン履歴の記録
INSERT INTO common.auth_login_history
(user_id, username, ip_address, user_agent, device_info, location_info, status)
VALUES
($1, $2, $3, $4, $5, $6, 'success');
```

#### 3.1.2 トークン検証

```sql
-- アクセストークン検証
SELECT
    s.id AS session_id,
    s.user_id,
    u.username,
    u.status,
    u.require_password_change
FROM common.auth_session s
JOIN common.auth_user u ON s.user_id = u.id
WHERE s.token = $1
AND s.expires_at > CURRENT_TIMESTAMP
AND s.revoked = false
AND u.status = 1;
```

### 3.2 権限チェックのクエリパターン

#### 3.2.1 ユーザーの権限確認

```sql
-- 特定リソースに対するユーザーの権限確認
SELECT EXISTS (
    SELECT 1
    FROM common.auth_user_role ur
    JOIN common.auth_role_permission rp ON ur.role_id = rp.role_id
    JOIN common.auth_permission p ON rp.permission_id = p.id
    WHERE ur.user_id = $1
    AND p.resource_type = $2
    AND p.action_type = $3
    AND (ur.expires_at IS NULL OR ur.expires_at > CURRENT_TIMESTAMP)
) AS has_permission;
```

#### 3.2.2 ユーザーのロール・権限一覧取得

```sql
-- ユーザーに付与されたロール一覧
SELECT
    r.id,
    r.code,
    r.name,
    r.description,
    ur.granted_at,
    ur.expires_at
FROM common.auth_role r
JOIN common.auth_user_role ur ON r.id = ur.role_id
WHERE ur.user_id = $1
AND (ur.expires_at IS NULL OR ur.expires_at > CURRENT_TIMESTAMP)
ORDER BY r.name;

-- ユーザーに付与された権限一覧（ロール経由）
SELECT DISTINCT
    p.id,
    p.code,
    p.name,
    p.resource_type,
    p.action_type
FROM common.auth_permission p
JOIN common.auth_role_permission rp ON p.id = rp.permission_id
JOIN common.auth_user_role ur ON rp.role_id = ur.role_id
WHERE ur.user_id = $1
AND (ur.expires_at IS NULL OR ur.expires_at > CURRENT_TIMESTAMP)
ORDER BY p.resource_type, p.action_type;
```

### 3.3 監査のクエリパターン

#### 3.3.1 ログイン履歴の分析

```sql
-- ユーザーごとのログイン失敗回数（過去24時間）
SELECT
    username,
    COUNT(*) AS failure_count
FROM common.auth_login_history
WHERE login_datetime > CURRENT_TIMESTAMP - interval '24 hours'
AND status = 'failure'
GROUP BY username
HAVING COUNT(*) >= 5
ORDER BY failure_count DESC;

-- 異常なログインパターン検出（複数の地域からのログイン）
SELECT
    user_id,
    username,
    COUNT(DISTINCT (location_info->>'country')) AS country_count
FROM common.auth_login_history
WHERE login_datetime > CURRENT_TIMESTAMP - interval '24 hours'
AND status = 'success'
GROUP BY user_id, username
HAVING COUNT(DISTINCT (location_info->>'country')) > 1
ORDER BY country_count DESC;
```

#### 3.3.2 アクセスログの分析

```sql
-- リソースタイプごとのアクセス数
SELECT
    resource_type,
    action_type,
    COUNT(*) AS access_count
FROM common.auth_access_log
WHERE access_datetime > CURRENT_TIMESTAMP - interval '7 days'
GROUP BY resource_type, action_type
ORDER BY access_count DESC;

-- ユーザーごとのアクセスパターン
SELECT
    username,
    resource_type,
    action_type,
    COUNT(*) AS access_count
FROM common.auth_access_log
WHERE access_datetime > CURRENT_TIMESTAMP - interval '7 days'
GROUP BY username, resource_type, action_type
ORDER BY username, access_count DESC;
```

## 4. データメンテナンス

### 4.1 定期メンテナンス処理

#### 4.1.1 セッションクリーンアップ

```sql
-- 期限切れセッションのクリーンアップ
DELETE FROM common.auth_session
WHERE expires_at < CURRENT_TIMESTAMP - interval '7 days'
OR (revoked = true AND revoked_at < CURRENT_TIMESTAMP - interval '7 days');
```

#### 4.1.2 パスワードリセットトークンクリーンアップ

```sql
-- 使用済み・期限切れパスワードリセットトークンのクリーンアップ
DELETE FROM common.auth_password_reset
WHERE (used_at IS NOT NULL AND used_at < CURRENT_TIMESTAMP - interval '30 days')
OR (expires_at < CURRENT_TIMESTAMP - interval '7 days');
```

#### 4.1.3 ログイン履歴のアーカイブ

```sql
-- 古いログイン履歴のアーカイブ（パーティションテーブルの使用を推奨）
INSERT INTO common.auth_login_history_archive
SELECT * FROM common.auth_login_history
WHERE login_datetime < CURRENT_TIMESTAMP - interval '90 days';

DELETE FROM common.auth_login_history
WHERE login_datetime < CURRENT_TIMESTAMP - interval '90 days';
```

#### 4.1.4 アクセスログのアーカイブ

```sql
-- 古いアクセスログのアーカイブ（パーティションテーブルの使用を推奨）
INSERT INTO common.auth_access_log_archive
SELECT * FROM common.auth_access_log
WHERE access_datetime < CURRENT_TIMESTAMP - interval '90 days';

DELETE FROM common.auth_access_log
WHERE access_datetime < CURRENT_TIMESTAMP - interval '90 days';
```

### 4.2 データ整合性チェック

```sql
-- 不整合な関連の検出と修正
-- 存在しないユーザーへの参照を持つユーザーロール関連
SELECT ur.user_id, ur.role_id
FROM common.auth_user_role ur
LEFT JOIN common.auth_user u ON ur.user_id = u.id
WHERE u.id IS NULL;

-- 存在しないロールへの参照を持つユーザーロール関連
SELECT ur.user_id, ur.role_id
FROM common.auth_user_role ur
LEFT JOIN common.auth_role r ON ur.role_id = r.id
WHERE r.id IS NULL;

-- 存在しないロールへの参照を持つロール権限関連
SELECT rp.role_id, rp.permission_id
FROM common.auth_role_permission rp
LEFT JOIN common.auth_role r ON rp.role_id = r.id
WHERE r.id IS NULL;

-- 存在しない権限への参照を持つロール権限関連
SELECT rp.role_id, rp.permission_id
FROM common.auth_role_permission rp
LEFT JOIN common.auth_permission p ON rp.permission_id = p.id
WHERE p.id IS NULL;
```

## 5. パフォーマンス最適化

### 5.1 特殊インデックス

#### 5.1.1 部分インデックス

```sql
-- アクティブユーザーのみを対象としたインデックス
CREATE INDEX ix_auth_user_active_username ON common.auth_user (username)
WHERE status = 1;

-- 未使用のセッションを対象としたインデックス
CREATE INDEX ix_auth_session_active ON common.auth_session (user_id, expires_at)
WHERE revoked = false AND expires_at > CURRENT_TIMESTAMP;
```

#### 5.1.2 式インデックス

```sql
-- メールアドレスを小文字変換したインデックス
CREATE INDEX ix_auth_user_lower_email ON common.auth_user (lower(email));

-- IPアドレスネットワークインデックス
CREATE INDEX ix_auth_login_history_ip_network ON common.auth_login_history (set_masklen(ip_address, 24));
```

### 5.2 テーブルパーティション

#### 5.2.1 アクセスログパーティション設計

```sql
-- アクセスログテーブルのパーティション設定
CREATE TABLE common.auth_access_log (
    id bigserial,
    user_id integer,
    username varchar(50),
    session_id uuid,
    resource_type varchar(50) NOT NULL,
    resource_id varchar(100),
    action_type varchar(20) NOT NULL,
    access_datetime timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    ip_address inet,
    user_agent text,
    request_data jsonb,
    response_code smallint,
    processing_time integer
) PARTITION BY RANGE (access_datetime);

-- 月次パーティションの作成例
CREATE TABLE common.auth_access_log_y2024m01 PARTITION OF common.auth_access_log
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE common.auth_access_log_y2024m02 PARTITION OF common.auth_access_log
FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');

-- パーティション自動作成関数
CREATE OR REPLACE FUNCTION common.create_access_log_partition_for_month()
RETURNS void AS $$
DECLARE
    next_month date;
    partition_name text;
    partition_start date;
    partition_end date;
BEGIN
    -- 2ヶ月先の月を計算
    next_month := date_trunc('month', current_date + interval '2 month');
    
    -- パーティション名の生成
    partition_name := 'auth_access_log_y' || to_char(next_month, 'YYYY') || 'm' || to_char(next_month, 'MM');
    
    -- パーティション範囲の計算
    partition_start := next_month;
    partition_end := next_month + interval '1 month';
    
    -- パーティションが存在しないか確認
    IF NOT EXISTS (
        SELECT 1 FROM pg_class c
        JOIN pg_namespace n ON n.oid = c.relnamespace
        WHERE n.nspname = 'common' AND c.relname = partition_name
    ) THEN
        -- パーティション作成
        EXECUTE format(
            'CREATE TABLE common.%I PARTITION OF common.auth_access_log FOR VALUES FROM (%L) TO (%L)',
            partition_name, partition_start, partition_end
        );
        
        -- パーティション用インデックス作成
        EXECUTE format(
            'CREATE INDEX ix_%I_user_id ON common.%I (user_id)',
            partition_name, partition_name
        );
        
        EXECUTE format(
            'CREATE INDEX ix_%I_access_datetime ON common.%I (access_datetime)',
            partition_name, partition_name
        );
        
        EXECUTE format(
            'CREATE INDEX ix_%I_resource_action ON common.%I (resource_type, action_type)',
            partition_name, partition_name
        );
        
        RAISE NOTICE 'Created partition: common.%', partition_name;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- 毎月1日に実行（pg_cron拡張を使用）
SELECT cron.schedule('0 0 1 * *', $$SELECT common.create_access_log_partition_for_month()$$);
```

### 5.3 データキャッシュ最適化

#### 5.3.1 マテリアライズドビュー

```sql
-- ユーザー権限キャッシュ用マテリアライズドビュー
CREATE MATERIALIZED VIEW common.mv_user_permissions AS
SELECT
    ur.user_id,
    array_agg(DISTINCT p.code) AS permission_codes,
    array_agg(DISTINCT concat(p.resource_type, '.', p.action_type)) AS resource_actions,
    array_agg(DISTINCT r.code) AS role_codes
FROM common.auth_user_role ur
JOIN common.auth_role r ON ur.role_id = r.id
JOIN common.auth_role_permission rp ON r.id = rp.role_id
JOIN common.auth_permission p ON rp.permission_id = p.id
WHERE (ur.expires_at IS NULL OR ur.expires_at > CURRENT_TIMESTAMP)
GROUP BY ur.user_id;

CREATE UNIQUE INDEX uix_mv_user_permissions ON common.mv_user_permissions (user_id);

-- 定期更新（1時間ごと）
CREATE OR REPLACE FUNCTION common.refresh_user_permissions_mv()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY common.mv_user_permissions;
END;
$$ LANGUAGE plpgsql;

SELECT cron.schedule('0 * * * *', $$SELECT common.refresh_user_permissions_mv()$$);
```

#### 5.3.2 関数インデックス

```sql
-- パスワードポリシー関数
CREATE OR REPLACE FUNCTION common.check_password_strength(password text)
RETURNS boolean AS $$
BEGIN
    -- 長さチェック
    IF length(password) < 8 THEN
        RETURN false;
    END IF;
    
    -- 大文字小文字数字特殊文字の組み合わせチェック
    IF NOT (
        password ~ '[A-Z]' AND
        password ~ '[a-z]' AND
        password ~ '[0-9]' AND
        password ~ '[!@#$%^&*(),.?":{}|<>]'
    ) THEN
        RETURN false;
    END IF;
    
    RETURN true;
END;
$$ LANGUAGE plpgsql;

-- パスワード変更関数
CREATE OR REPLACE FUNCTION common.change_user_password(
    p_user_id integer,
    p_old_password text,
    p_new_password text
)
RETURNS boolean AS $$
DECLARE
    v_password_hash text;
    v_valid boolean;
BEGIN
    -- 現在のパスワードを検証
    SELECT password_hash INTO v_password_hash
    FROM common.auth_user
    WHERE id = p_user_id;
    
    IF v_password_hash IS NULL OR v_password_hash != crypt(p_old_password, v_password_hash) THEN
        RETURN false;
    END IF;
    
    -- 新しいパスワードの強度チェック
    v_valid := common.check_password_strength(p_new_password);
    IF NOT v_valid THEN
        RETURN false;
    END IF;
    
    -- パスワード更新
    UPDATE common.auth_user
    SET password_hash = crypt(p_new_password, gen_salt('bf', 10)),
        last_password_change = CURRENT_TIMESTAMP,
        require_password_change = false,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_user_id;
    
    RETURN true;
END;
$$ LANGUAGE plpgsql;
```

## 6. セキュリティ考慮事項

### 6.1 データ暗号化

#### 6.1.1 パスワードハッシュ化

```sql
-- パスワードのハッシュ化と検証
-- ユーザー作成時
INSERT INTO common.auth_user 
(username, password_hash, email, first_name, last_name, status)
VALUES 
($1, crypt($2, gen_salt('bf', 10)), $3, $4, $5, 1);

-- パスワード検証時
SELECT EXISTS (
    SELECT 1 FROM common.auth_user
    WHERE username = $1
    AND password_hash = crypt($2, password_hash)
) AS valid_password;
```

#### 6.1.2 セッショントークン生成

```sql
-- JWTトークンの生成（pgcrypto拡張を使用）
CREATE OR REPLACE FUNCTION common.generate_jwt_token(
    p_user_id integer,
    p_username text,
    p_expires_in interval DEFAULT interval '1 day'
)
RETURNS text AS $$
DECLARE
    v_secret text := current_setting('app.jwt_secret');
    v_algorithm text := 'HS256';
    v_header jsonb;
    v_payload jsonb;
    v_header_encoded text;
    v_payload_encoded text;
    v_signature text;
BEGIN
    -- JWTヘッダー
    v_header := jsonb_build_object(
        'alg', v_algorithm,
        'typ', 'JWT'
    );
    
    -- JWTペイロード
    v_payload := jsonb_build_object(
        'sub', p_user_id,
        'name', p_username,
        'iat', extract(epoch from now())::integer,
        'exp', extract(epoch from now() + p_expires_in)::integer,
        'jti', gen_random_uuid()::text
    );
    
    -- Base64urlエンコーディング
    v_header_encoded := replace(replace(encode(v_header::text::bytea, 'base64'), '+', '-'), '/', '_');
    v_payload_encoded := replace(replace(encode(v_payload::text::bytea, 'base64'), '+', '-'), '/', '_');
    
    -- 署名の作成
    v_signature := replace(replace(
        encode(
            hmac(v_header_encoded || '.' || v_payload_encoded, 
                v_secret::bytea, v_algorithm),
            'base64'
        ),
        '+', '-'),
        '/', '_'
    );
    
    -- JWTトークンの組み立て
    RETURN v_header_encoded || '.' || v_payload_encoded || '.' || v_signature;
END;
$$ LANGUAGE plpgsql;
```

### 6.2 アクセス制御関数

```sql
-- リソースへのアクセス権限チェック関数
CREATE OR REPLACE FUNCTION common.check_user_permission(
    p_user_id integer,
    p_resource_type text,
    p_action_type text
)
RETURNS boolean AS $$
DECLARE
    v_has_permission boolean;
BEGIN
    -- キャッシュマテリアライズドビューからチェック（高速）
    SELECT EXISTS (
        SELECT 1
        FROM common.mv_user_permissions
        WHERE user_id = p_user_id
        AND (
            -- リソースアクション形式での検索
            concat(p_resource_type, '.', p_action_type) = ANY(resource_actions)
            -- または全アクセス権限を持つ場合
            OR concat(p_resource_type, '.', 'all') = ANY(resource_actions)
            OR concat('*', '.', p_action_type) = ANY(resource_actions)
            OR '*.*' = ANY(resource_actions)
        )
    ) INTO v_has_permission;
    
    -- キャッシュミス時は直接検索
    IF v_has_permission IS NULL THEN
        SELECT EXISTS (
            SELECT 1
            FROM common.auth_user_role ur
            JOIN common.auth_role_permission rp ON ur.role_id = rp.role_id
            JOIN common.auth_permission p ON rp.permission_id = p.id
            WHERE ur.user_id = p_user_id
            AND (
                (p.resource_type = p_resource_type AND p.action_type = p_action_type)
                OR (p.resource_type = p_resource_type AND p.action_type = 'all')
                OR (p.resource_type = '*' AND p.action_type = p_action_type)
                OR (p.resource_type = '*' AND p.action_type = 'all')
            )
            AND (ur.expires_at IS NULL OR ur.expires_at > CURRENT_TIMESTAMP)
        ) INTO v_has_permission;
    END IF;
    
    -- アクセスログの記録
    INSERT INTO common.auth_access_log
    (user_id, resource_type, resource_id, action_type, access_datetime)
    VALUES
    (p_user_id, p_resource_type, NULL, p_action_type, CURRENT_TIMESTAMP);
    
    RETURN COALESCE(v_has_permission, false);
END;
$$ LANGUAGE plpgsql;
```

### 6.3 監査ログトリガー

```sql
-- ユーザー変更の監査ログトリガー
CREATE OR REPLACE FUNCTION common.auth_user_audit_trigger()
RETURNS trigger AS $$
BEGIN
    IF (TG_OP = 'UPDATE') THEN
        INSERT INTO common.auth_audit_log
        (user_id, action_type, table_name, record_id, old_data, new_data, changed_by)
        VALUES
        (NEW.id, 'UPDATE', 'auth_user', NEW.id, 
         jsonb_build_object(
            'username', OLD.username,
            'email', OLD.email,
            'status', OLD.status,
            'require_password_change', OLD.require_password_change
         ),
         jsonb_build_object(
            'username', NEW.username,
            'email', NEW.email,
            'status', NEW.status,
            'require_password_change', NEW.require_password_change
         ),
         NEW.updated_by);
    ELSIF (TG_OP = 'INSERT') THEN
        INSERT INTO common.auth_audit_log
        (user_id, action_type, table_name, record_id, old_data, new_data, changed_by)
        VALUES
        (NEW.id, 'INSERT', 'auth_user', NEW.id, 
         NULL,
         jsonb_build_object(
            'username', NEW.username,
            'email', NEW.email,
            'status', NEW.status,
            'require_password_change', NEW.require_password_change
         ),
         NEW.created_by);
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER auth_user_audit
AFTER INSERT OR UPDATE ON common.auth_user
FOR EACH ROW EXECUTE FUNCTION common.auth_user_audit_trigger();
```

## 7. 運用時の注意点

1. **セキュリティ更新**: パスワードハッシュアルゴリズムや暗号化方法は定期的に見直し、より強力な方式への移行を検討する。

2. **パフォーマンス監視**: ログインピーク時のパフォーマンスを特に注視し、必要に応じてコネクションプールやキャッシュ設定を調整する。

3. **監査ログの容量管理**: アクセスログやログイン履歴は成長が早いため、パーティショニングと定期的なアーカイブを確実に実施する。

4. **権限管理の複雑さ制御**: ロールと権限の構造が複雑になりすぎないよう、定期的な見直しと整理を行う。

5. **緊急アクセス手段の確保**: システム管理者のアカウントロックアウト対策として、バックドアアクセス手段を安全に確保しておく。

6. **不正アクセス監視の自動化**: 異常なログインパターンや権限昇格の試みを検出する自動監視の仕組みを導入する。