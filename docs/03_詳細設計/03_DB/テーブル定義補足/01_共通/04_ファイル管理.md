# 共通モジュール - ファイル管理テーブル定義補足

## 1. テーブル概要

ファイル管理モジュールは、システム全体で使用されるファイルの保存、メタデータ管理、アクセス制御を担当する共通基盤です。このモジュールでは、契約書、提案書、スキルシート、請求書などの様々なファイルを一元管理します。

### 1.1 テーブル一覧

| テーブル名 | 説明 | 主要列 |
|----------|------|-------|
| `common.file_storage` | ファイルストレージ情報 | `id`, `file_name`, `original_name`, `content_type`, `size`, `storage_path` |
| `common.file_metadata` | ファイルメタデータ | `id`, `file_id`, `metadata_key`, `metadata_value` |
| `common.file_category` | ファイルカテゴリ | `id`, `category_name`, `description` |
| `common.file_tag` | ファイルタグ | `id`, `tag_name` |
| `common.file_tag_rel` | ファイルとタグの関連 | `file_id`, `tag_id` |
| `common.file_version` | ファイルバージョン | `id`, `file_id`, `version_number`, `created_at`, `created_by` |
| `common.file_access` | ファイルアクセス記録 | `id`, `file_id`, `user_id`, `access_type`, `access_datetime` |

## 2. 主要テーブル詳細

### 2.1 file_storage テーブル

ファイルの基本情報とストレージ場所を管理するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.file_storage (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    file_name varchar(255) NOT NULL,
    original_name varchar(255) NOT NULL,
    content_type varchar(100) NOT NULL,
    size bigint NOT NULL,
    storage_path varchar(500) NOT NULL,
    storage_type varchar(20) NOT NULL DEFAULT 'local',
    category_id integer REFERENCES common.file_category(id),
    checksum varchar(64),
    is_public boolean NOT NULL DEFAULT false,
    status smallint NOT NULL DEFAULT 1,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer REFERENCES common.user(id),
    updated_at timestamptz,
    updated_by integer REFERENCES common.user(id),
    deleted_at timestamptz,
    deleted_by integer REFERENCES common.user(id),
    CONSTRAINT ck_file_storage_status CHECK (status IN (0, 1, 2, 9)), -- 0:無効, 1:有効, 2:一時停止, 9:削除
    CONSTRAINT ck_file_storage_type CHECK (storage_type IN ('local', 's3', 'azure', 'gcs'))
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_file_storage` | PRIMARY KEY | `id` | 主キー |
| `ix_file_storage_file_name` | B-tree | `file_name` | ファイル名による検索 |
| `ix_file_storage_category_id` | B-tree | `category_id` | カテゴリによる検索 |
| `ix_file_storage_created_at` | B-tree | `created_at` | 作成日時による検索 |
| `ix_file_storage_status` | B-tree | `status` | ステータスによる検索 |

#### 特記事項

- ファイルIDにはUUID v4を使用し、予測不可能性を確保
- ストレージパスは実際のファイルの格納場所を示すパス（S3バケット内のパスなど）
- チェックサムはSHA-256ハッシュ値を格納し、ファイル整合性検証に使用
- 論理削除方式を採用（`deleted_at`, `deleted_by`で削除情報を管理）

### 2.2 file_metadata テーブル

ファイルに関連する追加メタデータを格納するテーブル。柔軟なキーバリュー形式で様々な属性を保存できます。

#### テーブル定義

```sql
CREATE TABLE common.file_metadata (
    id serial PRIMARY KEY,
    file_id uuid NOT NULL REFERENCES common.file_storage(id),
    metadata_key varchar(100) NOT NULL,
    metadata_value text,
    metadata_type varchar(20) DEFAULT 'string',
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer REFERENCES common.user(id),
    updated_at timestamptz,
    updated_by integer REFERENCES common.user(id),
    CONSTRAINT ck_file_metadata_type CHECK (metadata_type IN ('string', 'number', 'date', 'boolean', 'json'))
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_file_metadata` | PRIMARY KEY | `id` | 主キー |
| `ix_file_metadata_file_id` | B-tree | `file_id` | ファイルIDによる検索 |
| `ix_file_metadata_key` | B-tree | `metadata_key` | メタデータキーによる検索 |
| `ix_file_metadata_key_value` | B-tree | `metadata_key`, `metadata_value` | キーと値の組み合わせによる検索 |

#### 特記事項

- メタデータキーの例: `description`, `author`, `expiry_date`, `document_number`など
- 値の型を`metadata_type`で管理し、アプリケーション層での適切な型変換をサポート
- JSONメタデータは`metadata_type='json'`として保存可能

### 2.3 file_category テーブル

ファイルのカテゴリを管理するマスタテーブル。

#### テーブル定義

```sql
CREATE TABLE common.file_category (
    id serial PRIMARY KEY,
    category_name varchar(100) NOT NULL UNIQUE,
    description text,
    parent_id integer REFERENCES common.file_category(id),
    max_file_size bigint,
    allowed_extensions text[],
    retention_period interval,
    is_system boolean NOT NULL DEFAULT false,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer REFERENCES common.user(id),
    updated_at timestamptz,
    updated_by integer REFERENCES common.user(id)
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_file_category` | PRIMARY KEY | `id` | 主キー |
| `uix_file_category_name` | UNIQUE | `category_name` | カテゴリ名一意性 |
| `ix_file_category_parent_id` | B-tree | `parent_id` | 親カテゴリによる検索 |

#### 特記事項

- 階層構造をサポート（親カテゴリへの参照）
- カテゴリごとに許可されるファイルサイズや拡張子を制限可能
- 保持期間設定により自動アーカイブ/削除ポリシーの実装が可能
- システムカテゴリフラグによりシステム運用に必須のカテゴリを保護

### 2.4 file_tag / file_tag_rel テーブル

ファイルに付与できるタグとファイルとタグの関連を管理するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.file_tag (
    id serial PRIMARY KEY,
    tag_name varchar(50) NOT NULL UNIQUE,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer REFERENCES common.user(id)
);

CREATE TABLE common.file_tag_rel (
    file_id uuid NOT NULL REFERENCES common.file_storage(id),
    tag_id integer NOT NULL REFERENCES common.file_tag(id),
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer REFERENCES common.user(id),
    PRIMARY KEY (file_id, tag_id)
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_file_tag` | PRIMARY KEY | `id` | 主キー |
| `uix_file_tag_name` | UNIQUE | `tag_name` | タグ名一意性 |
| `pk_file_tag_rel` | PRIMARY KEY | `file_id`, `tag_id` | 主キー（複合） |
| `ix_file_tag_rel_tag_id` | B-tree | `tag_id` | タグIDによる検索 |

#### 特記事項

- タグは自由なラベル付けを可能にし、横断的なファイル分類をサポート
- ファイルとタグの多対多関連を実現

### 2.5 file_version テーブル

ファイルのバージョン履歴を管理するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.file_version (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    file_id uuid NOT NULL REFERENCES common.file_storage(id),
    version_number integer NOT NULL,
    storage_path varchar(500) NOT NULL,
    size bigint NOT NULL,
    checksum varchar(64),
    change_comment text,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer REFERENCES common.user(id)
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_file_version` | PRIMARY KEY | `id` | 主キー |
| `ix_file_version_file_id` | B-tree | `file_id` | ファイルIDによる検索 |
| `uix_file_version_file_version` | UNIQUE | `file_id`, `version_number` | ファイルとバージョンの一意性 |
| `ix_file_version_created_at` | B-tree | `created_at` | 作成日時による検索 |

#### 特記事項

- 各バージョンは独立したストレージパスを持ち、過去のバージョンを保持
- バージョン番号は1から始まる連番
- チェックサムでファイル内容の一致を確認可能

### 2.6 file_access テーブル

ファイルへのアクセス記録を管理するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.file_access (
    id bigserial PRIMARY KEY,
    file_id uuid NOT NULL REFERENCES common.file_storage(id),
    user_id integer REFERENCES common.user(id),
    access_type varchar(20) NOT NULL,
    access_datetime timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    ip_address inet,
    user_agent text,
    CONSTRAINT ck_file_access_type CHECK (access_type IN ('view', 'download', 'edit', 'delete', 'share'))
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_file_access` | PRIMARY KEY | `id` | 主キー |
| `ix_file_access_file_id` | B-tree | `file_id` | ファイルIDによる検索 |
| `ix_file_access_user_id` | B-tree | `user_id` | ユーザーIDによる検索 |
| `ix_file_access_datetime` | B-tree | `access_datetime` | 日時による検索 |
| `ix_file_access_type` | B-tree | `access_type` | アクセスタイプによる検索 |

#### 特記事項

- 監査目的でのアクセスログを記録
- ファイルの閲覧、ダウンロード、編集、削除、共有などの操作を追跡
- パーティショニング候補テーブル（日付でのパーティショニングを推奨）

## 3. クエリパターンと最適化

### 3.1 ファイル検索クエリパターン

#### 3.1.1 カテゴリとタグによる検索

```sql
-- カテゴリとタグの組み合わせでファイルを検索
SELECT DISTINCT f.*
FROM common.file_storage f
LEFT JOIN common.file_tag_rel ftr ON f.id = ftr.file_id
LEFT JOIN common.file_tag ft ON ftr.tag_id = ft.id
WHERE f.category_id = $1
AND f.status = 1
AND ft.tag_name IN ('重要', '契約書', '2025年度')
ORDER BY f.created_at DESC;

-- メタデータ条件も加えた検索
SELECT f.*
FROM common.file_storage f
JOIN common.file_metadata fm ON f.id = fm.file_id
WHERE f.category_id = $1
AND f.status = 1
AND fm.metadata_key = 'customer_id' 
AND fm.metadata_value = $2
ORDER BY f.created_at DESC;
```

#### 3.1.2 全文検索との連携

```sql
-- ファイル名とメタデータを含む検索（tsvector使用）
SELECT f.*
FROM common.file_storage f
LEFT JOIN common.file_metadata fm ON f.id = fm.file_id
WHERE f.status = 1
AND (
    to_tsvector('japanese', f.file_name || ' ' || f.original_name) @@ to_tsquery('japanese', $1)
    OR EXISTS (
        SELECT 1 FROM common.file_metadata
        WHERE file_id = f.id
        AND to_tsvector('japanese', metadata_value) @@ to_tsquery('japanese', $1)
    )
)
ORDER BY f.created_at DESC;
```

### 3.2 ファイル操作クエリパターン

#### 3.2.1 新規バージョン作成

```sql
-- 最新バージョン番号の取得
SELECT COALESCE(MAX(version_number), 0) + 1 AS next_version
FROM common.file_version
WHERE file_id = $1;

-- 新バージョン登録
INSERT INTO common.file_version
(file_id, version_number, storage_path, size, checksum, change_comment, created_by)
VALUES
($1, $2, $3, $4, $5, $6, $7)
RETURNING id, version_number;

-- ファイルストレージ情報更新
UPDATE common.file_storage
SET storage_path = $1, size = $2, checksum = $3, updated_at = CURRENT_TIMESTAMP, updated_by = $4
WHERE id = $5;
```

#### 3.2.2 ファイルアクセス記録

```sql
-- ファイルダウンロード時のアクセスログ記録
INSERT INTO common.file_access
(file_id, user_id, access_type, ip_address, user_agent)
VALUES
($1, $2, 'download', $3, $4);
```

## 4. データメンテナンス

### 4.1 定期メンテナンス処理

#### 4.1.1 一時ファイルのクリーンアップ

```sql
-- 未使用一時ファイルの削除（24時間以上経過したもの）
WITH deleted_files AS (
    UPDATE common.file_storage
    SET status = 9, deleted_at = CURRENT_TIMESTAMP, deleted_by = NULL
    WHERE category_id = (SELECT id FROM common.file_category WHERE category_name = 'temporary')
    AND created_at < CURRENT_TIMESTAMP - interval '24 hours'
    AND status = 1
    RETURNING id, storage_path, storage_type
)
SELECT * FROM deleted_files;
-- 戻り値を使用して物理ファイルを削除するバッチ処理を実行
```

#### 4.1.2 保持期間が過ぎたファイルのアーカイブ

```sql
-- 保持期間を超過したファイルのアーカイブ対象を特定
SELECT f.id, f.storage_path, f.storage_type, fc.retention_period
FROM common.file_storage f
JOIN common.file_category fc ON f.category_id = fc.id
WHERE f.status = 1
AND fc.retention_period IS NOT NULL
AND f.created_at + fc.retention_period < CURRENT_TIMESTAMP
AND NOT EXISTS (
    -- 法的保持対象は除外
    SELECT 1 FROM common.file_metadata
    WHERE file_id = f.id
    AND metadata_key = 'legal_hold'
    AND metadata_value = 'true'
);
```

### 4.2 ファイル整合性チェック

```sql
-- チェックサムが一致しないファイルの検出
SELECT fs.id, fs.file_name, fs.storage_path, fs.checksum AS stored_checksum, 
       $1 AS actual_checksum  -- アプリケーションから算出された実際のチェックサム
FROM common.file_storage fs
WHERE fs.id = $2
AND fs.checksum != $1;

-- 存在しない親カテゴリへの参照を持つカテゴリの検出
SELECT c.id, c.category_name, c.parent_id
FROM common.file_category c
LEFT JOIN common.file_category p ON c.parent_id = p.id
WHERE c.parent_id IS NOT NULL AND p.id IS NULL;
```

## 5. パフォーマンス最適化

### 5.1 特殊インデックス

#### 5.1.1 GINインデックス

```sql
-- メタデータ値のGINインデックス（JSONB型に変換して内容検索を効率化）
CREATE INDEX gin_file_metadata_value ON common.file_metadata 
USING GIN ((metadata_value::jsonb)) 
WHERE metadata_type = 'json';

-- ファイル名の全文検索用インデックス
CREATE INDEX gin_file_storage_name ON common.file_storage 
USING GIN (to_tsvector('japanese', file_name || ' ' || original_name));
```

#### 5.1.2 部分インデックス

```sql
-- 有効なファイルのみを対象とするインデックス
CREATE INDEX ix_file_storage_active_category ON common.file_storage (category_id)
WHERE status = 1;

-- 特定カテゴリのファイルに特化したインデックス
CREATE INDEX ix_file_storage_contract_docs ON common.file_storage (created_at)
WHERE category_id = (SELECT id FROM common.file_category WHERE category_name = 'contract_documents')
AND status = 1;
```

### 5.2 アクセスログパーティション設計

```sql
-- アクセスログテーブルのパーティション設定
CREATE TABLE common.file_access (
    id bigserial,
    file_id uuid NOT NULL,
    user_id integer,
    access_type varchar(20) NOT NULL,
    access_datetime timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    ip_address inet,
    user_agent text,
    CONSTRAINT ck_file_access_type CHECK (access_type IN ('view', 'download', 'edit', 'delete', 'share'))
) PARTITION BY RANGE (access_datetime);

-- 月次パーティションの作成例
CREATE TABLE common.file_access_y2024m01 PARTITION OF common.file_access
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE common.file_access_y2024m02 PARTITION OF common.file_access
FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
```

## 6. セキュリティ考慮事項

### 6.1 ファイルパス保護

ストレージパスには直接アクセスできないようにする設計を採用しています。すべてのファイルアクセスはアプリケーション層を介して行われ、アクセス権のチェックが行われます。

ファイル名の生成には以下のような関数を使用します：

```sql
-- セキュアなファイル名生成関数
CREATE OR REPLACE FUNCTION common.generate_secure_filename(
    original_name text,
    category_id integer
)
RETURNS text AS $$
DECLARE
    base_name text;
    extension text;
    random_part text;
    result text;
BEGIN
    -- 拡張子とベース名を分離
    extension := substring(original_name from '\.([^\.]+)$');
    
    -- 拡張子がない場合の対応
    IF extension IS NULL THEN
        base_name := original_name;
        extension := '';
    ELSE
        base_name := substring(original_name from '^(.+)\.[^\.]+$');
        extension := '.' || extension;
    END IF;
    
    -- ランダムな文字列生成
    random_part := encode(gen_random_bytes(8), 'hex');
    
    -- ファイル名構築（カテゴリID_タイムスタンプ_ランダム.拡張子）
    result := category_id || '_' || 
              to_char(CURRENT_TIMESTAMP, 'YYYYMMDD_HH24MISS') || '_' || 
              random_part || extension;
              
    RETURN result;
END;
$$ LANGUAGE plpgsql;
```

### 6.2 アクセス制御関数

```sql
-- ファイルアクセス権限チェック関数
CREATE OR REPLACE FUNCTION common.check_file_access_permission(
    p_file_id uuid,
    p_user_id integer,
    p_access_type text
)
RETURNS boolean AS $$
DECLARE
    v_has_permission boolean;
    v_file_status smallint;
    v_is_owner boolean;
    v_is_public boolean;
BEGIN
    -- ファイル基本情報チェック
    SELECT 
        status,
        is_public,
        created_by = p_user_id
    INTO
        v_file_status,
        v_is_public,
        v_is_owner
    FROM common.file_storage
    WHERE id = p_file_id;
    
    -- ファイルが存在しないか削除済み
    IF v_file_status IS NULL OR v_file_status = 9 THEN
        RETURN false;
    END IF;
    
    -- 公開ファイルの場合、view,downloadは許可
    IF v_is_public AND p_access_type IN ('view', 'download') THEN
        RETURN true;
    END IF;
    
    -- ファイル所有者は全権限を持つ
    IF v_is_owner THEN
        RETURN true;
    END IF;
    
    -- 権限チェック（別途、role_permissionから権限を確認）
    SELECT EXISTS (
        SELECT 1
        FROM common.auth_user_role ur
        JOIN common.auth_role_permission rp ON ur.role_id = rp.role_id
        JOIN common.auth_permission p ON rp.permission_id = p.id
        WHERE ur.user_id = p_user_id
        AND p.resource_type = 'file'
        AND p.action_type IN (p_access_type, 'all')
    ) INTO v_has_permission;
    
    -- アクセスログ記録
    INSERT INTO common.file_access
    (file_id, user_id, access_type, access_datetime)
    VALUES
    (p_file_id, p_user_id, p_access_type, CURRENT_TIMESTAMP);
    
    RETURN COALESCE(v_has_permission, false);
END;
$$ LANGUAGE plpgsql;
```

## 7. 運用時の注意点

1. **ストレージ容量管理**: ファイルの増加に伴うストレージ容量を定期的に監視し、適切なクリーンアップポリシーを実施する。

2. **バックアップ戦略**: ファイルデータはデータベースとは別にバックアップする必要がある。ストレージシステム（S3等）のバックアップと、データベースのメタデータバックアップを同期して行う。

3. **アクセスパターン監視**: 頻繁にアクセスされるファイルを特定し、キャッシュ戦略やCDN利用を検討する。

4. **ウイルススキャン**: アップロードされるファイルは適切なウイルス対策ソフトでスキャンする仕組みを導入する。

5. **法的保持対応**: 法的要件によるファイル保持ポリシーを定期的に見直し、対象ファイルには適切なメタデータフラグを設定する。