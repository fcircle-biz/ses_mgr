# 共通モジュール - ユーザー管理テーブル定義補足

## 1. テーブル概要

ユーザー管理モジュールは、システム利用者のプロファイル情報、組織構造、役職情報、および操作履歴を管理する機能を提供する。認証認可モジュールと密接に連携し、SES管理システム全体のユーザー情報基盤を構成する。

### 1.1 テーブル一覧

| テーブル名 | 説明 | 主要列 |
|----------|------|-------|
| `common.user_profile` | ユーザープロファイル情報 | `user_id`, `department_id`, `job_title_id`, `profile_image_id` |
| `common.department` | 組織・部署情報 | `id`, `parent_id`, `name`, `code`, `manager_id` |
| `common.job_title` | 役職定義 | `id`, `name`, `rank`, `description` |
| `common.user_contact` | ユーザー連絡先情報 | `id`, `user_id`, `contact_type`, `contact_value` |
| `common.user_preference` | ユーザー設定情報 | `user_id`, `preference_key`, `preference_value` |
| `common.user_tag` | ユーザーに付与されたタグ | `user_id`, `tag_id` |
| `common.tag` | タグマスター | `id`, `name`, `category`, `color` |
| `common.user_activity` | ユーザーアクティビティ | `id`, `user_id`, `activity_type`, `activity_data` |
| `common.user_relationship` | ユーザー間関係定義 | `id`, `from_user_id`, `to_user_id`, `relationship_type` |

## 2. 主要テーブル詳細

### 2.1 user_profile テーブル

ユーザーのプロファイル情報を格納するテーブル。auth_userとの1:1関連を持つ。

#### テーブル定義

```sql
CREATE TABLE common.user_profile (
    user_id integer PRIMARY KEY REFERENCES common.auth_user(id),
    department_id integer REFERENCES common.department(id),
    job_title_id integer REFERENCES common.job_title(id),
    profile_image_id integer REFERENCES common.file_storage(id),
    display_name varchar(100),
    employee_code varchar(20),
    hire_date date,
    birth_date date,
    gender varchar(1),
    tel_number varchar(20),
    mobile_number varchar(20),
    postal_code varchar(10),
    address1 varchar(100),
    address2 varchar(100),
    bio text,
    note text,
    is_admin boolean NOT NULL DEFAULT false,
    is_manager boolean NOT NULL DEFAULT false,
    employment_type varchar(20),
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer,
    updated_at timestamptz,
    updated_by integer,
    CONSTRAINT ck_user_profile_gender CHECK (gender IN ('M', 'F', 'O'))
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_user_profile` | PRIMARY KEY | `user_id` | 主キー |
| `ix_user_profile_department` | B-tree | `department_id` | 部署別検索 |
| `ix_user_profile_job_title` | B-tree | `job_title_id` | 役職別検索 |
| `ix_user_profile_hire_date` | B-tree | `hire_date` | 入社日順検索 |
| `ix_user_profile_employment_type` | B-tree | `employment_type` | 雇用形態別検索 |
| `ix_user_profile_admin_manager` | B-tree | `is_admin`, `is_manager` | 管理者・マネージャー検索 |

#### 特記事項

- ユーザーの業務上の役割と個人プロファイルを管理
- システム全体の管理者フラグを持ち、特権操作の権限判定に使用
- 組織上のマネージャー役割フラグを持ち、承認フロー等で使用
- プロフィール画像はファイル管理モジュールを参照
- 個人情報（生年月日、住所等）は必要に応じて暗号化も検討

### 2.2 department テーブル

組織構造を表現するテーブル。階層構造をself-referenceで表現。

#### テーブル定義

```sql
CREATE TABLE common.department (
    id serial PRIMARY KEY,
    parent_id integer REFERENCES common.department(id),
    name varchar(100) NOT NULL,
    code varchar(20) NOT NULL UNIQUE,
    manager_id integer REFERENCES common.auth_user(id),
    description text,
    display_order integer NOT NULL DEFAULT 0,
    path ltree, -- 階層パス表現（PostgreSQLのltree拡張使用）
    is_active boolean NOT NULL DEFAULT true,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer,
    updated_at timestamptz,
    updated_by integer
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_department` | PRIMARY KEY | `id` | 主キー |
| `uix_department_code` | UNIQUE | `code` | 部署コード一意性 |
| `ix_department_parent` | B-tree | `parent_id` | 親部署検索 |
| `ix_department_manager` | B-tree | `manager_id` | 部署マネージャー検索 |
| `ix_department_active` | B-tree | `is_active` | 有効部署のみ検索 |
| `ix_department_path` | GiST | `path` | 階層検索（ltree用） |

#### 特記事項

- 階層構造表現にはPostgreSQLのltree拡張を活用
- 部署間の親子関係をパス形式で効率的に検索可能
- 部署コードはシステム内での一意識別子として使用
- トリガーで部署パスの自動更新を実装
- 部署一覧や組織図表示のソート順を表示順で制御

### 2.3 job_title テーブル

役職の定義を管理するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.job_title (
    id serial PRIMARY KEY,
    name varchar(50) NOT NULL UNIQUE,
    code varchar(20) NOT NULL UNIQUE,
    rank integer NOT NULL, -- 序列（昇順）
    description text,
    is_active boolean NOT NULL DEFAULT true,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer,
    updated_at timestamptz,
    updated_by integer
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_job_title` | PRIMARY KEY | `id` | 主キー |
| `uix_job_title_name` | UNIQUE | `name` | 役職名一意性 |
| `uix_job_title_code` | UNIQUE | `code` | 役職コード一意性 |
| `ix_job_title_rank` | B-tree | `rank` | 役職序列検索 |
| `ix_job_title_active` | B-tree | `is_active` | 有効役職のみ検索 |

#### 特記事項

- ランク値は役職の序列を示し、承認フローなどで使用
- 組織変更時の役職名変更にも対応できるよう履歴設計も考慮
- 同一ランクの複数役職も許容する設計

### 2.4 user_contact テーブル

ユーザーの連絡先情報を管理するテーブル。複数種類の連絡先を登録可能。

#### テーブル定義

```sql
CREATE TABLE common.user_contact (
    id serial PRIMARY KEY,
    user_id integer NOT NULL REFERENCES common.auth_user(id),
    contact_type varchar(20) NOT NULL,
    contact_value varchar(255) NOT NULL,
    is_primary boolean NOT NULL DEFAULT false,
    is_verified boolean NOT NULL DEFAULT false,
    verified_at timestamptz,
    verification_code varchar(64),
    label varchar(50),
    note text,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer,
    updated_at timestamptz,
    updated_by integer,
    CONSTRAINT ck_user_contact_type CHECK (contact_type IN ('email', 'phone', 'mobile', 'fax', 'address', 'other')),
    CONSTRAINT uq_user_contact_primary UNIQUE (user_id, contact_type, is_primary) 
    DEFERRABLE INITIALLY DEFERRED -- 主連絡先の切り替え処理を容易にするため
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_user_contact` | PRIMARY KEY | `id` | 主キー |
| `ix_user_contact_user` | B-tree | `user_id` | ユーザー別連絡先検索 |
| `ix_user_contact_type` | B-tree | `contact_type`, `user_id` | 種類別連絡先検索 |
| `ix_user_contact_primary` | B-tree | `user_id`, `contact_type`, `is_primary` | 主連絡先検索 |
| `ix_user_contact_verified` | B-tree | `is_verified` | 検証済み連絡先検索 |

#### 特記事項

- メール、電話など複数種類の連絡先を単一テーブルで管理
- 種類ごとに主連絡先を設定可能（制約で1つのみに制限）
- 連絡先の検証状態を管理（検証コード送信と確認）
- 主連絡先切り替え操作は遅延制約を利用して簡素化

### 2.5 user_preference テーブル

ユーザー個別の設定情報を保存するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.user_preference (
    user_id integer NOT NULL REFERENCES common.auth_user(id),
    preference_key varchar(50) NOT NULL,
    preference_value text,
    data_type varchar(20) NOT NULL,
    is_system boolean NOT NULL DEFAULT false,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamptz,
    PRIMARY KEY (user_id, preference_key),
    CONSTRAINT ck_user_preference_data_type CHECK (data_type IN ('string', 'number', 'boolean', 'json', 'date', 'time', 'datetime'))
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_user_preference` | PRIMARY KEY | `user_id`, `preference_key` | 主キー（複合） |
| `ix_user_preference_system` | B-tree | `is_system`, `preference_key` | システム設定検索 |

#### 特記事項

- キーバリュー形式で多様なユーザー設定を柔軟に格納
- データ型情報を持ち、フロントエンドでの適切な表示に利用
- システム設定フラグで管理者のみ変更可能な設定を区別
- JSONBを活用した複雑な設定も保存可能
- ユーザーUIのカスタマイズや表示設定の永続化に使用

### 2.6 tag テーブル

タグのマスター情報を管理するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.tag (
    id serial PRIMARY KEY,
    name varchar(50) NOT NULL,
    category varchar(30) NOT NULL,
    color varchar(7),
    description text,
    created_by integer,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamptz,
    updated_by integer,
    CONSTRAINT uq_tag_name_category UNIQUE (name, category)
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_tag` | PRIMARY KEY | `id` | 主キー |
| `uix_tag_name_category` | UNIQUE | `name`, `category` | タグ名とカテゴリの一意性 |
| `ix_tag_category` | B-tree | `category` | カテゴリ別検索 |

#### 特記事項

- 複数のエンティティで共通利用できるタグシステム
- カテゴリで用途別にタグを分類（ユーザータグ、プロジェクトタグなど）
- 視覚的区別のためにカラーコードを保持（フロントエンドでの表示用）
- タグ名とカテゴリの組み合わせで一意性を確保

### 2.7 user_tag テーブル

ユーザーとタグの関連を管理する中間テーブル。

#### テーブル定義

```sql
CREATE TABLE common.user_tag (
    user_id integer NOT NULL REFERENCES common.auth_user(id),
    tag_id integer NOT NULL REFERENCES common.tag(id),
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer,
    PRIMARY KEY (user_id, tag_id)
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_user_tag` | PRIMARY KEY | `user_id`, `tag_id` | 主キー（複合） |
| `ix_user_tag_tag_id` | B-tree | `tag_id` | タグ別ユーザー検索 |

#### 特記事項

- ユーザーとタグの多対多の関連を表現
- タグ付けによるユーザーのグループ化や属性付与に活用
- 特定タグを持つユーザーの検索効率化のためのインデックス

### 2.8 user_activity テーブル

ユーザーのアクティビティ履歴を記録するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.user_activity (
    id bigserial PRIMARY KEY,
    user_id integer NOT NULL REFERENCES common.auth_user(id),
    activity_type varchar(50) NOT NULL,
    activity_data jsonb NOT NULL DEFAULT '{}',
    ip_address inet,
    user_agent text,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    target_entity_type varchar(50),
    target_entity_id varchar(50),
    context_data jsonb
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_user_activity` | PRIMARY KEY | `id` | 主キー |
| `ix_user_activity_user_id` | B-tree | `user_id`, `created_at` | ユーザー別アクティビティ検索 |
| `ix_user_activity_type` | B-tree | `activity_type`, `created_at` | アクティビティタイプ別検索 |
| `ix_user_activity_target` | B-tree | `target_entity_type`, `target_entity_id` | 対象エンティティ別検索 |
| `ix_user_activity_created_at` | B-tree | `created_at` | 時系列検索 |
| `ix_user_activity_data` | GIN | `activity_data` | JSONBデータ内容検索 |

#### 特記事項

- ユーザーのシステム利用履歴や操作ログを記録
- JSONBを活用して多様なアクティビティデータを柔軟に格納
- 大量データ蓄積のためパーティショニング対象（月次分割）
- アクセス元IPやユーザーエージェントも記録しセキュリティ分析に活用
- タイムラインビューやアクティビティフィードの基盤データ

### 2.9 user_relationship テーブル

ユーザー間の関係性を管理するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.user_relationship (
    id serial PRIMARY KEY,
    from_user_id integer NOT NULL REFERENCES common.auth_user(id),
    to_user_id integer NOT NULL REFERENCES common.auth_user(id),
    relationship_type varchar(30) NOT NULL,
    start_date date NOT NULL DEFAULT CURRENT_DATE,
    end_date date,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer,
    updated_at timestamptz,
    updated_by integer,
    CONSTRAINT ck_user_relationship_type CHECK (relationship_type IN ('manager', 'mentor', 'colleague', 'substitute', 'report')),
    CONSTRAINT uq_user_relationship UNIQUE (from_user_id, to_user_id, relationship_type)
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_user_relationship` | PRIMARY KEY | `id` | 主キー |
| `uix_user_relationship` | UNIQUE | `from_user_id`, `to_user_id`, `relationship_type` | 関係の一意性 |
| `ix_user_relationship_from` | B-tree | `from_user_id`, `relationship_type` | 起点ユーザー別関係検索 |
| `ix_user_relationship_to` | B-tree | `to_user_id`, `relationship_type` | 終点ユーザー別関係検索 |
| `ix_user_relationship_date_range` | B-tree | `start_date`, `end_date` | 期間別検索 |

#### 特記事項

- ユーザー間の多様な関係性を表現（上司・部下、メンター・メンティなど）
- 関係性に期間を設定し、時間的な変化も管理
- 関係の種類ごとに異なるビジネスロジックを適用可能
- 代理申請や承認の委任などの機能の基盤

## 3. クエリパターンと最適化

### 3.1 ユーザー検索パターン

#### 3.1.1 組織階層を考慮したユーザー検索

```sql
-- 特定部署とその配下部署のユーザーを検索
WITH RECURSIVE department_tree AS (
    -- 起点となる部署
    SELECT id, parent_id, name, path
    FROM common.department
    WHERE id = $1
    
    UNION ALL
    
    -- 子部署を再帰的に取得
    SELECT d.id, d.parent_id, d.name, d.path
    FROM common.department d
    JOIN department_tree dt ON d.parent_id = dt.id
)
SELECT
    u.id,
    u.username,
    p.display_name,
    d.name AS department_name,
    j.name AS job_title_name
FROM common.auth_user u
JOIN common.user_profile p ON u.id = p.user_id
JOIN department_tree d ON p.department_id = d.id
LEFT JOIN common.job_title j ON p.job_title_id = j.id
WHERE u.status = 1
ORDER BY d.name, j.rank, p.display_name;
```

#### 3.1.2 タグを使ったユーザー検索

```sql
-- 特定のタグを持つユーザーを検索
SELECT
    u.id,
    u.username,
    p.display_name,
    d.name AS department_name,
    array_agg(t.name) AS tags
FROM common.auth_user u
JOIN common.user_profile p ON u.id = p.user_id
JOIN common.department d ON p.department_id = d.id
JOIN common.user_tag ut ON u.id = ut.user_id
JOIN common.tag t ON ut.tag_id = t.id
WHERE t.category = 'skill'
AND t.name IN ('Java', 'Spring', 'PostgreSQL')
GROUP BY u.id, u.username, p.display_name, d.name
HAVING count(DISTINCT t.id) = 3  -- 指定したタグをすべて持つユーザー
ORDER BY p.display_name;
```

#### 3.1.3 複合条件でのユーザー検索

```sql
-- 複合条件を使った高度なユーザー検索
SELECT
    u.id,
    u.username,
    p.display_name,
    d.name AS department_name,
    j.name AS job_title_name
FROM common.auth_user u
JOIN common.user_profile p ON u.id = p.user_id
JOIN common.department d ON p.department_id = d.id
LEFT JOIN common.job_title j ON p.job_title_id = j.id
LEFT JOIN LATERAL (
    -- ユーザーの持つタグを集約
    SELECT array_agg(t.name) AS tag_names
    FROM common.user_tag ut
    JOIN common.tag t ON ut.tag_id = t.id
    WHERE ut.user_id = u.id
) tags ON true
WHERE u.status = 1
AND (
    -- 部署条件
    p.department_id IN (SELECT id FROM common.department WHERE path <@ 'company.it.development')
    -- 役職条件
    AND (p.job_title_id IS NULL OR j.rank >= 3)
    -- 入社日条件
    AND (p.hire_date BETWEEN '2020-01-01' AND '2023-12-31')
    -- タグ条件
    AND ('ProjectManager' = ANY(tags.tag_names) OR p.is_manager = true)
)
ORDER BY d.name, j.rank, p.display_name;
```

### 3.2 組織構造のクエリパターン

#### 3.2.1 組織ツリーの取得

```sql
-- 組織階層構造の取得
WITH RECURSIVE org_tree AS (
    -- トップレベル部署（親を持たない部署）
    SELECT
        id,
        parent_id,
        name,
        code,
        0 AS level,
        ARRAY[id] AS path_array,
        id::text AS path_text
    FROM common.department
    WHERE parent_id IS NULL
    
    UNION ALL
    
    -- 子部署を再帰的に取得
    SELECT
        d.id,
        d.parent_id,
        d.name,
        d.code,
        ot.level + 1 AS level,
        ot.path_array || d.id AS path_array,
        ot.path_text || '.' || d.id::text AS path_text
    FROM common.department d
    JOIN org_tree ot ON d.parent_id = ot.id
)
SELECT
    id,
    parent_id,
    name,
    code,
    level,
    path_array,
    path_text,
    repeat('    ', level) || name AS indented_name -- インデント付き表示用
FROM org_tree
ORDER BY path_text;
```

#### 3.2.2 部署マネージャーチェーン取得

```sql
-- ユーザーの所属部署から上位部署のマネージャーチェーンを取得
WITH RECURSIVE manager_chain AS (
    -- ユーザーの所属部署から開始
    SELECT
        d.id AS department_id,
        d.name AS department_name,
        d.parent_id,
        d.manager_id,
        u.id AS manager_user_id,
        u.username AS manager_username,
        p.display_name AS manager_name,
        0 AS level
    FROM common.department d
    LEFT JOIN common.auth_user u ON d.manager_id = u.id
    LEFT JOIN common.user_profile p ON u.id = p.user_id
    WHERE d.id = (
        SELECT department_id
        FROM common.user_profile
        WHERE user_id = $1  -- 対象ユーザーID
    )
    
    UNION ALL
    
    -- 親部署とそのマネージャーを再帰的に取得
    SELECT
        d.id,
        d.name,
        d.parent_id,
        d.manager_id,
        u.id,
        u.username,
        p.display_name,
        mc.level + 1
    FROM common.department d
    LEFT JOIN common.auth_user u ON d.manager_id = u.id
    LEFT JOIN common.user_profile p ON u.id = p.user_id
    JOIN manager_chain mc ON d.id = mc.parent_id
)
SELECT
    department_id,
    department_name,
    manager_user_id,
    manager_name,
    level
FROM manager_chain
WHERE manager_user_id IS NOT NULL  -- マネージャーが設定されている部署のみ
ORDER BY level;
```

### 3.3 ユーザーアクティビティのクエリパターン

#### 3.3.1 ユーザーのアクティビティタイムライン

```sql
-- ユーザーのアクティビティタイムライン取得
SELECT
    a.id,
    a.activity_type,
    a.created_at,
    a.target_entity_type,
    a.target_entity_id,
    a.activity_data,
    CASE
        WHEN a.activity_type = 'login' THEN 'ログイン'
        WHEN a.activity_type = 'profile_update' THEN 'プロフィール更新'
        WHEN a.activity_type = 'password_change' THEN 'パスワード変更'
        WHEN a.activity_type = 'document_view' THEN a.activity_data->>'document_name' || 'を閲覧'
        WHEN a.activity_type = 'data_export' THEN a.activity_data->>'export_type' || 'データをエクスポート'
        ELSE a.activity_type
    END AS activity_description
FROM common.user_activity a
WHERE a.user_id = $1
ORDER BY a.created_at DESC
LIMIT 50;
```

#### 3.3.2 エンティティに対するアクティビティ

```sql
-- 特定のエンティティに対するアクティビティ
SELECT
    a.id,
    u.username,
    p.display_name AS user_display_name,
    a.activity_type,
    a.created_at,
    a.activity_data
FROM common.user_activity a
JOIN common.auth_user u ON a.user_id = u.id
JOIN common.user_profile p ON u.id = p.user_id
WHERE a.target_entity_type = $1  -- エンティティタイプ（'project', 'document'など）
AND a.target_entity_id = $2      -- エンティティID
ORDER BY a.created_at DESC;
```

#### 3.3.3 システム全体のアクティビティ分析

```sql
-- 時間帯別のシステムアクティビティ分析
SELECT
    date_trunc('hour', created_at) AS activity_hour,
    activity_type,
    count(*) AS activity_count
FROM common.user_activity
WHERE created_at >= CURRENT_DATE - interval '7 days'
GROUP BY date_trunc('hour', created_at), activity_type
ORDER BY activity_hour, activity_type;

-- ユーザー別のアクティビティ集計
SELECT
    u.username,
    p.display_name,
    d.name AS department_name,
    count(*) AS total_activities,
    count(DISTINCT date_trunc('day', a.created_at)) AS active_days,
    max(a.created_at) AS last_activity
FROM common.user_activity a
JOIN common.auth_user u ON a.user_id = u.id
JOIN common.user_profile p ON u.id = p.user_id
JOIN common.department d ON p.department_id = d.id
WHERE a.created_at >= CURRENT_DATE - interval '30 days'
GROUP BY u.id, u.username, p.display_name, d.name
ORDER BY total_activities DESC
LIMIT 20;
```

## 4. データメンテナンス

### 4.1 定期メンテナンス処理

#### 4.1.1 非アクティブユーザーの検出

```sql
-- 長期間ログインしていないユーザーの検出
SELECT
    u.id,
    u.username,
    p.display_name,
    d.name AS department_name,
    u.last_login_datetime,
    age(CURRENT_TIMESTAMP, u.last_login_datetime) AS time_since_last_login
FROM common.auth_user u
JOIN common.user_profile p ON u.id = p.user_id
JOIN common.department d ON p.department_id = d.id
WHERE u.status = 1  -- アクティブ状態
AND (
    u.last_login_datetime IS NULL
    OR u.last_login_datetime < CURRENT_TIMESTAMP - interval '90 days'
)
ORDER BY u.last_login_datetime NULLS FIRST;
```

#### 4.1.2 組織構造の整合性チェック

```sql
-- 組織構造の循環参照チェック
WITH RECURSIVE org_cycle_check AS (
    -- すべての部署から開始
    SELECT
        id,
        parent_id,
        name,
        ARRAY[id] AS path_array
    FROM common.department
    
    UNION ALL
    
    -- 親部署を再帰的に検索し、循環参照をチェック
    SELECT
        d.id,
        d.parent_id,
        d.name,
        occ.path_array || d.id AS path_array
    FROM common.department d
    JOIN org_cycle_check occ ON d.id = occ.parent_id
    WHERE NOT d.id = ANY(occ.path_array)  -- 循環を検出する条件
)
SELECT id, name, path_array
FROM org_cycle_check
WHERE array_length(path_array, 1) > (
    SELECT count(*) FROM common.department
)
LIMIT 10;  -- 循環があれば結果が出力される

-- マネージャーがいない部署を検出
SELECT
    d.id,
    d.name,
    d.code
FROM common.department d
WHERE d.manager_id IS NULL
AND d.is_active = true;
```

#### 4.1.3 ユーザーアクティビティのアーカイブ

```sql
-- 古いアクティビティログのアーカイブ
INSERT INTO common.user_activity_archive
SELECT * FROM common.user_activity
WHERE created_at < CURRENT_DATE - interval '365 days';

DELETE FROM common.user_activity
WHERE created_at < CURRENT_DATE - interval '365 days';
```

### 4.2 データ整合性チェック

```sql
-- 不整合な参照を検出
-- ユーザープロファイルに紐づくユーザーの存在確認
SELECT p.user_id
FROM common.user_profile p
LEFT JOIN common.auth_user u ON p.user_id = u.id
WHERE u.id IS NULL;

-- 存在しない部署への参照を持つユーザープロファイル
SELECT p.user_id, p.department_id
FROM common.user_profile p
LEFT JOIN common.department d ON p.department_id = d.id
WHERE p.department_id IS NOT NULL
AND d.id IS NULL;

-- 存在しない役職への参照を持つユーザープロファイル
SELECT p.user_id, p.job_title_id
FROM common.user_profile p
LEFT JOIN common.job_title j ON p.job_title_id = j.id
WHERE p.job_title_id IS NOT NULL
AND j.id IS NULL;

-- ユーザー関係テーブルの整合性チェック
SELECT r.id, r.from_user_id, r.to_user_id
FROM common.user_relationship r
LEFT JOIN common.auth_user u1 ON r.from_user_id = u1.id
LEFT JOIN common.auth_user u2 ON r.to_user_id = u2.id
WHERE u1.id IS NULL OR u2.id IS NULL;
```

## 5. パフォーマンス最適化

### 5.1 特殊インデックス

#### 5.1.1 表現式インデックス

```sql
-- ユーザープロファイルの検索最適化
CREATE INDEX ix_user_profile_full_name ON common.user_profile (lower(display_name) varchar_pattern_ops);

-- アクティビティJSONBデータの検索用インデックス
CREATE INDEX ix_user_activity_entity_id ON common.user_activity ((activity_data->>'entity_id'));
```

#### 5.1.2 部分インデックス

```sql
-- アクティブユーザーのみのインデックス
CREATE INDEX ix_user_profile_active_manager ON common.user_profile (department_id)
WHERE is_manager = true;

-- 現在有効な関係のみのインデックス
CREATE INDEX ix_user_relationship_active ON common.user_relationship (from_user_id, to_user_id, relationship_type)
WHERE end_date IS NULL OR end_date >= CURRENT_DATE;
```

### 5.2 テーブルパーティション

#### 5.2.1 ユーザーアクティビティテーブルのパーティション

```sql
-- アクティビティテーブルのパーティション設定
CREATE TABLE common.user_activity (
    id bigserial,
    user_id integer NOT NULL,
    activity_type varchar(50) NOT NULL,
    activity_data jsonb NOT NULL DEFAULT '{}',
    ip_address inet,
    user_agent text,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    target_entity_type varchar(50),
    target_entity_id varchar(50),
    context_data jsonb
) PARTITION BY RANGE (created_at);

-- 月次パーティションの作成
CREATE TABLE common.user_activity_y2024m01 PARTITION OF common.user_activity
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE common.user_activity_y2024m02 PARTITION OF common.user_activity
FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');

-- パーティション自動作成関数
CREATE OR REPLACE FUNCTION common.create_activity_partition_for_month()
RETURNS void AS $$
DECLARE
    next_month date;
    partition_name text;
    partition_start date;
    partition_end date;
BEGIN
    -- 2ヶ月先の月を計算
    next_month := date_trunc('month', current_date + interval '2 month');
    
    -- パーティション名の生成
    partition_name := 'user_activity_y' || to_char(next_month, 'YYYY') || 'm' || to_char(next_month, 'MM');
    
    -- パーティション範囲の計算
    partition_start := next_month;
    partition_end := next_month + interval '1 month';
    
    -- パーティションが存在しないか確認
    IF NOT EXISTS (
        SELECT 1 FROM pg_class c
        JOIN pg_namespace n ON n.oid = c.relnamespace
        WHERE n.nspname = 'common' AND c.relname = partition_name
    ) THEN
        -- パーティション作成
        EXECUTE format(
            'CREATE TABLE common.%I PARTITION OF common.user_activity FOR VALUES FROM (%L) TO (%L)',
            partition_name, partition_start, partition_end
        );
        
        -- インデックス作成
        EXECUTE format(
            'CREATE INDEX ix_%I_user_id ON common.%I (user_id, created_at)',
            partition_name, partition_name
        );
        
        EXECUTE format(
            'CREATE INDEX ix_%I_activity_type ON common.%I (activity_type, created_at)',
            partition_name, partition_name
        );
        
        RAISE NOTICE 'Created partition: common.%', partition_name;
    END IF;
END;
$$ LANGUAGE plpgsql;
```

### 5.3 データキャッシュ最適化

#### 5.3.1 マテリアライズドビュー

```sql
-- 組織構造のマテリアライズドビュー
CREATE MATERIALIZED VIEW common.mv_department_hierarchy AS
WITH RECURSIVE department_tree AS (
    -- ルート部署
    SELECT
        id,
        parent_id,
        name,
        code,
        manager_id,
        path,
        0 AS level,
        ARRAY[name] AS name_path
    FROM common.department
    WHERE parent_id IS NULL
    
    UNION ALL
    
    -- 子部署
    SELECT
        d.id,
        d.parent_id,
        d.name,
        d.code,
        d.manager_id,
        d.path,
        dt.level + 1 AS level,
        dt.name_path || d.name AS name_path
    FROM common.department d
    JOIN department_tree dt ON d.parent_id = dt.id
)
SELECT
    id,
    parent_id,
    name,
    code,
    manager_id,
    path,
    level,
    name_path,
    (SELECT count(*) FROM common.user_profile WHERE department_id = dt.id) AS member_count
FROM department_tree dt
ORDER BY path;

CREATE UNIQUE INDEX uix_mv_department_hierarchy ON common.mv_department_hierarchy (id);
CREATE INDEX ix_mv_department_hierarchy_path ON common.mv_department_hierarchy USING gist (path);

-- 定期更新関数
CREATE OR REPLACE FUNCTION common.refresh_department_hierarchy_mv()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW common.mv_department_hierarchy;
END;
$$ LANGUAGE plpgsql;

-- 組織変更時の自動更新トリガー
CREATE OR REPLACE FUNCTION common.trigger_refresh_department_hierarchy()
RETURNS trigger AS $$
BEGIN
    PERFORM common.refresh_department_hierarchy_mv();
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER department_hierarchy_refresh
AFTER INSERT OR UPDATE OR DELETE ON common.department
FOR EACH STATEMENT EXECUTE FUNCTION common.trigger_refresh_department_hierarchy();
```

#### 5.3.2 ユーザーアクティビティ集計ビュー

```sql
-- ユーザーアクティビティ集計のマテリアライズドビュー
CREATE MATERIALIZED VIEW common.mv_user_activity_summary AS
SELECT
    user_id,
    date_trunc('day', created_at) AS activity_date,
    count(*) AS activity_count,
    count(DISTINCT activity_type) AS activity_type_count,
    array_agg(DISTINCT activity_type) AS activity_types,
    min(created_at) AS first_activity,
    max(created_at) AS last_activity
FROM common.user_activity
WHERE created_at >= CURRENT_DATE - interval '30 days'
GROUP BY user_id, date_trunc('day', created_at)
ORDER BY user_id, activity_date;

CREATE UNIQUE INDEX uix_mv_user_activity_summary ON common.mv_user_activity_summary (user_id, activity_date);

-- 日次更新スケジュール
CREATE OR REPLACE FUNCTION common.refresh_user_activity_summary_mv()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW common.mv_user_activity_summary;
END;
$$ LANGUAGE plpgsql;

SELECT cron.schedule('0 1 * * *', $$SELECT common.refresh_user_activity_summary_mv()$$);
```

## 6. セキュリティ考慮事項

### 6.1 データ保護

#### 6.1.1 個人情報の暗号化

```sql
-- pgcryptoを使用した個人情報の暗号化
CREATE OR REPLACE FUNCTION common.encrypt_personal_data(p_data text)
RETURNS text AS $$
DECLARE
    v_key text := current_setting('app.encryption_key');
BEGIN
    IF p_data IS NULL THEN
        RETURN NULL;
    END IF;
    RETURN encode(pgp_sym_encrypt(p_data, v_key), 'base64');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION common.decrypt_personal_data(p_encrypted text)
RETURNS text AS $$
DECLARE
    v_key text := current_setting('app.encryption_key');
BEGIN
    IF p_encrypted IS NULL THEN
        RETURN NULL;
    END IF;
    RETURN pgp_sym_decrypt(decode(p_encrypted, 'base64'), v_key);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;  -- 復号化失敗時はNULLを返す
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ビューを使用した暗号化データへの安全なアクセス
CREATE VIEW common.vw_user_profile_secure AS
SELECT
    p.user_id,
    p.department_id,
    p.job_title_id,
    p.display_name,
    p.employee_code,
    p.hire_date,
    common.decrypt_personal_data(p.birth_date::text)::date AS birth_date,
    p.gender,
    common.decrypt_personal_data(p.tel_number) AS tel_number,
    common.decrypt_personal_data(p.mobile_number) AS mobile_number,
    common.decrypt_personal_data(p.postal_code) AS postal_code,
    common.decrypt_personal_data(p.address1) AS address1,
    common.decrypt_personal_data(p.address2) AS address2,
    p.is_admin,
    p.is_manager,
    p.employment_type
FROM common.user_profile p;
```

#### 6.1.2 行レベルセキュリティ

```sql
-- ユーザー情報の行レベルセキュリティポリシー
ALTER TABLE common.user_profile ENABLE ROW LEVEL SECURITY;

-- 自分のプロファイルは閲覧・編集可能
CREATE POLICY user_profile_self_access ON common.user_profile
    USING (user_id = current_setting('app.current_user_id')::integer)
    WITH CHECK (user_id = current_setting('app.current_user_id')::integer);

-- 管理者は全てのプロファイルにアクセス可能
CREATE POLICY user_profile_admin_access ON common.user_profile
    USING (EXISTS (
        SELECT 1 FROM common.user_profile
        WHERE user_id = current_setting('app.current_user_id')::integer
        AND is_admin = true
    ))
    WITH CHECK (EXISTS (
        SELECT 1 FROM common.user_profile
        WHERE user_id = current_setting('app.current_user_id')::integer
        AND is_admin = true
    ));

-- マネージャーは自部署と配下部署のプロファイルを閲覧可能
CREATE POLICY user_profile_manager_view ON common.user_profile
    FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM common.user_profile manager_profile
            JOIN common.department d ON manager_profile.department_id = d.id
            JOIN common.department sub_dept ON sub_dept.path <@ d.path
            WHERE manager_profile.user_id = current_setting('app.current_user_id')::integer
            AND manager_profile.is_manager = true
            AND common.user_profile.department_id = sub_dept.id
        )
    );
```

### 6.2 データアクセス監査

```sql
-- ユーザープロファイル変更の監査ログトリガー
CREATE OR REPLACE FUNCTION common.user_profile_audit_trigger()
RETURNS trigger AS $$
BEGIN
    IF (TG_OP = 'UPDATE') THEN
        INSERT INTO common.user_activity
        (user_id, activity_type, target_entity_type, target_entity_id, activity_data)
        VALUES
        (COALESCE(NEW.updated_by, current_setting('app.current_user_id', TRUE)::integer),
         'profile_update',
         'user_profile',
         NEW.user_id::text,
         jsonb_build_object(
            'changed_fields', (
                SELECT jsonb_object_agg(key, value)
                FROM jsonb_each(to_jsonb(NEW))
                WHERE key NOT IN ('birth_date', 'tel_number', 'mobile_number', 'postal_code', 'address1', 'address2')
                AND key <> 'updated_at'
                AND key <> 'updated_by'
                AND to_jsonb(NEW) -> key IS DISTINCT FROM to_jsonb(OLD) -> key
            ),
            'target_user_id', NEW.user_id,
            'target_display_name', NEW.display_name
         )
        );
    ELSIF (TG_OP = 'INSERT') THEN
        INSERT INTO common.user_activity
        (user_id, activity_type, target_entity_type, target_entity_id, activity_data)
        VALUES
        (COALESCE(NEW.created_by, current_setting('app.current_user_id', TRUE)::integer),
         'profile_create',
         'user_profile',
         NEW.user_id::text,
         jsonb_build_object(
            'user_id', NEW.user_id,
            'display_name', NEW.display_name,
            'department_id', NEW.department_id,
            'job_title_id', NEW.job_title_id
         )
        );
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER user_profile_audit
AFTER INSERT OR UPDATE ON common.user_profile
FOR EACH ROW EXECUTE FUNCTION common.user_profile_audit_trigger();
```

## 7. 運用時の注意点

1. **組織変更対応**: 組織改編時はユーザーの部署移動と階層構造変更を一貫して実施する。ltreeパスの更新も忘れずに行う。

2. **パーティション管理**: ユーザーアクティビティログは成長が早いため、定期的なパーティション作成とアーカイブを確実に実施する。

3. **業務ルール変更対応**: 役職ランク変更や組織構造の大幅変更時は、関連機能（承認フローなど）への影響を確認する。

4. **マテリアライズドビュー更新**: 組織構造のマテリアライズドビューは重要なため、更新漏れが発生しないよう監視する。

5. **個人情報保護**: 個人情報を含むフィールドは必ず暗号化し、アクセス制御と監査ログを徹底する。

6. **ロールバック計画**: 組織構造の大規模変更時には、ロールバックプランを事前に準備しておく。

7. **バックアップ運用**: 定期的に組織構造データの整合性検証と復元テストを実施する。