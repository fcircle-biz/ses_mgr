# 共通モジュール - 通知テーブル定義補足

## 1. テーブル概要

通知機能モジュールは、システム全体でのユーザーへの通知配信を担当する共通基盤です。このモジュールでは、様々なイベントをトリガーとして通知の生成、配信、既読管理などを行います。タスク承認依頼、メッセージ受信、システムメンテナンス通知など、多様な用途に対応します。

### 1.1 テーブル一覧

| テーブル名 | 説明 | 主要列 |
|----------|------|-------|
| `common.notification` | 通知基本情報 | `id`, `user_id`, `type`, `title`, `content`, `is_read`, `created_at` |
| `common.notification_type` | 通知タイプ定義 | `id`, `type_code`, `name`, `description`, `template` |
| `common.notification_template` | 通知テンプレート | `id`, `template_code`, `title_template`, `content_template`, `icon` |
| `common.notification_event` | 通知イベント | `id`, `event_type`, `source_type`, `source_id`, `data`, `created_at` |
| `common.notification_channel` | 通知チャネル | `id`, `channel_code`, `name`, `is_active` |
| `common.notification_preference` | ユーザー通知設定 | `id`, `user_id`, `notification_type_id`, `channel_id`, `is_enabled` |
| `common.notification_delivery` | 通知配信状況 | `id`, `notification_id`, `channel_id`, `delivery_status`, `sent_at` |
| `common.notification_group` | 通知グループ | `id`, `group_name`, `description` |
| `common.notification_group_membership` | 通知グループ所属 | `group_id`, `user_id`, `created_at` |

## 2. 主要テーブル詳細

### 2.1 notification テーブル

ユーザー宛ての通知情報を格納するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.notification (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id integer NOT NULL REFERENCES common.user(id),
    type_id integer NOT NULL REFERENCES common.notification_type(id),
    title varchar(200) NOT NULL,
    content text NOT NULL,
    short_content varchar(200),
    link_url varchar(500),
    icon_url varchar(255),
    is_read boolean NOT NULL DEFAULT false,
    read_at timestamptz,
    is_deleted boolean NOT NULL DEFAULT false,
    deleted_at timestamptz,
    is_actionable boolean NOT NULL DEFAULT false,
    action_text varchar(50),
    action_url varchar(500),
    priority smallint NOT NULL DEFAULT 3,
    expiry_date timestamptz,
    source_type varchar(100),
    source_id varchar(100),
    context_data jsonb,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer REFERENCES common.user(id),
    CONSTRAINT ck_notification_priority CHECK (priority BETWEEN 1 AND 5)
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_notification` | PRIMARY KEY | `id` | 主キー |
| `ix_notification_user_id` | B-tree | `user_id` | ユーザーIDによる検索 |
| `ix_notification_user_read` | B-tree | `user_id`, `is_read`, `created_at` | 未読通知検索 |
| `ix_notification_created_at` | B-tree | `created_at` | 作成日時による検索 |
| `ix_notification_type_id` | B-tree | `type_id` | 通知タイプによる検索 |
| `ix_notification_source` | B-tree | `source_type`, `source_id` | ソースオブジェクトによる検索 |

#### 特記事項

- UUIDを主キーとして使用し、シャーディング可能な設計
- 短文コンテンツはプレビュー表示用
- アクション可能な通知には、アクションテキストとURLを設定可能
- コンテキストデータはJSONB型で様々な追加情報を格納
- 優先度は1（最高）〜5（最低）のスケール
- ソースタイプとソースIDでイベント発生元オブジェクトを特定

### 2.2 notification_type テーブル

通知の種類を定義するマスタテーブル。

#### テーブル定義

```sql
CREATE TABLE common.notification_type (
    id serial PRIMARY KEY,
    type_code varchar(50) NOT NULL UNIQUE,
    name varchar(100) NOT NULL,
    description text,
    is_actionable boolean NOT NULL DEFAULT false,
    icon varchar(50),
    color varchar(20),
    default_priority smallint NOT NULL DEFAULT 3,
    template_id integer REFERENCES common.notification_template(id),
    default_expiry_days integer,
    is_system boolean NOT NULL DEFAULT false,
    is_user_configurable boolean NOT NULL DEFAULT true,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer REFERENCES common.user(id),
    updated_at timestamptz,
    updated_by integer REFERENCES common.user(id),
    CONSTRAINT ck_notification_type_priority CHECK (default_priority BETWEEN 1 AND 5)
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_notification_type` | PRIMARY KEY | `id` | 主キー |
| `uix_notification_type_code` | UNIQUE | `type_code` | タイプコード一意性 |

#### 特記事項

- タイプコードはシステム内で一意の識別子（例: `task_assigned`, `approval_requested`）
- テンプレートIDは通知生成時に使用するテンプレートを指定
- アクション可能フラグとデフォルト優先度により通知の性質を定義
- システム通知フラグにより、システム運用に必須の通知を保護
- ユーザー設定可能フラグにより、ユーザーが受信有無を設定できる通知を制御

### 2.3 notification_template テーブル

通知の内容を生成するためのテンプレートを管理するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.notification_template (
    id serial PRIMARY KEY,
    template_code varchar(50) NOT NULL UNIQUE,
    name varchar(100) NOT NULL,
    description text,
    title_template text NOT NULL,
    content_template text NOT NULL,
    short_content_template text,
    icon varchar(50),
    is_html boolean NOT NULL DEFAULT false,
    variables jsonb,
    sample_data jsonb,
    is_system boolean NOT NULL DEFAULT false,
    language varchar(10) NOT NULL DEFAULT 'ja',
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer REFERENCES common.user(id),
    updated_at timestamptz,
    updated_by integer REFERENCES common.user(id)
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_notification_template` | PRIMARY KEY | `id` | 主キー |
| `uix_notification_template_code` | UNIQUE | `template_code` | テンプレートコード一意性 |
| `ix_notification_template_language` | B-tree | `language` | 言語による検索 |

#### 特記事項

- テンプレートにはプレースホルダー変数を含む（例: `{user_name}様、タスクが割り当てられました`）
- 変数定義はJSONB型で変数名と説明を格納
- サンプルデータでテンプレートプレビューのテスト可能
- 多言語対応を視野に言語コードを保持
- HTMLフラグにより、リッチテキスト通知とプレーンテキスト通知を区別

### 2.4 notification_event テーブル

通知を発生させるイベントを記録するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.notification_event (
    id bigserial PRIMARY KEY,
    event_type varchar(50) NOT NULL,
    source_type varchar(100) NOT NULL,
    source_id varchar(100) NOT NULL,
    actor_id integer REFERENCES common.user(id),
    target_type varchar(50),
    target_id varchar(100),
    data jsonb NOT NULL,
    is_processed boolean NOT NULL DEFAULT false,
    processed_at timestamptz,
    error_message text,
    retry_count smallint NOT NULL DEFAULT 0,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_notification_event` | PRIMARY KEY | `id` | 主キー |
| `ix_notification_event_type` | B-tree | `event_type` | イベントタイプによる検索 |
| `ix_notification_event_source` | B-tree | `source_type`, `source_id` | イベントソースによる検索 |
| `ix_notification_event_processed` | B-tree | `is_processed`, `created_at` | 未処理イベント検索 |
| `ix_notification_event_created_at` | B-tree | `created_at` | 作成日時による検索 |

#### 特記事項

- イベントはアプリケーションの様々な場所から発行され、通知生成のトリガーとなる
- 非同期処理のための処理状態管理と再試行機能
- データはJSONB型で通知テンプレートに埋め込むための変数を格納
- ターゲットタイプとIDは通知の送信先となるエンティティを特定（個人またはグループ）

### 2.5 notification_channel テーブル

通知の配信チャネルを管理するマスタテーブル。

#### テーブル定義

```sql
CREATE TABLE common.notification_channel (
    id serial PRIMARY KEY,
    channel_code varchar(50) NOT NULL UNIQUE,
    name varchar(100) NOT NULL,
    description text,
    icon varchar(50),
    is_active boolean NOT NULL DEFAULT true,
    config jsonb,
    handler_class varchar(255),
    supported_formats varchar(50)[] NOT NULL,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer REFERENCES common.user(id),
    updated_at timestamptz,
    updated_by integer REFERENCES common.user(id)
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_notification_channel` | PRIMARY KEY | `id` | 主キー |
| `uix_notification_channel_code` | UNIQUE | `channel_code` | チャネルコード一意性 |
| `ix_notification_channel_active` | B-tree | `is_active` | 有効チャネル検索 |

#### 特記事項

- 標準的なチャネルには「アプリ内通知」「Eメール」「Slack」「ブラウザプッシュ」などがある
- 設定情報はJSONB型で、APIキーやエンドポイントURLなどを格納
- ハンドラクラスはチャネル固有の配信ロジックを実装したクラス名
- サポートされるフォーマットは各チャネルが対応するコンテンツ形式（text, html, markdown等）

### 2.6 notification_preference テーブル

ユーザーごとの通知設定を管理するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.notification_preference (
    id serial PRIMARY KEY,
    user_id integer NOT NULL REFERENCES common.user(id),
    notification_type_id integer NOT NULL REFERENCES common.notification_type(id),
    channel_id integer NOT NULL REFERENCES common.notification_channel(id),
    is_enabled boolean NOT NULL DEFAULT true,
    custom_priority smallint,
    start_time time,
    end_time time,
    day_of_week smallint[],
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamptz,
    CONSTRAINT uq_notification_preference UNIQUE (user_id, notification_type_id, channel_id),
    CONSTRAINT ck_notification_preference_priority CHECK (custom_priority IS NULL OR custom_priority BETWEEN 1 AND 5)
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_notification_preference` | PRIMARY KEY | `id` | 主キー |
| `uix_notification_preference` | UNIQUE | `user_id`, `notification_type_id`, `channel_id` | 重複設定防止 |
| `ix_notification_preference_user` | B-tree | `user_id`, `is_enabled` | ユーザー設定検索 |
| `ix_notification_preference_type` | B-tree | `notification_type_id` | 通知タイプによる検索 |

#### 特記事項

- 各ユーザーは通知タイプとチャネルの組み合わせごとに設定が可能
- 時間帯と曜日の指定により、静か時間の設定が可能
- カスタム優先度により、通知タイプのデフォルト優先度をオーバーライド可能
- 一部のシステム通知タイプは設定変更不可（notification_typeテーブルのis_user_configurableによる）

### 2.7 notification_delivery テーブル

通知の配信状況を追跡するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.notification_delivery (
    id bigserial PRIMARY KEY,
    notification_id uuid NOT NULL REFERENCES common.notification(id),
    channel_id integer NOT NULL REFERENCES common.notification_channel(id),
    delivery_status varchar(20) NOT NULL,
    sent_at timestamptz,
    delivery_data text,
    retry_count smallint NOT NULL DEFAULT 0,
    next_retry_at timestamptz,
    error_message text,
    external_id varchar(255),
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamptz,
    CONSTRAINT ck_notification_delivery_status CHECK (
        delivery_status IN ('PENDING', 'SENT', 'DELIVERED', 'FAILED', 'BLOCKED', 'REJECTED')
    )
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_notification_delivery` | PRIMARY KEY | `id` | 主キー |
| `ix_notification_delivery_notification` | B-tree | `notification_id` | 通知IDによる検索 |
| `ix_notification_delivery_status` | B-tree | `delivery_status` | 配信ステータスによる検索 |
| `ix_notification_delivery_retry` | B-tree | `delivery_status`, `next_retry_at` | 再送信対象検索 |
| `ix_notification_delivery_external` | B-tree | `external_id` | 外部IDによる検索 |

#### 特記事項

- 各通知は複数のチャネルを通じて配信される可能性がある
- 配信ステータスの追跡により、信頼性の高い通知配信を実現
- 再試行メカニズムで一時的な障害に対応
- 外部IDは外部システム（メールサーバー等）での参照ID
- 配信データには送信された実際のコンテンツをキャプチャ

### 2.8 notification_group / notification_group_membership テーブル

通知グループとメンバーシップを管理するテーブル。

#### テーブル定義

```sql
CREATE TABLE common.notification_group (
    id serial PRIMARY KEY,
    group_name varchar(100) NOT NULL,
    description text,
    is_system boolean NOT NULL DEFAULT false,
    is_active boolean NOT NULL DEFAULT true,
    owner_id integer REFERENCES common.user(id),
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer REFERENCES common.user(id),
    updated_at timestamptz,
    updated_by integer REFERENCES common.user(id)
);

CREATE TABLE common.notification_group_membership (
    group_id integer NOT NULL REFERENCES common.notification_group(id),
    user_id integer NOT NULL REFERENCES common.user(id),
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer REFERENCES common.user(id),
    PRIMARY KEY (group_id, user_id)
);
```

#### インデックス設計

| インデックス名 | タイプ | 対象列 | 目的 |
|--------------|-------|-------|------|
| `pk_notification_group` | PRIMARY KEY | `id` | 主キー |
| `ix_notification_group_name` | B-tree | `group_name` | グループ名による検索 |
| `ix_notification_group_active` | B-tree | `is_active` | 有効グループ検索 |
| `pk_notification_group_membership` | PRIMARY KEY | `group_id`, `user_id` | 主キー（複合） |
| `ix_notification_group_membership_user` | B-tree | `user_id` | ユーザーIDによる検索 |

#### 特記事項

- 通知グループを使用して、複数のユーザーに同時に通知を配信
- システムグループフラグにより、部門やロールなどの自動生成グループを管理
- オーナーIDにより、カスタムグループの管理者を指定
- グループメンバーシップは多対多のリレーションシップを表現

## 3. クエリパターンと最適化

### 3.1 通知管理のクエリパターン

#### 3.1.1 ユーザーの未読通知取得

```sql
-- ユーザーの未読通知を最新順に取得
SELECT
    n.id,
    n.title,
    n.short_content,
    n.content,
    n.icon_url,
    n.created_at,
    n.is_actionable,
    n.action_text,
    n.action_url,
    n.priority,
    nt.type_code,
    nt.name AS type_name,
    nt.color
FROM common.notification n
JOIN common.notification_type nt ON n.type_id = nt.id
WHERE n.user_id = $1
AND n.is_read = false
AND n.is_deleted = false
AND (n.expiry_date IS NULL OR n.expiry_date > CURRENT_TIMESTAMP)
ORDER BY 
    n.priority,  -- 高優先度（低い数値）が先
    n.created_at DESC
LIMIT 50;

-- 未読通知のカウント
SELECT COUNT(*)
FROM common.notification
WHERE user_id = $1
AND is_read = false
AND is_deleted = false
AND (expiry_date IS NULL OR expiry_date > CURRENT_TIMESTAMP);
```

#### 3.1.2 通知タイプとチャネルのユーザー設定取得

```sql
-- ユーザーの通知設定一覧を取得
SELECT
    nt.id AS type_id,
    nt.type_code,
    nt.name AS type_name,
    nt.description,
    nt.is_user_configurable,
    nc.id AS channel_id,
    nc.channel_code,
    nc.name AS channel_name,
    np.is_enabled,
    COALESCE(np.custom_priority, nt.default_priority) AS priority,
    np.start_time,
    np.end_time,
    np.day_of_week
FROM common.notification_type nt
CROSS JOIN common.notification_channel nc
LEFT JOIN common.notification_preference np 
    ON np.user_id = $1 
    AND np.notification_type_id = nt.id
    AND np.channel_id = nc.id
WHERE nt.is_system = false
AND nc.is_active = true
ORDER BY nt.name, nc.name;

-- ユーザー設定の更新
INSERT INTO common.notification_preference
(user_id, notification_type_id, channel_id, is_enabled, custom_priority, start_time, end_time, day_of_week)
VALUES
($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (user_id, notification_type_id, channel_id)
DO UPDATE SET
    is_enabled = EXCLUDED.is_enabled,
    custom_priority = EXCLUDED.custom_priority,
    start_time = EXCLUDED.start_time,
    end_time = EXCLUDED.end_time,
    day_of_week = EXCLUDED.day_of_week,
    updated_at = CURRENT_TIMESTAMP;
```

### 3.2 通知生成と配信のクエリパターン

#### 3.2.1 イベントからの通知生成

```sql
-- 未処理イベントの取得
SELECT
    id,
    event_type,
    source_type,
    source_id,
    actor_id,
    target_type,
    target_id,
    data
FROM common.notification_event
WHERE is_processed = false
AND retry_count < 3
ORDER BY created_at
LIMIT 50
FOR UPDATE SKIP LOCKED;  -- 並列処理時の競合回避

-- イベントから通知テンプレートの検索
SELECT
    nt.id AS type_id,
    nt.type_code,
    nt.name,
    nt.default_priority,
    nt.is_actionable,
    nt.default_expiry_days,
    ntt.id AS template_id,
    ntt.title_template,
    ntt.content_template,
    ntt.short_content_template,
    ntt.icon,
    nt.color
FROM common.notification_type nt
JOIN common.notification_template ntt ON nt.template_id = ntt.id
WHERE nt.type_code = $1  -- イベントタイプに対応する通知タイプ
AND ntt.language = 'ja';  -- またはユーザー言語設定

-- ユーザーへの通知の挿入
INSERT INTO common.notification
(user_id, type_id, title, content, short_content, link_url, icon_url, is_actionable, action_text, action_url,
 priority, expiry_date, source_type, source_id, context_data, created_by)
VALUES
($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, 
 CASE WHEN $12 IS NOT NULL THEN CURRENT_TIMESTAMP + ($12 || ' days')::interval ELSE NULL END,
 $13, $14, $15, $16)
RETURNING id;

-- グループ通知のユーザー展開（グループメンバー全員に通知を作成）
INSERT INTO common.notification
(user_id, type_id, title, content, short_content, link_url, icon_url, is_actionable, action_text, action_url,
 priority, expiry_date, source_type, source_id, context_data, created_by)
SELECT
    ngm.user_id,
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    CASE WHEN $11 IS NOT NULL THEN CURRENT_TIMESTAMP + ($11 || ' days')::interval ELSE NULL END,
    $12, $13, $14, $15
FROM common.notification_group_membership ngm
WHERE ngm.group_id = $16
AND EXISTS (
    -- ユーザーがこの通知タイプをこのチャネルで受信する設定になっているか確認
    SELECT 1
    FROM common.notification_preference np
    WHERE np.user_id = ngm.user_id
    AND np.notification_type_id = $1
    AND np.channel_id = $17  -- アプリ内通知のチャネルID
    AND np.is_enabled = true
);
```

#### 3.2.2 通知配信状態管理

```sql
-- 通知配信エントリの作成（各チャネル向け）
INSERT INTO common.notification_delivery
(notification_id, channel_id, delivery_status, created_at)
SELECT
    $1 AS notification_id,  -- 通知ID
    nc.id AS channel_id,
    'PENDING' AS delivery_status,
    CURRENT_TIMESTAMP
FROM common.notification_channel nc
JOIN common.notification_preference np 
    ON np.channel_id = nc.id
    AND np.notification_type_id = $2  -- 通知タイプID
    AND np.user_id = $3  -- ユーザーID
WHERE nc.is_active = true
AND np.is_enabled = true
AND NOT EXISTS (
    -- 既に同じ通知IDとチャネルIDの組み合わせが存在しないことを確認
    SELECT 1 FROM common.notification_delivery
    WHERE notification_id = $1 AND channel_id = nc.id
);

-- 配信ステータスの更新
UPDATE common.notification_delivery
SET
    delivery_status = $1,
    sent_at = CASE WHEN $1 IN ('SENT', 'DELIVERED') THEN CURRENT_TIMESTAMP ELSE sent_at END,
    external_id = $2,
    delivery_data = $3,
    error_message = $4,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $5;

-- 失敗した配信の再試行スケジュール
UPDATE common.notification_delivery
SET
    delivery_status = 'PENDING',
    retry_count = retry_count + 1,
    next_retry_at = CURRENT_TIMESTAMP + 
        CASE retry_count
            WHEN 0 THEN interval '5 minutes'
            WHEN 1 THEN interval '30 minutes'
            WHEN 2 THEN interval '2 hours'
            ELSE interval '6 hours'
        END,
    error_message = $1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $2
AND delivery_status = 'FAILED'
AND retry_count < 3;
```

### 3.3 通知テンプレート管理クエリパターン

```sql
-- 通知テンプレート一覧取得
SELECT
    id,
    template_code,
    name,
    description,
    title_template,
    content_template,
    short_content_template,
    icon,
    is_html,
    variables,
    language,
    created_at,
    updated_at
FROM common.notification_template
ORDER BY name;

-- 特定の言語の全テンプレートを取得
SELECT
    id,
    template_code,
    title_template,
    content_template,
    short_content_template,
    icon,
    is_html,
    variables
FROM common.notification_template
WHERE language = $1  -- 'ja', 'en' などの言語コード
ORDER BY template_code;

-- テンプレートの更新
UPDATE common.notification_template
SET
    name = $1,
    description = $2,
    title_template = $3,
    content_template = $4,
    short_content_template = $5,
    icon = $6,
    is_html = $7,
    variables = $8,
    updated_at = CURRENT_TIMESTAMP,
    updated_by = $9
WHERE id = $10;
```

## 4. データメンテナンス

### 4.1 定期メンテナンス処理

#### 4.1.1 期限切れ通知のクリーンアップ

```sql
-- 期限切れの通知を論理削除
WITH updated_notifications AS (
    UPDATE common.notification
    SET
        is_deleted = true,
        deleted_at = CURRENT_TIMESTAMP
    WHERE (expiry_date IS NOT NULL AND expiry_date < CURRENT_TIMESTAMP)
    AND is_deleted = false
    RETURNING id
)
SELECT COUNT(*) FROM updated_notifications;

-- 古い通知の物理削除（アーカイブ済みデータ）
DELETE FROM common.notification
WHERE created_at < CURRENT_TIMESTAMP - interval '1 year'
AND is_deleted = true;

-- 古い配信記録のクリーンアップ
DELETE FROM common.notification_delivery
WHERE created_at < CURRENT_TIMESTAMP - interval '3 months'
AND delivery_status IN ('SENT', 'DELIVERED', 'FAILED', 'BLOCKED', 'REJECTED');
```

#### 4.1.2 通知イベントのクリーンアップ

```sql
-- 処理済みのイベントをアーカイブまたは削除
INSERT INTO common.notification_event_archive
SELECT * FROM common.notification_event
WHERE is_processed = true
AND created_at < CURRENT_TIMESTAMP - interval '30 days';

DELETE FROM common.notification_event
WHERE is_processed = true
AND created_at < CURRENT_TIMESTAMP - interval '30 days';

-- 長期間処理に失敗したイベントのクリーンアップ
DELETE FROM common.notification_event
WHERE is_processed = false
AND retry_count >= 3
AND created_at < CURRENT_TIMESTAMP - interval '7 days';
```

### 4.2 通知設定の整合性チェック

```sql
-- 無効なユーザーへの通知設定を検出
SELECT np.id, np.user_id, np.notification_type_id, np.channel_id
FROM common.notification_preference np
LEFT JOIN common.user u ON np.user_id = u.id
WHERE u.id IS NULL OR u.status != 1;  -- 1 = アクティブユーザー

-- 無効な通知タイプまたはチャネルの設定を検出
SELECT np.id, np.user_id, np.notification_type_id, np.channel_id
FROM common.notification_preference np
LEFT JOIN common.notification_type nt ON np.notification_type_id = nt.id
LEFT JOIN common.notification_channel nc ON np.channel_id = nc.id
WHERE nt.id IS NULL OR nc.id IS NULL OR nc.is_active = false;

-- 設定可能でない通知タイプの設定を検出
SELECT np.id, np.user_id, np.notification_type_id, np.channel_id
FROM common.notification_preference np
JOIN common.notification_type nt ON np.notification_type_id = nt.id
WHERE nt.is_user_configurable = false;
```

### 4.3 通知配信統計の収集

```sql
-- 日次配信統計の生成
INSERT INTO common.notification_delivery_stats
(stats_date, channel_id, notification_type_id, total_count, success_count, failure_count, avg_delivery_time_ms)
SELECT
    date_trunc('day', nd.created_at)::date AS stats_date,
    nd.channel_id,
    n.type_id AS notification_type_id,
    COUNT(*) AS total_count,
    COUNT(CASE WHEN nd.delivery_status IN ('SENT', 'DELIVERED') THEN 1 END) AS success_count,
    COUNT(CASE WHEN nd.delivery_status = 'FAILED' THEN 1 END) AS failure_count,
    AVG(CASE 
        WHEN nd.delivery_status IN ('SENT', 'DELIVERED') AND nd.sent_at IS NOT NULL 
        THEN EXTRACT(EPOCH FROM (nd.sent_at - nd.created_at)) * 1000 
    END) AS avg_delivery_time_ms
FROM common.notification_delivery nd
JOIN common.notification n ON nd.notification_id = n.id
WHERE nd.created_at >= CURRENT_DATE - interval '7 days'
AND nd.created_at < CURRENT_DATE
GROUP BY stats_date, nd.channel_id, n.type_id
ON CONFLICT (stats_date, channel_id, notification_type_id) DO UPDATE SET
    total_count = EXCLUDED.total_count,
    success_count = EXCLUDED.success_count,
    failure_count = EXCLUDED.failure_count,
    avg_delivery_time_ms = EXCLUDED.avg_delivery_time_ms;
```

## 5. パフォーマンス最適化

### 5.1 特殊インデックス

#### 5.1.1 部分インデックス

```sql
-- 未読通知のみに対するインデックス
CREATE INDEX ix_notification_unread ON common.notification (user_id, created_at)
WHERE is_read = false AND is_deleted = false;

-- アクション可能な通知に対するインデックス
CREATE INDEX ix_notification_actionable ON common.notification (user_id, priority, created_at)
WHERE is_actionable = true AND is_read = false AND is_deleted = false;

-- 保留中の配信項目に対するインデックス
CREATE INDEX ix_notification_delivery_pending ON common.notification_delivery (channel_id, created_at)
WHERE delivery_status = 'PENDING';

-- 失敗した再試行対象の配信項目に対するインデックス
CREATE INDEX ix_notification_delivery_retry ON common.notification_delivery (next_retry_at)
WHERE delivery_status = 'FAILED' AND retry_count < 3 AND next_retry_at IS NOT NULL;

-- 未処理のイベントに対するインデックス
CREATE INDEX ix_notification_event_unprocessed ON common.notification_event (created_at)
WHERE is_processed = false AND retry_count < 3;
```

#### 5.1.2 複合インデックス

```sql
-- 通知の優先表示用インデックス
CREATE INDEX ix_notification_user_priority_time ON common.notification 
(user_id, is_read, is_deleted, priority, created_at);

-- チャネル対応の通知配信検索用インデックス
CREATE INDEX ix_notification_delivery_channel_status ON common.notification_delivery 
(channel_id, delivery_status, created_at);

-- イベント処理効率化用インデックス
CREATE INDEX ix_notification_event_type_processed ON common.notification_event
(event_type, is_processed, retry_count, created_at);
```

### 5.2 アドバンスト機能

#### 5.2.1 通知コンテンツの全文検索対応

```sql
-- 全文検索用のtsvectorカラム追加
ALTER TABLE common.notification ADD COLUMN content_tsv tsvector;

-- インデックス作成
CREATE INDEX ix_notification_content_tsv ON common.notification USING GIN (content_tsv);

-- 自動更新トリガー
CREATE OR REPLACE FUNCTION common.notification_tsvector_update_trigger()
RETURNS trigger AS $$
BEGIN
    NEW.content_tsv = setweight(to_tsvector('japanese', COALESCE(NEW.title, '')), 'A') ||
                      setweight(to_tsvector('japanese', COALESCE(NEW.content, '')), 'B');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_notification_tsvector_update
BEFORE INSERT OR UPDATE OF title, content ON common.notification
FOR EACH ROW EXECUTE FUNCTION common.notification_tsvector_update_trigger();

-- 全文検索クエリ例
SELECT id, title, short_content, created_at
FROM common.notification
WHERE user_id = $1
AND content_tsv @@ plainto_tsquery('japanese', $2)
ORDER BY created_at DESC;
```

#### 5.2.2 JSONBインデックス

```sql
-- コンテキストデータの特定フィールドに対するインデックス
CREATE INDEX gin_notification_context_task_id ON common.notification 
USING GIN ((context_data -> 'task_id'));

-- イベントデータの特定フィールドに対するインデックス
CREATE INDEX gin_notification_event_data_entity ON common.notification_event 
USING GIN ((data -> 'entity_id'));
```

### 5.3 パーティショニング

特に通知テーブルは大量のデータが蓄積されるため、日付によるパーティショニングを適用します。

```sql
-- 日付パーティショニングされた通知テーブルの作成
CREATE TABLE common.notification (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id integer NOT NULL,
    type_id integer NOT NULL,
    title varchar(200) NOT NULL,
    content text NOT NULL,
    short_content varchar(200),
    link_url varchar(500),
    icon_url varchar(255),
    is_read boolean NOT NULL DEFAULT false,
    read_at timestamptz,
    is_deleted boolean NOT NULL DEFAULT false,
    deleted_at timestamptz,
    is_actionable boolean NOT NULL DEFAULT false,
    action_text varchar(50),
    action_url varchar(500),
    priority smallint NOT NULL DEFAULT 3,
    expiry_date timestamptz,
    source_type varchar(100),
    source_id varchar(100),
    context_data jsonb,
    content_tsv tsvector,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer,
    CONSTRAINT ck_notification_priority CHECK (priority BETWEEN 1 AND 5)
) PARTITION BY RANGE (created_at);

-- パーティション自動作成関数
CREATE OR REPLACE FUNCTION common.create_notification_partition_for_month()
RETURNS void AS $$
DECLARE
    next_month date;
    partition_name text;
    partition_start date;
    partition_end date;
BEGIN
    -- 2ヶ月先の月を計算
    next_month := date_trunc('month', current_date + interval '2 month');
    
    -- パーティション名の生成
    partition_name := 'notification_' || to_char(next_month, 'YYYY_MM');
    
    -- パーティション範囲の計算
    partition_start := next_month;
    partition_end := next_month + interval '1 month';
    
    -- パーティションが存在しないか確認
    IF NOT EXISTS (
        SELECT 1 FROM pg_class c
        JOIN pg_namespace n ON n.oid = c.relnamespace
        WHERE n.nspname = 'common' AND c.relname = partition_name
    ) THEN
        -- パーティション作成
        EXECUTE format(
            'CREATE TABLE common.%I PARTITION OF common.notification
             FOR VALUES FROM (%L) TO (%L)',
            partition_name, partition_start, partition_end
        );
        
        -- インデックス作成
        EXECUTE format(
            'CREATE INDEX ix_%I_user_id ON common.%I (user_id, is_read, priority, created_at)',
            partition_name, partition_name
        );
        
        EXECUTE format(
            'CREATE INDEX ix_%I_type_id ON common.%I (type_id, created_at)',
            partition_name, partition_name
        );
        
        -- 未読通知用の部分インデックス
        EXECUTE format(
            'CREATE INDEX ix_%I_unread ON common.%I (user_id, created_at)
             WHERE is_read = false AND is_deleted = false',
            partition_name, partition_name
        );
        
        RAISE NOTICE 'Created partition: common.%', partition_name;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- 毎月1日に実行（pg_cron拡張を使用）
SELECT cron.schedule('0 0 1 * *', $$
    SELECT common.create_notification_partition_for_month();
$$);
```

## 6. セキュリティ考慮事項

### 6.1 データアクセス制御

```sql
-- 通知テーブルはユーザーIDによるアクセス制限が重要
CREATE OR REPLACE FUNCTION common.check_notification_access(p_notification_id uuid, p_user_id integer)
RETURNS boolean AS $$
DECLARE
    v_owner_id integer;
    v_is_admin boolean;
BEGIN
    -- 要求されたユーザーが管理者かどうか確認
    SELECT EXISTS (
        SELECT 1 FROM common.user_role ur
        JOIN common.role r ON ur.role_id = r.id
        WHERE ur.user_id = p_user_id
        AND r.role_code = 'ADMIN'
    ) INTO v_is_admin;
    
    -- 管理者の場合はアクセス許可
    IF v_is_admin THEN
        RETURN true;
    END IF;
    
    -- 通知の所有者を確認
    SELECT user_id INTO v_owner_id
    FROM common.notification
    WHERE id = p_notification_id;
    
    -- 所有者のみアクセス許可
    RETURN v_owner_id = p_user_id;
END;
$$ LANGUAGE plpgsql;

-- 通知設定のアクセス制御
CREATE OR REPLACE FUNCTION common.check_notification_preference_access(p_preference_id integer, p_user_id integer)
RETURNS boolean AS $$
DECLARE
    v_owner_id integer;
    v_is_admin boolean;
BEGIN
    -- 要求されたユーザーが管理者かどうか確認
    SELECT EXISTS (
        SELECT 1 FROM common.user_role ur
        JOIN common.role r ON ur.role_id = r.id
        WHERE ur.user_id = p_user_id
        AND r.role_code = 'ADMIN'
    ) INTO v_is_admin;
    
    -- 管理者の場合はアクセス許可
    IF v_is_admin THEN
        RETURN true;
    END IF;
    
    -- 設定の所有者を確認
    SELECT user_id INTO v_owner_id
    FROM common.notification_preference
    WHERE id = p_preference_id;
    
    -- 所有者のみアクセス許可
    RETURN v_owner_id = p_user_id;
END;
$$ LANGUAGE plpgsql;
```

### 6.2 監査ログ

通知関連の重要な操作に対して監査ログを記録するためのトリガーを実装します。

```sql
-- 通知既読処理の監査ログ
CREATE OR REPLACE FUNCTION common.notification_read_audit_trigger()
RETURNS trigger AS $$
BEGIN
    IF OLD.is_read = false AND NEW.is_read = true THEN
        INSERT INTO common.audit_log (
            user_id,
            action,
            entity_type,
            entity_id,
            details,
            status,
            ip_address
        ) VALUES (
            NEW.user_id,
            'READ',
            'NOTIFICATION',
            NEW.id::text,
            jsonb_build_object(
                'type_id', NEW.type_id,
                'title', NEW.title,
                'created_at', NEW.created_at
            ),
            'SUCCESS',
            current_setting('app.client_ip', true)::inet
        );
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_notification_read_audit
AFTER UPDATE OF is_read ON common.notification
FOR EACH ROW
WHEN (OLD.is_read = false AND NEW.is_read = true)
EXECUTE FUNCTION common.notification_read_audit_trigger();
```

### 6.3 通知テンプレートの検証

テンプレートが悪意のあるコードや危険なコンテンツを含まないようにするための検証を行います。

```sql
-- テンプレート検証関数
CREATE OR REPLACE FUNCTION common.validate_notification_template(
    p_title_template text,
    p_content_template text,
    p_is_html boolean
)
RETURNS boolean AS $$
DECLARE
    v_is_valid boolean := true;
    v_error_message text;
BEGIN
    -- HTMLテンプレートの場合のセキュリティチェック
    IF p_is_html THEN
        -- 危険なスクリプトタグの検出
        IF regexp_match(p_content_template, '<script.*>.*</script>') IS NOT NULL THEN
            v_is_valid := false;
            v_error_message := 'Script tags are not allowed in HTML templates';
        END IF;
        
        -- インラインJavaScriptの検出
        IF regexp_match(p_content_template, 'on\w+\s*=\s*["'']') IS NOT NULL THEN
            v_is_valid := false;
            v_error_message := 'Inline JavaScript event handlers are not allowed';
        END IF;
        
        -- iframeの検出
        IF regexp_match(p_content_template, '<iframe.*>') IS NOT NULL THEN
            v_is_valid := false;
            v_error_message := 'Iframe tags are not allowed';
        END IF;
        
        -- objectタグの検出
        IF regexp_match(p_content_template, '<object.*>') IS NOT NULL THEN
            v_is_valid := false;
            v_error_message := 'Object tags are not allowed';
        END IF;
    END IF;
    
    -- テンプレート変数の妥当性検証
    -- 例: {user_name} 形式の変数のみを許可
    IF regexp_match(p_title_template, '{[^}]+}') IS NOT NULL AND 
       regexp_match(p_title_template, '{[a-zA-Z0-9_]+}') IS NULL THEN
        v_is_valid := false;
        v_error_message := 'Invalid template variable format in title';
    END IF;
    
    IF regexp_match(p_content_template, '{[^}]+}') IS NOT NULL AND 
       regexp_match(p_content_template, '{[a-zA-Z0-9_]+}') IS NULL THEN
        v_is_valid := false;
        v_error_message := 'Invalid template variable format in content';
    END IF;
    
    -- 検証エラーがある場合は例外をスロー
    IF NOT v_is_valid THEN
        RAISE EXCEPTION 'Template validation failed: %', v_error_message;
    END IF;
    
    RETURN v_is_valid;
END;
$$ LANGUAGE plpgsql;

-- テンプレート保存前の検証トリガー
CREATE OR REPLACE FUNCTION common.notification_template_validate_trigger()
RETURNS trigger AS $$
BEGIN
    PERFORM common.validate_notification_template(
        NEW.title_template,
        NEW.content_template,
        NEW.is_html
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_notification_template_validate
BEFORE INSERT OR UPDATE ON common.notification_template
FOR EACH ROW EXECUTE FUNCTION common.notification_template_validate_trigger();
```

## 7. 運用時の注意点

1. **テンプレート管理**: 通知テンプレートは慎重に管理し、変更前にはプレビュー機能で検証すること。HTML形式のテンプレートはセキュリティリスクがあるため、特に注意が必要。

2. **パフォーマンス監視**: 通知処理はバックグラウンドで多数実行されるため、定期的にパフォーマンスを監視し、ボトルネックを特定すること。特に高負荷時には通知イベントのキューイングと処理能力のバランスが重要。

3. **配信チャネルの信頼性**: 各配信チャネル（特に外部サービス連携）の状態を監視し、問題が発生した場合はアラートを発報する仕組みを導入すること。連携障害時の代替チャネルの設定も検討。

4. **通知数の管理**: ユーザーに対する過剰な通知は体験を損なう可能性がある。通知の優先度と頻度を適切に設定し、ユーザーが細かく制御できる仕組みを提供すること。

5. **テンプレート変数の整合性**: テンプレート内の変数とイベントデータの整合性を維持すること。変数名の変更や削除は、すべての関連テンプレートの更新が必要。

6. **多言語対応**: 国際化対応を行う場合は、言語ごとのテンプレートを適切に管理し、新規言語追加時に全テンプレートが揃っていることを確認する仕組みを構築すること。