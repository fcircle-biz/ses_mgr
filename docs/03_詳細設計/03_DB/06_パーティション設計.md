# DB詳細設計 - パーティション設計

## 1. パーティショニングの基本方針

本システムでは、大規模なデータを効率的に管理するために、以下の方針に基づいてテーブルパーティショニングを行う。

### 1.1 パーティショニング目的

- **性能向上**: クエリパフォーマンスの向上
- **管理効率**: 大規模テーブルの効率的な管理
- **運用性向上**: バックアップ/リストア、メンテナンス作業の最適化
- **アーカイブ対応**: 古いデータの効率的なアーカイブ処理

### 1.2 パーティショニング対象の選定基準

以下の条件に合致するテーブルをパーティショニングの候補とする。

- **データ量**: 現在または将来的に大量のデータを持つテーブル（目安：100万行以上）
- **アクセスパターン**: データの一部のみにアクセスするパターンが多いテーブル
- **データライフサイクル**: 定期的にデータのアーカイブが必要なテーブル
- **書き込み競合**: 書き込み競合が発生しやすいテーブル

## 2. パーティショニング戦略

PostgreSQL 17では、以下のパーティショニング戦略を利用できる。

### 2.1 パーティショニング方式の比較

| 方式 | 概要 | 適した用途 | 制限事項 |
|------|------|-----------|---------|
| レンジパーティショニング | 連続した値の範囲でパーティション分割 | 時系列データ、日付範囲、数値範囲 | 範囲が明確に定義できる必要あり |
| リストパーティショニング | 値のリストでパーティション分割 | カテゴリデータ、地域コード、ステータスコード | 値が限定的で予測可能であること |
| ハッシュパーティショニング | ハッシュ関数を使用した分割 | 特定のパターンがなく均等に分散したい場合 | 特定のパーティションを効率的に選択できない |
| 複合パーティショニング | 上記方式を組み合わせたサブパーティショニング | 複雑なデータ分散要件がある場合 | 設計・管理の複雑さが増加 |

### 2.2 方式選定ガイドライン

テーブルの特性に応じた最適なパーティショニング方式を選定するためのガイドライン。

- **時系列データ** → レンジパーティショニング（日付/時刻）
- **地域別データ** → リストパーティショニング（地域コード）
- **ステータス別データ** → リストパーティショニング（ステータスコード）
- **均等分散が必要なデータ** → ハッシュパーティショニング（ID等）
- **時系列 + カテゴリ** → 複合パーティショニング（日付 + カテゴリ）

## 3. パーティショニング実装パターン

主要なパーティショニング実装パターンを示す。

### 3.1 レンジパーティショニング

日付や数値の範囲でパーティションを分割する方式。時系列データに最適。

#### 実装例（月次パーティショニング）:

```sql
-- 親テーブル定義
CREATE TABLE audit.system_log (
    id bigserial,
    log_time timestamptz NOT NULL,
    level varchar(10) NOT NULL,
    message text NOT NULL,
    source varchar(100),
    metadata jsonb
) PARTITION BY RANGE (log_time);

-- 月次パーティション（過去データ）
CREATE TABLE audit.system_log_y2024m01 PARTITION OF audit.system_log
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
CREATE TABLE audit.system_log_y2024m02 PARTITION OF audit.system_log
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
CREATE TABLE audit.system_log_y2024m03 PARTITION OF audit.system_log
    FOR VALUES FROM ('2024-03-01') TO ('2024-04-01');

-- 現在月＋将来数ヶ月のパーティション
CREATE TABLE audit.system_log_y2024m04 PARTITION OF audit.system_log
    FOR VALUES FROM ('2024-04-01') TO ('2024-05-01');
CREATE TABLE audit.system_log_y2024m05 PARTITION OF audit.system_log
    FOR VALUES FROM ('2024-05-01') TO ('2024-06-01');
CREATE TABLE audit.system_log_y2024m06 PARTITION OF audit.system_log
    FOR VALUES FROM ('2024-06-01') TO ('2024-07-01');

-- デフォルトパーティション（想定外の値用）
CREATE TABLE audit.system_log_default PARTITION OF audit.system_log DEFAULT;
```

#### 自動パーティション作成の実装例:

```sql
-- 新規パーティション自動作成用の関数
CREATE OR REPLACE FUNCTION audit.create_log_partition_for_month()
RETURNS void AS $$
DECLARE
    next_month date;
    partition_name text;
    partition_start date;
    partition_end date;
BEGIN
    -- 現在月の3か月先の月を計算
    next_month := date_trunc('month', current_date + interval '3 month');
    
    -- パーティション名の生成
    partition_name := 'system_log_y' || to_char(next_month, 'YYYY') || 'm' || to_char(next_month, 'MM');
    
    -- パーティション範囲の計算
    partition_start := next_month;
    partition_end := next_month + interval '1 month';
    
    -- パーティションが存在しないか確認
    IF NOT EXISTS (
        SELECT 1 FROM pg_class c
        JOIN pg_namespace n ON n.oid = c.relnamespace
        WHERE n.nspname = 'audit' AND c.relname = partition_name
    ) THEN
        -- パーティション作成
        EXECUTE format(
            'CREATE TABLE audit.%I PARTITION OF audit.system_log FOR VALUES FROM (%L) TO (%L)',
            partition_name, partition_start, partition_end
        );
        
        RAISE NOTICE 'Created partition: audit.%', partition_name;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- 毎月実行するジョブとして登録
-- pg_cron拡張を使用する場合
SELECT cron.schedule('0 0 1 * *', $$SELECT audit.create_log_partition_for_month()$$);
```

### 3.2 リストパーティショニング

値のリストに基づいてパーティションを分割する方式。カテゴリやステータスなどの明確な区分けがある場合に最適。

#### 実装例（ステータスコードによるパーティショニング）:

```sql
-- 親テーブル定義
CREATE TABLE project.project (
    id serial,
    title varchar(200) NOT NULL,
    description text,
    status_code smallint NOT NULL,
    start_date date,
    end_date date,
    customer_id integer NOT NULL,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamptz
) PARTITION BY LIST (status_code);

-- 進行中案件用パーティション
CREATE TABLE project.project_active PARTITION OF project.project
    FOR VALUES IN (1, 2, 3);  -- 1: 準備中, 2: 進行中, 3: 調整中

-- 完了案件用パーティション
CREATE TABLE project.project_completed PARTITION OF project.project
    FOR VALUES IN (4, 5);  -- 4: 完了, 5: 評価済み

-- キャンセル案件用パーティション
CREATE TABLE project.project_cancelled PARTITION OF project.project
    FOR VALUES IN (6, 7);  -- 6: 中止, 7: キャンセル

-- デフォルトパーティション
CREATE TABLE project.project_default PARTITION OF project.project DEFAULT;
```

### 3.3 ハッシュパーティショニング

ハッシュ関数を使用してパーティションを分割する方式。データを均等に分散させたい場合に最適。

#### 実装例（IDによるハッシュパーティショニング）:

```sql
-- 親テーブル定義
CREATE TABLE engineer.engineer (
    id serial,
    name varchar(100) NOT NULL,
    email varchar(255) NOT NULL,
    phone varchar(20),
    skills_json jsonb,
    status_code smallint NOT NULL,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamptz
) PARTITION BY HASH (id);

-- ハッシュパーティション（8分割の例）
CREATE TABLE engineer.engineer_p0 PARTITION OF engineer.engineer
    FOR VALUES WITH (MODULUS 8, REMAINDER 0);
CREATE TABLE engineer.engineer_p1 PARTITION OF engineer.engineer
    FOR VALUES WITH (MODULUS 8, REMAINDER 1);
CREATE TABLE engineer.engineer_p2 PARTITION OF engineer.engineer
    FOR VALUES WITH (MODULUS 8, REMAINDER 2);
CREATE TABLE engineer.engineer_p3 PARTITION OF engineer.engineer
    FOR VALUES WITH (MODULUS 8, REMAINDER 3);
CREATE TABLE engineer.engineer_p4 PARTITION OF engineer.engineer
    FOR VALUES WITH (MODULUS 8, REMAINDER 4);
CREATE TABLE engineer.engineer_p5 PARTITION OF engineer.engineer
    FOR VALUES WITH (MODULUS 8, REMAINDER 5);
CREATE TABLE engineer.engineer_p6 PARTITION OF engineer.engineer
    FOR VALUES WITH (MODULUS 8, REMAINDER 6);
CREATE TABLE engineer.engineer_p7 PARTITION OF engineer.engineer
    FOR VALUES WITH (MODULUS 8, REMAINDER 7);
```

### 3.4 複合パーティショニング

異なるパーティショニング方式を階層的に組み合わせる方式。複雑なデータ分散要件がある場合に最適。

#### 実装例（年次レンジ＋月次サブパーティション）:

```sql
-- 親テーブル定義
CREATE TABLE timesheet.working_hours (
    id bigserial,
    engineer_id integer NOT NULL,
    project_id integer NOT NULL,
    work_date date NOT NULL,
    hours numeric(4,2) NOT NULL,
    description text,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamptz
) PARTITION BY RANGE (work_date);

-- 年次パーティション
CREATE TABLE timesheet.working_hours_y2023 PARTITION OF timesheet.working_hours
    FOR VALUES FROM ('2023-01-01') TO ('2024-01-01')
    PARTITION BY RANGE (work_date);

CREATE TABLE timesheet.working_hours_y2024 PARTITION OF timesheet.working_hours
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01')
    PARTITION BY RANGE (work_date);

-- 2023年の月次サブパーティション
CREATE TABLE timesheet.working_hours_y2023m01 PARTITION OF timesheet.working_hours_y2023
    FOR VALUES FROM ('2023-01-01') TO ('2023-02-01');
CREATE TABLE timesheet.working_hours_y2023m02 PARTITION OF timesheet.working_hours_y2023
    FOR VALUES FROM ('2023-02-01') TO ('2023-03-01');
-- （以下、月次パーティション省略）

-- 2024年の月次サブパーティション
CREATE TABLE timesheet.working_hours_y2024m01 PARTITION OF timesheet.working_hours_y2024
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
CREATE TABLE timesheet.working_hours_y2024m02 PARTITION OF timesheet.working_hours_y2024
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
-- （以下、月次パーティション省略）

-- デフォルトパーティション
CREATE TABLE timesheet.working_hours_default PARTITION OF timesheet.working_hours DEFAULT;
```

## 4. モジュール別パーティショニング設計

各業務モジュールにおけるパーティショニング対象テーブルとその設計方針を示す。

### 4.1 共通モジュール（common）

| テーブル名 | パーティション方式 | パーティション列 | 分割単位 | 理由 |
|-----------|------------------|----------------|----------|------|
| common.log | RANGE | created_at | 月次 | ログデータは時系列で大量に蓄積されるため |
| common.notification | RANGE | created_at | 四半期 | 通知データは時系列で蓄積、アクセスパターンは最近のデータが中心 |
| common.file_storage | LIST | file_type | タイプ別 | ファイルタイプごとにアクセスパターンが異なるため |

### 4.2 技術者管理モジュール（engineer）

| テーブル名 | パーティション方式 | パーティション列 | 分割単位 | 理由 |
|-----------|------------------|----------------|----------|------|
| engineer.engineer | HASH | id | 8分割 | アクセスが均等で書き込み競合が発生する可能性があるため |
| engineer.skill_history | RANGE | updated_at | 年次 | 歴史的なスキル変更データは時系列で参照されるため |

### 4.3 案件管理モジュール（project）

| テーブル名 | パーティション方式 | パーティション列 | 分割単位 | 理由 |
|-----------|------------------|----------------|----------|------|
| project.project | LIST | status_code | ステータス別 | 進行中案件と完了案件で参照頻度が大きく異なるため |
| project.activity_log | RANGE | activity_date | 月次 | 活動ログは時系列で大量に蓄積されるため |

### 4.4 マッチングモジュール（matching）

| テーブル名 | パーティション方式 | パーティション列 | 分割単位 | 理由 |
|-----------|------------------|----------------|----------|------|
| matching.result | RANGE | created_at | 月次 | マッチング結果は時系列で蓄積され、直近のデータが頻繁にアクセスされるため |
| matching.search_history | RANGE | search_date | 週次 | 検索履歴は短期間でアクセス頻度が低下するため |

### 4.5 契約管理モジュール（contract）

| テーブル名 | パーティション方式 | パーティション列 | 分割単位 | 理由 |
|-----------|------------------|----------------|----------|------|
| contract.contract | LIST | status_code | ステータス別 | 契約状態によりアクセスパターンが異なるため |
| contract.document_version | RANGE | created_at | 四半期 | 文書バージョンは時系列で管理され、最新バージョンへのアクセスが多いため |

### 4.6 勤怠工数管理モジュール（timesheet）

| テーブル名 | パーティション方式 | パーティション列 | 分割単位 | 理由 |
|-----------|------------------|----------------|----------|------|
| timesheet.attendance | RANGE + LIST | work_date + status_code | 月次 + ステータス | 勤怠データは月次で処理され、承認状態によりアクセスパターンが異なるため |
| timesheet.working_hours | RANGE | work_date | 月次 | 工数データは月次で集計・参照されることが多いため |

### 4.7 請求支払管理モジュール（billing）

| テーブル名 | パーティション方式 | パーティション列 | 分割単位 | 理由 |
|-----------|------------------|----------------|----------|------|
| billing.invoice | RANGE | invoice_date | 月次 | 請求データは月次で発生し、時系列での参照が多いため |
| billing.payment | RANGE | payment_date | 月次 | 支払データは月次で処理され、時系列での参照が多いため |

### 4.8 レポーティングモジュール（reporting）

| テーブル名 | パーティション方式 | パーティション列 | 分割単位 | 理由 |
|-----------|------------------|----------------|----------|------|
| reporting.kpi_data | RANGE | period_date | 月次 | KPIデータは月次で集計され、時系列での参照が多いため |
| reporting.aggregated_data | RANGE + LIST | period_date + dimension | 月次 + 次元 | 集計データは期間と集計軸の組み合わせでアクセスされるため |

## 5. パーティショニング管理戦略

パーティショニングを効率的に運用するための管理戦略を示す。

### 5.1 パーティション作成自動化

定期的なパーティション追加を自動化する方法。

#### 自動化方針:

- 時系列パーティションは3ヶ月先まで前倒しで作成
- cron ジョブでの定期実行
- エラー通知の仕組み

#### 実装例:

```sql
-- パーティション作成関数（共通モジュール）
CREATE OR REPLACE FUNCTION common.create_monthly_partitions(
    p_schema text, 
    p_table text, 
    p_months_ahead int DEFAULT 3
)
RETURNS void AS $$
DECLARE
    next_date date;
    partition_name text;
    partition_start date;
    partition_end date;
BEGIN
    FOR i IN 1..p_months_ahead LOOP
        -- i ヶ月先の日付を計算
        next_date := date_trunc('month', current_date + (i * interval '1 month'));
        
        -- パーティション名の生成
        partition_name := p_table || '_y' || to_char(next_date, 'YYYY') || 'm' || to_char(next_date, 'MM');
        
        -- パーティション範囲の計算
        partition_start := next_date;
        partition_end := next_date + interval '1 month';
        
        -- パーティションが存在しないか確認
        IF NOT EXISTS (
            SELECT 1 FROM pg_class c
            JOIN pg_namespace n ON n.oid = c.relnamespace
            WHERE n.nspname = p_schema AND c.relname = partition_name
        ) THEN
            -- パーティション作成
            EXECUTE format(
                'CREATE TABLE %I.%I PARTITION OF %I.%I FOR VALUES FROM (%L) TO (%L)',
                p_schema, partition_name, p_schema, p_table, partition_start, partition_end
            );
            
            RAISE NOTICE 'Created partition: %.%', p_schema, partition_name;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- 各テーブルに対するパーティション作成バッチジョブ
CREATE OR REPLACE FUNCTION common.create_all_partitions()
RETURNS void AS $$
BEGIN
    -- 共通モジュールのパーティション作成
    PERFORM common.create_monthly_partitions('common', 'log', 3);
    PERFORM common.create_monthly_partitions('common', 'notification', 3);
    
    -- 勤怠工数モジュールのパーティション作成
    PERFORM common.create_monthly_partitions('timesheet', 'attendance', 3);
    PERFORM common.create_monthly_partitions('timesheet', 'working_hours', 3);
    
    -- 請求支払モジュールのパーティション作成
    PERFORM common.create_monthly_partitions('billing', 'invoice', 3);
    PERFORM common.create_monthly_partitions('billing', 'payment', 3);
    
    -- レポーティングモジュールのパーティション作成
    PERFORM common.create_monthly_partitions('reporting', 'kpi_data', 3);
    PERFORM common.create_monthly_partitions('reporting', 'aggregated_data', 3);
END;
$$ LANGUAGE plpgsql;

-- cron ジョブとして登録（pg_cron拡張を使用）
SELECT cron.schedule('0 1 1 * *', $$SELECT common.create_all_partitions()$$);
```

### 5.2 パーティションの削除・アーカイブ

古いデータのパーティションを効率的に削除またはアーカイブする方法。

#### アーカイブ方針:

- 一定期間（例：1年）経過したデータはアーカイブ
- 四半期ごとにアーカイブ処理を実施
- アーカイブデータは別のテーブルスペースまたはスキーマに移動

#### 実装例:

```sql
-- パーティションアーカイブ関数
CREATE OR REPLACE FUNCTION common.archive_old_partitions(
    p_schema text, 
    p_table text, 
    p_months_to_keep int DEFAULT 12
)
RETURNS void AS $$
DECLARE
    cutoff_date date;
    partition_name text;
    archive_schema text;
    r record;
BEGIN
    -- アーカイブ対象の日付を計算
    cutoff_date := date_trunc('month', current_date - (p_months_to_keep * interval '1 month'));
    archive_schema := p_schema || '_archive';
    
    -- アーカイブスキーマが存在しない場合は作成
    EXECUTE format('CREATE SCHEMA IF NOT EXISTS %I', archive_schema);
    
    -- パーティションの検索
    FOR r IN 
        SELECT c.relname AS partition_name
        FROM pg_class c
        JOIN pg_namespace n ON n.oid = c.relnamespace
        JOIN pg_inherits i ON i.inhrelid = c.oid
        JOIN pg_class parent ON i.inhparent = parent.oid
        JOIN pg_namespace pn ON parent.relnamespace = pn.oid
        WHERE pn.nspname = p_schema
        AND parent.relname = p_table
        AND c.relname ~ (p_table || '_y[0-9]{4}m[0-9]{2}')
        AND to_date(
            substring(c.relname FROM (p_table || '_y([0-9]{4})m([0-9]{2})$') FOR '#"%1$s-%2$s-01"#'),
            'YYYY-MM-DD'
        ) < cutoff_date
    LOOP
        partition_name := r.partition_name;
        
        -- アーカイブテーブルの作成
        EXECUTE format(
            'CREATE TABLE IF NOT EXISTS %I.%I (LIKE %I.%I INCLUDING ALL)',
            archive_schema, partition_name, p_schema, partition_name
        );
        
        -- データの移動
        EXECUTE format(
            'INSERT INTO %I.%I SELECT * FROM %I.%I',
            archive_schema, partition_name, p_schema, partition_name
        );
        
        -- 元のパーティションを切り離して削除
        EXECUTE format(
            'ALTER TABLE %I.%I DETACH PARTITION %I.%I',
            p_schema, p_table, p_schema, partition_name
        );
        
        EXECUTE format(
            'DROP TABLE %I.%I',
            p_schema, partition_name
        );
        
        RAISE NOTICE 'Archived partition: %.% to %.%', 
            p_schema, partition_name, archive_schema, partition_name;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- 各テーブルに対するアーカイブバッチジョブ
CREATE OR REPLACE FUNCTION common.archive_all_old_partitions()
RETURNS void AS $$
BEGIN
    -- 共通モジュールのパーティションアーカイブ
    PERFORM common.archive_old_partitions('common', 'log', 12);
    PERFORM common.archive_old_partitions('common', 'notification', 12);
    
    -- 勤怠工数モジュールのパーティションアーカイブ
    PERFORM common.archive_old_partitions('timesheet', 'attendance', 24);
    PERFORM common.archive_old_partitions('timesheet', 'working_hours', 24);
    
    -- 請求支払モジュールのパーティションアーカイブ
    PERFORM common.archive_old_partitions('billing', 'invoice', 36);
    PERFORM common.archive_old_partitions('billing', 'payment', 36);
    
    -- レポーティングモジュールのパーティションアーカイブ（集計データは長期保持）
    PERFORM common.archive_old_partitions('reporting', 'kpi_data', 60);
    PERFORM common.archive_old_partitions('reporting', 'aggregated_data', 60);
END;
$$ LANGUAGE plpgsql;

-- cron ジョブとして登録（pg_cron拡張を使用）
SELECT cron.schedule('0 2 1 1,4,7,10 *', $$SELECT common.archive_all_old_partitions()$$);
```

### 5.3 パーティション統計情報の管理

パーティショニングテーブルの統計情報を効率的に管理する方法。

#### 統計情報管理方針:

- 新規パーティション作成後に統計情報を初期化
- 定期的な統計情報の更新
- パーティション単位での統計情報更新

#### 実装例:

```sql
-- 新規パーティション統計情報初期化
CREATE OR REPLACE FUNCTION common.init_partition_stats(
    p_schema text,
    p_table text
)
RETURNS void AS $$
BEGIN
    EXECUTE format('ANALYZE %I.%I', p_schema, p_table);
    RAISE NOTICE 'Initialized statistics for %.%', p_schema, p_table;
END;
$$ LANGUAGE plpgsql;

-- パーティション統計情報更新関数
CREATE OR REPLACE FUNCTION common.update_partition_stats()
RETURNS void AS $$
DECLARE
    r record;
BEGIN
    -- 親テーブルのリスト
    FOR r IN 
        SELECT n.nspname AS schema_name, c.relname AS table_name
        FROM pg_class c
        JOIN pg_namespace n ON n.oid = c.relnamespace
        WHERE c.relkind = 'p'  -- パーティションテーブル
        AND n.nspname NOT IN ('pg_catalog', 'information_schema')
    LOOP
        -- 親テーブルの統計情報更新
        EXECUTE format('ANALYZE %I.%I', r.schema_name, r.table_name);
        RAISE NOTICE 'Updated statistics for parent table %.%', r.schema_name, r.table_name;
        
        -- 当月のパーティションを特定して統計情報更新
        EXECUTE format(
            'SELECT common.init_partition_stats(%L, %L || ''_y'' || to_char(current_date, ''YYYY'') || ''m'' || to_char(current_date, ''MM''))',
            r.schema_name, r.table_name
        );
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- cron ジョブとして登録（pg_cron拡張を使用）
SELECT cron.schedule('0 3 * * 0', $$SELECT common.update_partition_stats()$$);
```

## 6. パーティショニング性能モニタリング

パーティショニングの効果を評価するためのモニタリング方法を示す。

### 6.1 パーティション使用状況の監視

パーティションの使用状況や効率を監視するクエリ。

```sql
-- パーティションサイズと行数の監視
CREATE OR REPLACE VIEW common.partition_stats AS
SELECT
    nsp.nspname AS schema_name,
    parent.relname AS parent_table,
    child.relname AS partition_name,
    pg_size_pretty(pg_relation_size(child.oid)) AS partition_size,
    pg_size_pretty(pg_indexes_size(child.oid)) AS index_size,
    pg_stat_get_live_tuples(child.oid) AS row_count,
    pg_stat_get_ins_since_vacuum(child.oid) AS inserts_since_vacuum,
    pg_stat_get_last_analyze_time(child.oid) AS last_analyzed,
    pg_stat_get_last_vacuum_time(child.oid) AS last_vacuumed
FROM pg_inherits inh
JOIN pg_class child ON inh.inhrelid = child.oid
JOIN pg_class parent ON inh.inhparent = parent.oid
JOIN pg_namespace nsp ON child.relnamespace = nsp.oid
WHERE parent.relkind = 'p' -- パーティションドテーブル
AND nsp.nspname NOT IN ('pg_catalog', 'information_schema')
ORDER BY nsp.nspname, parent.relname, child.relname;

-- パーティションクエリ効率の監視
CREATE OR REPLACE VIEW common.partition_query_stats AS
WITH partition_queries AS (
    SELECT
        nsp.nspname AS schema_name,
        parent.relname AS parent_table,
        child.relname AS partition_name,
        s.userid,
        s.calls,
        s.rows,
        s.total_time,
        s.total_time / NULLIF(s.calls, 0) AS avg_time_per_call
    FROM pg_stat_statements s
    JOIN pg_inherits inh ON s.queryid = inh.inhrelid
    JOIN pg_class child ON inh.inhrelid = child.oid
    JOIN pg_class parent ON inh.inhparent = parent.oid
    JOIN pg_namespace nsp ON child.relnamespace = nsp.oid
    WHERE parent.relkind = 'p' -- パーティションドテーブル
    AND nsp.nspname NOT IN ('pg_catalog', 'information_schema')
)
SELECT
    schema_name,
    parent_table,
    partition_name,
    SUM(calls) AS total_calls,
    SUM(rows) AS total_rows,
    SUM(total_time) AS total_time,
    SUM(total_time) / NULLIF(SUM(calls), 0) AS avg_time_per_call
FROM partition_queries
GROUP BY schema_name, parent_table, partition_name
ORDER BY schema_name, parent_table, partition_name;
```

### 6.2 パーティション切り替え効率の監視

パーティションプルーニングの効率を監視するクエリ。

```sql
-- パーティションプルーニング効率の監視クエリ
CREATE OR REPLACE VIEW common.partition_pruning_stats AS
SELECT
    nsp.nspname AS schema_name,
    parent.relname AS parent_table,
    COUNT(child.oid) AS total_partitions,
    (SELECT COUNT(*) FROM pg_stat_user_tables t WHERE t.relname LIKE (parent.relname || '_%') AND t.schemaname = nsp.nspname AND t.idx_scan > 0) AS partitions_with_idx_scan,
    (SELECT COUNT(*) FROM pg_stat_user_tables t WHERE t.relname LIKE (parent.relname || '_%') AND t.schemaname = nsp.nspname AND t.seq_scan > 0) AS partitions_with_seq_scan
FROM pg_inherits inh
JOIN pg_class child ON inh.inhrelid = child.oid
JOIN pg_class parent ON inh.inhparent = parent.oid
JOIN pg_namespace nsp ON child.relnamespace = nsp.oid
WHERE parent.relkind = 'p' -- パーティションドテーブル
AND nsp.nspname NOT IN ('pg_catalog', 'information_schema')
GROUP BY nsp.nspname, parent.relname
ORDER BY nsp.nspname, parent.relname;
```

## 7. モジュール別テーブル定義補足との関連

各業務モジュールの「テーブル定義補足」ドキュメントには、モジュール固有のパーティション詳細設計を記載する。本ドキュメントは全体方針と共通パターンを定義し、各モジュールの詳細は対応する補足ドキュメントを参照すること。