# DB詳細設計 - インデックス設計

## 1. インデックス設計の基本方針

本システムにおけるインデックス設計では、以下の方針に基づいてインデックスを設計・実装する。

### 1.1 設計方針

- **パフォーマンス最適化**: クエリパフォーマンスの向上を目的として設計
- **選択的インデックス作成**: データアクセスパターンを考慮し必要な箇所にのみ作成
- **バランス考慮**: 検索速度と更新コストのバランスを考慮
- **段階的な改善**: パフォーマンス監視に基づき段階的に最適化

### 1.2 インデックス選定の判断基準

インデックスの作成を検討すべき列は以下の条件に基づいて選定する。

- **WHERE句での使用頻度**: 頻繁に検索条件として使用される列
- **結合条件**: テーブル結合の条件として使用される列（特に外部キー）
- **ORDER BY/GROUP BY**: ソートやグループ化に使用される列
- **データ分布**: カーディナリティとデータ分布の偏り
- **テーブルサイズ**: 大規模テーブルほどインデックスの効果が高い

## 2. インデックスタイプと用途

PostgreSQLで利用可能な各インデックスタイプの特性と用途を示す。

### 2.1 インデックスタイプの概要

| インデックスタイプ | 特徴 | 適した用途 | 制限事項 |
|------------------|------|-----------|---------|
| B-tree | デフォルト、バランスの良い性能 | 等値・範囲検索、ソート | NULL値を含む |
| Hash | 等値比較に最適化 | 等値検索のみ | 範囲検索、ソート不可 |
| GiST | 複雑な型向け汎用インデックス | 地理データ、全文検索 | 特定の演算子のみ |
| GIN | 複合要素を含むデータ向け | 配列、JSONB、全文検索 | 更新コスト高 |
| BRIN | 大規模テーブル向け軽量インデックス | 時系列データ、連続値 | 精度より効率重視 |
| SP-GiST | 空間分割による非バランスツリー | 特定の非均等分布データ | 特殊な用途向け |

### 2.2 B-treeインデックス

最も一般的に使用されるインデックスタイプで、大部分のユースケースに適している。

#### 適用例:

```sql
-- 主キーインデックス（自動作成）
CREATE TABLE engineer.engineer (
    id serial PRIMARY KEY,  -- 自動的にB-treeインデックスが作成される
    name varchar(100) NOT NULL,
    ...
);

-- 一般的な検索用インデックス
CREATE INDEX ix_engineer_name ON engineer.engineer (name);

-- 複合インデックス
CREATE INDEX ix_project_dates ON project.project (start_date, end_date);

-- 関数インデックス
CREATE INDEX ix_engineer_lower_name ON engineer.engineer (lower(name));
```

### 2.3 Hashインデックス

等値検索のみに使用される特化型インデックス。

#### 適用例:

```sql
-- ハッシュインデックス
CREATE INDEX ix_user_email_hash ON common.user USING hash (email);
```

### 2.4 GiSTインデックス

地理データや範囲型など特殊なデータタイプに対応するインデックス。

#### 適用例:

```sql
-- 地理データ用GiSTインデックス
CREATE INDEX ix_location_geo ON project.location USING gist (geo_data);

-- 範囲型用GiSTインデックス
CREATE INDEX ix_reservation_daterange ON timesheet.reservation USING gist (tsrange(start_time, end_time));

-- 全文検索用GiSTインデックス
CREATE INDEX ix_document_search_gist ON document.content USING gist (to_tsvector('japanese', content));
```

### 2.5 GINインデックス

配列や複合型、JSONB型など複数の要素を含むデータ型に適したインデックス。

#### 適用例:

```sql
-- 配列型用GINインデックス
CREATE INDEX ix_engineer_skills_gin ON engineer.engineer USING gin (skills);

-- JSONB型用GINインデックス
CREATE INDEX ix_project_attributes_gin ON project.project USING gin (attributes jsonb_path_ops);

-- 全文検索用GINインデックス（高精度）
CREATE INDEX ix_document_search_gin ON document.content USING gin (to_tsvector('japanese', content));
```

### 2.6 BRINインデックス

大規模テーブルに対して使用する軽量インデックス。特に順序性のあるデータで効果的。

#### 適用例:

```sql
-- 時系列データ用BRINインデックス
CREATE INDEX ix_log_timestamp_brin ON audit.system_log USING brin (timestamp);

-- 大規模テーブルの範囲検索用
CREATE INDEX ix_timesheet_date_brin ON timesheet.working_hours USING brin (work_date);
```

### 2.7 SP-GiSTインデックス

特殊な分布特性を持つデータ向けのインデックス。

#### 適用例:

```sql
-- IPアドレス範囲検索用
CREATE INDEX ix_access_log_ip_spgist ON audit.access_log USING spgist (ip_address);

-- 点データ用SP-GiSTインデックス
CREATE INDEX ix_location_point_spgist ON project.location USING spgist (point_data);
```

## 3. インデックス設計パターン

### 3.1 単一列インデックス

単一の列に対するインデックス。シンプルで広く使用される。

#### 設計パターン:

- **主キー/一意キー**: すべてのテーブルの主キーや一意制約のある列
- **外部キー**: 頻繁に結合条件として使われる外部キー列
- **頻出検索条件**: WHERE句で頻繁に使用される列

#### 実装例:

```sql
-- 主キーインデックス（自動作成）
CREATE TABLE common.user (
    id serial PRIMARY KEY,
    email varchar(255) NOT NULL
);

-- 一意キーインデックス（自動作成）
ALTER TABLE common.user ADD CONSTRAINT uq_user_email UNIQUE (email);

-- 外部キー検索用インデックス
CREATE INDEX ix_skill_engineer_id ON engineer.skill (engineer_id);

-- 頻出検索条件用インデックス
CREATE INDEX ix_engineer_status ON engineer.engineer (status_code);
```

### 3.2 複合インデックス

複数の列を組み合わせたインデックス。複数条件の検索やカバリングインデックスとして使用。

#### 設計パターン:

- **複合検索条件**: 複数の列が組み合わされた検索条件
- **カバリングインデックス**: クエリで必要な全ての列を含むインデックス
- **順序考慮**: 等値条件と範囲条件の組み合わせでは等値条件を先に配置

#### 実装例:

```sql
-- 複合検索条件用インデックス
CREATE INDEX ix_timesheet_engineer_date ON timesheet.working_hours (engineer_id, work_date);

-- カバリングインデックス
CREATE INDEX ix_project_summary ON project.project (id, title, status_code, start_date, end_date);

-- 順序を考慮した複合インデックス（等値条件を先に）
CREATE INDEX ix_invoice_customer_date ON billing.invoice (customer_id, invoice_date);
```

### 3.3 部分インデックス

条件を満たすレコードのみを対象とするインデックス。特定の条件に対する検索を最適化。

#### 設計パターン:

- **アクティブデータ**: アクティブな状態のレコードのみインデックス化
- **特定条件データ**: 特定の条件に該当するデータのみインデックス化
- **NULL除外**: NULL値を除外したインデックス

#### 実装例:

```sql
-- アクティブな技術者のみのインデックス
CREATE INDEX ix_engineer_active_skills ON engineer.engineer (skills) 
WHERE is_active = true;

-- 特定ステータスの案件のみのインデックス
CREATE INDEX ix_project_open_date ON project.project (start_date, end_date) 
WHERE status_code IN (1, 2, 3);  -- オープン状態の案件コード

-- NULL以外の値のみのインデックス
CREATE INDEX ix_contract_signed_date ON contract.contract (signed_date) 
WHERE signed_date IS NOT NULL;
```

### 3.4 関数インデックス

列に関数を適用した結果に対するインデックス。関数を使った検索を最適化。

#### 設計パターン:

- **大文字小文字無視**: 大文字小文字を区別しない検索
- **日付部分抽出**: 日付から年月日などを抽出する検索
- **計算結果**: 計算結果に基づく検索

#### 実装例:

```sql
-- 大文字小文字を区別しない検索用
CREATE INDEX ix_engineer_lower_name ON engineer.engineer (lower(name));

-- 月次集計用
CREATE INDEX ix_timesheet_year_month ON timesheet.working_hours (EXTRACT(YEAR FROM work_date), EXTRACT(MONTH FROM work_date));

-- 計算結果に基づく検索用
CREATE INDEX ix_billing_tax_amount ON billing.invoice ((amount * tax_rate));
```

### 3.5 インクルードインデックス

インデックスキーとは別に「含める列」を指定することで、インデックスオンリースキャンを可能にする。

#### 設計パターン:

- **頻出参照列の追加**: 検索条件以外の頻繁に参照される列を含める
- **テーブルアクセス削減**: インデックスのみで結果を返せるようにする

#### 実装例:

```sql
-- インクルードインデックス
CREATE INDEX ix_project_status_include ON project.project (status_code) INCLUDE (title, start_date, end_date);

-- 複合キー + インクルード
CREATE INDEX ix_timesheet_engineer_date_include ON timesheet.working_hours (engineer_id, work_date) INCLUDE (hours, project_id);
```

## 4. モジュール別インデックス要件

主要モジュールごとの特徴的なインデックス要件を定義する。

### 4.1 共通モジュール（common）

- ユーザー認証・認可関連のインデックス
- コード値参照の高速化
- ファイル管理の効率化

#### 実装例:

```sql
-- ユーザー認証用インデックス
CREATE UNIQUE INDEX uix_user_email ON common.user (email);
CREATE INDEX ix_user_last_login ON common.user (last_login_datetime);

-- コード値参照用インデックス
CREATE INDEX ix_code_value_category ON common.code_value (category_id, sort_order);
CREATE INDEX ix_code_value_code ON common.code_value (category_id, code);

-- ファイル管理用インデックス
CREATE INDEX ix_file_storage_type ON common.file_storage (file_type, created_at);
CREATE INDEX ix_file_storage_reference ON common.file_storage (reference_type, reference_id);
```

### 4.2 技術者管理モジュール（engineer）

- 技術者検索の最適化
- スキルベースの検索
- 稼働状況確認の効率化

#### 実装例:

```sql
-- 技術者検索用インデックス
CREATE INDEX ix_engineer_status ON engineer.engineer (status_code);
CREATE INDEX ix_engineer_skills ON engineer.engineer USING gin (skills_json jsonb_path_ops);
CREATE INDEX ix_engineer_fulltext ON engineer.engineer USING gin (to_tsvector('japanese', name || ' ' || biography));

-- 稼働状況確認用インデックス
CREATE INDEX ix_availability_date_range ON engineer.availability (engineer_id, start_date, end_date);
CREATE INDEX ix_availability_status ON engineer.availability (status_code, start_date);
```

### 4.3 案件管理モジュール（project）

- 案件検索の最適化
- ステータスベースの検索
- 期間ベースの検索

#### 実装例:

```sql
-- 案件検索用インデックス
CREATE INDEX ix_project_status ON project.project (status_code);
CREATE INDEX ix_project_customer ON project.project (customer_id);
CREATE INDEX ix_project_date_range ON project.project (start_date, end_date);
CREATE INDEX ix_project_fulltext ON project.project USING gin (to_tsvector('japanese', title || ' ' || description));

-- 案件要件検索用インデックス
CREATE INDEX ix_requirement_skill ON project.requirement (skill_id, importance);
```

### 4.4 マッチングモジュール（matching）

- マッチング結果の高速検索
- スコアベースのソート
- 提案管理の効率化

#### 実装例:

```sql
-- マッチング結果用インデックス
CREATE INDEX ix_matching_result_project ON matching.result (project_id, score DESC);
CREATE INDEX ix_matching_result_engineer ON matching.result (engineer_id, score DESC);

-- 提案管理用インデックス
CREATE INDEX ix_proposal_status ON matching.proposal (status_code, created_at);
CREATE INDEX ix_proposal_project_engineer ON matching.proposal (project_id, engineer_id);
```

### 4.5 契約管理モジュール（contract）

- 契約状態の検索
- 期間ベースの検索
- 契約書ドキュメント管理

#### 実装例:

```sql
-- 契約検索用インデックス
CREATE INDEX ix_contract_status ON contract.contract (status_code);
CREATE INDEX ix_contract_date_range ON contract.contract (start_date, end_date);
CREATE INDEX ix_contract_parties ON contract.contract (customer_id, engineer_id);

-- 契約書ドキュメント管理用インデックス
CREATE INDEX ix_document_version ON contract.document (contract_id, version DESC);
CREATE INDEX ix_document_status ON contract.document (status_code, updated_at);
```

### 4.6 勤怠工数管理モジュール（timesheet）

- 日付ベースの検索
- 技術者ベースの検索
- 集計の効率化

#### 実装例:

```sql
-- 勤怠管理用インデックス
CREATE INDEX ix_attendance_date ON timesheet.attendance (work_date);
CREATE INDEX ix_attendance_engineer_date ON timesheet.attendance (engineer_id, work_date);
CREATE INDEX ix_attendance_status ON timesheet.attendance (status_code, work_date);

-- 工数管理用インデックス
CREATE INDEX ix_working_hours_project_date ON timesheet.working_hours (project_id, work_date);
CREATE INDEX ix_working_hours_engineer_month ON timesheet.working_hours (engineer_id, EXTRACT(YEAR FROM work_date), EXTRACT(MONTH FROM work_date));

-- 承認管理用インデックス
CREATE INDEX ix_approval_status ON timesheet.approval (status_code, updated_at);
CREATE INDEX ix_approval_approver ON timesheet.approval (approver_id, status_code);
```

### 4.7 請求支払管理モジュール（billing）

- 請求情報の検索
- 支払状況の検索
- 期間ベースの検索

#### 実装例:

```sql
-- 請求管理用インデックス
CREATE INDEX ix_invoice_customer ON billing.invoice (customer_id, invoice_date);
CREATE INDEX ix_invoice_status ON billing.invoice (status_code, due_date);
CREATE INDEX ix_invoice_date_range ON billing.invoice (invoice_date, due_date);

-- 支払管理用インデックス
CREATE INDEX ix_payment_status ON billing.payment (status_code, payment_date);
CREATE INDEX ix_payment_invoice ON billing.payment (invoice_id);
```

### 4.8 レポーティングモジュール（reporting）

- KPI検索の最適化
- 集計データの効率的なアクセス
- 時系列データの分析

#### 実装例:

```sql
-- KPI管理用インデックス
CREATE INDEX ix_kpi_period ON reporting.kpi (period_type, period_value);
CREATE INDEX ix_kpi_category ON reporting.kpi (category, name);

-- 集計データ用インデックス
CREATE INDEX ix_aggregated_data_dimension ON reporting.aggregated_data (dimension, period);
CREATE INDEX ix_aggregated_data_measure ON reporting.aggregated_data (measure, period);

-- 予測データ用インデックス
CREATE INDEX ix_forecast_target_period ON reporting.forecast (target, period_type, period_value);
```

## 5. インデックスメンテナンス

### 5.1 インデックス再構築

インデックスの断片化や肥大化を防ぐために、定期的なメンテナンスを行う。

#### メンテナンスポリシー:

- 大規模更新後のインデックス再構築
- 定期的なインデックス統計情報の更新
- 未使用インデックスの特定と削除

#### 実装例:

```sql
-- インデックス再構築
REINDEX INDEX ix_engineer_skills;

-- 特定のテーブルの全インデックスを再構築
REINDEX TABLE engineer.engineer;

-- 統計情報の更新
ANALYZE engineer.engineer;

-- 特定のスキーマの全テーブルの統計情報を更新
ANALYZE engineer;
```

### 5.2 インデックス使用状況の監視

インデックスの効果的な利用を確保するために、使用状況を監視する。

#### 監視項目:

- インデックスのサイズと肥大化率
- インデックスの使用頻度
- インデックスの効率（スキャン回数vs取得行数）
- 未使用インデックスの特定

#### 監視クエリ例:

```sql
-- インデックスサイズの確認
SELECT
    schemaname || '.' || relname AS table_name,
    indexrelname AS index_name,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_all_indexes
WHERE schemaname NOT LIKE 'pg_%' AND schemaname != 'information_schema'
ORDER BY pg_relation_size(indexrelid) DESC
LIMIT 20;

-- インデックス使用状況の確認
SELECT
    schemaname || '.' || relname AS table_name,
    indexrelname AS index_name,
    idx_scan AS index_scans,
    idx_tup_read AS tuples_read,
    idx_tup_fetch AS tuples_fetched
FROM pg_stat_all_indexes
WHERE schemaname NOT LIKE 'pg_%' AND schemaname != 'information_schema'
ORDER BY idx_scan DESC
LIMIT 20;

-- 未使用インデックスの確認
SELECT
    schemaname || '.' || relname AS table_name,
    indexrelname AS index_name,
    idx_scan AS index_scans,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_all_indexes
WHERE schemaname NOT LIKE 'pg_%' 
  AND schemaname != 'information_schema'
  AND idx_scan = 0
ORDER BY pg_relation_size(indexrelid) DESC
LIMIT 20;
```

## 6. 性能チューニング手法

### 6.1 実行計画の分析

クエリの実行計画を分析し、インデックスの効果を確認・最適化する。

#### 分析手法:

- EXPLAINコマンドを使用した実行計画の確認
- 実際の実行時間の測定（EXPLAIN ANALYZE）
- インデックススキャンvs.シーケンシャルスキャンの判断
- インデックスオンリースキャンの活用

#### 実装例:

```sql
-- 実行計画の確認
EXPLAIN SELECT * FROM engineer.engineer WHERE status_code = 1;

-- 実際の実行時間を含む詳細な実行計画
EXPLAIN ANALYZE SELECT * FROM engineer.engineer WHERE status_code = 1;

-- バッファ使用状況なども含めた詳細情報
EXPLAIN (ANALYZE, BUFFERS) 
SELECT e.name, e.email, p.title
FROM engineer.engineer e
JOIN project.project_engineer pe ON e.id = pe.engineer_id
JOIN project.project p ON pe.project_id = p.id
WHERE e.status_code = 1 AND p.status_code = 2;
```

### 6.2 インデックス最適化手法

より効率的なインデックス利用のための最適化手法。

#### 最適化手法:

- 選択性の高い列を先頭に配置
- 部分インデックスでの絞り込み
- データ分布に応じたインデックスタイプの選択
- インデックスのカバリング化

#### 実装例:

```sql
-- 選択性を考慮した複合インデックス（高選択性の列を先頭に）
CREATE INDEX ix_contract_optimized ON contract.contract (type_code, customer_id, start_date);

-- データ分布に応じたBRINインデックス（時系列データ）
CREATE INDEX ix_log_timestamp_optimized ON audit.system_log USING brin (timestamp) WITH (pages_per_range = 128);

-- カバリングインデックス（頻出クエリの全カラムを含む）
CREATE INDEX ix_engineer_search_covering ON engineer.engineer 
(status_code, skill_category_id) INCLUDE (name, email, phone);
```

## 7. インデックス設計ドキュメント

### 7.1 インデックス設計書テンプレート

各テーブルのインデックス設計を記録するためのテンプレート。

```
## テーブル：[スキーマ名].[テーブル名]

### インデックス一覧

| インデックス名 | タイプ | 列 | 条件 | 目的 | 備考 |
|--------------|-------|-----|-----|------|-----|
| [インデックス名] | [B-tree/Hash/GIN等] | [カラム名] | [条件式] | [検索/ソート等の目的] | [その他特記事項] |

### 想定クエリパターン

```sql
-- クエリ例1
SELECT ...

-- クエリ例2
SELECT ...
```

### 性能要件

- 検索時間：[目標値]
- 更新時間：[目標値]
- その他要件：[説明]
```

### 7.2 インデックス設計の審査観点

インデックス設計の審査時に確認すべき観点。

- **必要性**: 本当にそのインデックスが必要か
- **重複**: 既存インデックスと機能が重複していないか
- **効果**: 対象クエリに対して効果的か
- **コスト**: 更新・維持コストが許容範囲内か
- **代替案**: より効率的な設計はないか
- **命名規則**: 命名規則に準拠しているか
- **特定条件**: 特定条件対応の要件はないか

## 8. モジュール別テーブル定義補足との関連

各業務モジュールの「テーブル定義補足」ドキュメントには、モジュール固有のインデックス詳細設計を記載する。本ドキュメントは全体方針と共通パターンを定義し、各モジュールの詳細は対応する補足ドキュメントを参照すること。