# DB詳細設計 - モニタリング設計

## 1. モニタリングの基本方針

本システムにおけるデータベースのモニタリングは、以下の方針に基づいて設計・実装する。

### 1.1 モニタリング目標

- **リアルタイム性**: 問題の早期検出と迅速な対応
- **網羅性**: データベース全体の健全性を包括的にモニタリング
- **予防検知**: 問題が発生する前の予兆検出
- **自動化**: モニタリングプロセスの自動化と運用負荷の軽減
- **集中管理**: 監視情報の一元管理とダッシュボード化

### 1.2 モニタリング対象

以下の主要な項目をモニタリングの対象とする。

- **可用性**: データベースの稼働状況と接続性
- **パフォーマンス**: クエリのレスポンスタイムとスループット
- **リソース使用状況**: CPU、メモリ、ディスク、コネクション
- **キャッシュ効率**: バッファキャッシュのヒット率など
- **トランザクション**: トランザクション数と処理時間
- **ロック**: ロック競合とブロッキング状況
- **レプリケーション**: レプリケーション遅延と健全性
- **バックアップ**: バックアップの成功/失敗とサイズ
- **セキュリティ**: 不審なアクセスや認証失敗

## 2. モニタリングアーキテクチャ

### 2.1 モニタリングコンポーネント

本システムでは、以下のコンポーネントを組み合わせたモニタリングアーキテクチャを採用する。

#### 2.1.1 コンポーネント構成

| コンポーネント | 役割 | 実装例 |
|--------------|------|-------|
| メトリクス収集 | データベースからの各種メトリクスの収集 | PostgreSQL統計ビュー、pg_stat_statements、prometheus-postgres-exporter |
| メトリクスストレージ | 収集したメトリクスの蓄積と集計 | Prometheus、InfluxDB |
| ログ収集・分析 | データベースログの収集と分析 | Fluentd、Elasticsearch |
| アラート管理 | しきい値超過時のアラート発行と管理 | Alertmanager、Grafana Alerting |
| 可視化 | メトリクスの視覚化とダッシュボード | Grafana |
| レポート生成 | 定期的なパフォーマンスレポートの生成 | Grafana、カスタムスクリプト |

#### 2.1.2 アーキテクチャ図

```
+----------------+     +---------------------+     +----------------+
| PostgreSQLサーバ |     | モニタリングサーバ   |     | アラート通知   |
+----------------+     +---------------------+     +----------------+
        |                        |                        |
        v                        v                        v
+----------------+     +---------------------+     +----------------+
| メトリクス収集   |---->| メトリクスストレージ |---->| アラート管理   |
| (exporter)     |     | (Prometheus)       |     | (Alertmanager) |
+----------------+     +---------------------+     +----------------+
        |                        |                        |
        v                        v                        v
+----------------+     +---------------------+     +----------------+
| ログ収集       |---->| ログストレージ       |---->| メール/Slack等 |
| (Fluentd)     |     | (Elasticsearch)     |     | 通知チャネル   |
+----------------+     +---------------------+     +----------------+
                                |
                                v
                       +---------------------+
                       | ダッシュボード      |
                       | (Grafana)          |
                       +---------------------+
```

### 2.2 PostgreSQL固有のモニタリング

PostgreSQLデータベースを効果的にモニタリングするための設定。

#### 2.2.1 統計情報収集の設定

```
# postgresql.conf設定例

# 統計情報コレクタの設定
track_activities = on
track_counts = on
track_io_timing = on
track_functions = pl             # プロシージャ言語関数の追跡
track_activity_query_size = 4096 # 記録されるクエリテキストの最大サイズ

# 実行統計情報の設定
log_statement_stats = off        # 利用しない場合はオフに
log_parser_stats = off           # 利用しない場合はオフに
log_planner_stats = off          # 利用しない場合はオフに
log_executor_stats = off         # 利用しない場合はオフに

# pg_stat_statements拡張の設定
shared_preload_libraries = 'pg_stat_statements'  # 起動時に読み込むライブラリ
pg_stat_statements.max = 10000                   # 追跡するステートメントの最大数
pg_stat_statements.track = all                   # すべてのステートメントを追跡
```

#### 2.2.2 ログ設定

```
# postgresql.conf設定例

# ログの出力先
log_destination = 'csvlog'        # CSVログ形式
logging_collector = on            # 標準エラー出力のログファイルへのリダイレクト
log_directory = 'pg_log'          # ログファイルディレクトリ
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'  # ログファイル名パターン
log_rotation_age = 1d             # ログローテーション（時間）
log_rotation_size = 100MB         # ログローテーション（サイズ）

# ログの詳細度
log_min_messages = warning        # 出力するメッセージレベル
log_min_error_statement = error   # エラー時のステートメント出力
log_min_duration_statement = 5000 # スロークエリログ（5秒以上）
log_checkpoints = on              # チェックポイント情報の出力
log_connections = on              # 接続情報の出力
log_disconnections = on           # 切断情報の出力
log_lock_waits = on               # ロック待ち情報の出力
log_temp_files = 0                # 一時ファイル使用の出力
log_autovacuum_min_duration = 0   # 自動VACUUMの情報出力

# ログの内容
log_line_prefix = '%m [%p:%l] %q%u@%d '  # ログの行頭プレフィックス
log_statement = 'mod'             # DDL/DML文のログ出力
log_error_verbosity = default     # エラーの詳細度
```

## 3. メトリクス収集とモニタリング

### 3.1 基本システムメトリクス

データベースサーバの基本的なシステムメトリクスの収集と監視方法。

#### 3.1.1 CPU使用率

```sql
-- CPUビジー率の監視
SELECT
    pid,
    usename AS username,
    datname AS database,
    client_addr AS client,
    application_name AS application,
    backend_start,
    state,
    state_change,
    wait_event_type,
    wait_event,
    query,
    pg_stat_activity.backend_type,
    pg_stat_get_backend_pid(s.backendid) AS backend_pid,
    pg_stat_get_backend_activity_start(s.backendid) AS backend_activity_start,
    pg_stat_get_backend_xact_start(s.backendid) AS backend_xact_start,
    pg_stat_get_backend_wait_event_type(s.backendid) AS backend_wait_event_type,
    pg_stat_get_backend_wait_event(s.backendid) AS backend_wait_event,
    pg_stat_get_backend_activity(s.backendid) AS backend_activity
FROM
    pg_stat_activity
JOIN
    (SELECT backendid FROM pg_stat_get_backend_idset() AS backendid) AS s
ON
    pg_stat_activity.pid = pg_stat_get_backend_pid(s.backendid)
WHERE
    pg_stat_activity.state = 'active'
AND
    pid <> pg_backend_pid();
```

##### モニタリングしきい値:

- **注意**: CPU使用率 > 70%が5分間継続
- **警告**: CPU使用率 > 85%が5分間継続
- **重大**: CPU使用率 > 95%が5分間継続

#### 3.1.2 メモリ使用率

```sql
-- 共有バッファ使用状況
SELECT
    sum(heap_blks_read) as heap_read,
    sum(heap_blks_hit) as heap_hit,
    sum(heap_blks_hit) / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0) as ratio
FROM pg_statio_user_tables;

-- 各テーブルのバッファ使用状況
SELECT
    c.relname,
    pg_size_pretty(count(*) * 8192) as buffered,
    round(100.0 * count(*) / (SELECT setting::integer FROM pg_settings WHERE name='shared_buffers'), 2) as buffer_percent,
    round(100.0 * count(*) * 8192 / pg_table_size(c.oid), 2) as percent_of_relation
FROM pg_class c
INNER JOIN pg_buffercache b ON b.relfilenode = c.relfilenode
INNER JOIN pg_database d ON (b.reldatabase = d.oid AND d.datname = current_database())
WHERE c.relkind IN ('r', 't') AND c.relpersistence != 't'
GROUP BY c.oid, c.relname
ORDER BY 3 DESC
LIMIT 10;
```

##### モニタリングしきい値:

- **注意**: バッファキャッシュヒット率 < 95%
- **警告**: バッファキャッシュヒット率 < 90%
- **重大**: バッファキャッシュヒット率 < 80%

#### 3.1.3 ディスク使用率

```sql
-- データベースサイズ
SELECT
    pg_database.datname,
    pg_size_pretty(pg_database_size(pg_database.datname)) AS size
FROM pg_database
ORDER BY pg_database_size(pg_database.datname) DESC;

-- 最大のテーブル
SELECT
    nspname || '.' || relname AS relation,
    pg_size_pretty(pg_total_relation_size(C.oid)) AS total_size,
    pg_size_pretty(pg_relation_size(C.oid)) AS data_size,
    pg_size_pretty(pg_total_relation_size(C.oid) - pg_relation_size(C.oid)) AS external_size
FROM pg_class C
LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace)
WHERE nspname NOT IN ('pg_catalog', 'information_schema')
AND C.relkind = 'r'
ORDER BY pg_total_relation_size(C.oid) DESC
LIMIT 20;

-- テーブルスペース使用率
SELECT
    spcname AS tablespace,
    pg_size_pretty(pg_tablespace_size(spcname)) AS size,
    pg_tablespace_location(oid) AS location
FROM pg_tablespace
ORDER BY pg_tablespace_size(spcname) DESC;
```

##### モニタリングしきい値:

- **注意**: ディスク使用率 > 70%
- **警告**: ディスク使用率 > 85%
- **重大**: ディスク使用率 > 95%

#### 3.1.4 I/O使用率

```sql
-- I/O統計情報
SELECT
    datname,
    temp_files,
    temp_bytes,
    blks_read,
    blks_hit,
    tup_returned,
    tup_fetched,
    tup_inserted,
    tup_updated,
    tup_deleted
FROM pg_stat_database
WHERE datname = current_database();

-- テーブルごとのI/O統計
SELECT
    schemaname,
    relname,
    heap_blks_read,
    heap_blks_hit,
    idx_blks_read,
    idx_blks_hit,
    toast_blks_read,
    toast_blks_hit,
    tidx_blks_read,
    tidx_blks_hit
FROM pg_statio_user_tables
ORDER BY (heap_blks_read + idx_blks_read) DESC
LIMIT 10;
```

##### モニタリングしきい値:

- **注意**: 読み取りI/O > 5000 IOPS継続
- **警告**: 読み取りI/O > 10000 IOPS継続
- **重大**: 読み取りI/O > 20000 IOPS継続

### 3.2 PostgreSQL固有のメトリクス

PostgreSQL特有のデータベースメトリクスの収集と監視方法。

#### 3.2.1 接続数

```sql
-- 接続数の監視
SELECT
    max_conn,
    used,
    res_for_super,
    max_conn - used - res_for_super AS remaining
FROM
    (SELECT setting::int AS max_conn FROM pg_settings WHERE name = 'max_connections') AS max_conn,
    (SELECT setting::int AS res_for_super FROM pg_settings WHERE name = 'superuser_reserved_connections') AS res_for_super,
    (SELECT count(*) AS used FROM pg_stat_activity WHERE pid <> pg_backend_pid()) AS used;

-- 接続状態ごとの数
SELECT
    state,
    count(*) AS count
FROM pg_stat_activity
WHERE pid <> pg_backend_pid()
GROUP BY state
ORDER BY count DESC;

-- 最長実行中のクエリ
SELECT
    now() - query_start AS duration,
    datname,
    usename,
    query
FROM pg_stat_activity
WHERE state = 'active'
AND pid <> pg_backend_pid()
ORDER BY duration DESC
LIMIT 5;
```

##### モニタリングしきい値:

- **注意**: 接続数 > 最大接続数の 70%
- **警告**: 接続数 > 最大接続数の 85%
- **重大**: 接続数 > 最大接続数の 95%

#### 3.2.2 トランザクション状態

```sql
-- トランザクション統計
SELECT
    datname,
    numbackends,
    xact_commit,
    xact_rollback,
    blks_read,
    blks_hit,
    tup_returned,
    tup_fetched,
    tup_inserted,
    tup_updated,
    tup_deleted,
    conflicts,
    temp_files,
    temp_bytes,
    deadlocks,
    blk_read_time,
    blk_write_time
FROM pg_stat_database
WHERE datname = current_database();

-- 長時間実行トランザクション
SELECT
    pid,
    usename,
    now() - xact_start AS xact_runtime,
    now() - query_start AS query_runtime,
    query
FROM pg_stat_activity
WHERE state = 'active'
AND xact_start IS NOT NULL
AND now() - xact_start > '00:30:00'::interval
ORDER BY xact_runtime DESC;
```

##### モニタリングしきい値:

- **注意**: トランザクション実行時間 > 5分
- **警告**: トランザクション実行時間 > 15分
- **重大**: トランザクション実行時間 > 30分

#### 3.2.3 ロック状態

```sql
-- ロック競合の監視
WITH blocked_queries AS (
    SELECT
        pid,
        usename,
        pg_blocking_pids(pid) AS blocked_by,
        query,
        now() - query_start AS waiting_duration
    FROM pg_stat_activity
    WHERE wait_event_type = 'Lock'
    AND wait_event IS NOT NULL
)
SELECT
    b.pid AS blocked_pid,
    b.usename AS blocked_user,
    b.blocked_by,
    array_to_string(b.blocked_by, ',') AS blocking_pids,
    a.usename AS blocking_user,
    a.query AS blocking_query,
    b.query AS blocked_query,
    b.waiting_duration
FROM blocked_queries b
JOIN pg_stat_activity a ON a.pid = ANY(b.blocked_by)
ORDER BY b.waiting_duration DESC;

-- テーブルごとのロック数
SELECT
    relname,
    count(*) AS lock_count
FROM pg_locks l
JOIN pg_class c ON l.relation = c.oid
WHERE l.mode IN ('ExclusiveLock', 'AccessExclusiveLock')
GROUP BY relname
ORDER BY lock_count DESC;
```

##### モニタリングしきい値:

- **注意**: ロック待ち時間 > 10秒
- **警告**: ロック待ち時間 > 1分
- **重大**: ロック待ち時間 > 5分

#### 3.2.4 VACUUM状態

```sql
-- VACUUM必要テーブルの監視
SELECT
    schemaname,
    relname,
    n_dead_tup,
    n_live_tup,
    round(n_dead_tup * 100.0 / (n_live_tup + n_dead_tup), 2) AS dead_tup_ratio,
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
WHERE n_dead_tup > 0
ORDER BY dead_tup_ratio DESC;

-- VACUUM実行中プロセス
SELECT
    pid,
    datname,
    usename,
    query,
    now() - query_start AS duration
FROM pg_stat_activity
WHERE query LIKE 'VACUUM%'
OR query LIKE 'ANALYZE%'
OR query LIKE 'autovacuum: %';
```

##### モニタリングしきい値:

- **注意**: デッドタプル比率 > 10%
- **警告**: デッドタプル比率 > 20%
- **重大**: デッドタプル比率 > 30%

### 3.3 クエリパフォーマンス

クエリのパフォーマンスをモニタリングするための方法。

#### 3.3.1 スロークエリ

```sql
-- スロークエリの監視（pg_stat_statements拡張使用）
SELECT
    round(total_exec_time::numeric, 2) AS total_exec_time_ms,
    calls,
    round(mean_exec_time::numeric, 2) AS mean_exec_time_ms,
    round(stddev_exec_time::numeric, 2) AS stddev_exec_time_ms,
    round((100 * total_exec_time / sum(total_exec_time) OVER ())::numeric, 2) AS percent_of_total,
    substring(query, 1, 200) AS query_sample
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 10;

-- 頻度の高いクエリ
SELECT
    calls,
    round(total_exec_time::numeric, 2) AS total_exec_time_ms,
    round(mean_exec_time::numeric, 2) AS mean_exec_time_ms,
    substring(query, 1, 200) AS query_sample
FROM pg_stat_statements
ORDER BY calls DESC
LIMIT 10;

-- 標準偏差の大きいクエリ（実行時間のブレが大きい）
SELECT
    round(stddev_exec_time::numeric, 2) AS stddev_exec_time_ms,
    round(mean_exec_time::numeric, 2) AS mean_exec_time_ms,
    calls,
    substring(query, 1, 200) AS query_sample
FROM pg_stat_statements
WHERE calls > 100  -- ある程度の実行回数があるクエリのみを対象
ORDER BY stddev_exec_time DESC
LIMIT 10;
```

##### モニタリングしきい値:

- **注意**: クエリ実行時間 > 1秒
- **警告**: クエリ実行時間 > 5秒
- **重大**: クエリ実行時間 > 30秒

#### 3.3.2 インデックス使用状況

```sql
-- インデックス使用状況
SELECT
    schemaname,
    relname,
    indexrelname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    pg_size_pretty(pg_relation_size(pg_get_indexdef::regclass)) AS index_size
FROM pg_stat_user_indexes
ORDER BY idx_scan DESC;

-- 未使用インデックス
SELECT
    schemaname,
    relname,
    indexrelname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
JOIN pg_index USING (indexrelid)
WHERE idx_scan = 0
AND indisunique IS FALSE
ORDER BY pg_relation_size(indexrelid) DESC;

-- シーケンシャルスキャン過多テーブル
SELECT
    schemaname,
    relname,
    seq_scan,
    seq_tup_read,
    idx_scan,
    idx_tup_fetch,
    pg_size_pretty(pg_relation_size(relid)) AS table_size
FROM pg_stat_user_tables
WHERE seq_scan > 0
AND (seq_scan::float / GREATEST(seq_scan + idx_scan, 1)) > 0.5
AND pg_relation_size(relid) > 10 * 8192
ORDER BY seq_tup_read DESC;
```

##### モニタリングしきい値:

- **注意**: シーケンシャルスキャン/インデックススキャン比率 > 0.5
- **警告**: シーケンシャルスキャン/インデックススキャン比率 > 0.7
- **重大**: シーケンシャルスキャン/インデックススキャン比率 > 0.9（大規模テーブル）

#### 3.3.3 プラン変動

```sql
-- クエリプラン変動監視（pg_plan_capture拡張使用、あれば）
SELECT
    queryid,
    planid,
    plan_count,
    first_plan_date,
    last_plan_date,
    median_execution_time,
    most_frequent_plans
FROM pg_plan_capture_stat
WHERE plan_count > 1
ORDER BY plan_count DESC;

-- クエリプランの強制適用状況（pg_hint_plan拡張使用、あれば）
SELECT
    hint_count,
    hint_description,
    hint_usage,
    hint_type,
    hint_target
FROM pg_hint_usage
WHERE hint_count > 0
ORDER BY hint_count DESC;
```

##### モニタリングしきい値:

- **注意**: クエリごとのプラン変動回数 > 5
- **警告**: クエリごとのプラン変動回数 > 10
- **重大**: 頻繁なプラン変動とパフォーマンス低下の相関関係

### 3.4 レプリケーション状態

レプリケーションの状態をモニタリングするための方法。

```sql
-- レプリケーション遅延の監視
SELECT
    client_addr,
    usename,
    application_name,
    state,
    sync_state,
    pg_wal_lsn_diff(sent_lsn, write_lsn) AS write_lag_bytes,
    pg_wal_lsn_diff(sent_lsn, flush_lsn) AS flush_lag_bytes,
    pg_wal_lsn_diff(sent_lsn, replay_lsn) AS replay_lag_bytes,
    write_lag,
    flush_lag,
    replay_lag,
    sync_priority
FROM pg_stat_replication;

-- スロットの状態
SELECT
    slot_name,
    plugin,
    slot_type,
    datoid,
    database,
    active,
    xmin,
    catalog_xmin,
    restart_lsn,
    confirmed_flush_lsn,
    pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn) AS retained_wal_bytes
FROM pg_replication_slots;

-- WALアーカイブの状態
SELECT
    archived_count,
    last_archived_wal,
    last_archived_time,
    failed_count,
    last_failed_wal,
    last_failed_time,
    stats_reset
FROM pg_stat_archiver;
```

##### モニタリングしきい値:

- **注意**: レプリケーション遅延 > 10MB
- **警告**: レプリケーション遅延 > 100MB
- **重大**: レプリケーション遅延 > 1GB

### 3.5 セキュリティモニタリング

セキュリティ関連のイベントをモニタリングするための方法。

```sql
-- 認証失敗ログの監視（ログ分析）
-- pg_audit拡張での監視（インストールされている場合）
SELECT
    event_time,
    session_user_name,
    database_name,
    remote_host,
    statement_type,
    statement
FROM pg_audit_log
WHERE event_time > now() - interval '24 hours'
AND (
    session_user_name <> current_user
    OR statement_type IN ('CREATE', 'DROP', 'ALTER', 'TRUNCATE')
    OR statement LIKE '%grant%'
    OR statement LIKE '%owner%'
)
ORDER BY event_time DESC;

-- 権限変更の監視
-- 定期的な権限スナップショットの比較
WITH current_roles AS (
    SELECT
        r.rolname,
        r.rolsuper,
        r.rolinherit,
        r.rolcreaterole,
        r.rolcreatedb,
        r.rolcanlogin,
        r.rolreplication,
        r.rolbypassrls,
        array_to_string(ARRAY(
            SELECT b.rolname
            FROM pg_catalog.pg_auth_members m
            JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
            WHERE m.member = r.oid
        ), ',') AS memberof
    FROM pg_catalog.pg_roles r
    WHERE r.rolname !~ '^pg_'
    ORDER BY 1
)
SELECT * FROM current_roles;
```

##### モニタリングしきい値:

- **注意**: 24時間以内の認証失敗 > 10回
- **警告**: 1時間以内の認証失敗 > 10回
- **重大**: 10分以内の認証失敗 > 10回

## 4. アラート設定

システムの問題を検出し通知するためのアラート設定。

### 4.1 アラートレベル定義

| レベル | 定義 | 通知方法 | レスポンス時間 |
|------|------|---------|------------|
| 情報 (INFO) | 参考情報、アクション不要 | ダッシュボード表示 | - |
| 注意 (WARNING) | 軽度の問題、対応推奨 | Eメール | 営業時間内に対応 |
| 警告 (ALERT) | 重要な問題、対応必須 | Eメール + SMS/Slack | 4時間以内に対応 |
| 重大 (CRITICAL) | 緊急の問題、即時対応必須 | Eメール + SMS + 電話 | 1時間以内に対応 |

### 4.2 主要アラート定義

#### 4.2.1 可用性アラート

```yaml
# Prometheusアラートルール例（YAML形式）
groups:
  - name: PostgreSQL_Availability
    rules:
      - alert: PostgreSQLDown
        expr: pg_up == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "PostgreSQL instance down"
          description: "PostgreSQL instance is down for more than 1 minute."
          
      - alert: PostgreSQLHighReplicationLag
        expr: pg_replication_lag > 300
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High replication lag"
          description: "PostgreSQL replication lag is {{ $value }} seconds, which exceeds the threshold of 300 seconds."
```

#### 4.2.2 パフォーマンスアラート

```yaml
# Prometheusアラートルール例（YAML形式）
groups:
  - name: PostgreSQL_Performance
    rules:
      - alert: PostgreSQLSlowQueries
        expr: rate(pg_stat_activity_max_tx_duration{datname=~"ses_mgr"}[1m]) > 300
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "Slow queries detected"
          description: "PostgreSQL has queries running for more than 5 minutes."
          
      - alert: PostgreSQLHighCPUUtilization
        expr: rate(pg_stat_database_xact_commit{datname=~"ses_mgr"}[5m]) + rate(pg_stat_database_xact_rollback{datname=~"ses_mgr"}[5m]) > 1000
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "High database load"
          description: "PostgreSQL is experiencing high transaction rate (> 1000 TPS)."
```

#### 4.2.3 ストレージアラート

```yaml
# Prometheusアラートルール例（YAML形式）
groups:
  - name: PostgreSQL_Storage
    rules:
      - alert: PostgreSQLDiskSpaceCritical
        expr: node_filesystem_avail_bytes{mountpoint=~"/var/lib/postgresql/data"} / node_filesystem_size_bytes{mountpoint=~"/var/lib/postgresql/data"} * 100 < 10
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Critical disk space"
          description: "PostgreSQL data directory has less than 10% free disk space."
          
      - alert: PostgreSQLDiskSpaceWarning
        expr: node_filesystem_avail_bytes{mountpoint=~"/var/lib/postgresql/data"} / node_filesystem_size_bytes{mountpoint=~"/var/lib/postgresql/data"} * 100 < 20
        for: 15m
        labels:
          severity: warning
        annotations:
          summary: "Low disk space"
          description: "PostgreSQL data directory has less than 20% free disk space."
          
      - alert: PostgreSQLTableBloat
        expr: pg_bloat_table_ratio > 50
        for: 1d
        labels:
          severity: warning
        annotations:
          summary: "Table bloat detected"
          description: "PostgreSQL table {{ $labels.table }} has bloat ratio of {{ $value }}%."
```

#### 4.2.4 コネクションアラート

```yaml
# Prometheusアラートルール例（YAML形式）
groups:
  - name: PostgreSQL_Connections
    rules:
      - alert: PostgreSQLConnectionsCritical
        expr: sum(pg_stat_activity_count) > pg_settings_max_connections * 0.9
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Critical connection usage"
          description: "PostgreSQL is using more than 90% of available connections."
          
      - alert: PostgreSQLConnectionsWarning
        expr: sum(pg_stat_activity_count) > pg_settings_max_connections * 0.8
        for: 15m
        labels:
          severity: warning
        annotations:
          summary: "High connection usage"
          description: "PostgreSQL is using more than 80% of available connections."
          
      - alert: PostgreSQLIdleConnections
        expr: sum(pg_stat_activity_count{state="idle"}) > sum(pg_stat_activity_count) * 0.5
        for: 30m
        labels:
          severity: warning
        annotations:
          summary: "High idle connections"
          description: "More than 50% of PostgreSQL connections are idle."
```

### 4.3 アラート通知チャネル

アラートを通知するための各種チャネルの設定例。

#### 4.3.1 Emailによる通知

```yaml
# AlertManagerの設定例
receivers:
  - name: email-notifications
    email_configs:
    - to: 'dba-team@example.com'
      from: 'monitoring@example.com'
      smarthost: 'smtp.example.com:587'
      auth_username: 'monitoring@example.com'
      auth_password: 'password'
      send_resolved: true
```

#### 4.3.2 Slackによる通知

```yaml
# AlertManagerの設定例
receivers:
  - name: slack-notifications
    slack_configs:
    - api_url: 'https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX'
      channel: '#db-alerts'
      send_resolved: true
      title: '{{ .GroupLabels.alertname }}'
      text: >-
        {{ range .Alerts }}
        *Alert:* {{ .Annotations.summary }}
        *Description:* {{ .Annotations.description }}
        *Severity:* {{ .Labels.severity }}
        *Time:* {{ .StartsAt.Format "2006-01-02 15:04:05" }}
        {{ end }}
```

#### 4.3.3 PagerDutyによる通知（緊急時）

```yaml
# AlertManagerの設定例
receivers:
  - name: pagerduty-critical
    pagerduty_configs:
    - service_key: '1234567890abcdef1234567890abcdef'
      description: '{{ .GroupLabels.alertname }}'
      details:
        summary: '{{ .Annotations.summary }}'
        description: '{{ .Annotations.description }}'
        severity: '{{ .Labels.severity }}'
```

### 4.4 エスカレーション設定

重要なアラートをエスカレーションするための設定例。

```yaml
# AlertManagerの設定例
route:
  receiver: default-receiver
  group_wait: 30s
  group_interval: 5m
  repeat_interval: 4h
  group_by: [alertname, cluster, service]
  routes:
  - match:
      severity: critical
    receiver: critical-alerts
    continue: true
    routes:
    - match_re:
        service: postgres
      receiver: db-team
      continue: true
    - match:
        service: postgres
        severity: critical
        job: postgres
      receiver: pagerduty-critical
      group_wait: 30s
      group_interval: 5m
      repeat_interval: 1h
```

## 5. ダッシュボード設計

メトリクスを可視化するためのダッシュボード設計。

### 5.1 主要ダッシュボード

#### 5.1.1 データベース概要ダッシュボード

データベース全体の健全性を示す主要メトリクスのダッシュボード。

**パネル構成:**

1. **可用性ステータス**
   - データベースの稼働状態
   - レプリケーション状態
   - バックアップ状態

2. **リソース使用率**
   - CPU使用率
   - メモリ使用率
   - ディスク使用率
   - ディスクI/O

3. **接続統計**
   - 現在の接続数
   - 接続状態の内訳
   - 最大接続数と残り接続数

4. **トランザクション統計**
   - 1分あたりのトランザクション数
   - コミット率とロールバック率
   - 長時間実行トランザクション

5. **クエリパフォーマンス概要**
   - アクティブクエリ数
   - スロークエリ数
   - 平均クエリ実行時間

#### 5.1.2 クエリパフォーマンスダッシュボード

クエリのパフォーマンスに焦点を当てたダッシュボード。

**パネル構成:**

1. **トップスロークエリ**
   - 実行時間トップ10クエリ
   - 総実行時間の割合
   - 平均実行時間と標準偏差

2. **高頻度クエリ**
   - 実行回数トップ10クエリ
   - 単位時間あたりの実行頻度
   - 平均実行時間

3. **クエリ実行時間トレンド**
   - 全体の平均クエリ実行時間の時系列
   - 特定クエリの実行時間の時系列

4. **インデックス使用統計**
   - インデックススキャン対シーケンシャルスキャン比率
   - トップインデックス使用率
   - 未使用インデックスリスト

5. **ロック統計**
   - 現在のロック競合
   - ロック待ち時間の分布
   - ロックタイプの内訳

#### 5.1.3 システムリソースダッシュボード

データベースサーバのシステムリソースに焦点を当てたダッシュボード。

**パネル構成:**

1. **CPU使用率**
   - 全体のCPU使用率時系列
   - ユーザ/システム/I/O Wait比率
   - コア別CPU使用率

2. **メモリ使用率**
   - 物理メモリ使用率
   - バッファキャッシュ使用率
   - スワップ使用率

3. **ディスク使用率**
   - パーティション別ディスク使用率
   - ディスク使用量の時系列
   - ディスク増加率

4. **ディスクI/O**
   - IOPS（読み取り/書き込み）
   - スループット（読み取り/書き込み）
   - I/O待ち時間
   - I/Oキュー長

5. **ネットワーク**
   - ネットワークインターフェース別トラフィック
   - 接続数
   - TCP/UDP統計

### 5.2 運用ダッシュボード

#### 5.2.1 バックアップダッシュボード

バックアップに焦点を当てたダッシュボード。

**パネル構成:**

1. **バックアップステータス**
   - 最新バックアップの状態
   - バックアップ成功/失敗履歴
   - バックアップ所要時間

2. **バックアップサイズトレンド**
   - バックアップサイズの時系列
   - 増加率
   - タイプ別バックアップサイズ

3. **WALアーカイブ**
   - WALアーカイブの成功/失敗
   - WALアーカイブサイズ
   - WAL生成率

4. **ストレージ使用率**
   - バックアップストレージ使用率
   - 残り容量
   - 予測枯渇時期

#### 5.2.2 レプリケーションダッシュボード

レプリケーションに焦点を当てたダッシュボード。

**パネル構成:**

1. **レプリケーション状態**
   - スタンバイサーバの状態
   - 同期/非同期レプリケーション状態
   - レプリケーションスロット状態

2. **レプリケーション遅延**
   - WAL送信遅延
   - WAL適用遅延
   - 遅延の時系列グラフ

3. **レプリケーショントラフィック**
   - WAL生成レート
   - WAL送信レート
   - ネットワーク転送量

4. **レプリケーション問題**
   - エラーログ
   - 再接続回数
   - フェイルオーバー履歴

### 5.3 アラートダッシュボード

アラートの状態と履歴を表示するためのダッシュボード。

**パネル構成:**

1. **アクティブアラート**
   - 重大度別のアクティブアラート
   - アラート発生時刻
   - アラート詳細

2. **アラート履歴**
   - 過去のアラート履歴
   - 解決までの時間
   - 頻発するアラート

3. **アラートタイプ分析**
   - カテゴリ別アラート発生数
   - 時間帯別アラート発生数
   - アラートトレンド

4. **対応状況**
   - 未対応アラート
   - 対応中アラート
   - 解決済みアラート
   - 平均解決時間

## 6. レポート設計

定期的なレポートの自動生成設定。

### 6.1 日次レポート

毎日生成される基本的なパフォーマンスレポート。

**レポート内容:**

1. **データベース可用性**
   - 稼働時間
   - ダウンタイム（あれば）
   - 主要な障害イベント

2. **パフォーマンスサマリー**
   - トップスロークエリ（上位5件）
   - 接続統計
   - トランザクション統計

3. **リソース使用率**
   - CPU/メモリ/ディスク使用率のピークと平均
   - 前日比較

4. **アラートサマリー**
   - 重大度別アラート数
   - 未解決アラート

### 6.2 週次レポート

毎週生成される詳細なパフォーマンスレポート。

**レポート内容:**

1. **週間サマリー**
   - 全体の可用性
   - パフォーマンストレンド
   - 主要なイベント

2. **詳細パフォーマンス分析**
   - トップスロークエリとその傾向
   - インデックス使用状況
   - テーブルアクセス統計

3. **キャパシティ計画**
   - ディスク使用量増加率
   - 接続数トレンド
   - データベースサイズ増加

4. **最適化推奨事項**
   - インデックス最適化提案
   - テーブル最適化提案
   - パラメータ調整提案

### 6.3 月次レポート

毎月生成される包括的な健全性レポート。

**レポート内容:**

1. **月間サマリー**
   - 全体の可用性
   - SLA達成状況
   - 主要なインシデント

2. **長期パフォーマンスの傾向**
   - 重要メトリクスの月次比較
   - 異常値分析
   - 季節変動分析

3. **キャパシティ予測**
   - 3ヶ月先の予測
   - リソース要件予測
   - ボトルネック予測

4. **セキュリティレポート**
   - 認証失敗統計
   - 権限変更履歴
   - セキュリティ監査結果

5. **バックアップと災害対策**
   - バックアップ成功率
   - リカバリテスト結果
   - バックアップサイズとトレンド

## 7. モニタリング運用

モニタリングシステム自体の運用と管理。

### 7.1 モニタリングシステムの監視

モニタリングシステム自体の健全性を維持するための設定。

```yaml
# Prometheusアラートルール例（YAML形式）
groups:
  - name: MonitoringSystem
    rules:
      - alert: PrometheusNotConnected
        expr: up{job="prometheus"} == 0
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Prometheus is down"
          description: "Prometheus has been down for more than 5 minutes."
          
      - alert: PrometheusHighMemory
        expr: process_resident_memory_bytes{job="prometheus"} > 8e9
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "Prometheus high memory usage"
          description: "Prometheus is using more than 8GB of memory."
          
      - alert: PrometheusTargetMissing
        expr: up == 0
        for: 15m
        labels:
          severity: warning
        annotations:
          summary: "Prometheus target missing"
          description: "Target {{ $labels.instance }} of job {{ $labels.job }} is down."
```

### 7.2 モニタリングデータの保持ポリシー

モニタリングデータの保持と削減のポリシーを定義。

**Prometheusの保持ポリシー例:**

```yaml
# prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s
  # 保持期間の設定
  storage:
    tsdb:
      path: /var/lib/prometheus
      retention:
        time: 90d  # 90日間保持
        size: 500GB  # 500GBまで保持
```

**メトリクス集約ポリシー例:**

- **詳細メトリクス (15秒間隔)**: 7日間保持
- **時間集約メトリクス (1分間隔)**: 30日間保持
- **日次集約メトリクス (1時間間隔)**: 90日間保持
- **月次集約メトリクス (1日間隔)**: 1年間保持

### 7.3 モニタリング改善プロセス

モニタリング設定の定期的な見直しと改善プロセス。

1. **モニタリングレビュー** (月次)
   - 誤検知アラートの見直し
   - 検出漏れの特定
   - アラートのしきい値調整

2. **ダッシュボードの最適化** (四半期ごと)
   - 使用頻度の低いパネルの整理
   - 新たな要件に基づくパネル追加
   - 視覚化の改善

3. **メトリクスの最適化** (半年ごと)
   - 未使用メトリクスの特定と削除
   - 高カーディナリティメトリクスの見直し
   - 集約レベルの調整

4. **障害後レビュー**
   - モニタリングによる問題の早期検出状況の評価
   - 検出漏れがあった場合の改善策の特定
   - 新たなモニタリング要件の特定

## 8. モジュール別テーブル定義補足との関連

各業務モジュールの「テーブル定義補足」ドキュメントには、モジュール固有のモニタリング要件を記載する。本ドキュメントは全体方針と共通パターンを定義し、各モジュールの詳細は対応する補足ドキュメントを参照すること。