# DB詳細設計 - パフォーマンス最適化

## 1. パフォーマンス最適化の基本方針

本システムにおけるデータベースパフォーマンス最適化は、以下の方針に基づいて行う。

### 1.1 最適化目標

- **応答時間**: ユーザー向け操作の95%が3秒以内に完了
- **スループット**: ピーク時に最大500同時接続を処理可能
- **リソース使用効率**: CPU、メモリ、ディスクI/Oの効率的な利用
- **スケーラビリティ**: データ量の増加に伴う性能低下を最小限に維持

### 1.2 最適化アプローチ

- **設計段階での最適化**: スキーマ設計、インデックス設計での考慮
- **クエリレベルの最適化**: 効率的なSQLクエリ作成と最適化
- **データベースパラメータの最適化**: PostgreSQLパラメータの調整
- **ハードウェアリソースの最適化**: ハードウェアリソースの適切な配分
- **監視と継続的改善**: 性能監視に基づく継続的な最適化

## 2. スキーマレベルの最適化

データベーススキーマ設計における最適化手法を示す。

### 2.1 テーブル設計の最適化

#### 2.1.1 正規化と非正規化のバランス

業務要件とパフォーマンスのバランスを考慮した正規化レベルの選定方法。

##### 基本方針:

- **基本は第3正規形**: 基本的には第3正規形までの正規化を行う
- **戦略的な非正規化**: 以下の場合に限定して非正規化を検討
  - 頻繁に結合が必要でパフォーマンスが重要な場合
  - 読み取り操作が圧倒的に多い場合
  - 集計データや計算結果の再利用が必要な場合

##### 適用例:

```sql
-- 正規化されたテーブル設計
CREATE TABLE engineer.engineer (
    id serial PRIMARY KEY,
    name varchar(100) NOT NULL,
    email varchar(255) NOT NULL UNIQUE,
    phone varchar(20),
    status_code smallint NOT NULL
);

CREATE TABLE engineer.skill (
    id serial PRIMARY KEY,
    skill_name varchar(100) NOT NULL UNIQUE,
    category_id integer NOT NULL REFERENCES engineer.skill_category(id)
);

CREATE TABLE engineer.engineer_skill (
    id serial PRIMARY KEY,
    engineer_id integer NOT NULL REFERENCES engineer.engineer(id),
    skill_id integer NOT NULL REFERENCES engineer.skill(id),
    level smallint NOT NULL,
    years smallint,
    UNIQUE (engineer_id, skill_id)
);

-- 特定の読み取りパターン向けに非正規化したビュー
CREATE MATERIALIZED VIEW engineer.engineer_with_skills AS
SELECT
    e.id,
    e.name,
    e.email,
    e.status_code,
    array_agg(s.skill_name) AS skill_names,
    jsonb_object_agg(s.skill_name, es.level) AS skill_levels,
    jsonb_agg(jsonb_build_object(
        'skill_id', s.id,
        'skill_name', s.skill_name,
        'level', es.level,
        'years', es.years
    )) AS skills_json
FROM engineer.engineer e
LEFT JOIN engineer.engineer_skill es ON e.id = es.engineer_id
LEFT JOIN engineer.skill s ON es.skill_id = s.id
GROUP BY e.id, e.name, e.email, e.status_code;
```

#### 2.1.2 データ型の最適化

パフォーマンスとストレージ効率を考慮したデータ型選択の方法。

##### 最適化方針:

- **適切なサイズ**: データの実際の範囲に合わせた最小サイズの型を選択
- **処理効率**: 計算や比較操作が多い列は処理効率の高い型を選択
- **メモリアライメント**: メモリアライメントを考慮した型と順序の選択

##### 適用例:

```sql
-- 最適化前
CREATE TABLE project.project_inefficient (
    id varchar(50) PRIMARY KEY,  -- 過剰なサイズ
    title varchar(1000),  -- 過剰なサイズ
    description text,
    status varchar(50),  -- 列挙型が適切
    start_date timestamp,  -- 日付のみなのでdate型が適切
    end_date timestamp,
    is_active varchar(5),  -- boolean型が適切
    created_by varchar(100),
    created_at timestamp,
    budget numeric(18,2)  -- 過剰な精度
);

-- 最適化後
CREATE TABLE project.project_optimized (
    id serial PRIMARY KEY,  -- 自動採番の整数型
    title varchar(200) NOT NULL,  -- 実際の最大長に合わせたサイズ
    description text,
    status_code smallint NOT NULL,  -- コード値として効率化
    start_date date NOT NULL,  -- 日付型に最適化
    end_date date,
    is_active boolean NOT NULL DEFAULT true,  -- boolean型に最適化
    created_by integer NOT NULL,  -- 外部キー参照として整数型
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    budget numeric(12,2)  -- 実際の範囲に合わせた精度
);
```

#### 2.1.3 パーティショニング

大規模テーブルの効率的な管理のためのパーティショニング戦略。詳細は「06_パーティション設計.md」を参照。

##### 最適化効果:

- クエリの実行時間短縮（パーティションプルーニングによる）
- インデックスサイズの縮小と効率化
- メンテナンス作業の並列化と効率化
- データアーカイブの容易化

### 2.2 インデックス設計の最適化

効率的なインデックス設計によるクエリパフォーマンスの向上方法。詳細は「05_インデックス設計.md」を参照。

#### 2.2.1 最適なインデックス選択

クエリパターンに応じた最適なインデックスの選択方法。

##### 選択基準:

- **クエリパターン分析**: 実際のクエリパターンを分析し、頻度の高いパターンを優先
- **選択性評価**: カラムの選択性（カーディナリティ）を評価し、高選択性のカラムを優先
- **複合インデックス設計**: WHERE句、JOIN条件、ORDER BY句の組み合わせを考慮
- **インデックスオーバーヘッド**: インデックスの更新コストとストレージオーバーヘッドを考慮

##### 適用例:

```sql
-- クエリパターン：ステータス+日付範囲での検索、頻度高
-- 複合インデックス（選択性の低い列+高い列の順）
CREATE INDEX ix_project_status_dates ON project.project (status_code, start_date, end_date);

-- クエリパターン：技術者のスキル検索、頻度高
-- GINインデックス（配列または複合要素の検索向け）
CREATE INDEX ix_engineer_skills_gin ON engineer.engineer_with_skills USING gin (skill_names);

-- クエリパターン：フルテキスト検索、頻度中
-- 全文検索インデックス
CREATE INDEX ix_project_fulltext ON project.project 
USING gin (to_tsvector('japanese', title || ' ' || COALESCE(description, '')));

-- クエリパターン：階層データの検索、頻度低～中
-- 特殊インデックス（ltree型用）
CREATE INDEX ix_category_path_gist ON common.category USING gist (path);
```

#### 2.2.2 インデックスメンテナンス

インデックスの効率を維持するためのメンテナンス戦略。

##### メンテナンス戦略:

- **定期的な再構築**: 断片化したインデックスの定期的な再構築
- **統計情報の更新**: 適切な実行計画選択のための統計情報更新
- **未使用インデックスの特定と削除**: 使用されていないインデックスの定期的な見直し

##### 適用例:

```sql
-- インデックス再構築
REINDEX INDEX ix_project_status_dates;

-- テーブルの全インデックス再構築
REINDEX TABLE project.project;

-- スキーマ内の全インデックス再構築
REINDEX SCHEMA project;

-- 統計情報の更新
ANALYZE project.project;

-- 未使用インデックスの特定
SELECT
    schemaname || '.' || relname AS table_name,
    indexrelname AS index_name,
    idx_scan AS scan_count,
    idx_tup_read AS tuples_read,
    idx_tup_fetch AS tuples_fetched,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_all_indexes
WHERE schemaname NOT LIKE 'pg_%' AND schemaname != 'information_schema'
AND idx_scan = 0  -- 未使用インデックス
ORDER BY pg_relation_size(indexrelid) DESC;
```

## 3. クエリレベルの最適化

効率的なSQLクエリの作成とクエリパフォーマンスの最適化方法を示す。

### 3.1 効率的なクエリ作成

#### 3.1.1 効率的なSELECTクエリ

パフォーマンスを考慮した効率的なSELECTクエリの作成方法。

##### 最適化方針:

- **必要なカラムのみ選択**: `SELECT *` の使用を避け、必要なカラムのみを指定
- **適切なJOIN**: 必要なテーブルのみを結合し、適切なJOINタイプを選択
- **効率的なWHERE句**: インデックスを活用できる条件式を記述
- **ページネーション**: 大量のデータを返す場合はLIMITとOFFSETを使用
- **集計の最適化**: 集計関数とGROUP BYの効率的な使用

##### 適用例:

```sql
-- 非効率なクエリ
SELECT * FROM engineer.engineer e
JOIN engineer.engineer_skill es ON e.id = es.engineer_id
JOIN engineer.skill s ON es.skill_id = s.id
WHERE e.status_code = 1;

-- 最適化したクエリ（必要なカラムのみ選択）
SELECT 
    e.id, 
    e.name, 
    e.email, 
    s.skill_name, 
    es.level
FROM engineer.engineer e
JOIN engineer.engineer_skill es ON e.id = es.engineer_id
JOIN engineer.skill s ON es.skill_id = s.id
WHERE e.status_code = 1
ORDER BY e.id, s.skill_name
LIMIT 100 OFFSET 0;

-- さらに最適化（マテリアライズドビューの活用）
SELECT 
    id, 
    name, 
    email, 
    jsonb_array_elements(skills_json)->>'skill_name' AS skill_name,
    (jsonb_array_elements(skills_json)->'level')::int AS level
FROM engineer.engineer_with_skills
WHERE status_code = 1
ORDER BY id
LIMIT 100 OFFSET 0;
```

#### 3.1.2 効率的なJOIN

パフォーマンスを考慮したJOIN操作の最適化方法。

##### 最適化方針:

- **JOIN順序**: 小さいテーブルから大きいテーブルへの結合順序を検討
- **JOIN条件**: インデックス付きの列を結合条件に使用
- **JOINタイプ**: INNER JOIN、LEFT JOIN、RIGHT JOIN、FULL JOINの適切な使い分け
- **JOIN代替手段**: サブクエリやEXISTSの活用を検討

##### 適用例:

```sql
-- 非効率なJOIN（不要なテーブルの結合）
SELECT p.id, p.title, c.name, e.name AS engineer_name
FROM project.project p
JOIN project.customer c ON p.customer_id = c.id
JOIN project.project_engineer pe ON p.id = pe.project_id
JOIN engineer.engineer e ON pe.engineer_id = e.id
JOIN engineer.engineer_skill es ON e.id = es.engineer_id
JOIN engineer.skill s ON es.skill_id = s.id
WHERE p.status_code = 1;

-- 最適化したJOIN（必要なテーブルのみ）
SELECT p.id, p.title, c.name, e.name AS engineer_name
FROM project.project p
JOIN project.customer c ON p.customer_id = c.id
JOIN project.project_engineer pe ON p.id = pe.project_id
JOIN engineer.engineer e ON pe.engineer_id = e.id
WHERE p.status_code = 1;

-- EXISTS活用（特定の条件チェックのみ）
SELECT p.id, p.title, c.name
FROM project.project p
JOIN project.customer c ON p.customer_id = c.id
WHERE p.status_code = 1
AND EXISTS (
    SELECT 1
    FROM project.project_engineer pe
    JOIN engineer.engineer e ON pe.engineer_id = e.id
    WHERE pe.project_id = p.id
    AND e.status_code = 1
);
```

#### 3.1.3 効率的なサブクエリ

パフォーマンスを考慮したサブクエリの最適化方法。

##### 最適化方針:

- **相関サブクエリの最小化**: 可能な限り非相関サブクエリやJOINに置き換え
- **サブクエリの限定**: サブクエリで取得するデータを必要最小限に制限
- **共通テーブル式（CTE）の活用**: 複雑なクエリや再帰クエリでCTEを活用
- **LATERAL JOINの活用**: 外部クエリの各行に依存するサブクエリを効率的に実行

##### 適用例:

```sql
-- 非効率な相関サブクエリ
SELECT
    e.id,
    e.name,
    (SELECT COUNT(*) FROM engineer.engineer_skill es WHERE es.engineer_id = e.id) AS skill_count,
    (SELECT MAX(level) FROM engineer.engineer_skill es WHERE es.engineer_id = e.id) AS max_skill_level
FROM engineer.engineer e
WHERE e.status_code = 1;

-- 最適化したクエリ（LEFT JOINとGROUP BY）
SELECT
    e.id,
    e.name,
    COUNT(es.id) AS skill_count,
    MAX(es.level) AS max_skill_level
FROM engineer.engineer e
LEFT JOIN engineer.engineer_skill es ON e.id = es.engineer_id
WHERE e.status_code = 1
GROUP BY e.id, e.name;

-- CTE活用例（階層データの処理）
WITH RECURSIVE skill_hierarchy AS (
    -- ルートノード
    SELECT id, skill_name, parent_id, 1 AS level
    FROM engineer.skill_category
    WHERE parent_id IS NULL
    
    UNION ALL
    
    -- 子ノード
    SELECT c.id, c.skill_name, c.parent_id, h.level + 1 AS level
    FROM engineer.skill_category c
    JOIN skill_hierarchy h ON c.parent_id = h.id
)
SELECT * FROM skill_hierarchy ORDER BY level, skill_name;

-- LATERAL JOIN活用例
SELECT
    p.id,
    p.title,
    engineers.engineer_names
FROM project.project p
CROSS JOIN LATERAL (
    SELECT string_agg(e.name, ', ') AS engineer_names
    FROM project.project_engineer pe
    JOIN engineer.engineer e ON pe.engineer_id = e.id
    WHERE pe.project_id = p.id
    AND e.status_code = 1
) engineers
WHERE p.status_code = 1;
```

#### 3.1.4 データ変更操作の最適化

パフォーマンスを考慮したINSERT、UPDATE、DELETEの最適化方法。

##### 最適化方針:

- **一括処理**: 複数の行を一度に処理（バルク操作）
- **トランザクション最適化**: 適切なトランザクション粒度の設定
- **UPSERT活用**: ON CONFLICTを使った効率的な更新
- **CTEによる複合操作**: WITH句を使った複合的なデータ操作

##### 適用例:

```sql
-- 非効率な1行ずつの処理
INSERT INTO engineer.skill (skill_name, category_id) VALUES ('Java', 1);
INSERT INTO engineer.skill (skill_name, category_id) VALUES ('Python', 1);
INSERT INTO engineer.skill (skill_name, category_id) VALUES ('SQL', 2);

-- 最適化したバルクINSERT
INSERT INTO engineer.skill (skill_name, category_id)
VALUES 
    ('Java', 1),
    ('Python', 1),
    ('SQL', 2);

-- UPSERTの活用
INSERT INTO engineer.skill (skill_name, category_id)
VALUES 
    ('Java', 1),
    ('Python', 1),
    ('SQL', 2)
ON CONFLICT (skill_name)
DO UPDATE SET 
    category_id = EXCLUDED.category_id;

-- CTE活用による複合操作
WITH skill_update AS (
    UPDATE engineer.skill 
    SET category_id = 3
    WHERE skill_name IN ('Java', 'Python')
    RETURNING id, skill_name
)
INSERT INTO engineer.skill_history (skill_id, skill_name, action, changed_at)
SELECT id, skill_name, 'UPDATE', CURRENT_TIMESTAMP
FROM skill_update;

-- 効率的な大量DELETE（バッチ処理）
DO $$
DECLARE
    batch_size INTEGER := 1000;
    deleted INTEGER;
BEGIN
    LOOP
        DELETE FROM audit.system_log
        WHERE created_at < now() - interval '1 year'
        LIMIT batch_size;
        
        GET DIAGNOSTICS deleted = ROW_COUNT;
        
        EXIT WHEN deleted < batch_size;
        COMMIT;
    END LOOP;
END $$;
```

### 3.2 クエリプラン最適化

#### 3.2.1 実行計画の分析

クエリ実行計画の分析と最適化方法。

##### 分析手法:

- **EXPLAINの活用**: 実行計画の詳細な分析
- **問題点の特定**: シーケンシャルスキャン、非効率な結合、不適切なインデックス使用などの特定
- **実行時間の測定**: 実際の実行時間とリソース使用量の測定

##### 適用例:

```sql
-- 基本的な実行計画の確認
EXPLAIN
SELECT e.id, e.name, e.email, s.skill_name, es.level
FROM engineer.engineer e
JOIN engineer.engineer_skill es ON e.id = es.engineer_id
JOIN engineer.skill s ON es.skill_id = s.id
WHERE e.status_code = 1;

-- 実際の実行時間と詳細情報を含む実行計画
EXPLAIN ANALYZE
SELECT e.id, e.name, e.email, s.skill_name, es.level
FROM engineer.engineer e
JOIN engineer.engineer_skill es ON e.id = es.engineer_id
JOIN engineer.skill s ON es.skill_id = s.id
WHERE e.status_code = 1;

-- バッファ使用状況も含めた詳細な実行計画
EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON)
SELECT e.id, e.name, e.email, s.skill_name, es.level
FROM engineer.engineer e
JOIN engineer.engineer_skill es ON e.id = es.engineer_id
JOIN engineer.skill s ON es.skill_id = s.id
WHERE e.status_code = 1;
```

#### 3.2.2 クエリヒントの活用

クエリプランナの動作を制御するクエリヒントの活用方法。

##### 活用方針:

- **最適な結合方法の指定**: 結合アルゴリズムや結合順序の制御
- **インデックス使用の制御**: 特定のインデックスの使用を強制または回避
- **並列処理の制御**: 並列処理の有効化や並列度の制御
- **その他のプランナパラメータの調整**: コスト推定に影響するパラメータの調整

##### 適用例（pg_hint_plan拡張を使用）:

```sql
-- 特定のインデックスを使用するヒント
/*+ IndexScan(e ix_engineer_status) */
SELECT e.id, e.name, e.email
FROM engineer.engineer e
WHERE e.status_code = 1;

-- 結合順序を指定するヒント
/*+ Leading(e es s) */
SELECT e.id, e.name, s.skill_name, es.level
FROM engineer.engineer e
JOIN engineer.engineer_skill es ON e.id = es.engineer_id
JOIN engineer.skill s ON es.skill_id = s.id
WHERE e.status_code = 1;

-- 結合方法を指定するヒント
/*+ NestLoop(e es) HashJoin(es s) */
SELECT e.id, e.name, s.skill_name, es.level
FROM engineer.engineer e
JOIN engineer.engineer_skill es ON e.id = es.engineer_id
JOIN engineer.skill s ON es.skill_id = s.id
WHERE e.status_code = 1;

-- 並列処理を制御するヒント
/*+ Parallel(e 4) */
SELECT e.id, e.name, e.email
FROM engineer.engineer e
WHERE e.status_code = 1;
```

#### 3.2.3 統計情報の最適化

クエリプランナのための統計情報最適化方法。

##### 最適化方針:

- **統計情報の定期更新**: 適切なタイミングでの統計情報更新
- **サンプリング率の調整**: 大規模テーブルのサンプリング率調整
- **拡張統計情報の活用**: 列間の相関関係に関する統計情報の追加
- **式インデックスの統計情報**: 式に基づくインデックスの統計情報管理

##### 適用例:

```sql
-- 基本的な統計情報更新
ANALYZE engineer.engineer;

-- サンプリング率を指定した統計情報更新
ANALYZE engineer.engineer WITH 30;

-- 特定の列の拡張統計情報を作成（列間の相関）
CREATE STATISTICS engineer_status_skill_stats ON status_code, skill_id FROM engineer.engineer_skill;

-- テーブル単位のパラメータ設定
ALTER TABLE engineer.engineer SET (autovacuum_analyze_scale_factor = 0.05);
ALTER TABLE engineer.engineer SET (autovacuum_analyze_threshold = 100);

-- 自動統計情報更新の最適化
CREATE OR REPLACE FUNCTION common.schedule_analyze_for_large_tables()
RETURNS void AS $$
DECLARE
    r record;
BEGIN
    FOR r IN (
        SELECT schemaname, relname
        FROM pg_stat_user_tables
        WHERE n_live_tup > 100000
    ) LOOP
        EXECUTE format('ANALYZE %I.%I', r.schemaname, r.relname);
        RAISE NOTICE 'Analyzed table: %.%', r.schemaname, r.relname;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- 毎日深夜に実行
SELECT cron.schedule('0 2 * * *', $$SELECT common.schedule_analyze_for_large_tables()$$);
```

## 4. データベース設定の最適化

PostgreSQLのパラメータ設定による性能最適化方法を示す。

### 4.1 メモリ関連パラメータ

メモリ使用に関するパラメータの最適化方法。

#### 4.1.1 共有バッファ設定

```
# 共有バッファの設定
shared_buffers = 8GB  # 物理メモリの25%程度が目安

# 作業用メモリの設定
work_mem = 64MB       # 複雑なソート・ハッシュ操作向け
maintenance_work_mem = 1GB  # メンテナンス操作向け

# 一時バッファの設定
temp_buffers = 64MB   # 一時テーブル用バッファ

# WALバッファ
wal_buffers = 16MB    # WAL書き込みバッファ
```

#### 4.1.2 キャッシュ関連設定

```
# キャッシュサイズ設定
effective_cache_size = 24GB  # システムキャッシュ含む利用可能メモリ（物理メモリの75%程度）

# プランキャッシュ
plan_cache_mode = auto       # プリペアドステートメントの計画再利用モード

# クエリキャッシュレベル
track_activity_query_size = 4kB  # トラッキングする最大クエリサイズ
```

### 4.2 ディスクI/O関連パラメータ

ディスクI/O性能に関するパラメータの最適化方法。

#### 4.2.1 チェックポイント設定

```
# チェックポイント関連設定
checkpoint_timeout = 15min       # チェックポイント間の最大時間
max_wal_size = 8GB               # WALの最大サイズ（これを超えるとチェックポイント発生）
min_wal_size = 2GB               # WALの最小保持サイズ
checkpoint_completion_target = 0.9  # チェックポイント処理の目標完了時間（次のチェックポイントまでの割合）
```

#### 4.2.2 バックグラウンドライタ設定

```
# バックグラウンドライタ設定
bgwriter_delay = 200ms             # 書き込み間の遅延
bgwriter_lru_maxpages = 1000       # 1サイクルで書き込む最大ページ数
bgwriter_lru_multiplier = 10.0     # 必要ページ数の倍率
```

### 4.3 自動バキューム設定

自動バキュームに関するパラメータの最適化方法。

```
# 自動バキューム基本設定
autovacuum = on
autovacuum_max_workers = 5         # 同時実行可能なワーカー数
autovacuum_naptime = 1min          # スリープ時間

# バキューム処理のしきい値
autovacuum_vacuum_threshold = 50   # 更新/削除された行数のしきい値
autovacuum_analyze_threshold = 50  # 挿入/更新/削除された行数のしきい値
autovacuum_vacuum_scale_factor = 0.1  # テーブルサイズに対する比率（バキューム）
autovacuum_analyze_scale_factor = 0.05  # テーブルサイズに対する比率（分析）

# バキュームコスト遅延
autovacuum_vacuum_cost_delay = 20ms  # コストベース遅延
autovacuum_vacuum_cost_limit = 2000  # コスト制限
```

### 4.4 クエリプランナ設定

クエリプランナに関するパラメータの最適化方法。

```
# コスト推定パラメータ
random_page_cost = 1.1          # ランダムページアクセスコスト（SSDなら低く設定）
seq_page_cost = 1.0             # シーケンシャルページアクセスコスト
cpu_tuple_cost = 0.01           # タプル処理CPU時間の相対コスト
cpu_index_tuple_cost = 0.005    # インデックスタプル処理CPU時間の相対コスト
cpu_operator_cost = 0.0025      # 演算子CPU時間の相対コスト

# 統計情報関連
default_statistics_target = 100  # 統計情報の詳細度

# 並列クエリ
max_parallel_workers_per_gather = 2  # Gatherノードあたりの並列ワーカー数
max_parallel_workers = 8             # 並列ワーカーの最大数
max_parallel_maintenance_workers = 4  # メンテナンス操作の並列ワーカー数
parallel_setup_cost = 1000           # 並列処理の初期化コスト
parallel_tuple_cost = 0.1            # 並列処理のタプル転送コスト
```

### 4.5 接続関連パラメータ

データベース接続に関するパラメータの最適化方法。

```
# 接続数制限
max_connections = 500          # 最大同時接続数

# 接続プーリング（PgBouncerを使用）
# PgBouncer設定例
# [pgbouncer]
# pool_mode = transaction
# default_pool_size = 100
# min_pool_size = 10
# reserve_pool_size = 20
# max_client_conn = 3000
# max_db_connections = 500
```

## 5. 監視と継続的最適化

データベースパフォーマンスの監視と継続的改善方法を示す。

### 5.1 パフォーマンス監視

#### 5.1.1 クエリパフォーマンス監視

クエリのパフォーマンスを監視する方法。

```sql
-- スロークエリの特定（pg_stat_statements拡張を使用）
SELECT
    substring(query, 1, 50) AS short_query,
    round(total_exec_time::numeric, 2) AS total_time_ms,
    calls,
    round(mean_exec_time::numeric, 2) AS mean_time_ms,
    round((100 * total_exec_time / sum(total_exec_time) OVER ())::numeric, 2) AS percent
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 20;

-- 実行回数の多いクエリ
SELECT
    substring(query, 1, 50) AS short_query,
    calls,
    round(total_exec_time::numeric, 2) AS total_time_ms,
    round(mean_exec_time::numeric, 2) AS mean_time_ms
FROM pg_stat_statements
ORDER BY calls DESC
LIMIT 20;

-- クエリパフォーマンス監視ビューの作成
CREATE OR REPLACE VIEW common.query_performance AS
SELECT
    substring(query, 1, 100) AS query_sample,
    calls,
    round(total_exec_time::numeric, 2) AS total_time_ms,
    round(mean_exec_time::numeric, 2) AS mean_time_ms,
    round(stddev_exec_time::numeric, 2) AS stddev_time_ms,
    round(min_exec_time::numeric, 2) AS min_time_ms,
    round(max_exec_time::numeric, 2) AS max_time_ms,
    rows,
    shared_blks_hit,
    shared_blks_read,
    shared_blks_dirtied,
    shared_blks_written,
    temp_blks_read,
    temp_blks_written
FROM pg_stat_statements
WHERE query NOT LIKE '%pg_%' AND query NOT LIKE '%common.query_performance%'
ORDER BY total_exec_time DESC;
```

#### 5.1.2 テーブル・インデックス監視

テーブルとインデックスのパフォーマンスを監視する方法。

```sql
-- テーブル統計情報の監視
SELECT
    schemaname,
    relname,
    seq_scan,
    seq_tup_read,
    idx_scan,
    idx_tup_fetch,
    n_tup_ins,
    n_tup_upd,
    n_tup_del,
    n_live_tup,
    n_dead_tup,
    last_vacuum,
    last_analyze
FROM pg_stat_user_tables
ORDER BY n_live_tup DESC;

-- インデックス使用率の監視
SELECT
    schemaname,
    relname,
    indexrelname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
ORDER BY idx_scan DESC;

-- 未使用インデックスの特定
SELECT
    schemaname,
    relname,
    indexrelname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
WHERE idx_scan = 0
AND indexrelid NOT IN (
    SELECT indexrelid
    FROM pg_index
    WHERE indisprimary OR indisunique
)
ORDER BY pg_relation_size(indexrelid) DESC;

-- テーブルサイズの監視
SELECT
    schemaname,
    relname,
    pg_size_pretty(pg_total_relation_size(relid)) AS total_size,
    pg_size_pretty(pg_relation_size(relid)) AS data_size,
    pg_size_pretty(pg_total_relation_size(relid) - pg_relation_size(relid)) AS external_size
FROM pg_catalog.pg_statio_user_tables
ORDER BY pg_total_relation_size(relid) DESC;
```

#### 5.1.3 パーティション監視

パーティションテーブルのパフォーマンスを監視する方法。

```sql
-- パーティション使用状況の監視ビュー
CREATE OR REPLACE VIEW common.partition_usage AS
WITH parent_tables AS (
    SELECT
        nmsp_parent.nspname AS parent_schema,
        parent.relname AS parent_table,
        parent.oid AS parent_oid
    FROM pg_inherits
    JOIN pg_class parent ON pg_inherits.inhparent = parent.oid
    JOIN pg_namespace nmsp_parent ON parent.relnamespace = nmsp_parent.oid
    WHERE parent.relkind = 'p'
    GROUP BY parent_schema, parent_table, parent_oid
),
partition_stats AS (
    SELECT
        nmsp_child.nspname AS partition_schema,
        child.relname AS partition_name,
        nmsp_parent.nspname AS parent_schema,
        parent.relname AS parent_table,
        pg_stat_get_live_tuples(child.oid) AS n_live_tup,
        pg_stat_get_dead_tuples(child.oid) AS n_dead_tup,
        pg_stat_get_tuples_inserted(child.oid) AS n_tup_ins,
        pg_stat_get_tuples_updated(child.oid) AS n_tup_upd,
        pg_stat_get_tuples_deleted(child.oid) AS n_tup_del,
        child.oid AS partition_oid
    FROM pg_inherits
    JOIN pg_class parent ON pg_inherits.inhparent = parent.oid
    JOIN pg_class child ON pg_inherits.inhrelid = child.oid
    JOIN pg_namespace nmsp_parent ON parent.relnamespace = nmsp_parent.oid
    JOIN pg_namespace nmsp_child ON child.relnamespace = nmsp_child.oid
    WHERE parent.relkind = 'p'
)
SELECT
    ps.parent_schema,
    ps.parent_table,
    ps.partition_schema,
    ps.partition_name,
    ps.n_live_tup,
    ps.n_dead_tup,
    ps.n_tup_ins,
    ps.n_tup_upd,
    ps.n_tup_del,
    pg_size_pretty(pg_relation_size(ps.partition_oid)) AS partition_size,
    pg_stat_get_last_vacuum_time(ps.partition_oid) AS last_vacuum,
    pg_stat_get_last_analyze_time(ps.partition_oid) AS last_analyze
FROM partition_stats ps
ORDER BY ps.parent_schema, ps.parent_table, ps.partition_name;
```

### 5.2 性能課題の検出と対応

#### 5.2.1 一般的な性能問題とその対応

一般的なパフォーマンス問題の検出と対応方法。

| 問題の種類 | 検出方法 | 対応策 |
|----------|---------|-------|
| スロークエリ | pg_stat_statementsでの監視 | クエリの最適化、インデックス追加、統計情報更新 |
| シーケンシャルスキャン過多 | pg_stat_user_tablesのseq_scan監視 | 適切なインデックス追加、クエリの書き換え |
| インデックス使用率低下 | pg_stat_user_indexesの監視 | インデックス再構築、統計情報更新、インデックス設計見直し |
| デッドタプル蓄積 | n_dead_tupの監視 | 手動VACUUM、自動VACUUM設定の調整 |
| テーブル肥大化 | テーブルサイズの定期監視 | VACUUM FULL、クラスタリング、パーティショニング |
| キャッシュヒット率低下 | blks_hit対blks_readの比率監視 | shared_buffersの増加、アクセスパターンの見直し |
| 接続数過多 | pg_stat_activityの監視 | 接続プーリングの導入、アプリケーション側の接続管理改善 |
| ロック競合 | pg_locks、pg_stat_activityの監視 | トランザクション設計の見直し、デッドロック回避戦略の実装 |

#### 5.2.2 パフォーマンスアラート設定

パフォーマンス問題を検出するためのアラート設定例。

```sql
-- パフォーマンスアラート関数
CREATE OR REPLACE FUNCTION common.check_database_performance()
RETURNS TABLE (
    alert_level text,
    alert_type text,
    description text,
    recommendation text
) AS $$
BEGIN
    -- スロークエリアラート
    RETURN QUERY
    SELECT
        'WARNING'::text AS alert_level,
        'SLOW_QUERY'::text AS alert_type,
        'Query taking more than 1 second on average: ' || substring(query, 1, 100) AS description,
        'Consider optimizing the query or adding indexes' AS recommendation
    FROM pg_stat_statements
    WHERE mean_exec_time > 1000  -- 1秒以上
    AND calls > 100  -- 十分な実行回数
    LIMIT 5;
    
    -- シーケンシャルスキャン過多アラート
    RETURN QUERY
    SELECT
        'WARNING'::text AS alert_level,
        'SEQUENTIAL_SCAN'::text AS alert_type,
        'Table ' || schemaname || '.' || relname || ' has high sequential scan count: ' || seq_scan AS description,
        'Consider adding indexes or reviewing query patterns' AS recommendation
    FROM pg_stat_user_tables
    WHERE seq_scan > 1000  -- 1000回以上のシーケンシャルスキャン
    AND seq_scan > 10 * idx_scan  -- インデックススキャンの10倍以上
    AND n_live_tup > 10000  -- 十分な行数
    LIMIT 5;
    
    -- デッドタプル蓄積アラート
    RETURN QUERY
    SELECT
        'WARNING'::text AS alert_level,
        'DEAD_TUPLES'::text AS alert_type,
        'Table ' || schemaname || '.' || relname || ' has high dead tuple ratio: ' || 
        round(100.0 * n_dead_tup / nullif(n_live_tup + n_dead_tup, 0), 2) || '%' AS description,
        'Consider running VACUUM or adjusting autovacuum settings' AS recommendation
    FROM pg_stat_user_tables
    WHERE n_dead_tup > 10000  -- 10000行以上のデッドタプル
    AND n_dead_tup > 0.2 * n_live_tup  -- 生存タプルの20%以上
    LIMIT 5;
    
    -- 未使用インデックスアラート
    RETURN QUERY
    SELECT
        'INFO'::text AS alert_level,
        'UNUSED_INDEX'::text AS alert_type,
        'Index ' || schemaname || '.' || indexrelname || ' on table ' || relname || ' is not used' AS description,
        'Consider dropping this index if not required for constraints' AS recommendation
    FROM pg_stat_user_indexes
    WHERE idx_scan = 0
    AND indexrelid NOT IN (
        SELECT indexrelid
        FROM pg_index
        WHERE indisprimary OR indisunique
    )
    AND pg_relation_size(indexrelid) > 10 * 1024 * 1024  -- 10MB以上
    LIMIT 5;
    
    -- 長時間実行トランザクションアラート
    RETURN QUERY
    SELECT
        'WARNING'::text AS alert_level,
        'LONG_TRANSACTION'::text AS alert_type,
        'Transaction running for ' || 
        extract(epoch FROM now() - xact_start) / 60 || ' minutes, state: ' || state AS description,
        'Investigate and potentially terminate this transaction' AS recommendation
    FROM pg_stat_activity
    WHERE xact_start IS NOT NULL
    AND state != 'idle'
    AND extract(epoch FROM now() - xact_start) > 30 * 60  -- 30分以上実行
    LIMIT 5;
END;
$$ LANGUAGE plpgsql;

-- アラートのスケジューリング
SELECT cron.schedule('*/10 * * * *', $$
    INSERT INTO common.performance_alerts (
        alert_time, alert_level, alert_type, description, recommendation
    )
    SELECT 
        now(), alert_level, alert_type, description, recommendation
    FROM common.check_database_performance();
$$);
```

### 5.3 継続的最適化プロセス

データベースパフォーマンスの継続的な改善プロセス。

#### 5.3.1 定期的な健全性チェック

```sql
-- データベース健全性チェック関数
CREATE OR REPLACE FUNCTION common.database_health_check()
RETURNS TABLE (
    check_category text,
    check_name text,
    status text,
    details text
) AS $$
BEGIN
    -- 1. データベースサイズチェック
    RETURN QUERY
    SELECT
        'DATABASE'::text AS check_category,
        'Size'::text AS check_name,
        'INFO'::text AS status,
        'Total size: ' || pg_size_pretty(pg_database_size(current_database())) AS details;
    
    -- 2. 最大テーブルサイズチェック
    RETURN QUERY
    SELECT
        'TABLES'::text AS check_category,
        'Largest Tables'::text AS check_name,
        'INFO'::text AS status,
        schemaname || '.' || relname || ': ' || pg_size_pretty(pg_total_relation_size(relid)) AS details
    FROM pg_catalog.pg_statio_user_tables
    ORDER BY pg_total_relation_size(relid) DESC
    LIMIT 5;
    
    -- 3. インデックスサイズチェック
    RETURN QUERY
    SELECT
        'INDEXES'::text AS check_category,
        'Largest Indexes'::text AS check_name,
        'INFO'::text AS status,
        schemaname || '.' || indexrelname || ': ' || pg_size_pretty(pg_relation_size(indexrelid)) AS details
    FROM pg_stat_user_indexes
    ORDER BY pg_relation_size(indexrelid) DESC
    LIMIT 5;
    
    -- 4. VACUUMチェック
    RETURN QUERY
    SELECT
        'MAINTENANCE'::text AS check_category,
        'VACUUM Status'::text AS check_name,
        CASE 
            WHEN last_vacuum IS NULL AND last_autovacuum IS NULL THEN 'WARNING'
            WHEN (now() - COALESCE(last_vacuum, last_autovacuum)) > interval '7 days' AND n_dead_tup > 1000 THEN 'WARNING'
            ELSE 'OK'
        END AS status,
        schemaname || '.' || relname || 
        ': Last vacuum: ' || COALESCE(last_vacuum::text, 'never') ||
        ', Last autovacuum: ' || COALESCE(last_autovacuum::text, 'never') ||
        ', Dead tuples: ' || n_dead_tup AS details
    FROM pg_stat_user_tables
    WHERE (last_vacuum IS NULL AND last_autovacuum IS NULL)
    OR ((now() - COALESCE(last_vacuum, last_autovacuum)) > interval '7 days' AND n_dead_tup > 1000)
    ORDER BY n_dead_tup DESC
    LIMIT 5;
    
    -- 5. ANALYZE状況チェック
    RETURN QUERY
    SELECT
        'MAINTENANCE'::text AS check_category,
        'ANALYZE Status'::text AS check_name,
        CASE 
            WHEN last_analyze IS NULL AND last_autoanalyze IS NULL THEN 'WARNING'
            WHEN (now() - COALESCE(last_analyze, last_autoanalyze)) > interval '7 days' AND 
                 (n_mod_since_analyze > 1000 OR n_mod_since_analyze > 0.1 * n_live_tup) THEN 'WARNING'
            ELSE 'OK'
        END AS status,
        schemaname || '.' || relname || 
        ': Last analyze: ' || COALESCE(last_analyze::text, 'never') ||
        ', Last autoanalyze: ' || COALESCE(last_autoanalyze::text, 'never') ||
        ', Modified rows since: ' || COALESCE(n_mod_since_analyze::text, '0') AS details
    FROM pg_stat_user_tables
    WHERE (last_analyze IS NULL AND last_autoanalyze IS NULL)
    OR ((now() - COALESCE(last_analyze, last_autoanalyze)) > interval '7 days' AND 
        (n_mod_since_analyze > 1000 OR n_mod_since_analyze > 0.1 * n_live_tup))
    ORDER BY n_mod_since_analyze DESC
    LIMIT 5;
    
    -- 6. ブロッキングクエリチェック
    RETURN QUERY
    SELECT
        'LOCKS'::text AS check_category,
        'Blocking Queries'::text AS check_name,
        CASE WHEN count(*) > 0 THEN 'WARNING' ELSE 'OK' END AS status,
        count(*) || ' queries are blocking other queries' AS details
    FROM pg_locks blockers
    JOIN pg_stat_activity blocker_activity ON blockers.pid = blocker_activity.pid
    JOIN pg_locks waiters ON blockers.locktype = waiters.locktype
      AND blockers.database IS NOT DISTINCT FROM waiters.database
      AND blockers.relation IS NOT DISTINCT FROM waiters.relation
      AND blockers.page IS NOT DISTINCT FROM waiters.page
      AND blockers.tuple IS NOT DISTINCT FROM waiters.tuple
      AND blockers.virtualxid IS NOT DISTINCT FROM waiters.virtualxid
      AND blockers.transactionid IS NOT DISTINCT FROM waiters.transactionid
      AND blockers.classid IS NOT DISTINCT FROM waiters.classid
      AND blockers.objid IS NOT DISTINCT FROM waiters.objid
      AND blockers.objsubid IS NOT DISTINCT FROM waiters.objsubid
      AND blockers.pid != waiters.pid
    WHERE NOT waiters.granted;
    
    -- 7. キャッシュヒット率チェック
    RETURN QUERY
    SELECT
        'PERFORMANCE'::text AS check_category,
        'Cache Hit Ratio'::text AS check_name,
        CASE 
            WHEN blks_hit + blks_read = 0 THEN 'INFO'
            WHEN 100 * blks_hit / (blks_hit + blks_read) < 90 THEN 'WARNING'
            ELSE 'OK'
        END AS status,
        CASE 
            WHEN blks_hit + blks_read = 0 THEN 'No data available'
            ELSE 'Cache hit ratio: ' || round(100 * blks_hit / (blks_hit + blks_read), 2) || '%'
        END AS details
    FROM pg_stat_database
    WHERE datname = current_database();
END;
$$ LANGUAGE plpgsql;

-- 週次健全性チェックのスケジューリング
SELECT cron.schedule('0 0 * * 0', $$
    INSERT INTO common.health_check_history (
        check_time, check_category, check_name, status, details
    )
    SELECT 
        now(), check_category, check_name, status, details
    FROM common.database_health_check();
$$);
```

#### 5.3.2 パフォーマンスチューニングサイクル

継続的なパフォーマンス改善のためのプロセスフロー。

1. **監視フェーズ**:
   - 定期的なパフォーマンスメトリクス収集
   - アラートの検出と分析
   - ベースラインとの比較

2. **分析フェーズ**:
   - スロークエリの特定と分析
   - リソース使用量のボトルネック特定
   - ワークロードパターンの変化検出

3. **改善フェーズ**:
   - インデックス設計の最適化
   - クエリの書き換えと最適化
   - テーブル設計の見直し
   - パラメータ調整

4. **検証フェーズ**:
   - 改善効果の測定
   - 副作用の有無確認
   - 新たなベースラインの確立

5. **実装フェーズ**:
   - 本番環境への適用計画
   - 変更管理プロセスの遵守
   - 適用後の監視強化

サイクルを繰り返すことで継続的なパフォーマンス向上を実現する。

## 6. モジュール別テーブル定義補足との関連

各業務モジュールの「テーブル定義補足」ドキュメントには、そのモジュール固有のパフォーマンス最適化方法を記載する。本ドキュメントは全体方針と共通パターンを定義し、各モジュールの詳細は対応する補足ドキュメントを参照すること。