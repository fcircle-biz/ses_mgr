# DB詳細設計 - データ型と制約

## 1. データ型選定の基本方針

本システムのデータベース設計において、各カラムのデータ型は以下の方針に基づいて選定する。

- **適切性**: データの性質に最も適したデータ型を選択
- **効率性**: ストレージ効率とパフォーマンスを考慮
- **互換性**: アプリケーションとの互換性を確保
- **拡張性**: 将来の要件変更に対応可能な設計

## 2. 標準データ型

### 2.1 数値型

| データ型       | 用途                             | 使用例                         |
|--------------|----------------------------------|--------------------------------|
| `serial`      | 自動採番ID (32ビット)             | 小~中規模テーブルの主キー        |
| `bigserial`   | 自動採番ID (64ビット)             | 大規模テーブルの主キー           |
| `integer`     | 整数値 (-2^31 ~ 2^31-1)          | 数量、回数などの一般的な整数値    |
| `bigint`      | 大きな整数値 (-2^63 ~ 2^63-1)    | 大きな値を扱う場合、外部キー     |
| `numeric(p,s)`| 精度が必要な小数                  | 金額、請求額、料率など           |
| `double precision` | 精度より範囲が重要な小数      | 統計値、科学的数値など           |
| `smallint`    | 小さな整数値 (-32768 ~ 32767)    | コード値、ステータスなど         |

### 2.2 文字列型

| データ型       | 用途                             | 使用例                         |
|--------------|----------------------------------|--------------------------------|
| `char(n)`     | 固定長文字列                      | 固定桁数のコード値など          |
| `varchar(n)`  | 可変長文字列                      | 名前、説明文など一般的な文字列   |
| `text`        | 長い可変長文字列                  | 詳細説明、備考など              |
| `citext`      | 大文字小文字を区別しない文字列    | メールアドレス、ユーザー名など   |

### 2.3 日時型

| データ型       | 用途                             | 使用例                         |
|--------------|----------------------------------|--------------------------------|
| `date`        | 日付のみ                         | 契約日、期限日など              |
| `time`        | 時刻のみ                         | 開始時刻、終了時刻など          |
| `timestamp`   | 日付と時刻                       | 登録日時、更新日時など          |
| `timestamptz` | タイムゾーン付き日付と時刻       | イベント日時、予定日時など      |
| `interval`    | 時間間隔                         | 期間、所要時間など              |

### 2.4 論理型

| データ型       | 用途                             | 使用例                         |
|--------------|----------------------------------|--------------------------------|
| `boolean`     | 真偽値                           | フラグ、状態など                |

### 2.5 JSON型

| データ型       | 用途                             | 使用例                         |
|--------------|----------------------------------|--------------------------------|
| `json`        | JSON形式データ                   | 構造化データの保存              |
| `jsonb`       | バイナリJSON形式                 | 高速検索が必要な構造化データ    |

### 2.6 その他の型

| データ型       | 用途                             | 使用例                         |
|--------------|----------------------------------|--------------------------------|
| `uuid`        | 汎用一意識別子                    | グローバル一意のID             |
| `bytea`       | バイナリデータ                    | 小さなファイルデータなど        |
| `enum`        | 列挙型                           | 固定選択肢の値                  |
| `tsquery/tsvector` | 全文検索型                   | 全文検索インデックス            |
| `cidr/inet`   | ネットワークアドレス型           | IPアドレス管理                  |

## 3. データ型選定ガイドライン

### 3.1 ID/キー列の型選定

- 主キー: 基本的に`serial`または`bigserial`を使用
- 論理的に意味のあるIDの場合は適切な型を選択（例: `uuid`など）
- 外部キーは参照先テーブルの主キーと同じ型を使用

#### 例:

```sql
-- 一般的なIDカラム（自動採番）
id serial PRIMARY KEY,

-- 大規模テーブルのIDカラム
id bigserial PRIMARY KEY,

-- UUID型を使用する場合
id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
```

### 3.2 文字列型選定

- 固定長であることが確実な場合のみ`char(n)`を使用
- 一般的な文字列は`varchar(n)`を使用し、適切な最大長を設定
- 長さ制限の必要がない長文には`text`型を使用
- 大文字小文字を区別しない検索が必要な場合は`citext`拡張を使用

#### 例:

```sql
-- 一般的な名前や説明
name varchar(100) NOT NULL,
description varchar(1000),

-- 長文のコンテンツ
content text,

-- 大文字小文字を区別しないメールアドレス
email citext NOT NULL UNIQUE,
```

### 3.3 数値型選定

- 金額など計算精度が重要な場合は`numeric(p,s)`を使用
- 科学的計算など精度より範囲が重要な場合は`double precision`を使用
- 整数値は`integer`または`bigint`を基本とし、値の範囲に応じて選択
- ステータスなど少ない値の範囲では`smallint`を検討

#### 例:

```sql
-- 金額カラム（10桁の整数部と2桁の小数部）
amount numeric(12,2) NOT NULL,

-- 一般的な整数値
count integer NOT NULL DEFAULT 0,

-- 大きな数値が予想される場合
total_count bigint NOT NULL DEFAULT 0,

-- ステータスコードなど
status_code smallint NOT NULL,
```

### 3.4 日時型選定

- 基本的に`timestamptz`を使用し、タイムゾーンを考慮
- 日付のみの場合は`date`型を使用
- 時刻のみの場合は`time`型を使用
- 期間を表す場合は`interval`型を使用

#### 例:

```sql
-- 日時カラム（タイムゾーン付き）
created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
updated_at timestamptz,

-- 日付のみのカラム
start_date date NOT NULL,
end_date date,

-- 時刻のみのカラム
start_time time,
end_time time,

-- 期間カラム
duration interval,
```

### 3.5 JSON型選定

- インデックス検索やJSONパスを使用した検索が必要な場合は`jsonb`型を使用
- 単純な格納・取得のみの場合は`json`型を使用
- スキーマが頻繁に変更される可能性のあるデータに適用

#### 例:

```sql
-- 検索や操作が必要なJSONデータ
settings jsonb NOT NULL DEFAULT '{}',

-- 単純な格納・取得のみのJSONデータ
raw_data json,
```

## 4. 制約設計

### 4.1 制約の種類と使用方針

| 制約タイプ     | 説明                              | 使用方針                        |
|---------------|----------------------------------|--------------------------------|
| 主キー制約     | テーブルの行を一意に識別する制約    | すべてのテーブルに適用           |
| 外部キー制約   | 参照整合性を保証する制約           | エンティティ間の関連に適用       |
| 一意制約       | カラムまたはカラム組合せの一意性    | 業務的に一意であるべき項目に適用  |
| NOT NULL制約   | NULL値を許可しない制約            | 必須項目に適用                  |
| CHECK制約      | カラム値が特定条件を満たすことを保証 | データの妥当性検証に適用        |
| DEFAULT制約    | 値が指定されない場合のデフォルト値  | 適切なデフォルト値がある場合に適用 |
| EXCLUDE制約    | 排他制約                          | 重複登録防止などの特殊なケースに適用 |

### 4.2 主キー制約

- 各テーブルには必ず主キーを設定する
- 基本的に`id`カラムを主キーとする
- 複合主キーは関連テーブルなど必要な場合のみ使用

#### 例:

```sql
-- 単一カラム主キー
CREATE TABLE engineer.engineer (
    id serial PRIMARY KEY,
    name varchar(100) NOT NULL,
    ...
);

-- 複合主キー
CREATE TABLE timesheet.working_hours (
    engineer_id integer NOT NULL,
    project_id integer NOT NULL,
    work_date date NOT NULL,
    hours numeric(4,2) NOT NULL,
    PRIMARY KEY (engineer_id, project_id, work_date)
);
```

### 4.3 外部キー制約

- テーブル間の参照整合性を保証するために使用
- カスケード動作は業務要件に応じて慎重に設定
- インデックス作成も考慮する

#### 例:

```sql
-- 基本的な外部キー制約
CREATE TABLE engineer.skill (
    id serial PRIMARY KEY,
    engineer_id integer NOT NULL,
    skill_name varchar(100) NOT NULL,
    CONSTRAINT fk_skill_engineer FOREIGN KEY (engineer_id)
        REFERENCES engineer.engineer (id) ON DELETE CASCADE
);

-- カスケード動作を制限した外部キー制約
CREATE TABLE contract.contract (
    id serial PRIMARY KEY,
    project_id integer NOT NULL,
    engineer_id integer NOT NULL,
    CONSTRAINT fk_contract_project FOREIGN KEY (project_id)
        REFERENCES project.project (id) ON DELETE RESTRICT,
    CONSTRAINT fk_contract_engineer FOREIGN KEY (engineer_id)
        REFERENCES engineer.engineer (id) ON DELETE RESTRICT
);
```

### 4.4 一意制約

- ビジネスルール上、一意であるべきデータに適用
- 複合カラムの一意性が必要な場合も考慮
- 索引付けも考慮する

#### 例:

```sql
-- 単一カラムの一意制約
CREATE TABLE common.user (
    id serial PRIMARY KEY,
    email varchar(255) NOT NULL,
    CONSTRAINT uq_user_email UNIQUE (email)
);

-- 複合カラムの一意制約
CREATE TABLE billing.invoice (
    id serial PRIMARY KEY,
    invoice_number varchar(20) NOT NULL,
    year integer NOT NULL,
    CONSTRAINT uq_invoice_number_year UNIQUE (invoice_number, year)
);
```

### 4.5 CHECK制約

- データの妥当性を保証するために使用
- 業務ルールをデータベースレベルで強制するために活用
- 複雑なバリデーションはトリガーも検討

#### 例:

```sql
-- 単純な値の範囲チェック
CREATE TABLE timesheet.working_hours (
    ...
    hours numeric(4,2) NOT NULL,
    CONSTRAINT ck_working_hours_valid_range CHECK (hours >= 0 AND hours <= 24)
);

-- 日付関連のチェック
CREATE TABLE project.project (
    ...
    start_date date NOT NULL,
    end_date date,
    CONSTRAINT ck_project_date_order CHECK (end_date IS NULL OR end_date >= start_date)
);

-- 複雑な条件のチェック
CREATE TABLE billing.payment (
    ...
    amount numeric(12,2) NOT NULL,
    invoice_amount numeric(12,2) NOT NULL,
    CONSTRAINT ck_payment_amount_valid CHECK (amount > 0 AND amount <= invoice_amount)
);
```

### 4.6 DEFAULT制約

- 値が指定されない場合のデフォルト値を設定
- 現在時刻、真偽値、カウンタの初期値などによく使用

#### 例:

```sql
-- 現在時刻のデフォルト
created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,

-- 真偽値のデフォルト
is_active boolean NOT NULL DEFAULT true,

-- 数値のデフォルト
retry_count integer NOT NULL DEFAULT 0,

-- 関数を使用したデフォルト
id uuid DEFAULT gen_random_uuid(),
```

### 4.7 EXCLUDE制約

- 排他的条件を設定する高度な制約
- 主に期間の重複防止などに使用

#### 例:

```sql
-- 同一技術者の同一日における重複シフト防止
CREATE TABLE engineer.shift (
    id serial PRIMARY KEY,
    engineer_id integer NOT NULL,
    shift_date date NOT NULL,
    start_time time NOT NULL,
    end_time time NOT NULL,
    CONSTRAINT fk_shift_engineer FOREIGN KEY (engineer_id)
        REFERENCES engineer.engineer (id),
    CONSTRAINT ck_shift_time_order CHECK (start_time < end_time),
    CONSTRAINT ex_overlapping_shifts EXCLUDE USING gist (
        engineer_id WITH =,
        shift_date WITH =,
        tsrange(start_time, end_time) WITH &&
    )
);
```

## 5. ドメイン型の活用

業務上、共通の制約を持つデータ型は、ドメイン型として定義して再利用する。

### 5.1 ドメイン型定義例

```sql
-- メールアドレスのドメイン型
CREATE DOMAIN email_address AS varchar(255)
    CHECK (value ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$');

-- 電話番号のドメイン型
CREATE DOMAIN phone_number AS varchar(20)
    CHECK (value ~ '^\+?[0-9]{10,15}$');

-- 郵便番号のドメイン型
CREATE DOMAIN postal_code AS char(8)
    CHECK (value ~ '^[0-9]{3}-[0-9]{4}$');

-- 百分率のドメイン型
CREATE DOMAIN percentage AS numeric(5,2)
    CHECK (value >= 0 AND value <= 100);
```

### 5.2 ドメイン型の使用例

```sql
-- ドメイン型を使用したテーブル定義
CREATE TABLE engineer.engineer (
    id serial PRIMARY KEY,
    name varchar(100) NOT NULL,
    email email_address NOT NULL,
    phone phone_number,
    postal_code postal_code,
    skill_level percentage
);
```

## 6. 列挙型の活用

固定値セットを表現する場合は列挙型を活用する。

### 6.1 列挙型定義例

```sql
-- 契約ステータスの列挙型
CREATE TYPE contract_status AS ENUM (
    'draft',
    'pending_review',
    'approved',
    'signed',
    'active',
    'expired',
    'terminated'
);

-- プロジェクト優先度の列挙型
CREATE TYPE project_priority AS ENUM (
    'low',
    'medium',
    'high',
    'critical'
);
```

### 6.2 列挙型の使用例

```sql
-- 列挙型を使用したテーブル定義
CREATE TABLE contract.contract (
    id serial PRIMARY KEY,
    project_id integer NOT NULL,
    status contract_status NOT NULL DEFAULT 'draft',
    priority project_priority NOT NULL DEFAULT 'medium',
    CONSTRAINT fk_contract_project FOREIGN KEY (project_id)
        REFERENCES project.project (id)
);
```

## 7. 複合型の活用

複数のカラムがセットで扱われることが多い場合は、複合型を検討する。

### 7.1 複合型定義例

```sql
-- 住所の複合型
CREATE TYPE address AS (
    postal_code varchar(8),
    prefecture varchar(20),
    city varchar(50),
    street varchar(100),
    building varchar(100)
);

-- 位置情報の複合型
CREATE TYPE location AS (
    latitude numeric(9,6),
    longitude numeric(9,6)
);
```

### 7.2 複合型の使用例

```sql
-- 複合型を使用したテーブル定義
CREATE TABLE engineer.engineer (
    id serial PRIMARY KEY,
    name varchar(100) NOT NULL,
    home_address address,
    office_address address,
    current_location location
);
```

## 8. 継承の活用

共通のカラム構造を持つテーブル群には、テーブル継承を検討する。

### 8.1 継承の使用例

```sql
-- 基底テーブル
CREATE TABLE common.base_entity (
    id serial PRIMARY KEY,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by integer,
    updated_at timestamptz,
    updated_by integer,
    is_deleted boolean NOT NULL DEFAULT false
);

-- 継承テーブル
CREATE TABLE engineer.engineer (
    name varchar(100) NOT NULL,
    email varchar(255) NOT NULL UNIQUE,
    status_code smallint NOT NULL
) INHERITS (common.base_entity);
```

## 9. トリガーによる制約実装

複雑な制約条件は、トリガーを使用して実装する。

### 9.1 トリガー実装例

```sql
-- 勤怠時間の整合性チェックトリガー
CREATE OR REPLACE FUNCTION timesheet.check_working_hours()
RETURNS TRIGGER AS $$
BEGIN
    -- 1日の労働時間が24時間を超えていないかチェック
    IF EXISTS (
        SELECT 1
        FROM timesheet.working_hours
        WHERE engineer_id = NEW.engineer_id
        AND work_date = NEW.work_date
        GROUP BY engineer_id, work_date
        HAVING SUM(hours) + NEW.hours > 24
    ) THEN
        RAISE EXCEPTION 'Total working hours cannot exceed 24 hours per day';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_check_working_hours
BEFORE INSERT OR UPDATE ON timesheet.working_hours
FOR EACH ROW EXECUTE FUNCTION timesheet.check_working_hours();
```

## 10. 制約命名規則

制約の命名規則については、「03_スキーマ設計.md」の命名規則セクションを参照。