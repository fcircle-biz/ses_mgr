# DB詳細設計 - バックアップリカバリ

## 1. バックアップ・リカバリの基本方針

本システムにおけるデータベースのバックアップとリカバリは、以下の方針に基づいて設計・実装する。

### 1.1 バックアップ方針

- **RTO（Recovery Time Objective）**: 2時間以内のサービス復旧
- **RPO（Recovery Point Objective）**: 15分以内のデータ損失許容範囲
- **多層バックアップ戦略**: 複数の異なるバックアップ方式を組み合わせて実施
- **定期的な検証**: バックアップデータのリストア検証による信頼性確保
- **自動化**: バックアップ処理の自動実行と監視体制の確立

### 1.2 リカバリ方針

- **明確な手順**: 詳細なリカバリ手順の文書化
- **インシデントの分類**: 影響範囲と重要度に応じたリカバリ手順の分類
- **定期的な訓練**: リカバリ手順の実践訓練による効果の検証
- **段階的な復旧**: 優先順位に応じた段階的なシステム復旧
- **代替手段の確保**: リカバリ手段に複数の選択肢を用意

## 2. バックアップ戦略

### 2.1 バックアップの種類と目的

| バックアップ種類 | 目的 | 頻度 | 保持期間 | RPO |
|---------------|------|------|---------|-----|
| 物理バックアップ（フル） | 全データベースの完全コピー | 日次（深夜） | 14日間 | 24時間 |
| 差分バックアップ | 前回のフルバックアップからの変更分 | 6時間ごと | 3日間 | 6時間 |
| WALアーカイブ | ポイントインタイムリカバリ用のトランザクションログ | 継続的（5分間隔） | 7日間 | 5分 |
| 論理バックアップ | スキーマやデータの選択的リストア | 週次 | 3ヶ月間 | 7日間 |
| スナップショット | 迅速な復旧用の完全コピー | 週次 | 1ヶ月間 | 7日間 |

### 2.2 物理バックアップ

PostgreSQLの物理バックアップは、ファイルシステムレベルでのデータベースファイルのコピーである。`pg_basebackup`ツールを使用して実装する。

#### 2.2.1 フルバックアップの実装

```bash
#!/bin/bash
# フルバックアップスクリプト例

# 変数設定
BACKUP_DIR=/backup/postgres/basebackups
DATE=$(date +%Y%m%d_%H%M%S)
LOG_FILE=/var/log/postgres/backup_${DATE}.log

# バックアップディレクトリがなければ作成
mkdir -p ${BACKUP_DIR}

# バックアップ実行
pg_basebackup -h localhost -U backup_user -D ${BACKUP_DIR}/${DATE} -Ft -z -P -X stream >> ${LOG_FILE} 2>&1

# 圧縮
tar -czf ${BACKUP_DIR}/${DATE}.tar.gz -C ${BACKUP_DIR} ${DATE}
rm -rf ${BACKUP_DIR}/${DATE}

# 古いバックアップの削除（14日以上前）
find ${BACKUP_DIR} -name "*.tar.gz" -type f -mtime +14 -delete

# 結果確認とステータス送信
if [ $? -eq 0 ]; then
    echo "Backup successful: ${BACKUP_DIR}/${DATE}.tar.gz" >> ${LOG_FILE}
    # アラート送信（成功）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"success\",\"type\":\"full_backup\",\"file\":\"${DATE}.tar.gz\"}" http://monitoring-server/api/backup-status
else
    echo "Backup failed" >> ${LOG_FILE}
    # アラート送信（失敗）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"failed\",\"type\":\"full_backup\",\"error\":\"Check log for details\"}" http://monitoring-server/api/backup-status
fi
```

#### 2.2.2 差分バックアップの実装（WALベース）

```bash
#!/bin/bash
# WALアーカイブバックアップスクリプト例

# 変数設定
WAL_ARCHIVE_DIR=/backup/postgres/wal_archive
DATE=$(date +%Y%m%d_%H%M%S)
LOG_FILE=/var/log/postgres/wal_archive_${DATE}.log

# WALアーカイブディレクトリがなければ作成
mkdir -p ${WAL_ARCHIVE_DIR}

# WALの切り替えをトリガー
psql -U postgres -c "SELECT pg_switch_wal();" >> ${LOG_FILE} 2>&1

# 現在時刻を記録（バックアップポイント）
echo "WAL switch triggered at $(date)" >> ${LOG_FILE}

# 古いWALファイルの削除（7日以上前）
find ${WAL_ARCHIVE_DIR} -name "*.gz" -type f -mtime +7 -delete

# 結果確認とステータス送信
if [ $? -eq 0 ]; then
    echo "WAL archive successful" >> ${LOG_FILE}
    # アラート送信（成功）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"success\",\"type\":\"wal_archive\",\"timestamp\":\"${DATE}\"}" http://monitoring-server/api/backup-status
else
    echo "WAL archive failed" >> ${LOG_FILE}
    # アラート送信（失敗）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"failed\",\"type\":\"wal_archive\",\"error\":\"Check log for details\"}" http://monitoring-server/api/backup-status
fi
```

### 2.3 論理バックアップ

論理バックアップは、データベースの内容をSQL形式で抽出するバックアップである。`pg_dump`ツールを使用して実装する。

#### 2.3.1 データベース全体の論理バックアップ

```bash
#!/bin/bash
# 論理バックアップスクリプト例

# 変数設定
BACKUP_DIR=/backup/postgres/logical
DATE=$(date +%Y%m%d_%H%M%S)
DB_NAME=ses_mgr
LOG_FILE=/var/log/postgres/logical_backup_${DATE}.log

# バックアップディレクトリがなければ作成
mkdir -p ${BACKUP_DIR}

# カスタムフォーマットでのバックアップ実行
pg_dump -h localhost -U backup_user -d ${DB_NAME} -F c -f ${BACKUP_DIR}/${DB_NAME}_${DATE}.dump >> ${LOG_FILE} 2>&1

# 圧縮（既にカスタムフォーマットで圧縮済みの場合は不要）
gzip ${BACKUP_DIR}/${DB_NAME}_${DATE}.dump

# 古いバックアップの削除（3ヶ月以上前）
find ${BACKUP_DIR} -name "*.dump.gz" -type f -mtime +90 -delete

# 結果確認とステータス送信
if [ $? -eq 0 ]; then
    echo "Logical backup successful: ${BACKUP_DIR}/${DB_NAME}_${DATE}.dump.gz" >> ${LOG_FILE}
    # アラート送信（成功）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"success\",\"type\":\"logical_backup\",\"file\":\"${DB_NAME}_${DATE}.dump.gz\"}" http://monitoring-server/api/backup-status
else
    echo "Logical backup failed" >> ${LOG_FILE}
    # アラート送信（失敗）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"failed\",\"type\":\"logical_backup\",\"error\":\"Check log for details\"}" http://monitoring-server/api/backup-status
fi
```

#### 2.3.2 スキーマごとの論理バックアップ

```bash
#!/bin/bash
# スキーマ別論理バックアップスクリプト例

# 変数設定
BACKUP_DIR=/backup/postgres/logical/schemas
DATE=$(date +%Y%m%d_%H%M%S)
DB_NAME=ses_mgr
LOG_FILE=/var/log/postgres/schema_backup_${DATE}.log
SCHEMAS=("common" "engineer" "project" "matching" "contract" "timesheet" "billing" "reporting")

# バックアップディレクトリがなければ作成
mkdir -p ${BACKUP_DIR}/${DATE}

# スキーマごとのバックアップ実行
for SCHEMA in "${SCHEMAS[@]}"; do
    echo "Backing up schema: ${SCHEMA}" >> ${LOG_FILE}
    pg_dump -h localhost -U backup_user -d ${DB_NAME} -n ${SCHEMA} -F c -f ${BACKUP_DIR}/${DATE}/${SCHEMA}.dump >> ${LOG_FILE} 2>&1
    
    # エラーチェック
    if [ $? -ne 0 ]; then
        echo "Backup failed for schema: ${SCHEMA}" >> ${LOG_FILE}
        # アラート送信（失敗）
        curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"failed\",\"type\":\"schema_backup\",\"schema\":\"${SCHEMA}\",\"error\":\"Check log for details\"}" http://monitoring-server/api/backup-status
    fi
done

# ディレクトリごと圧縮
tar -czf ${BACKUP_DIR}/schemas_${DATE}.tar.gz -C ${BACKUP_DIR} ${DATE}
rm -rf ${BACKUP_DIR}/${DATE}

# 古いバックアップの削除（3ヶ月以上前）
find ${BACKUP_DIR} -name "schemas_*.tar.gz" -type f -mtime +90 -delete

# 結果確認とステータス送信
echo "Schema backup completed: ${BACKUP_DIR}/schemas_${DATE}.tar.gz" >> ${LOG_FILE}
curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"success\",\"type\":\"schema_backup\",\"file\":\"schemas_${DATE}.tar.gz\"}" http://monitoring-server/api/backup-status
```

### 2.4 AWS RDSでのバックアップ戦略

本番環境ではAWS RDSを使用する場合の設定例。

#### 2.4.1 自動バックアップの設定

```
# RDSパラメータ設定例
backup_retention_period = 14  # 14日間の自動バックアップ保持
preferred_backup_window = '00:00-03:00'  # バックアップウィンドウ（UTC）
preferred_maintenance_window = 'Sun:03:00-Sun:06:00'  # メンテナンスウィンドウ（UTC）

# WALアーカイブ設定
rds.logical_replication = 1  # 論理レプリケーション有効化（WALアーカイブに必要）
```

#### 2.4.2 手動スナップショットの作成

```bash
#!/bin/bash
# RDS手動スナップショット作成スクリプト例

# 変数設定
DB_INSTANCE=ses-mgr-prod
SNAPSHOT_ID=${DB_INSTANCE}-snapshot-$(date +%Y%m%d)
RETENTION_DAYS=30

# スナップショット作成
aws rds create-db-snapshot \
    --db-instance-identifier ${DB_INSTANCE} \
    --db-snapshot-identifier ${SNAPSHOT_ID}

# 古いスナップショットの削除（30日以上前）
OLD_SNAPSHOTS=$(aws rds describe-db-snapshots \
    --db-instance-identifier ${DB_INSTANCE} \
    --query "DBSnapshots[?SnapshotCreateTime<='$(date -d "${RETENTION_DAYS} days ago" +%Y-%m-%d)'].DBSnapshotIdentifier" \
    --output text)

for SNAPSHOT in ${OLD_SNAPSHOTS}; do
    echo "Deleting old snapshot: ${SNAPSHOT}"
    aws rds delete-db-snapshot --db-snapshot-identifier ${SNAPSHOT}
done
```

### 2.5 バックアップスケジュール

バックアップタスクを自動実行するためのスケジュール設定例。

```
# crontab設定例

# フルバックアップ（毎日午前1時）
0 1 * * * /backup/scripts/full_backup.sh

# 差分バックアップ（6時間ごと）
0 */6 * * * /backup/scripts/wal_switch.sh

# 論理バックアップ（毎週日曜日午前2時）
0 2 * * 0 /backup/scripts/logical_backup.sh

# スキーマバックアップ（毎週日曜日午前3時）
0 3 * * 0 /backup/scripts/schema_backup.sh

# RDSスナップショット（毎週月曜日午前4時）
0 4 * * 1 /backup/scripts/rds_snapshot.sh

# バックアップ検証（毎月第1日曜日午前5時）
0 5 * * 0 [ $(date +\%d) -le 7 ] && /backup/scripts/verify_backup.sh
```

### 2.6 バックアップファイルの転送と保管

バックアップファイルをセカンダリロケーションに転送するための設定例。

#### 2.6.1 AWS S3への転送

```bash
#!/bin/bash
# バックアップファイルのS3転送スクリプト例

# 変数設定
SOURCE_DIR=/backup/postgres
S3_BUCKET=s3://ses-mgr-backups
LOG_FILE=/var/log/postgres/s3_transfer_$(date +%Y%m%d_%H%M%S).log

# 新しいバックアップファイルをS3に同期
aws s3 sync ${SOURCE_DIR} ${S3_BUCKET} \
    --exclude "*" \
    --include "*.tar.gz" \
    --include "*.dump.gz" \
    --storage-class STANDARD_IA >> ${LOG_FILE} 2>&1

# S3バケットのライフサイクルポリシー設定（コンソールまたはAWS CLIで設定）
# - 30日後にGLACIERに移行
# - 365日後に削除
```

#### 2.6.2 セカンダリロケーションへの複製

```bash
#!/bin/bash
# セカンダリサイトへのバックアップ複製スクリプト例

# 変数設定
SOURCE_DIR=/backup/postgres
DEST_SERVER=dr-backup-server
DEST_DIR=/backup/postgres/primary-replica
LOG_FILE=/var/log/postgres/replication_$(date +%Y%m%d_%H%M%S).log

# rsyncでセカンダリサイトに転送
rsync -avz --delete ${SOURCE_DIR}/ ${DEST_SERVER}:${DEST_DIR}/ >> ${LOG_FILE} 2>&1

# 結果確認とステータス送信
if [ $? -eq 0 ]; then
    echo "Backup replication successful" >> ${LOG_FILE}
    # アラート送信（成功）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"success\",\"type\":\"backup_replication\",\"timestamp\":\"$(date +%Y%m%d_%H%M%S)\"}" http://monitoring-server/api/backup-status
else
    echo "Backup replication failed" >> ${LOG_FILE}
    # アラート送信（失敗）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"failed\",\"type\":\"backup_replication\",\"error\":\"Check log for details\"}" http://monitoring-server/api/backup-status
fi
```

## 3. リカバリ戦略

### 3.1 リカバリシナリオと対応方法

| シナリオ | 対応方法 | 推定復旧時間 | データ損失 |
|---------|---------|------------|----------|
| クエリ/トランザクションエラー | アプリケーションレベルのリトライや例外処理 | 即時 | なし |
| テーブル/レコード誤削除 | ポイントインタイムリカバリまたは論理バックアップからのリストア | 30分〜2時間 | 最大5分（WALアーカイブ間隔） |
| DB破損 | 物理バックアップからのリストア + WALリカバリ | 1〜2時間 | 最大5分（WALアーカイブ間隔） |
| DBサーバ障害 | RDSフェイルオーバーまたはスタンバイへの切り替え | 5〜15分 | 最小（トランザクション複製遅延） |
| リージョン障害 | クロスリージョンリードレプリカへの切り替え | 1〜3時間 | 最大15分（リードレプリカの遅延） |
| 誤った構成変更 | 構成バックアップまたはスナップショットからのリストア | 30分〜1時間 | なし（構成のみ） |

### 3.2 物理バックアップからのリカバリ

#### 3.2.1 フルバックアップからのリストア

```bash
#!/bin/bash
# フルバックアップからのリストアスクリプト例

# 変数設定
BACKUP_DIR=/backup/postgres/basebackups
RESTORE_DIR=/var/lib/postgresql/data
BACKUP_FILE=$1  # リストアするバックアップファイル名を引数で指定
LOG_FILE=/var/log/postgres/restore_$(date +%Y%m%d_%H%M%S).log

# PostgreSQLサービス停止
systemctl stop postgresql >> ${LOG_FILE} 2>&1

# 既存データディレクトリのバックアップ
mv ${RESTORE_DIR} ${RESTORE_DIR}.bak.$(date +%Y%m%d_%H%M%S) >> ${LOG_FILE} 2>&1
mkdir -p ${RESTORE_DIR} >> ${LOG_FILE} 2>&1
chown postgres:postgres ${RESTORE_DIR} >> ${LOG_FILE} 2>&1

# バックアップファイルの解凍と展開
tar -xzf ${BACKUP_DIR}/${BACKUP_FILE} -C /tmp >> ${LOG_FILE} 2>&1
cp -rp /tmp/$(basename ${BACKUP_FILE} .tar.gz)/* ${RESTORE_DIR}/ >> ${LOG_FILE} 2>&1
rm -rf /tmp/$(basename ${BACKUP_FILE} .tar.gz) >> ${LOG_FILE} 2>&1

# リカバリ設定ファイルの作成
cat > ${RESTORE_DIR}/recovery.conf << EOF
restore_command = 'cp /backup/postgres/wal_archive/%f %p'
recovery_target_time = '$(date -d "now" +"%Y-%m-%d %H:%M:%S")'
recovery_target_timeline = 'latest'
EOF

chown postgres:postgres ${RESTORE_DIR}/recovery.conf >> ${LOG_FILE} 2>&1

# PostgreSQLサービス起動
systemctl start postgresql >> ${LOG_FILE} 2>&1

# リカバリ状態の確認
sleep 10
if systemctl is-active postgresql > /dev/null; then
    echo "PostgreSQL restore completed successfully" >> ${LOG_FILE}
    # アラート送信（成功）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"success\",\"type\":\"full_restore\",\"file\":\"${BACKUP_FILE}\"}" http://monitoring-server/api/restore-status
else
    echo "PostgreSQL restore failed" >> ${LOG_FILE}
    # アラート送信（失敗）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"failed\",\"type\":\"full_restore\",\"error\":\"Check log for details\"}" http://monitoring-server/api/restore-status
fi
```

#### 3.2.2 ポイントインタイムリカバリ

```bash
#!/bin/bash
# ポイントインタイムリカバリスクリプト例

# 変数設定
BACKUP_DIR=/backup/postgres/basebackups
WAL_ARCHIVE_DIR=/backup/postgres/wal_archive
RESTORE_DIR=/var/lib/postgresql/data
BACKUP_FILE=$1  # リストアするバックアップファイル名を引数で指定
RECOVERY_TARGET_TIME=$2  # リカバリ対象時刻を引数で指定（YYYY-MM-DD HH:MM:SS形式）
LOG_FILE=/var/log/postgres/pitr_$(date +%Y%m%d_%H%M%S).log

# PostgreSQLサービス停止
systemctl stop postgresql >> ${LOG_FILE} 2>&1

# 既存データディレクトリのバックアップ
mv ${RESTORE_DIR} ${RESTORE_DIR}.bak.$(date +%Y%m%d_%H%M%S) >> ${LOG_FILE} 2>&1
mkdir -p ${RESTORE_DIR} >> ${LOG_FILE} 2>&1
chown postgres:postgres ${RESTORE_DIR} >> ${LOG_FILE} 2>&1

# バックアップファイルの解凍と展開
tar -xzf ${BACKUP_DIR}/${BACKUP_FILE} -C /tmp >> ${LOG_FILE} 2>&1
cp -rp /tmp/$(basename ${BACKUP_FILE} .tar.gz)/* ${RESTORE_DIR}/ >> ${LOG_FILE} 2>&1
rm -rf /tmp/$(basename ${BACKUP_FILE} .tar.gz) >> ${LOG_FILE} 2>&1

# リカバリ設定ファイルの作成
cat > ${RESTORE_DIR}/recovery.conf << EOF
restore_command = 'cp ${WAL_ARCHIVE_DIR}/%f %p'
recovery_target_time = '${RECOVERY_TARGET_TIME}'
recovery_target_inclusive = true
recovery_target_timeline = 'latest'
pause_at_recovery_target = true
EOF

chown postgres:postgres ${RESTORE_DIR}/recovery.conf >> ${LOG_FILE} 2>&1

# PostgreSQLサービス起動
systemctl start postgresql >> ${LOG_FILE} 2>&1

# リカバリ状態の確認
sleep 30
if systemctl is-active postgresql > /dev/null; then
    # リカバリ完了の確認
    psql -U postgres -c "SELECT pg_is_in_recovery();" | grep -q "f"
    if [ $? -eq 0 ]; then
        echo "PITR completed successfully to ${RECOVERY_TARGET_TIME}" >> ${LOG_FILE}
        # アラート送信（成功）
        curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"success\",\"type\":\"pitr\",\"target_time\":\"${RECOVERY_TARGET_TIME}\"}" http://monitoring-server/api/restore-status
    else
        echo "Database is still in recovery mode" >> ${LOG_FILE}
        # アラート送信（進行中）
        curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"in_progress\",\"type\":\"pitr\",\"target_time\":\"${RECOVERY_TARGET_TIME}\"}" http://monitoring-server/api/restore-status
    fi
else
    echo "PITR failed" >> ${LOG_FILE}
    # アラート送信（失敗）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"failed\",\"type\":\"pitr\",\"error\":\"Check log for details\"}" http://monitoring-server/api/restore-status
fi
```

### 3.3 論理バックアップからのリカバリ

#### 3.3.1 データベース全体のリストア

```bash
#!/bin/bash
# 論理バックアップからのリストアスクリプト例

# 変数設定
BACKUP_DIR=/backup/postgres/logical
DB_NAME=ses_mgr
BACKUP_FILE=$1  # リストアするバックアップファイル名を引数で指定
LOG_FILE=/var/log/postgres/logical_restore_$(date +%Y%m%d_%H%M%S).log

# バックアップファイルの解凍（圧縮されている場合）
if [[ ${BACKUP_FILE} == *.gz ]]; then
    gunzip -c ${BACKUP_DIR}/${BACKUP_FILE} > /tmp/$(basename ${BACKUP_FILE} .gz)
    RESTORE_FILE=/tmp/$(basename ${BACKUP_FILE} .gz)
else
    RESTORE_FILE=${BACKUP_DIR}/${BACKUP_FILE}
fi

# 既存データベースの削除と再作成
psql -U postgres -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '${DB_NAME}';" >> ${LOG_FILE} 2>&1
psql -U postgres -c "DROP DATABASE IF EXISTS ${DB_NAME};" >> ${LOG_FILE} 2>&1
psql -U postgres -c "CREATE DATABASE ${DB_NAME};" >> ${LOG_FILE} 2>&1

# リストア実行
pg_restore -h localhost -U postgres -d ${DB_NAME} -v ${RESTORE_FILE} >> ${LOG_FILE} 2>&1

# 一時ファイルの削除
if [[ ${BACKUP_FILE} == *.gz ]]; then
    rm ${RESTORE_FILE}
fi

# リストア結果の確認
if [ $? -eq 0 ]; then
    echo "Logical restore completed successfully" >> ${LOG_FILE}
    # アラート送信（成功）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"success\",\"type\":\"logical_restore\",\"file\":\"${BACKUP_FILE}\"}" http://monitoring-server/api/restore-status
else
    echo "Logical restore failed" >> ${LOG_FILE}
    # アラート送信（失敗）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"failed\",\"type\":\"logical_restore\",\"error\":\"Check log for details\"}" http://monitoring-server/api/restore-status
fi
```

#### 3.3.2 特定スキーマ/テーブルのリストア

```bash
#!/bin/bash
# 特定スキーマのリストアスクリプト例

# 変数設定
BACKUP_DIR=/backup/postgres/logical/schemas
DB_NAME=ses_mgr
SCHEMA_NAME=$1  # リストアするスキーマ名を引数で指定
BACKUP_DATE=$2  # バックアップ日付を引数で指定（YYYYMMDDなど）
LOG_FILE=/var/log/postgres/schema_restore_$(date +%Y%m%d_%H%M%S).log

# バックアップアーカイブの展開
mkdir -p /tmp/schema_restore_${BACKUP_DATE}
tar -xzf ${BACKUP_DIR}/schemas_${BACKUP_DATE}.tar.gz -C /tmp/schema_restore_${BACKUP_DATE} >> ${LOG_FILE} 2>&1

# スキーマの削除と再作成
psql -U postgres -d ${DB_NAME} -c "DROP SCHEMA IF EXISTS ${SCHEMA_NAME} CASCADE;" >> ${LOG_FILE} 2>&1
psql -U postgres -d ${DB_NAME} -c "CREATE SCHEMA ${SCHEMA_NAME};" >> ${LOG_FILE} 2>&1

# リストア実行
pg_restore -h localhost -U postgres -d ${DB_NAME} -n ${SCHEMA_NAME} -v /tmp/schema_restore_${BACKUP_DATE}/${BACKUP_DATE}/${SCHEMA_NAME}.dump >> ${LOG_FILE} 2>&1

# 一時ファイルの削除
rm -rf /tmp/schema_restore_${BACKUP_DATE}

# リストア結果の確認
if [ $? -eq 0 ]; then
    echo "Schema restore completed successfully for ${SCHEMA_NAME}" >> ${LOG_FILE}
    # アラート送信（成功）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"success\",\"type\":\"schema_restore\",\"schema\":\"${SCHEMA_NAME}\",\"date\":\"${BACKUP_DATE}\"}" http://monitoring-server/api/restore-status
else
    echo "Schema restore failed for ${SCHEMA_NAME}" >> ${LOG_FILE}
    # アラート送信（失敗）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"failed\",\"type\":\"schema_restore\",\"schema\":\"${SCHEMA_NAME}\",\"error\":\"Check log for details\"}" http://monitoring-server/api/restore-status
fi
```

### 3.4 AWS RDSでのリカバリ

#### 3.4.1 RDSスナップショットからのリストア

```bash
#!/bin/bash
# RDSスナップショットからのリストアスクリプト例

# 変数設定
SOURCE_SNAPSHOT=$1  # リストアするスナップショットIDを引数で指定
TARGET_INSTANCE=${SOURCE_SNAPSHOT}-restored
INSTANCE_CLASS=db.m6i.2xlarge
SUBNET_GROUP=ses-mgr-db-subnet
SECURITY_GROUP=ses-mgr-db-sg
LOG_FILE=/var/log/postgres/rds_restore_$(date +%Y%m%d_%H%M%S).log

# RDSインスタンスの復元
aws rds restore-db-instance-from-db-snapshot \
    --db-instance-identifier ${TARGET_INSTANCE} \
    --db-snapshot-identifier ${SOURCE_SNAPSHOT} \
    --db-instance-class ${INSTANCE_CLASS} \
    --db-subnet-group-name ${SUBNET_GROUP} \
    --vpc-security-group-ids ${SECURITY_GROUP} \
    --multi-az \
    --publicly-accessible \
    --no-auto-minor-version-upgrade >> ${LOG_FILE} 2>&1

# インスタンス作成状態の確認
echo "Waiting for RDS instance to be available..." >> ${LOG_FILE}
aws rds wait db-instance-available --db-instance-identifier ${TARGET_INSTANCE}

if [ $? -eq 0 ]; then
    # インスタンス情報の取得
    ENDPOINT=$(aws rds describe-db-instances --db-instance-identifier ${TARGET_INSTANCE} --query "DBInstances[0].Endpoint.Address" --output text)
    
    echo "RDS restore completed successfully. New instance endpoint: ${ENDPOINT}" >> ${LOG_FILE}
    # アラート送信（成功）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"success\",\"type\":\"rds_restore\",\"snapshot\":\"${SOURCE_SNAPSHOT}\",\"endpoint\":\"${ENDPOINT}\"}" http://monitoring-server/api/restore-status
else
    echo "RDS restore failed" >> ${LOG_FILE}
    # アラート送信（失敗）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"failed\",\"type\":\"rds_restore\",\"error\":\"Check log for details\"}" http://monitoring-server/api/restore-status
fi
```

#### 3.4.2 ポイントインタイムリカバリ（RDS）

```bash
#!/bin/bash
# RDSポイントインタイムリカバリスクリプト例

# 変数設定
SOURCE_INSTANCE=ses-mgr-prod
TARGET_INSTANCE=${SOURCE_INSTANCE}-pitr-$(date +%Y%m%d)
RECOVERY_TIME=$1  # リカバリ対象時刻を引数で指定（YYYY-MM-DDTHH:MM:SSZ形式）
INSTANCE_CLASS=db.m6i.2xlarge
SUBNET_GROUP=ses-mgr-db-subnet
SECURITY_GROUP=ses-mgr-db-sg
LOG_FILE=/var/log/postgres/rds_pitr_$(date +%Y%m%d_%H%M%S).log

# RDSインスタンスのポイントインタイムリカバリ
aws rds restore-db-instance-to-point-in-time \
    --source-db-instance-identifier ${SOURCE_INSTANCE} \
    --target-db-instance-identifier ${TARGET_INSTANCE} \
    --restore-time ${RECOVERY_TIME} \
    --db-instance-class ${INSTANCE_CLASS} \
    --db-subnet-group-name ${SUBNET_GROUP} \
    --vpc-security-group-ids ${SECURITY_GROUP} \
    --multi-az \
    --no-auto-minor-version-upgrade >> ${LOG_FILE} 2>&1

# インスタンス作成状態の確認
echo "Waiting for RDS instance to be available..." >> ${LOG_FILE}
aws rds wait db-instance-available --db-instance-identifier ${TARGET_INSTANCE}

if [ $? -eq 0 ]; then
    # インスタンス情報の取得
    ENDPOINT=$(aws rds describe-db-instances --db-instance-identifier ${TARGET_INSTANCE} --query "DBInstances[0].Endpoint.Address" --output text)
    
    echo "RDS PITR completed successfully to ${RECOVERY_TIME}. New instance endpoint: ${ENDPOINT}" >> ${LOG_FILE}
    # アラート送信（成功）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"success\",\"type\":\"rds_pitr\",\"target_time\":\"${RECOVERY_TIME}\",\"endpoint\":\"${ENDPOINT}\"}" http://monitoring-server/api/restore-status
else
    echo "RDS PITR failed" >> ${LOG_FILE}
    # アラート送信（失敗）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"failed\",\"type\":\"rds_pitr\",\"error\":\"Check log for details\"}" http://monitoring-server/api/restore-status
fi
```

### 3.5 障害復旧手順

#### 3.5.1 軽微な障害（サービス再起動）

1. 障害の確認と切り分け
2. PostgreSQLサービスの再起動
3. サービス状態の検証
4. 障害原因の調査と対策

```bash
#!/bin/bash
# PostgreSQLサービス再起動スクリプト例

# 変数設定
LOG_FILE=/var/log/postgres/service_restart_$(date +%Y%m%d_%H%M%S).log

# 現在のプロセス状態の記録
ps aux | grep postgres >> ${LOG_FILE} 2>&1

# PostgreSQLサービスの再起動
systemctl restart postgresql >> ${LOG_FILE} 2>&1

# 再起動結果の確認
if systemctl is-active postgresql > /dev/null; then
    echo "PostgreSQL service restarted successfully" >> ${LOG_FILE}
    # アラート送信（成功）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"success\",\"type\":\"service_restart\",\"timestamp\":\"$(date +%Y%m%d_%H%M%S)\"}" http://monitoring-server/api/service-status
else
    echo "PostgreSQL service restart failed" >> ${LOG_FILE}
    # アラート送信（失敗）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"failed\",\"type\":\"service_restart\",\"error\":\"Check log for details\"}" http://monitoring-server/api/service-status
fi

# サービス状態の検証
psql -U postgres -c "SELECT version();" >> ${LOG_FILE} 2>&1
psql -U postgres -c "SELECT count(*) FROM pg_stat_activity;" >> ${LOG_FILE} 2>&1
psql -U postgres -c "SELECT datname, numbackends FROM pg_stat_database;" >> ${LOG_FILE} 2>&1
```

#### 3.5.2 中程度の障害（部分的なデータ破損）

1. 障害の確認と切り分け
2. データベースの停止
3. 破損したテーブル/スキーマの特定
4. 論理バックアップからの選択的リストア
5. サービス状態の検証
6. 障害原因の調査と対策

#### 3.5.3 重大な障害（システム全体の復旧）

1. 障害の確認と切り分け
2. 災害復旧計画の発動
3. 復旧チームの召集
4. 代替サーバでのフルバックアップからのリストア
5. WALアーカイブを使用した最新状態への復旧
6. サービス状態の検証
7. DNSエントリの更新など、アクセスポイントの切り替え
8. 障害原因の調査と対策

## 4. バックアップ検証と訓練

### 4.1 定期的なバックアップ検証

バックアップデータの信頼性を確保するための定期的な検証プロセス。

```bash
#!/bin/bash
# バックアップ検証スクリプト例

# 変数設定
BACKUP_DIR=/backup/postgres/basebackups
VERIFY_DIR=/tmp/backup_verify
DB_NAME=ses_mgr
LOG_FILE=/var/log/postgres/backup_verify_$(date +%Y%m%d_%H%M%S).log

# 最新のバックアップファイルを特定
LATEST_BACKUP=$(ls -t ${BACKUP_DIR}/*.tar.gz | head -1)
BACKUP_BASENAME=$(basename ${LATEST_BACKUP})

echo "Verifying backup: ${BACKUP_BASENAME}" >> ${LOG_FILE}

# 検証用ディレクトリの作成
mkdir -p ${VERIFY_DIR} >> ${LOG_FILE} 2>&1

# バックアップファイルの展開
tar -xzf ${LATEST_BACKUP} -C ${VERIFY_DIR} >> ${LOG_FILE} 2>&1

# バックアップファイルの整合性確認
if [ $? -eq 0 ]; then
    echo "Backup file extraction successful" >> ${LOG_FILE}
    
    # PostgreSQLのpg_controldata検証（クラスタ情報の確認）
    pg_controldata ${VERIFY_DIR}/$(basename ${BACKUP_BASENAME} .tar.gz) >> ${LOG_FILE} 2>&1
    
    # サンプルデータの検証（論理バックアップからの抽出）
    # 検証用データベースの作成
    psql -U postgres -c "DROP DATABASE IF EXISTS verify_${DB_NAME};" >> ${LOG_FILE} 2>&1
    psql -U postgres -c "CREATE DATABASE verify_${DB_NAME};" >> ${LOG_FILE} 2>&1
    
    # 論理バックアップの作成と検証
    pg_dump -h localhost -U postgres -d ${DB_NAME} -t common.user -f ${VERIFY_DIR}/sample_table.dump >> ${LOG_FILE} 2>&1
    psql -U postgres -d verify_${DB_NAME} -f ${VERIFY_DIR}/sample_table.dump >> ${LOG_FILE} 2>&1
    
    # サンプルクエリの実行
    USER_COUNT=$(psql -U postgres -d verify_${DB_NAME} -t -c "SELECT COUNT(*) FROM common.user;")
    echo "Sample table verification - User count: ${USER_COUNT}" >> ${LOG_FILE}
    
    # 検証用データベースの削除
    psql -U postgres -c "DROP DATABASE verify_${DB_NAME};" >> ${LOG_FILE} 2>&1
    
    # 一時ファイルの削除
    rm -rf ${VERIFY_DIR}
    
    echo "Backup verification completed successfully" >> ${LOG_FILE}
    # アラート送信（成功）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"success\",\"type\":\"backup_verify\",\"file\":\"${BACKUP_BASENAME}\"}" http://monitoring-server/api/backup-status
else
    echo "Backup file extraction failed" >> ${LOG_FILE}
    # アラート送信（失敗）
    curl -X POST -H "Content-Type: application/json" -d "{\"status\":\"failed\",\"type\":\"backup_verify\",\"error\":\"Check log for details\"}" http://monitoring-server/api/backup-status
fi
```

### 4.2 復旧訓練の実施

定期的な復旧訓練によるリカバリ手順の検証と改善。

#### 4.2.1 訓練シナリオ

1. **テーブル誤削除シナリオ**
   - 特定のテーブルが誤って削除された想定
   - ポイントインタイムリカバリによる復旧手順の訓練
   - 復旧時間と手順の評価

2. **データベース破損シナリオ**
   - データベースファイルが破損した想定
   - フルバックアップからのリストア手順の訓練
   - WALリカバリの実施と評価

3. **災害復旧シナリオ**
   - 本番環境が完全に利用不可になった想定
   - DR環境でのフルリカバリ手順の訓練
   - サービス切り替えと検証手順の評価

#### 4.2.2 訓練スケジュール

- **テーブル誤削除シナリオ**: 四半期ごと（1月、4月、7月、10月）
- **データベース破損シナリオ**: 半年ごと（3月、9月）
- **災害復旧シナリオ**: 年1回（11月）

#### 4.2.3 訓練結果の評価と改善

- **復旧時間の測定**: 目標RTO/RPOとの比較
- **手順の評価**: 手順の明確さ、実行の容易さ、改善点の特定
- **ドキュメントの更新**: 訓練結果に基づくドキュメントの更新
- **自動化の改善**: 自動化可能なステップの特定と実装

## 5. 監視とアラート

### 5.1 バックアップ監視

バックアップジョブの実行状況と成功/失敗を監視するための設定。

#### 5.1.1 バックアップステータスの監視

```bash
#!/bin/bash
# バックアップステータス監視スクリプト例

# 変数設定
BACKUP_DIR=/backup/postgres
LOG_DIR=/var/log/postgres
ALERT_EMAIL=dba@example.com
NOW=$(date +%Y%m%d)
YESTERDAY=$(date -d "yesterday" +%Y%m%d)

# フルバックアップの確認
FULL_BACKUP_FILE=$(ls -1 ${BACKUP_DIR}/basebackups/*_${YESTERDAY}*.tar.gz 2>/dev/null)
if [ -z "${FULL_BACKUP_FILE}" ]; then
    echo "ALERT: Daily full backup is missing!" | mail -s "Backup Alert: Full Backup Missing" ${ALERT_EMAIL}
fi

# 差分バックアップ（WAL）の確認
WAL_FILES_COUNT=$(find ${BACKUP_DIR}/wal_archive -type f -name "*.gz" -mtime -1 | wc -l)
if [ ${WAL_FILES_COUNT} -lt 10 ]; then  # 通常は1日に数十ファイル以上が期待される
    echo "ALERT: WAL archive files count is low (${WAL_FILES_COUNT})!" | mail -s "Backup Alert: WAL Archive Issue" ${ALERT_EMAIL}
fi

# バックアップログのエラー確認
ERROR_COUNT=$(grep -i "error\|failed\|failure" ${LOG_DIR}/backup_${YESTERDAY}* | wc -l)
if [ ${ERROR_COUNT} -gt 0 ]; then
    echo "ALERT: Found ${ERROR_COUNT} errors in yesterday's backup logs!" | mail -s "Backup Alert: Errors in Logs" ${ALERT_EMAIL}
fi
```

#### 5.1.2 バックアップサイズとトレンドの監視

```bash
#!/bin/bash
# バックアップサイズ監視スクリプト例

# 変数設定
BACKUP_DIR=/backup/postgres
METRICS_FILE=/var/log/postgres/backup_metrics.csv
ALERT_EMAIL=dba@example.com

# 日付
TODAY=$(date +%Y-%m-%d)

# 各種バックアップディレクトリのサイズ計算
BASEBACKUP_SIZE=$(du -sm ${BACKUP_DIR}/basebackups | awk '{print $1}')
WAL_SIZE=$(du -sm ${BACKUP_DIR}/wal_archive | awk '{print $1}')
LOGICAL_SIZE=$(du -sm ${BACKUP_DIR}/logical | awk '{print $1}')
TOTAL_SIZE=$((BASEBACKUP_SIZE + WAL_SIZE + LOGICAL_SIZE))

# メトリクスファイルに記録
echo "${TODAY},${BASEBACKUP_SIZE},${WAL_SIZE},${LOGICAL_SIZE},${TOTAL_SIZE}" >> ${METRICS_FILE}

# 過去7日間の平均と比較
AVG_TOTAL=$(tail -7 ${METRICS_FILE} | awk -F, '{sum+=$5} END {print sum/7}')
GROWTH_PERCENT=$(echo "scale=2; ($TOTAL_SIZE - $AVG_TOTAL) * 100 / $AVG_TOTAL" | bc)

# 急激な増加があれば警告
if (( $(echo "$GROWTH_PERCENT > 20" | bc -l) )); then
    echo "ALERT: Backup size increased by ${GROWTH_PERCENT}% compared to 7-day average!" | mail -s "Backup Alert: Size Growth" ${ALERT_EMAIL}
fi

# 残りのディスク容量確認
DISK_FREE=$(df -m ${BACKUP_DIR} | awk 'NR==2 {print $4}')
DISK_FREE_PERCENT=$(df -h ${BACKUP_DIR} | awk 'NR==2 {print $5}' | tr -d '%')

if [ ${DISK_FREE_PERCENT} -gt 90 ]; then
    echo "ALERT: Backup disk is ${DISK_FREE_PERCENT}% full! Only ${DISK_FREE}MB free." | mail -s "Backup Alert: Disk Space Low" ${ALERT_EMAIL}
fi
```

### 5.2 リカバリ監視

リカバリプロセスの進行状況を監視するための設定。

```bash
#!/bin/bash
# リカバリ進行監視スクリプト例

# 変数設定
DB_NAME=ses_mgr
LOG_FILE=/var/log/postgres/recovery_monitor_$(date +%Y%m%d_%H%M%S).log
ALERT_EMAIL=dba@example.com

# リカバリ状態の確認
RECOVERY_STATUS=$(psql -U postgres -t -c "SELECT pg_is_in_recovery();")
if [ "${RECOVERY_STATUS}" = " t" ]; then
    echo "Database is in recovery mode..." >> ${LOG_FILE}
    
    # リカバリの進行状況を確認
    # PostgreSQL 12以降の場合
    RECOVERY_PROGRESS=$(psql -U postgres -t -c "SELECT CASE WHEN pg_is_wal_replay_paused() THEN 'paused' ELSE 'in progress' END AS status, pg_walfile_name(pg_last_wal_receive_lsn()) AS last_received, pg_walfile_name(pg_last_wal_replay_lsn()) AS last_replayed, pg_last_wal_receive_lsn() - pg_last_wal_replay_lsn() AS lag_bytes;")
    
    echo "Recovery progress: ${RECOVERY_PROGRESS}" >> ${LOG_FILE}
    
    # リカバリの進行が遅い場合や停止している場合はアラート
    LAG_BYTES=$(echo ${RECOVERY_PROGRESS} | awk '{print $NF}')
    if [ ${LAG_BYTES} -gt 1073741824 ]; then  # 1GBを超える遅延
        echo "ALERT: Recovery is lagging by ${LAG_BYTES} bytes (> 1GB)" | mail -s "Recovery Alert: Significant Lag" ${ALERT_EMAIL}
    fi
    
    # 長時間のリカバリチェック
    RECOVERY_START=$(stat -c %Y /var/lib/postgresql/data/recovery.signal 2>/dev/null || stat -c %Y /var/lib/postgresql/data/recovery.conf 2>/dev/null)
    NOW=$(date +%s)
    DURATION=$((NOW - RECOVERY_START))
    
    if [ ${DURATION} -gt 7200 ]; then  # 2時間以上
        echo "ALERT: Recovery has been running for $(( DURATION / 60 )) minutes" | mail -s "Recovery Alert: Long Duration" ${ALERT_EMAIL}
    fi
else
    echo "Database is not in recovery mode" >> ${LOG_FILE}
fi
```

## 6. モジュール別テーブル定義補足との関連

各業務モジュールの「テーブル定義補足」ドキュメントには、モジュール固有のバックアップ・リカバリ要件を記載する。本ドキュメントは全体方針と共通パターンを定義し、各モジュールの詳細は対応する補足ドキュメントを参照すること。