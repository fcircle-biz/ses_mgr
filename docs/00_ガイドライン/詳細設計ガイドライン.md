# SES業務システム 詳細設計ガイドライン

## 1. はじめに

### 1.1 目的

本ガイドラインは、SES業務システムの詳細設計フェーズにおいて、開発効率と保守性を高めるための設計アプローチを提供します。必要最小限のドキュメントと効果的な開発プラクティスを通じて、高品質なコードを効率的に開発するための指針となります。

### 1.2 適用範囲

本ガイドラインは、SES業務システムの全ての機能モジュールの詳細設計に適用されます。

### 1.3 基本方針

- **必要最小限のドキュメント**: 実装に直接必要な情報のみを文書化
- **コードファースト**: 詳細なロジックはコード自体と単体テストで表現
- **自動化の最大活用**: ドキュメント生成の自動化により鮮度を維持
- **統一パターンの採用**: 共通パターンを定義し、個別の再説明を省略
- **開発プラクティスによる品質担保**: 効率的なドキュメントでも品質を確保する方法論の導入

## 2. ドキュメント体系

### 2.1 必須ドキュメント

| ドキュメント | 目的 | 更新頻度 | 形式 | 保存場所 |
|------------|------|---------|------|---------|
| アーキテクチャ設計書 | システム全体の設計方針 | 初期作成後、主要変更時 | Markdown | `/docs/02_詳細設計/01_アーキテクチャ/` |
| モジュール設計書 | 機能モジュールの設計 | 機能実装時・主要変更時 | Markdown | `/docs/02_詳細設計/02_モジュール/` |
| API仕様書 | 外部公開APIの仕様 | 継続的に自動生成 | OpenAPI | `/docs/02_詳細設計/04_API/` |
| データベース設計補足 | 基本設計のDB定義に対する補足 | 必要に応じて | Markdown | `/docs/02_詳細設計/03_DB/` |
| アーキテクチャ決定記録 | 重要な設計決定の記録 | 設計決定時 | Markdown | `/docs/02_詳細設計/08_ADR/` |

### 2.2 オプションドキュメント

必要に応じて以下のドキュメントを作成します：

| ドキュメント | 作成判断基準 | 形式 | 保存場所 |
|------------|------------|------|---------|
| 重要処理フロー図 | 複雑なビジネスロジックを含む場合 | PlantUML/Mermaid | モジュール設計書内または別ファイル |
| セキュリティ実装詳細 | 高セキュリティ要件のある機能 | Markdown | `/docs/02_詳細設計/05_セキュリティ/` |
| パフォーマンス対策設計 | 性能要件が厳しい機能 | Markdown | `/docs/02_詳細設計/07_パフォーマンス/` |
| 外部連携設計 | 外部システムとの連携がある場合 | Markdown | `/docs/02_詳細設計/04_API/外部連携API.md` |

## 3. ドキュメントテンプレート

### 3.1 アーキテクチャ設計書 (アーキテクチャ概要.md)

```markdown
# SES業務システム アーキテクチャ設計書

## 1. 全体アーキテクチャ

### 1.1 アーキテクチャ概要
システム全体のアーキテクチャを図で表現し、簡潔に説明

### 1.2 レイヤー構成
- プレゼンテーション層（Thymeleaf）
- API層（Spring MVC）
- ビジネス層（Spring Service）
- データアクセス層（Spring Data JDBC）
- 共通基盤層（認証・認可、ロギングなど）

### 1.3 モジュール構成
- モジュール一覧と責務
- モジュール間の連携ポイント

## 2. 技術スタックと標準パターン

### 2.1 採用技術スタック
- バックエンド: Spring Boot 3.2.x, Java 21
- フロントエンド: Thymeleaf, Bootstrap
- データベース: PostgreSQL 17
- 開発環境: Docker, GitHub Actions

### 2.2 標準実装パターン
- レイヤードアーキテクチャの実装方針
- RESTful APIの設計原則
- データアクセスパターン
- 例外処理パターン

### 2.3 命名規則
- パッケージ名: com.example.sesapp.[モジュール名].[レイヤー名]
- クラス名: [機能名][レイヤー名]（例: EngineerController）
- メソッド名: 動詞 + 名詞（例: findById, createContract）
- 変数名: キャメルケース
- 定数名: 大文字スネークケース
- データベース: スネークケース

## 3. 共通機能

### 3.1 認証・認可
- Spring Securityを使用した認証基盤
- JWTによるステートレス認証の実装方針
- 権限管理の設計
- ロールベースアクセス制御（RBAC）の詳細

### 3.2 トランザクション管理
- トランザクション境界の方針
- 分散トランザクションの取り扱い

### 3.3 例外処理
- 例外クラス階層設計
- グローバル例外ハンドラーの実装
- エラーコード体系

### 3.4 ロギング
- ログレベルと出力方針
- 構造化ロギングの実装
- 監査ログの取り扱い

## 4. 非機能要件への対応

### 4.1 セキュリティ対策
- Spring Securityによる実装詳細
- JWT認証の実装詳細
- CSRF対策
- XSS対策
- SQLインジェクション対策

### 4.2 パフォーマンス対策
- キャッシュ戦略
- N+1問題への対応
- 大量データ処理の最適化

### 4.3 可用性確保
- 障害検知と自動復旧
- 冗長構成

## 5. 開発・テスト方針

### 5.1 開発環境構成
- 環境構成図
- ローカル開発環境のセットアップ

### 5.2 テスト戦略
- 単体テスト方針
- 統合テスト方針
- E2Eテスト方針
- 品質目標とカバレッジ基準

### 5.3 CI/CD
- ビルドパイプライン構成
- 品質ゲート
- デプロイ戦略

## 6. 参照情報
- 関連ドキュメントへのリンク
- 外部リソースへの参照
```

### 3.2 モジュール設計書 (技術者管理/技術者基本情報.md)

```markdown
# 技術者基本情報 詳細設計書

## 1. 概要

### 1.1 目的
技術者の基本情報を管理するための機能を提供する。技術者の登録、検索、詳細情報の閲覧、編集、削除などの基本的なCRUD操作を実現する。

### 1.2 機能範囲
- 技術者の基本情報登録・編集
- 技術者一覧表示と検索
- 技術者詳細表示
- 稼働状況管理
- 技術者情報のエクスポート/インポート

### 1.3 関連モジュール
- スキル管理モジュール：技術者のスキル情報を管理
- 契約管理モジュール：技術者の契約情報と連携
- マッチングモジュール：技術者情報をマッチングに活用

## 2. コンポーネント構成

### 2.1 コントローラー
- **EngineerController**
  - 責務：技術者情報のWeb APIエンドポイントを提供
  - エンドポイント：
    - GET /api/v1/engineers：技術者一覧取得
    - POST /api/v1/engineers：技術者新規登録
    - GET /api/v1/engineers/{id}：技術者詳細取得
    - PUT /api/v1/engineers/{id}：技術者情報更新
    - DELETE /api/v1/engineers/{id}：技術者削除

- **EngineerViewController**
  - 責務：技術者情報の画面表示用コントローラー
  - エンドポイント：
    - GET /engineers：技術者一覧画面
    - GET /engineers/new：技術者登録画面
    - GET /engineers/{id}：技術者詳細画面
    - GET /engineers/{id}/edit：技術者編集画面

### 2.2 サービス
- **EngineerService**
  - 責務：技術者情報に関するビジネスロジックを実装
  - 主要メソッド：
    - findAll()：全技術者取得
    - findById(id)：ID指定技術者取得
    - search(criteria)：検索条件に合致する技術者検索
    - create(engineerDto)：技術者新規作成
    - update(id, engineerDto)：技術者情報更新
    - delete(id)：技術者削除
  - トランザクション境界：各メソッドレベルでトランザクション設定

### 2.3 リポジトリ
- **EngineerRepository**
  - 責務：技術者エンティティのデータアクセス
  - 主要メソッド：
    - findAll()：全技術者取得
    - findById(id)：ID指定検索
    - findByNameContaining(name)：名前部分一致検索
    - findBySkills(skills)：スキル条件検索
    - findByAvailabilityDate(date)：稼働可能日検索
    - save(engineer)：保存/更新
    - delete(engineer)：削除

### 2.4 ドメインモデル/エンティティ
- **Engineer**
  - 属性：
    - id：技術者ID
    - firstName：名
    - lastName：姓
    - firstNameKana：名（カナ）
    - lastNameKana：姓（カナ）
    - email：メールアドレス
    - phoneNumber：電話番号
    - birthDate：生年月日
    - address：住所（Valueオブジェクト）
    - employmentStatus：雇用形態
    - joinedDate：入社日
    - yearsOfExperience：経験年数
    - isAvailable：稼働可能フラグ
    - nextAvailableDate：次回稼働可能日
    - monthlyRate：月額単価
    - skillSummary：スキル概要
    - createdAt：作成日時
    - updatedAt：更新日時
  - バリデーションルール：
    - 姓名：必須、最大100文字
    - メールアドレス：必須、メール形式、一意制約
    - 電話番号：必須、電話番号形式
    - 生年月日：必須、過去の日付

### 2.5 DTOとバリデーション
- **EngineerRequestDTO**
  - 技術者登録・更新リクエスト用DTO
  - バリデーション：@NotBlank、@Email、@Past等のアノテーション

- **EngineerResponseDTO**
  - 技術者情報レスポンス用DTO
  - Engineerエンティティの外部公開用データを整形

- **EngineerSearchDTO**
  - 技術者検索条件DTO
  - 検索パラメータをカプセル化

## 3. 主要処理フロー

### 3.1 技術者登録フロー
```
sequenceDiagram
    Client->>EngineerController: POST /api/v1/engineers
    EngineerController->>EngineerController: リクエスト検証
    EngineerController->>EngineerService: create(engineerDto)
    EngineerService->>EngineerService: DTOからエンティティへ変換
    EngineerService->>EngineerRepository: save(engineer)
    EngineerRepository-->>EngineerService: 保存結果
    EngineerService->>EngineerService: エンティティからDTOへ変換
    EngineerService-->>EngineerController: 登録結果
    EngineerController-->>Client: 201 Created レスポンス
```

- 新規技術者を登録する処理の流れ
- バリデーションエラー時は400 Bad Requestを返却
- メールアドレス重複時は409 Conflictを返却

### 3.2 技術者検索フロー
```
sequenceDiagram
    Client->>EngineerController: GET /api/v1/engineers?keyword=xxx
    EngineerController->>EngineerService: search(criteria)
    EngineerService->>EngineerRepository: 検索条件に応じたクエリ実行
    EngineerRepository-->>EngineerService: 検索結果
    EngineerService->>EngineerService: エンティティリストをDTOリストに変換
    EngineerService-->>EngineerController: 検索結果DTOリスト
    EngineerController-->>Client: 200 OK レスポンス
```

- 検索条件に基づいて技術者一覧を取得
- ページネーション対応（デフォルトページ = 0、サイズ = 20）
- 検索結果なしの場合は空リスト（204ではなく200を返却）

## 4. 特記事項

### 4.1 実装上の注意点
- 個人情報を扱うため、セキュリティに十分配慮する
- 大量データ取得時のパフォーマンスに注意
- スキル情報は関連エンティティとして別途管理

### 4.2 パフォーマンス考慮点
- 技術者一覧取得時はページネーションを適用
- 検索条件が複雑な場合はインデックス最適化
- 技術者詳細ページではスキル情報の遅延読み込み

### 4.3 テストの観点
- バリデーションのテストを重点的に実施
- 検索条件の複雑なパターンのテスト
- 大量データ時のパフォーマンステスト

## 5. 参照情報
- 基本設計書：[/docs/01_基本設計/UI設計/画面/技術者管理/ENG-001_技術者一覧画面.html](/docs/01_基本設計/UI設計/画面/技術者管理/ENG-001_技術者一覧画面.html)
- ADR：[/docs/02_詳細設計/08_ADR/adr-002-Spring-Data-JDBC採用.md](/docs/02_詳細設計/08_ADR/adr-002-Spring-Data-JDBC採用.md)
```

### 3.3 アーキテクチャ決定記録 (ADR) (adr-003-JWT認証採用.md)

```markdown
# ADR-003: RESTful APIにおけるJWT認証の採用

## ステータス
承認

## 作成日
YYYY-MM-DD

## 作成者
名前 (メールアドレス)

## コンテキスト
SES業務システムのRESTful API認証方式を決定する必要がある。システムはWebフロントエンドとモバイルアプリからアクセスされ、APIのステートレス性が求められる。また、マイクロサービスアーキテクチャから変更された単一モノリシックアプリケーションでの認証基盤として適切な方式を選定する必要がある。

考慮すべき点：
- セキュリティレベル：機密情報を扱うため、高いセキュリティが必要
- スケーラビリティ：負荷分散環境での動作に対応
- 開発効率：実装の容易さと保守性
- 現代的な認証方式の採用

## 決定
RESTful APIの認証にはJWT（JSON Web Token）を使用する。具体的な実装方針：

1. Spring Security＋JWTによる認証基盤の構築
2. アクセストークンとリフレッシュトークンの2種類のトークンを使用
3. アクセストークンの有効期限は30分
4. リフレッシュトークンの有効期限は2週間
5. HMAC SHA-256 (HS256) をトークン署名アルゴリズムとして使用
6. ペイロードには最小限の情報（ユーザーID、権限情報、発行時間、有効期限）のみを含める
7. トークンはHTTPヘッダーのAuthorizationフィールドで Bearer形式で送信

## 結果
この決定による影響と結果：

### メリット
- ステートレス性：サーバー側でセッション状態を保持する必要がない
- スケーラビリティ：負荷分散環境でも追加設定なしで動作可能
- クロスドメイン：異なるドメイン間でのAPI利用が容易
- モバイル互換性：モバイルアプリとの連携が容易
- 実装ライブラリ：Spring Securityとの統合が容易で実装が単純化

### デメリット
- トークン無効化：一度発行したトークンはサーバー側で直接無効化できない（ブラックリスト管理が必要）
- ペイロードサイズ：トークンに含める情報が増えるとサイズが大きくなる
- セキュリティリスク：トークン盗難時の影響範囲（対策として有効期限の短縮が必要）

### トレードオフ
- セキュリティと利便性のバランス：アクセストークンの有効期限を短くし、リフレッシュトークンで再取得する仕組みにすることで両立
- トークンサイズと情報量：必要最小限の情報だけをトークンに含めることでサイズを最適化

## 代替案
検討した他の選択肢：

### 1. セッションベース認証
- メリット：従来の手法で実装が容易、直接無効化可能
- デメリット：ステートフル性によりスケーリングが複雑化、モバイルアプリとの連携が煩雑
- 不採用理由：スケーラビリティとクロスプラットフォーム対応の制約

### 2. OAuth 2.0 / OpenID Connect (フル実装)
- メリット：標準化された堅牢な認証フレームワーク、フェデレーション認証に対応
- デメリット：実装の複雑さ、現時点での要件に対してオーバースペック
- 不採用理由：実装コストと複雑性が現在の要件に見合わない（将来的に拡張可能性あり）

### 3. API Key認証
- メリット：単純な実装、ヘッダーベース
- デメリット：キー管理の課題、権限の粒度管理が複雑
- 不採用理由：ユーザー認証とロールベースアクセス制御の要件を満たさない

## 参照情報
- [JWT公式ドキュメント](https://jwt.io/)
- [Spring Security JWT実装ガイド](https://spring.io/guides/tutorials/spring-security-and-angular-js/)
- [OWASP JWTセキュリティチートシート](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)
```

## 4. コード品質確保のための取り組み

効率的なドキュメントを採用しても高品質なコードを維持するため、以下の取り組みを実施します。

### 4.1 コーディング規約とツール

#### 4.1.1 コーディング規約

- Java: [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html)
- Kotlin: [Kotlin Coding Conventions](https://kotlinlang.org/docs/coding-conventions.html)
- SQL: プロジェクト独自のSQLスタイルガイド
- HTML/CSS/JavaScript: [Airbnbスタイルガイドをベースにカスタマイズしたもの]

#### 4.1.2 静的解析ツール

| ツール | 目的 | 使用方法 |
|-------|------|---------|
| SonarQube | コード品質分析（カバレッジ、重複、バグ、脆弱性など） | CI/CDパイプラインに組み込み、品質ゲートとして使用 |
| SpotBugs | Javaコードのバグパターン検出 | ビルド時に自動実行 |
| PMD | コード品質ルールチェック | ビルド時に自動実行 |
| Checkstyle | コードスタイルチェック | ビルド時に自動実行、IDEに設定として統合 |

#### 4.1.3 基準と閾値

- コードカバレッジ：80%以上（目標85%）
- 重複コード：5%未満
- 技術的負債比率：5%未満
- 未解決のバグ：重大度「High」以上は0件

### 4.2 コードレビュープロセス

#### 4.2.1 レビュー観点チェックリスト

- **機能性**
  - 仕様に準拠しているか
  - エッジケースが適切に処理されているか
  - エラー処理は適切か

- **可読性**
  - 命名は明確で理解しやすいか
  - コードは自己説明的か
  - 複雑なロジックには適切なコメントがあるか

- **パフォーマンス**
  - N+1問題はないか
  - インデックス設計は適切か
  - メモリ効率は考慮されているか

- **セキュリティ**
  - インジェクション攻撃への対策は講じられているか
  - Spring Securityの設定は適切か
  - JWT認証の実装は安全か
  - 機密情報の取り扱いは安全か

- **テスト可能性**
  - 単体テストは十分に書かれているか
  - テストのカバレッジは十分か
  - モックとスタブは適切に使用されているか

#### 4.2.2 レビュープロセス

1. 実装者はPull Requestを作成し、レビュー依頼
2. 少なくとも2名のレビュワーを指定
3. レビュワーはチェックリストに基づきレビュー
4. レビューコメントに対応
5. 全てのレビュアーの承認後、マージ可能に

### 4.3 テスト戦略

#### 4.3.1 テスト種別と責任範囲

| テスト種別 | 責任者 | 内容 | 目標 |
|----------|-------|------|------|
| 単体テスト | 開発者 | クラスやメソッドの機能検証 | カバレッジ80%以上 |
| 統合テスト | 開発者 | コンポーネント間連携の検証 | 主要フロー100%カバー |
| API テスト | 開発者 | 外部APIの動作検証 | 全APIエンドポイントをカバー |
| E2Eテスト | QA/開発者 | エンドツーエンドのビジネスフロー検証 | 重要業務フローをカバー |

#### 4.3.2 テストフレームワークと方法論

- JUnit 5: 単体テスト・統合テスト
- Mockito: モック作成
- RestAssured: APIテスト
- Playwright: E2Eテスト
- TestContainers: 統合テスト環境

#### 4.3.3 テスト実施のタイミング

- 単体テスト・統合テスト: 開発時に実装、コミット前に実行
- APIテスト: エンドポイント実装時に作成、PRマージ前に実行
- E2Eテスト: 機能実装完了時に実装、リリース前に実行

### 4.4 継続的な改善サイクル

- イテレーション終了時のコードメトリクスレビュー
- 四半期ごとのコード品質トレンド分析
- 発見された課題に基づくプロセス改善

## 5. 自動化と効率的なドキュメント管理

### 5.1 自動ドキュメント生成

| 対象 | 使用ツール | 生成タイミング |
|-----|-----------|-------------|
| APIドキュメント | Springdoc-OpenAPI | ビルド時、CI/CD時 |
| データベース設計 | SchemaSpyまたは同等ツール | DB変更後 |
| コードドキュメント | JavaDoc/KDoc | ビルド時 |
| コード品質レポート | SonarQube | CI/CD実行時 |

### 5.2 効率的なドキュメント管理

- Markdownを基本形式とし、Gitでバージョン管理
- 図表は可能な限りPlantUML/Mermaidで表現し、テキストとして管理
- リポジトリ内の`/docs/02_詳細設計`ディレクトリでドキュメントを管理
- 自動生成ドキュメントの公開先として専用のドキュメントポータルを構築

## 6. 詳細設計プロセス

### 6.1 詳細設計の手順

1. 基本設計の理解と要件確認
2. アーキテクチャ設計または既存設計の理解
3. モジュール設計書の作成
4. 設計レビュー実施
5. レビュー指摘事項の修正
6. 実装と設計の整合性確認（実装と並行）

### 6.2 詳細設計の作業分担

- アーキテクチャ設計: アーキテクトまたは技術リード
- モジュール設計: 担当開発者（ペア/モブでの設計を推奨）
- レビュー: 技術リードと他の開発者
- 自動生成ドキュメント整備: DevOps担当

### 6.3 詳細設計の成果物管理

- ドキュメントは同じリポジトリで管理し、コードと同じライフサイクルにする
- 変更はプルリクエストを通じて行い、レビューを実施
- 大規模な変更は設計変更書を作成し、承認を得る

## 7. フォルダ構成

「02_詳細設計」フォルダの構成は以下の通りです：

```
/docs/02_詳細設計/
│
├── 01_アーキテクチャ/                     # システム全体のアーキテクチャ設計
│   ├── アーキテクチャ概要.md              # 全体アーキテクチャの概要
│   ├── テクノロジースタック.md            # 採用技術一覧と詳細
│   ├── 標準設計パターン.md                # プロジェクト全体で採用する設計パターン
│   └── 共通ライブラリ設計.md              # 共通ライブラリの詳細設計
│
├── 02_モジュール/                        # 機能モジュール別の詳細設計
│   ├── 01_共通機能/                      # 共通機能モジュール
│   │   ├── 認証認可.md                   # 認証・認可機能の詳細設計
│   │   ├── ファイル管理.md                # ファイル管理機能の詳細設計
│   │   └── 通知機能.md                   # 通知機能の詳細設計
│   │
│   ├── 02_技術者管理/                    # 技術者管理モジュール
│   │   ├── 技術者基本情報.md              # 技術者基本情報機能の詳細設計
│   │   ├── スキル管理.md                  # スキル管理機能の詳細設計
│   │   └── 稼働状況管理.md                # 稼働状況管理機能の詳細設計
│   │
│   ├── 03_案件管理/                      # 案件管理モジュール
│   │   ├── 案件登録管理.md                # 案件登録管理機能の詳細設計
│   │   └── 案件検索.md                   # 案件検索機能の詳細設計
│   │
│   ├── 04_マッチング/                    # マッチングモジュール
│   │   ├── マッチングエンジン.md           # マッチングエンジン機能の詳細設計
│   │   └── 提案管理.md                   # 提案管理機能の詳細設計
│   │
│   ├── 05_契約管理/                      # 契約管理モジュール
│   │   ├── 契約基本機能.md                # 契約基本機能の詳細設計
│   │   └── 電子署名.md                   # 電子署名機能の詳細設計
│   │
│   ├── 06_勤怠工数管理/                  # 勤怠工数管理モジュール
│   │   ├── 勤怠管理.md                   # 勤怠管理機能の詳細設計
│   │   └── 工数承認.md                   # 工数承認機能の詳細設計
│   │
│   ├── 07_請求支払管理/                  # 請求支払管理モジュール
│   │   ├── 請求管理.md                   # 請求管理機能の詳細設計
│   │   └── 支払管理.md                   # 支払管理機能の詳細設計
│   │
│   └── 08_レポーティング/                # レポーティングモジュール
│       ├── ダッシュボード.md              # ダッシュボード機能の詳細設計
│       └── KPI分析.md                    # KPI分析機能の詳細設計
│
├── 03_DB/                               # データベース詳細設計
│   ├── テーブル定義補足/                  # 基本設計のテーブル定義に対する補足情報
│   │   ├── 01_共通.md                   # 共通テーブルの補足情報
│   │   ├── 02_技術者管理.md               # 技術者管理テーブルの補足情報
│   │   └── ...                         # 他のモジュールのテーブル補足情報
│   │
│   └── マイグレーション計画.md             # データベースマイグレーション計画
│
├── 04_API/                             # API詳細設計
│   ├── OpenAPI/                        # OpenAPIドキュメント
│   │   ├── 01_共通.yaml                 # 共通APIのOpenAPI定義
│   │   ├── 02_技術者管理.yaml             # 技術者管理APIのOpenAPI定義
│   │   └── ...                         # 他のモジュールのOpenAPI定義
│   │
│   ├── API概要.md                      # API設計の共通方針と概要
│   └── 外部連携API.md                   # 外部システム連携用API設計
│
├── 05_セキュリティ/                     # セキュリティ実装詳細
│   ├── 認証認可実装.md                   # 認証・認可機能の詳細実装設計
│   ├── 個人情報保護.md                   # 個人情報保護についての設計
│   └── セキュリティ対策一覧.md             # セキュリティ対策の一覧と実装方針
│
├── 06_テスト/                           # テスト設計
│   ├── テスト方針.md                     # テスト全体の方針
│   ├── 単体テスト計画.md                  # 単体テスト計画
│   ├── 統合テスト計画.md                  # 統合テスト計画
│   └── E2Eテスト計画.md                  # E2Eテスト計画
│
├── 07_パフォーマンス/                    # パフォーマンス対策設計
│   ├── 負荷対策.md                      # 負荷対策設計
│   └── キャッシュ戦略.md                  # キャッシュ戦略設計
│
├── 08_ADR/                             # アーキテクチャ決定記録
│   ├── adr-001-レイヤードアーキテクチャ採用.md  # ADR: レイヤードアーキテクチャの採用
│   ├── adr-002-Spring-Data-JDBC採用.md   # ADR: Spring Data JDBCの採用
│   ├── adr-003-JWT認証採用.md             # ADR: JWT認証の採用
│   └── ...                             # その他のADR
│
├── 09_運用/                             # 運用設計
│   ├── 監視設計.md                       # 監視設計
│   ├── バックアップ計画.md                 # バックアップ計画
│   └── 障害復旧計画.md                    # 障害復旧計画
│
├── templates/                           # ドキュメントテンプレート
│   ├── module_template.md               # モジュール設計書テンプレート
│   ├── adr_template.md                  # ADRテンプレート
│   └── table_definition_template.md     # テーブル定義補足テンプレート
│
└── index.md                             # 詳細設計書のインデックス・目次
```

## 8. 参考資料

- [Spring Framework Documentation](https://docs.spring.io/spring-framework/docs/current/reference/html/)
- [Spring Boot Documentation](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/)
- [Spring Security Reference](https://docs.spring.io/spring-security/reference/index.html)
- [Spring Data JDBC Reference](https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/)
- [JWT.io](https://jwt.io/)
- [PlantUML](https://plantuml.com/)
- [Mermaid Live Editor](https://mermaid.live/)

## 付録A: Spring Security + JWT実装パターン

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Autowired
    private JwtTokenProvider jwtTokenProvider;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()  // RESTful APIでは通常無効化
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .authorizeHttpRequests(authorize -> authorize
                .requestMatchers("/api/v1/auth/**").permitAll()
                .requestMatchers("/api/v1/public/**").permitAll()
                .requestMatchers("/api/v1/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .addFilterBefore(new JwtAuthenticationFilter(jwtTokenProvider), 
                UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    // その他の設定...
}
```

## 付録B: 用語集

- **ADR**: Architecture Decision Record（アーキテクチャ決定記録）
- **DTO**: Data Transfer Object（データ転送オブジェクト）
- **E2E**: End to End（エンドツーエンド）
- **CI/CD**: Continuous Integration/Continuous Delivery（継続的統合/継続的デリバリー）
- **JWT**: JSON Web Token（JSONウェブトークン）
- **RBAC**: Role-Based Access Control（ロールベースのアクセス制御）