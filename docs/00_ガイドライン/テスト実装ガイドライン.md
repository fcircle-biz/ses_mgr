# テスト実装ガイドライン

このガイドラインは、SES管理システムのテスト実装における標準とベストプラクティスを定義します。適切なテストを実装することで、コードの品質を確保し、リグレッションを防止します。

## 目次

1. [テストの基本方針](#1-テストの基本方針)
2. [テスト種別](#2-テスト種別)
3. [単体テスト実装ガイドライン](#3-単体テスト実装ガイドライン)
4. [統合テスト実装ガイドライン](#4-統合テスト実装ガイドライン)
5. [E2Eテスト実装ガイドライン](#5-e2eテスト実装ガイドライン)
6. [テストデータ管理](#6-テストデータ管理)
7. [テストカバレッジ](#7-テストカバレッジ)
8. [テスト実装チェックリスト](#8-テスト実装チェックリスト)

## 1. テストの基本方針

### 1.1 テストの目的

- バグの早期発見と防止
- 設計品質の向上
- リファクタリングの安全性確保
- 要件の確実な実装
- ドキュメントとしての役割

### 1.2 テスト実装の原則

- **テストの独立性**: 各テストは他のテストに依存せず、独立して実行可能であること
- **繰り返し実行可能**: 何度実行しても同じ結果が得られること
- **自己完結性**: テストは自動的に結果を検証し、手動確認を必要としないこと
- **実行速度**: テストは可能な限り高速に実行できること
- **メンテナンス性**: テストコードも製品コードと同様に保守性を考慮すること

### 1.3 テストファーストの推奨

- 可能な限りテストファースト開発（TDD）を推奨
- テストを先に書くことで、設計の改善とインターフェースの明確化を促進
- レッド・グリーン・リファクタリングのサイクルを意識

## 2. テスト種別

SES管理システムでは、次の3種類のテストを実装します：

### 2.1 単体テスト

- **対象**: クラス、メソッドレベルの機能
- **ツール**: JUnit 5, Mockito
- **フォーカス**: ロジックの正確性、エッジケース、例外処理
- **依存関係**: モックまたはスタブを使用して分離

### 2.2 統合テスト

- **対象**: 複数のコンポーネントやレイヤー間の連携
- **ツール**: Spring Boot Test, TestContainers
- **フォーカス**: コンポーネント間のインタラクション、DB連携
- **依存関係**: 実際のコンポーネントやテスト用のDBを使用

### 2.3 E2Eテスト

- **対象**: エンドツーエンドの機能、ユーザーストーリー
- **ツール**: Playwright
- **フォーカス**: ユーザーシナリオ、UI機能、主要業務フロー
- **依存関係**: 実際のアプリケーションとテスト環境を使用

## 3. 単体テスト実装ガイドライン

### 3.1 単体テストの命名規則

```
[テスト対象メソッド名]_[テスト条件]_[期待される結果]
```

例：
- `findById_存在するID_エンジニア情報が返される`
- `createEngineer_無効なデータ_例外が発生する`

または、BDDスタイルで：

```
[given]_[when]_[then]
```

例：
- `有効なエンジニアデータが与えられた場合_作成処理を実行すると_エンジニアIDが返される`

### 3.2 テストクラスの構造

- テストクラス名は `[クラス名]Test` とする
- テストクラスは対象クラスと同じパッケージに配置
- @TestInstanceのライフサイクルはper-methodを基本とする

```java
@ExtendWith(MockitoExtension.class)
class EngineerServiceTest {

    @Mock
    private EngineerRepository engineerRepository;
    
    @InjectMocks
    private EngineerServiceImpl engineerService;
    
    @Test
    void findById_存在するID_エンジニア情報が返される() {
        // Setup / Arrange
        when(engineerRepository.findById(1L)).thenReturn(Optional.of(new Engineer(1L, "山田太郎")));
        
        // Exercise / Act
        Optional<Engineer> result = engineerService.findById(1L);
        
        // Verify / Assert
        assertTrue(result.isPresent());
        assertEquals("山田太郎", result.get().getName());
        verify(engineerRepository).findById(1L);
    }
}
```

### 3.3 テストの構造

テストは「AAA（Arrange-Act-Assert）」または「Given-When-Then」パターンで構造化する：

- **Arrange（Given）**: テストの前提条件を設定
- **Act（When）**: テスト対象の処理を実行
- **Assert（Then）**: 期待される結果を検証

### 3.4 モックの使用方法

- 外部依存（DB、API、ファイル）はモックまたはスタブで置き換える
- モックは必要最小限にとどめる
- テスト対象のクラス内のprivateメソッドはモックしない
- Mockitoを使用したモックオブジェクトの作成例：

```java
// リポジトリをモック化
@Mock
private EngineerRepository engineerRepository;

// モックの振る舞いを定義
when(engineerRepository.findById(anyLong())).thenReturn(Optional.of(new Engineer()));

// モックの呼び出しを検証
verify(engineerRepository, times(1)).save(any(Engineer.class));
```

### 3.5 テストケースの種類

各メソッドに対して最低限以下のテストケースを実装：

1. **正常系テスト**: 正常な入力での期待通りの動作
2. **境界値テスト**: 入力値の境界での動作
3. **異常系テスト**: 不正な入力での例外処理
4. **エッジケーステスト**: 特殊な条件での動作

### 3.6 検証方法

- JUnit 5のアサーションメソッドを使用
- 複雑なオブジェクトの検証にはAssertJを活用
- 例外検証には`assertThrows`を使用

```java
// 基本的な値の検証
assertEquals(expected, actual);
assertTrue(condition);

// コレクション要素の検証
assertThat(list).hasSize(3).contains("item1", "item2");

// 例外の検証
BusinessException exception = assertThrows(BusinessException.class, () -> {
    service.performAction(invalidData);
});
assertEquals("Invalid data", exception.getMessage());
```

## 4. 統合テスト実装ガイドライン

### 4.1 統合テストの範囲

- コントローラーとサービスの連携
- サービスとリポジトリの連携
- データベースアクセスの検証
- キャッシュ機能の検証
- トランザクション管理の検証

### 4.2 テスト環境

- Spring Boot Testを使用したテスト環境の構築
- TestContainersを使用した実際のDBMSの利用
- テスト用プロファイルの活用

```java
@SpringBootTest
@ActiveProfiles("test")
@Testcontainers
class EngineerServiceIntegrationTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:14.4")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");

    @DynamicPropertySource
    static void registerPgProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    private EngineerService engineerService;

    @Autowired
    private EngineerRepository engineerRepository;

    @BeforeEach
    void setup() {
        // テストデータのセットアップ
    }

    @Test
    void データベースとの連携テスト() {
        // テストコード
    }
}
```

### 4.2.1 PostgreSQLのUUID型の扱い

PostgreSQLのUUID型を使用する場合、JDBCテンプレートで以下の点に注意が必要です：

- UUIDを使用するSQLクエリでは明示的な型キャストが必要
- 特にリポジトリテストではこの点に注意する

```java
// JdbcTemplate使用時の正しいSQLクエリ例
@Test
void findById_存在するID_データが返される() {
    // UUID型のパラメータを渡す際は明示的にキャスト
    String sql = "SELECT * FROM schema.table WHERE id = CAST(? AS UUID)";
    jdbcTemplate.queryForObject(sql, rowMapper, uuid.toString());
    
    // 誤った方法（型変換エラーになる）
    // String sql = "SELECT * FROM schema.table WHERE id = ?";
}
```

### 4.3 トランザクション管理

- `@Transactional`を使用したテストデータのロールバック
- 必要に応じて`@Commit`を使用してデータを永続化

### 4.4 スライスドテスト

全体の統合テストだけでなく、特定の層に焦点を当てたスライスドテストも実装：

- `@WebMvcTest`: コントローラー層のテスト
- `@DataJdbcTest`: データアクセス層のテスト
- `@ServiceTest`: サービス層のテスト

```java
@WebMvcTest(EngineerController.class)
class EngineerControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private EngineerService engineerService;

    @Test
    void getEngineerById_正常系() throws Exception {
        when(engineerService.findById(1L)).thenReturn(Optional.of(new Engineer(1L, "山田太郎")));

        mockMvc.perform(get("/api/engineers/1"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.id").value(1))
            .andExpect(jsonPath("$.name").value("山田太郎"));
    }
}
```

## 5. E2Eテスト実装ガイドライン

### 5.1 E2Eテストの対象

- 主要なユーザーストーリー
- クリティカルな業務フロー
- UI要素とインタラクション

### 5.2 Playwrightの使用

- Playwrightを使用したブラウザテストの実装
- 複数のブラウザでのテスト（Chrome, Firefox, Safari）
- ヘッドレスモードでのテスト実行

```java
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class EngineerE2ETest {

    private Browser browser;
    private BrowserContext context;
    private Page page;

    @BeforeAll
    void launchBrowser() {
        browser = Playwright
            .create()
            .chromium()
            .launch(new BrowserType.LaunchOptions().setHeadless(true));
    }

    @BeforeEach
    void createContextAndPage() {
        context = browser.newContext();
        page = context.newPage();
    }

    @AfterEach
    void closeContext() {
        context.close();
    }

    @AfterAll
    void closeBrowser() {
        browser.close();
    }

    @Test
    void エンジニア登録フロー() {
        page.navigate("http://localhost:8080/login");
        page.fill("#username", "admin");
        page.fill("#password", "password");
        page.click("button[type=submit]");
        
        // ダッシュボードが表示されることを確認
        page.waitForSelector("h1:has-text('ダッシュボード')");
        
        // エンジニア登録ページに移動
        page.click("text=技術者管理");
        page.click("text=新規登録");
        
        // フォームに入力
        page.fill("#name", "新規エンジニー");
        page.fill("#email", "engineer@example.com");
        page.selectOption("#skillLevel", "中級者");
        page.click("#submit");
        
        // 登録成功メッセージの確認
        page.waitForSelector("text=技術者を登録しました");
    }
}
```

### 5.3 テストシナリオの設計

- ユーザーストーリーに基づくテストシナリオの作成
- ハッピーパスだけでなく、代替フローもテスト
- データの準備と事後クリーンアップ

### 5.4 テスト環境の分離

- テスト専用の環境を用意
- テスト用のデータセットを準備
- CI/CDパイプラインでの自動実行

## 6. テストデータ管理

### 6.1 テストデータの原則

- テストは自己完結的であるべき
- 各テストは独自のテストデータを準備
- グローバルな状態への依存を避ける

### 6.2 テストデータの準備方法

#### 6.2.1 単体テスト

- テストメソッド内でテストデータを作成
- テストファクトリーメソッドを活用
- モックデータの使用

```java
// テストファクトリーメソッド
private Engineer createTestEngineer(Long id, String name) {
    Engineer engineer = new Engineer();
    engineer.setId(id);
    engineer.setName(name);
    engineer.setEmail(name + "@example.com");
    return engineer;
}
```

#### 6.2.2 統合テスト

- `@BeforeEach`でのデータセットアップ
- TestContainersを使用したDBの初期化
- SQLスクリプトを用いたデータロード

```java
@Sql({"/schema.sql", "/test-data.sql"})
@Test
void データベーステスト() {
    // テストコード
}
```

#### 6.2.2.1 データベーステスト用のSQL対策

テスト用の初期化SQLスクリプトでは、以下の点に注意します：

- スキーマが確実に作成されるようエラーハンドリングを追加
- 依存関係やテーブル順を考慮した初期化
- クリーンアップスクリプトの用意

```sql
-- スキーマ作成（エラーハンドリング付き）
DO $$
BEGIN
    -- スキーマが既に存在しても、エラーを出さずにスキップ
    DROP SCHEMA IF EXISTS schema_name CASCADE;
    
    -- スキーマ作成
    BEGIN
        CREATE SCHEMA schema_name;
        RAISE NOTICE 'Successfully created the schema';
    EXCEPTION WHEN OTHERS THEN
        RAISE NOTICE 'Failed to create the schema: %', SQLERRM;
    END;
END $$;

-- テーブル作成
CREATE TABLE schema_name.table_name (
    id UUID PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    -- 他のカラム
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

#### 6.2.3 E2Eテスト

- テスト前のAPIコールでデータセットアップ
- テスト用の管理画面を用意
- 外部システムのモック

### 6.3 テストデータクリーンアップ

- `@AfterEach`でのデータクリーンアップ
- トランザクションのロールバック
- テスト用DBのリセット

## 7. テストカバレッジ

### 7.1 カバレッジ目標

- 単体テスト: 80%以上のコードカバレッジ
- 統合テスト: 主要なコンポーネント連携をカバー
- E2Eテスト: すべての主要業務フローをカバー

### 7.2 カバレッジの計測

- JaCoCoを使用したコードカバレッジの計測
- ビルドプロセスに統合されたカバレッジレポート

```gradle
jacocoTestReport {
    reports {
        xml.required = true
        html.required = true
    }
}

test {
    finalizedBy jacocoTestReport
}
```

### 7.3 カバレッジ除外

以下のコードは、カバレッジ計測から除外可能：

- 自動生成されたコード（Getter/Setter, toString()など）
- 設定クラス
- 単純なDTO（データ転送オブジェクト）
- フレームワークが直接呼び出すコード

## 8. テスト実装チェックリスト

各テスト実装時に以下のチェックリストを使用して品質を確保します。

### 8.1 単体テストチェックリスト

- [ ] テストクラスとメソッドの命名は規約に従っているか
- [ ] テストケースは「AAA」パターンで構造化されているか
- [ ] 外部依存はモックに置き換えられているか
- [ ] すべての条件分岐がテストでカバーされているか
- [ ] 正常系、異常系、境界値のテストが含まれているか
- [ ] テストは独立して実行可能か
- [ ] アサーションは適切か（何を検証しているか明確か）
- [ ] テストは高速に実行可能か
- [ ] テストコードは読みやすく保守性が高いか

### 8.2 統合テストチェックリスト

- [ ] テスト環境が適切に設定されているか
- [ ] コンポーネント間のインタラクションが検証されているか
- [ ] データベースとの連携が適切にテストされているか
- [ ] トランザクション管理が適切にテストされているか
- [ ] キャッシュ機能が検証されているか
- [ ] テストデータの準備とクリーンアップが適切か
- [ ] エラーケースが考慮されているか

### 8.3 E2Eテストチェックリスト

- [ ] 主要なユーザーフローがカバーされているか
- [ ] UI要素とインタラクションが検証されているか
- [ ] 異なるブラウザでのテストが考慮されているか
- [ ] パフォーマンスへの影響が最小限に抑えられているか
- [ ] テストは安定して実行可能か
- [ ] 環境依存が適切に管理されているか
- [ ] スクリーンショットやビデオ記録が必要に応じて設定されているか

このガイドラインとチェックリストを活用して、SES管理システムの品質を確保するための効果的なテストを実装しましょう。テストは単なるバグ発見のツールではなく、仕様を明確にし、安全なリファクタリングを可能にする重要な資産です。