# SES業務システム 国際化・多言語対応機能 基本設計書

## 1. はじめに

本書は、SES業務システムにおける国際化・多言語対応機能の基本設計を定義したものである。
日本語および英語を主要言語とし、将来的な多言語展開も視野に入れた、メッセージ、日付、数値などの
適切なローカライズを実現するための基盤的な共通機能について記述する。

## 2. 機能概要

国際化・多言語対応機能は、ユーザーが設定した言語環境や地域設定に応じて、適切な表示言語や
書式でシステムを利用できるようにする基盤的な共通機能である。テキストメッセージの翻訳だけでなく、
日付、時刻、数値、通貨などの表示形式もローカライズすることで、様々な地域・言語のユーザーに
対応可能なシステムを提供する。

## 3. 国際化・多言語対応機能設計

### 3.1 機能構成

国際化・多言語対応機能は以下のサブ機能で構成される：

1. **ロケール管理**: ユーザーのロケール（言語・地域）設定の管理
2. **メッセージ多言語化**: 画面表示テキストの多言語対応
3. **フォーマット制御**: 日付、時刻、数値、通貨のローカライズ
4. **コンテンツ多言語化**: データベース内コンテンツの多言語対応
5. **ローカライズリソース管理**: 翻訳リソースの管理と更新

### 3.2 対応言語・ロケール

以下の言語・ロケールに対応する：

| 言語 | ロケール | 優先度 | 備考 |
|------|---------|--------|------|
| 日本語 | ja_JP | 高（第一言語） | システムのデフォルト言語 |
| 英語 | en_US | 高 | 第二言語として完全対応 |
| 中国語（簡体字） | zh_CN | 中 | 将来対応予定 |
| 中国語（繁体字） | zh_TW | 中 | 将来対応予定 |
| 韓国語 | ko_KR | 中 | 将来対応予定 |

### 3.3 ロケール管理機能

#### 3.3.1 ロケール解決方式

ユーザーのロケールを特定する方法として、以下の方式を優先順に採用する：

1. **ユーザー設定**: ユーザーがシステム内で明示的に選択した言語設定
2. **セッション設定**: 現在のセッションに保存されているロケール情報
3. **Cookie**: ユーザーのブラウザに保存されたロケール設定Cookie
4. **Accept-Language**: ブラウザから送信されるAccept-Languageヘッダー
5. **デフォルト設定**: システムのデフォルトロケール（ja_JP）

#### 3.3.2 ロケール切り替え

ユーザーがロケールを切り替える方法：

1. **UI上の言語セレクター**: ヘッダー部分に表示する言語選択ドロップダウン
2. **マイページの設定**: ユーザー設定画面での言語設定
3. **URLパラメータ**: `?lang=en`のようなURLパラメータによる一時的な切り替え

#### 3.3.3 ロケール情報の保存

ロケール情報の保存方法：

1. **ユーザー設定**: ログインユーザーの場合、ユーザープロファイルに保存
2. **セッション**: 現在のセッションに保存
3. **Cookie**: 永続的な設定として、ブラウザCookieに保存（有効期限1年）

### 3.4 メッセージ多言語化機能

#### 3.4.1 メッセージリソース管理

各言語のメッセージを管理するリソースファイルを使用する：

```
/resources/i18n/messages_ja.properties
/resources/i18n/messages_en.properties
/resources/i18n/validation_ja.properties
/resources/i18n/validation_en.properties
/resources/i18n/errors_ja.properties
/resources/i18n/errors_en.properties
```

#### 3.4.2 メッセージカテゴリ

メッセージを以下のカテゴリに分類して管理する：

1. **messages**: 一般的なUI表示用メッセージ
2. **validation**: 入力検証用メッセージ
3. **errors**: エラーメッセージ
4. **emails**: メール通知用テンプレート
5. **labels**: ラベル、ボタン、メニュー項目名
6. **help**: ヘルプテキスト

#### 3.4.3 メッセージキー命名規則

メッセージキーは以下の命名規則に従う：

```
{モジュール}.{サブモジュール}.{要素タイプ}.{識別子}
```

例:
- `common.button.save`: 共通の保存ボタンテキスト
- `project.list.title`: 案件一覧画面のタイトル
- `engineer.form.skill.required`: 技術者スキル入力の必須エラーメッセージ
- `error.validation.required`: 汎用的な必須入力エラーメッセージ

#### 3.4.4 メッセージパラメータ

メッセージ中の動的な部分には、番号付きプレースホルダーを使用する：

```properties
# 日本語リソース (messages_ja.properties)
project.assigned.success=技術者 {0} を案件 {1} にアサインしました。

# 英語リソース (messages_en.properties)
project.assigned.success=Engineer {0} has been assigned to project {1}.
```

#### 3.4.5 複数形対応

英語などの複数形がある言語では、複数形メッセージにも対応する：

```properties
# 英語リソース (messages_en.properties)
project.count.single=There is {0} project.
project.count.plural=There are {0} projects.
```

### 3.5 フォーマット制御機能

#### 3.5.1 日付・時刻のフォーマット

各ロケールに応じた日付・時刻表示：

| フォーマット種別 | 日本語 (ja_JP) | 英語 (en_US) |
|----------------|--------------|--------------|
| 短い日付 | 2025/05/05 | 5/5/2025 |
| 中程度の日付 | 2025年5月5日 | May 5, 2025 |
| 長い日付 | 2025年5月5日(月) | Monday, May 5, 2025 |
| 短い時刻 | 14:30 | 2:30 PM |
| 長い時刻 | 14時30分45秒 | 2:30:45 PM |
| 日時 | 2025/05/05 14:30 | 5/5/2025 2:30 PM |

#### 3.5.2 数値のフォーマット

各ロケールに応じた数値表示：

| フォーマット種別 | 日本語 (ja_JP) | 英語 (en_US) |
|----------------|--------------|--------------|
| 整数 | 1,234 | 1,234 |
| 小数 | 1,234.56 | 1,234.56 |
| パーセント | 12.34% | 12.34% |
| 通貨 | ¥1,234 | $1,234 |

#### 3.5.3 フォーマットユーティリティ

以下のフォーマットユーティリティを提供する：

1. **日付フォーマッター**: 日付・時刻の変換と表示
2. **数値フォーマッター**: 数値の変換と表示
3. **通貨フォーマッター**: 通貨金額の変換と表示
4. **パターンフォーマッター**: カスタムパターンによる書式化

```java
// 使用例
public class FormatExample {
    @Autowired
    private FormatService formatService;
    
    public void displayFormattedValues(Locale locale) {
        // 日付フォーマット
        LocalDate date = LocalDate.of(2025, 5, 5);
        String shortDate = formatService.formatDate(date, FormatStyle.SHORT, locale);
        String mediumDate = formatService.formatDate(date, FormatStyle.MEDIUM, locale);
        String longDate = formatService.formatDate(date, FormatStyle.LONG, locale);
        
        // 時刻フォーマット
        LocalTime time = LocalTime.of(14, 30, 45);
        String shortTime = formatService.formatTime(time, FormatStyle.SHORT, locale);
        String mediumTime = formatService.formatTime(time, FormatStyle.MEDIUM, locale);
        
        // 数値フォーマット
        double number = 1234.56;
        String formattedNumber = formatService.formatNumber(number, locale);
        String formattedPercent = formatService.formatPercent(0.1234, locale);
        
        // 通貨フォーマット
        BigDecimal amount = new BigDecimal("1234.56");
        String formattedCurrency = formatService.formatCurrency(amount, locale);
    }
}
```

### 3.6 コンテンツ多言語化機能

#### 3.6.1 データベースの多言語対応

以下の2つのアプローチを用途に応じて使い分ける：

1. **リソーステーブル方式**: 言語ごとのリソーステーブルを持つ

```
// マスタテーブル
project_status (
  id INT PRIMARY KEY,
  code VARCHAR(20) UNIQUE
)

// 多言語リソーステーブル
project_status_resource (
  status_id INT,
  locale VARCHAR(10),
  name VARCHAR(50),
  description VARCHAR(200),
  PRIMARY KEY (status_id, locale),
  FOREIGN KEY (status_id) REFERENCES project_status(id)
)
```

2. **JSONカラム方式**: 単一テーブル内でJSON形式の多言語データを持つ

```
project_status (
  id INT PRIMARY KEY,
  code VARCHAR(20) UNIQUE,
  name JSONB, -- {"ja": "進行中", "en": "In Progress"}
  description JSONB -- {"ja": "プロジェクトが現在進行中です", "en": "The project is currently in progress"}
)
```

#### 3.6.2 多言語コンテンツの取得

多言語コンテンツを取得するためのユーティリティサービス：

```java
// 多言語コンテンツ取得インターフェース
public interface LocalizedContentService {
    <T> T getLocalizedEntity(T entity, Locale locale);
    String getLocalizedField(Object jsonValue, Locale locale);
    List<T> getLocalizedEntities(List<T> entities, Locale locale);
    Map<String, String> getAvailableTranslations(Object jsonValue);
}
```

### 3.7 ローカライズリソース管理

#### 3.7.1 リソース追加・更新プロセス

翻訳リソースの管理プロセス：

1. **リソース抽出**: ソースコードからメッセージキーを抽出
2. **未翻訳検出**: 既存リソースと比較して未翻訳キーを検出
3. **翻訳作業**: 各言語の担当者による翻訳作業
4. **品質レビュー**: 翻訳内容の品質レビュー
5. **リソース更新**: 新しい翻訳の適用とデプロイ

#### 3.7.2 リソースファイル管理ツール

リソースファイル管理のためのツールを提供：

1. **未翻訳キー検出ツール**: 未翻訳のキーを検出するツール
2. **重複キー検出ツール**: 重複するキーを検出するツール
3. **未使用キー検出ツール**: ソースコードで使用されていないキーを検出するツール
4. **リソース統計ツール**: 翻訳カバレッジを確認するツール

## 4. UI設計

### 4.1 言語切り替えUI

#### 4.1.1 言語セレクター

ヘッダーに表示する言語セレクターの設計：

* **位置**: ヘッダー右上部
* **表示形式**: 言語名またはフラグアイコン
* **選択方法**: ドロップダウンメニュー

#### 4.1.2 ユーザー設定画面

マイページ内の言語設定セクション：

* **設定項目**:
  - 表示言語選択
  - 日付フォーマット選択
  - 時刻フォーマット選択
  - 数値フォーマット選択
  - タイムゾーン選択

#### 4.1.3 多言語コンテンツ入力

多言語コンテンツを入力するためのUI：

* **タブ方式**: 言語ごとにタブで切り替えて入力
* **インライン方式**: 言語ごとの入力フィールドを並べて表示
* **プレビュー**: 各言語での表示プレビュー機能

### 4.2 国際化対応の考慮点

#### 4.2.1 レイアウト対応

異なる言語間でのレイアウト互換性：

1. **テキスト長の違い**: 英語は日本語より文字列長が平均20〜50%長くなる可能性
2. **文字サイズ**: 異なる言語での表示サイズの違い
3. **書字方向**: 将来的な右から左への書字方向（RTL）対応の考慮

#### 4.2.2 フォント対応

複数言語のフォント対応：

1. **マルチリンガルフォント**: 複数言語のグリフをサポートするフォント選定
2. **フォントフォールバック**: 代替フォントの定義
3. **ウェブフォント**: 必要な言語のみ動的にロードするウェブフォントの活用

## 5. API設計

### 5.1 ロケール管理API

| エンドポイント | メソッド | 説明 |
|----------------|----------|------|
| /api/v1/locales | GET | サポートされているロケール一覧の取得 |
| /api/v1/locales/current | GET | 現在のロケール設定の取得 |
| /api/v1/locales/current | PUT | 現在のロケール設定の更新 |
| /api/v1/users/{userId}/locale | GET | 特定ユーザーのロケール設定取得 |
| /api/v1/users/{userId}/locale | PUT | 特定ユーザーのロケール設定更新 |

#### リクエスト例（ロケール更新）

```json
{
  "locale": "en_US",
  "savePreference": true
}
```

#### レスポンス例（ロケール情報）

```json
{
  "locale": "en_US",
  "language": "en",
  "country": "US",
  "displayName": "English (United States)",
  "nativeDisplayName": "English (United States)",
  "direction": "ltr"
}
```

### 5.2 メッセージリソースAPI

| エンドポイント | メソッド | 説明 |
|----------------|----------|------|
| /api/v1/i18n/messages | GET | 特定カテゴリとロケールのメッセージリソース取得 |
| /api/v1/i18n/messages/{key} | GET | 特定メッセージキーの翻訳取得 |
| /api/v1/i18n/messages/categories | GET | メッセージカテゴリ一覧取得 |
| /api/v1/i18n/messages/missing | GET | 未翻訳メッセージの一覧取得 |

#### リクエスト例（メッセージリソース取得）

```
GET /api/v1/i18n/messages?category=common&locale=en_US
```

#### レスポンス例（メッセージリソース）

```json
{
  "locale": "en_US",
  "category": "common",
  "messages": {
    "common.button.save": "Save",
    "common.button.cancel": "Cancel",
    "common.button.edit": "Edit",
    "common.button.delete": "Delete",
    "common.message.confirm": "Are you sure?",
    "common.label.search": "Search"
  }
}
```

### 5.3 管理者向けリソース管理API

| エンドポイント | メソッド | 説明 |
|----------------|----------|------|
| /api/v1/admin/i18n/resources | GET | リソース管理情報の取得 |
| /api/v1/admin/i18n/resources/{locale} | GET | 特定ロケールのリソース取得 |
| /api/v1/admin/i18n/resources/{locale}/{category} | GET | 特定ロケール・カテゴリのリソース取得 |
| /api/v1/admin/i18n/resources/{locale}/{category} | PUT | リソース更新 |
| /api/v1/admin/i18n/statistics | GET | 翻訳カバレッジ統計情報の取得 |

## 6. 技術的実装

### 6.1 使用技術

* **フレームワーク**: Spring Framework (MessageSource, LocaleResolver)
* **リソース管理**: ResourceBundle + Properties/YAML
* **UI**: React-Intl (フロントエンド翻訳)
* **データベース**: PostgreSQL JSONB型 (多言語コンテンツ)

### 6.2 設定例

#### 6.2.1 Spring Boot設定

```yaml
# application.yml
spring:
  messages:
    basename: i18n/messages,i18n/validation,i18n/errors
    encoding: UTF-8
    fallback-to-system-locale: false
    use-code-as-default-message: false
    cache-duration: 3600
  web:
    locale: ja_JP
    locale-resolver: session

# 国際化設定
i18n:
  supported-locales:
    - ja_JP
    - en_US
  default-locale: ja_JP
  message-sources:
    - name: messages
      description: "一般メッセージ"
    - name: validation
      description: "検証メッセージ"
    - name: errors
      description: "エラーメッセージ"
```

#### 6.2.2 メッセージリソース例

```properties
# messages_ja.properties
common.header.title=SES業務システム
common.footer.copyright=© 2025 SES業務システム

project.list.title=案件一覧
project.list.empty=表示する案件がありません。
project.detail.title=案件詳細: {0}
project.form.name.label=案件名
project.form.name.placeholder=案件名を入力してください
project.form.description.label=案件概要
project.form.startDate.label=開始日
project.form.endDate.label=終了日

# messages_en.properties
common.header.title=SES Management System
common.footer.copyright=© 2025 SES Management System

project.list.title=Project List
project.list.empty=No projects to display.
project.detail.title=Project Detail: {0}
project.form.name.label=Project Name
project.form.name.placeholder=Enter project name
project.form.description.label=Project Description
project.form.startDate.label=Start Date
project.form.endDate.label=End Date
```

### 6.3 コード実装例

#### 6.3.1 バックエンド実装

```java
// ロケール解決
@Configuration
public class LocaleConfig implements WebMvcConfigurer {
    @Value("${i18n.default-locale}")
    private String defaultLocale;
    
    @Value("${i18n.supported-locales}")
    private List<String> supportedLocales;
    
    @Bean
    public LocaleResolver localeResolver() {
        SessionLocaleResolver resolver = new SessionLocaleResolver();
        resolver.setDefaultLocale(Locale.forLanguageTag(defaultLocale.replace('_', '-')));
        return resolver;
    }
    
    @Bean
    public LocaleChangeInterceptor localeChangeInterceptor() {
        LocaleChangeInterceptor interceptor = new LocaleChangeInterceptor();
        interceptor.setParamName("lang");
        return interceptor;
    }
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(localeChangeInterceptor());
    }
}

// メッセージソースサービス
@Service
public class MessageSourceServiceImpl implements MessageSourceService {
    @Autowired
    private MessageSource messageSource;
    
    @Override
    public String getMessage(String code, Locale locale) {
        return messageSource.getMessage(code, null, locale);
    }
    
    @Override
    public String getMessage(String code, Object[] args, Locale locale) {
        return messageSource.getMessage(code, args, locale);
    }
    
    @Override
    public String getMessage(String code, Object[] args, String defaultMessage, Locale locale) {
        return messageSource.getMessage(code, args, defaultMessage, locale);
    }
    
    @Override
    public Map<String, String> getMessages(List<String> codes, Locale locale) {
        Map<String, String> messages = new HashMap<>();
        for (String code : codes) {
            try {
                messages.put(code, getMessage(code, locale));
            } catch (NoSuchMessageException e) {
                messages.put(code, "???" + code + "???");
            }
        }
        return messages;
    }
}

// フォーマットサービス
@Service
public class FormatServiceImpl implements FormatService {
    @Override
    public String formatDate(LocalDate date, FormatStyle style, Locale locale) {
        DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDate(style)
            .withLocale(locale);
        return date.format(formatter);
    }
    
    @Override
    public String formatTime(LocalTime time, FormatStyle style, Locale locale) {
        DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedTime(style)
            .withLocale(locale);
        return time.format(formatter);
    }
    
    @Override
    public String formatDateTime(LocalDateTime dateTime, FormatStyle dateStyle, 
                                FormatStyle timeStyle, Locale locale) {
        DateTimeFormatter formatter = DateTimeFormatter
            .ofLocalizedDateTime(dateStyle, timeStyle)
            .withLocale(locale);
        return dateTime.format(formatter);
    }
    
    @Override
    public String formatNumber(Number number, Locale locale) {
        NumberFormat formatter = NumberFormat.getInstance(locale);
        return formatter.format(number);
    }
    
    @Override
    public String formatCurrency(Number amount, Locale locale) {
        NumberFormat formatter = NumberFormat.getCurrencyInstance(locale);
        return formatter.format(amount);
    }
    
    @Override
    public String formatPercent(Number value, Locale locale) {
        NumberFormat formatter = NumberFormat.getPercentInstance(locale);
        return formatter.format(value);
    }
}

// 多言語コンテンツ処理
@Service
public class LocalizedContentServiceImpl implements LocalizedContentService {
    @Autowired
    private LocaleResolver localeResolver;
    
    @Override
    public <T> T getLocalizedEntity(T entity, Locale locale) {
        if (entity == null) return null;
        
        // エンティティをプロキシで包み、多言語フィールドをローカライズするプロキシ実装
        // ...実装省略...
        
        return localizedEntity;
    }
    
    @Override
    public String getLocalizedField(Object jsonValue, Locale locale) {
        if (jsonValue == null) return null;
        
        // JSON形式の多言語値からロケールに合致する翻訳を取得
        try {
            ObjectMapper mapper = new ObjectMapper();
            JsonNode node = mapper.valueToTree(jsonValue);
            
            // 完全一致のロケールで検索
            String localeStr = locale.toString();
            if (node.has(localeStr)) {
                return node.get(localeStr).asText();
            }
            
            // 言語のみで検索
            String lang = locale.getLanguage();
            if (node.has(lang)) {
                return node.get(lang).asText();
            }
            
            // デフォルトロケールで検索
            if (node.has("ja")) {
                return node.get("ja").asText();
            }
            
            // 最初に見つかった値を返す
            if (node.isObject() && node.size() > 0) {
                return node.elements().next().asText();
            }
            
            return jsonValue.toString();
        } catch (Exception e) {
            return jsonValue.toString();
        }
    }
}
```

#### 6.3.2 フロントエンド実装

```typescript
// src/i18n/config.ts
import { IntlConfig } from 'react-intl';
import * as messagesJa from './messages/ja.json';
import * as messagesEn from './messages/en.json';

export type MessageKey = keyof typeof messagesJa;

export const locales = ['ja-JP', 'en-US'] as const;
export type Locale = typeof locales[number];

export const defaultLocale: Locale = 'ja-JP';

export const messages: Record<Locale, Record<string, string>> = {
  'ja-JP': messagesJa,
  'en-US': messagesEn,
};

export const dateFormats: Record<Locale, Record<string, IntlConfig['formats']['date']>> = {
  'ja-JP': {
    short: { year: 'numeric', month: '2-digit', day: '2-digit' },
    medium: { year: 'numeric', month: 'long', day: 'numeric' },
    long: { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' },
  },
  'en-US': {
    short: { year: 'numeric', month: '2-digit', day: '2-digit' },
    medium: { year: 'numeric', month: 'long', day: 'numeric' },
    long: { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' },
  },
};

export const timeFormats: Record<Locale, Record<string, IntlConfig['formats']['time']>> = {
  'ja-JP': {
    short: { hour: '2-digit', minute: '2-digit' },
    medium: { hour: '2-digit', minute: '2-digit', second: '2-digit' },
  },
  'en-US': {
    short: { hour: 'numeric', minute: '2-digit', hour12: true },
    medium: { hour: 'numeric', minute: '2-digit', second: '2-digit', hour12: true },
  },
};

// src/i18n/I18nProvider.tsx
import React, { ReactNode, useEffect, useState } from 'react';
import { IntlProvider } from 'react-intl';
import { defaultLocale, Locale, locales, messages, dateFormats, timeFormats } from './config';

interface I18nProviderProps {
  children: ReactNode;
}

export const I18nProvider: React.FC<I18nProviderProps> = ({ children }) => {
  const [locale, setLocale] = useState<Locale>(defaultLocale);
  
  useEffect(() => {
    // ユーザー設定、Cookie、ブラウザ設定から最適なロケールを決定
    const determineLocale = async (): Promise<Locale> => {
      try {
        // 1. APIからユーザー設定を取得
        const response = await fetch('/api/v1/locales/current');
        if (response.ok) {
          const data = await response.json();
          const userLocale = data.locale.replace('_', '-') as Locale;
          if (locales.includes(userLocale)) {
            return userLocale;
          }
        }
      } catch (error) {
        console.error('Failed to fetch user locale', error);
      }
      
      // 2. ブラウザのロケールを確認
      const browserLocale = navigator.language as Locale;
      if (locales.includes(browserLocale)) {
        return browserLocale;
      }
      
      // 3. ブラウザ言語のみをベースにマッチング
      const browserLang = browserLocale.split('-')[0];
      const match = locales.find(locale => locale.startsWith(browserLang + '-'));
      if (match) {
        return match;
      }
      
      // 4. デフォルトロケールを使用
      return defaultLocale;
    };
    
    determineLocale().then(setLocale);
  }, []);
  
  return (
    <IntlProvider
      locale={locale}
      messages={messages[locale]}
      defaultLocale={defaultLocale}
      formats={{
        date: dateFormats[locale],
        time: timeFormats[locale],
      }}
    >
      {children}
    </IntlProvider>
  );
};

// src/i18n/useI18n.ts
import { useIntl } from 'react-intl';
import { MessageKey } from './config';

export const useI18n = () => {
  const intl = useIntl();
  
  return {
    t: (id: MessageKey, values?: Record<string, any>) => 
      intl.formatMessage({ id }, values),
    
    formatDate: (date: Date | number, options?: Intl.DateTimeFormatOptions) => 
      intl.formatDate(date, options),
    
    formatTime: (date: Date | number, options?: Intl.DateTimeFormatOptions) => 
      intl.formatTime(date, options),
    
    formatNumber: (value: number, options?: Intl.NumberFormatOptions) => 
      intl.formatNumber(value, options),
    
    formatCurrency: (value: number, currency: string = 'JPY') => 
      intl.formatNumber(value, { style: 'currency', currency }),
    
    formatRelativeTime: (value: number, unit: Intl.RelativeTimeFormatUnit) => 
      intl.formatRelativeTime(value, unit)
  };
};

// 使用例
const ProjectList: React.FC = () => {
  const { t, formatDate, formatCurrency } = useI18n();
  
  return (
    <div>
      <h1>{t('project.list.title')}</h1>
      {projects.length === 0 ? (
        <p>{t('project.list.empty')}</p>
      ) : (
        <ul>
          {projects.map(project => (
            <li key={project.id}>
              <h3>{project.name}</h3>
              <p>{formatDate(project.startDate, { dateStyle: 'medium' })} - 
                 {formatDate(project.endDate, { dateStyle: 'medium' })}</p>
              <p>{t('project.list.rate')}: {formatCurrency(project.rate)}</p>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};
```

## 7. セキュリティ対策

* **リソースファイルのインジェクション防止**: メッセージリソースの安全な処理
* **XSS対策**: ユーザー入力を含むメッセージの適切なエスケープ処理
* **翻訳プロセスの監査**: 翻訳変更の履歴管理と承認フロー

## 8. 課題と制限事項

* **リソース管理の複雑性**: 多言語対応に伴うリソース管理の複雑化
* **UI表示領域の制約**: 様々な言語長に対応する UI レイアウトの設計
* **翻訳品質の維持**: 一貫性のある翻訳品質の確保
* **コンテキスト理解**: 翻訳者への適切なコンテキスト情報の提供
* **パフォーマンス影響**: 多言語コンテンツのデータ増加に伴うパフォーマンス影響