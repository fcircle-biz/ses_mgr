# SES業務システム ロギング機能 基本設計書

## 1. はじめに

本書は、SES業務システムにおけるロギング機能の基本設計を定義したものである。
システム全体のログ管理の方針と実装方法について記述し、障害解析、セキュリティ監査、
業務分析などを支援する基盤的な共通機能について定義する。

## 2. 機能概要

ロギング機能は、アプリケーションの動作状況、ユーザーの操作履歴、エラー情報、セキュリティ関連イベントなどを
記録し、システムの運用・保守・監査を支援する基盤的な共通機能である。適切なログを記録することで、
障害発生時の原因分析や不正アクセスの検知など、様々な運用上の課題に対応する。

## 3. ロギング機能設計

### 3.1 機能構成

ロギング機能は以下のサブ機能で構成される：

1. **アプリケーションログ**: システムの動作に関する技術的なログ記録
2. **操作ログ**: ユーザーの操作履歴の記録
3. **監査ログ**: セキュリティ監査のためのイベント記録
4. **システムログ**: サーバー／インフラレベルのログ記録
5. **ログ収集・管理**: 各種ログの一元管理と検索

### 3.2 ログ種別設計

#### 3.2.1 アプリケーションログ

アプリケーションの内部動作を記録するログ。

| 項目 | 説明 |
|------|------|
| 目的 | システムの技術的な動作状況の記録と障害解析 |
| 対象 | サービス処理、外部連携、エラー、警告など |
| レベル | TRACE, DEBUG, INFO, WARN, ERROR |
| 出力先 | アプリケーションログファイル、集中ログ管理システム |
| 保存期間 | 90日（本番環境）、30日（他環境） |

##### アプリケーションログレベル定義

| レベル | 説明 | 用途 | 環境 |
|------|------|------|------|
| TRACE | 最も詳細なデバッグ情報 | 詳細なプログラムフロー追跡 | 開発環境のみ |
| DEBUG | デバッグ情報 | 一般的なデバッグ情報 | 開発・テスト環境 |
| INFO | 通常の動作情報 | 主要処理の開始・終了、設定情報など | 全環境 |
| WARN | 警告情報 | 潜在的な問題、性能低下の兆候など | 全環境 |
| ERROR | エラー情報 | 処理続行可能なエラー | 全環境 |
| FATAL | 致命的エラー | システム停止につながる重大エラー | 全環境 |

##### 主要ログ項目

```
[2025-05-05 10:15:30.123] [INFO] [project-service] [req-8a7b9c3d2e1f] [user_12345] [ProjectServiceImpl:createProject] - プロジェクト作成開始: ID=proj_8a7b9c3d, 名称=新規SES案件管理システム開発
```

| 項目 | 説明 |
|------|------|
| タイムスタンプ | ログ記録日時 |
| レベル | ログレベル (INFO/WARN/ERROR など) |
| サービス名 | ログを出力したサービス/モジュール名 |
| リクエストID | リクエストを一意に識別する ID |
| ユーザーID | 処理を実行したユーザーの ID |
| 実行クラス:メソッド | ログを出力したクラスとメソッド |
| メッセージ | ログメッセージ本文 |

#### 3.2.2 操作ログ

ユーザーの操作内容を記録するログ。

| 項目 | 説明 |
|------|------|
| 目的 | ユーザー操作の履歴管理と業務分析 |
| 対象 | データ登録、更新、削除、照会、ダウンロードなどの操作 |
| レベル | INFO（通常操作）, WARN（異常操作） |
| 出力先 | 操作ログテーブル、操作ログファイル |
| 保存期間 | 1年間 |

##### 操作ログの記録対象操作

以下の操作を記録対象とする：

1. **データ操作**:
   - マスタデータの登録・更新・削除
   - 重要トランザクションデータの登録・更新・削除
   
2. **参照操作**:
   - 個人情報・機密情報の参照
   - データダウンロード・エクスポート
   
3. **ステータス変更**:
   - ワークフローの承認・却下
   - ステータス遷移
   
4. **セキュリティ関連操作**:
   - ログイン・ログアウト
   - パスワード変更
   - 権限設定変更

##### 操作ログ項目

| 項目 | 型 | 説明 |
|------|------|------|
| id | UUID | ログ一意識別子 |
| timestamp | DateTime | 操作日時 |
| userId | String | 操作ユーザーID |
| userName | String | 操作ユーザー名 |
| userRoles | List\<String\> | 操作時のユーザーロール |
| ipAddress | String | クライアントIPアドレス |
| operationType | Enum | 操作種別（登録、更新、削除、参照など） |
| resourceType | String | 操作対象リソース種別（案件、技術者、契約など） |
| resourceId | String | 操作対象リソースID |
| resourceName | String | 操作対象リソース名 |
| details | JSON | 操作詳細情報（変更前後の値など） |
| result | Enum | 操作結果（成功、失敗） |
| clientInfo | String | クライアント情報（ブラウザ、デバイスなど） |
| sessionId | String | セッションID |
| requestId | String | リクエストID |

#### 3.2.3 監査ログ

セキュリティ監査のためのイベントを記録するログ。

| 項目 | 説明 |
|------|------|
| 目的 | セキュリティ監査とコンプライアンス対応 |
| 対象 | 認証、認可、重要データアクセス、設定変更など |
| レベル | INFO（通常）, WARN（警告）, ERROR（違反） |
| 出力先 | 監査ログテーブル、監査ログファイル（改ざん防止機能付き） |
| 保存期間 | 5年間 |

##### 監査ログの記録対象イベント

以下のイベントを記録対象とする：

1. **認証関連**:
   - ログイン成功・失敗
   - パスワードリセット
   - アカウントロック・ロック解除
   - 多要素認証

2. **認可関連**:
   - アクセス権限変更
   - ロール割り当て・削除
   - アクセス拒否

3. **機密データ操作**:
   - 個人情報の参照・更新
   - 給与情報の参照・更新
   - 契約情報の参照・更新

4. **システム管理操作**:
   - システム設定変更
   - バッチ処理実行
   - インポート・エクスポート
   - データベース直接操作

##### 監査ログ項目

| 項目 | 型 | 説明 |
|------|------|------|
| id | UUID | ログ一意識別子 |
| timestamp | DateTime | イベント発生日時 |
| eventType | Enum | イベント種別 |
| severity | Enum | 重要度（通常、警告、重大） |
| userId | String | 関連ユーザーID |
| userName | String | 関連ユーザー名 |
| userRoles | List\<String\> | ユーザーロール |
| ipAddress | String | IPアドレス |
| resourceType | String | 対象リソース種別 |
| resourceId | String | 対象リソースID |
| action | String | 実行されたアクション |
| result | Enum | 結果（成功、失敗） |
| before | JSON | 変更前の状態（該当する場合） |
| after | JSON | 変更後の状態（該当する場合） |
| reason | String | 理由・説明（該当する場合） |
| clientInfo | String | クライアント情報 |
| sessionId | String | セッションID |
| requestId | String | リクエストID |

#### 3.2.4 システムログ

サーバーやインフラストラクチャレベルの情報を記録するログ。

| 項目 | 説明 |
|------|------|
| 目的 | システムの稼働状況監視と障害解析 |
| 対象 | サーバー起動/停止、リソース使用率、ネットワーク状態など |
| レベル | INFO, WARN, ERROR, FATAL |
| 出力先 | システムログファイル、syslog |
| 保存期間 | 90日 |

### 3.3 ログ管理アーキテクチャ

#### 3.3.1 ログ収集・管理フロー

ログの収集・管理フローを以下に定義する：

```
[アプリケーション] --> [ログファイル] --> [ログ収集エージェント] --> [ログ集約サーバー] --> [ログストレージ]
                      |                                               |
                      v                                               v
      [リアルタイムモニタリング] <-------------------------------- [ログ分析エンジン] --> [アラート通知]
                                                                      |
                                                                      v
                                                                [ログUI/ダッシュボード]
```

1. **ログ生成**: アプリケーション・システムからのログ出力
2. **ログ収集**: ログ収集エージェントによるログファイル監視と収集
3. **ログ転送**: 収集したログの集中ログサーバーへの転送
4. **ログ解析**: ログパターンの分析と構造化
5. **ログ保存**: 長期保存とアーカイブ
6. **ログ検索**: インデックス化と高速検索機能の提供
7. **ログ可視化**: ダッシュボードによる可視化と分析
8. **アラート**: 異常検知時のアラート通知

#### 3.3.2 技術スタック

ログ管理に使用する技術スタックを以下に定義する：

| コンポーネント | 技術 | 説明 |
|--------------|------|------|
| ロガー | SLF4J + Logback | アプリケーションのログ出力 |
| ログ収集 | Fluentd | ログファイルの監視と収集 |
| ログ転送 | Kafka | ログデータのストリーミング |
| ログストレージ | Elasticsearch | ログの検索・分析・保存 |
| ログ可視化 | Kibana | ログの可視化とダッシュボード |
| アラート | Elastalert | 異常検知とアラート通知 |
| 長期アーカイブ | S3 + Glacier | ログの長期保存 |

### 3.4 ログ出力設計

#### 3.4.1 アプリケーションログ出力

アプリケーションログの出力方針を以下に定義する：

1. **統一ログフォーマット**:
   - JSON形式によるログ構造化
   - 共通フィールドの標準化

2. **コンテキスト情報の付与**:
   - MDC (Mapped Diagnostic Context) による共通情報の自動付与
   - リクエストID、ユーザーID、セッションIDなどの自動設定

3. **適切なログレベルの使用**:
   - 各レベルの使用方針の明確化
   - 環境ごとのログレベル設定

4. **パフォーマンスへの配慮**:
   - 高負荷処理時のログ出力抑制
   - ログ構築コストの最小化（条件付きログ出力など）

```java
// アプリケーションログの使用例
@Service
public class ProjectServiceImpl implements ProjectService {
    private static final Logger log = LoggerFactory.getLogger(ProjectServiceImpl.class);
    
    @Override
    public Project createProject(ProjectCreateDTO dto) {
        // ログ出力（情報）
        log.info("プロジェクト作成開始: {}", dto.getProjectName());
        
        try {
            // 処理実装
            // ...
            
            // 処理成功ログ
            log.info("プロジェクト作成完了: ID={}, 名称={}", project.getId(), project.getName());
            return project;
        } catch (DataIntegrityViolationException e) {
            // エラーログ出力
            log.error("プロジェクト作成時のデータ整合性違反: {}, 原因: {}", 
                      dto.getProjectName(), e.getMessage());
            throw new BusinessException("...", e);
        } catch (Exception e) {
            // 予期せぬエラーログ
            log.error("プロジェクト作成時の予期せぬエラー", e);
            throw e;
        }
    }
    
    // デバッグログの適切な使用
    private void processComplexLogic(Project project) {
        // 詳細なデバッグ情報（開発環境のみで出力）
        if (log.isDebugEnabled()) {
            log.debug("複雑なロジック処理開始: projectId={}, data={}", 
                     project.getId(), serializeForDebug(project));
        }
        
        // 処理実装
        // ...
    }
}
```

#### 3.4.2 操作ログ記録

操作ログの記録方針を以下に定義する：

1. **AOP (Aspect Oriented Programming) による自動記録**:
   - 特定のメソッドやアノテーションに基づく自動ログ記録
   - パラメータと戻り値の自動キャプチャ

2. **オブジェクト変更の追跡**:
   - エンティティの変更内容の自動検出と記録
   - 変更前後の値の比較と記録

3. **ログメタデータの自動収集**:
   - HTTPリクエスト情報の自動収集
   - セッション・認証情報の自動取得

```java
// 操作ログアスペクトの例
@Aspect
@Component
public class OperationLogAspect {
    @Autowired
    private OperationLogService logService;
    
    @Autowired
    private SecurityUtils securityUtils;
    
    @Around("@annotation(operationLog)")
    public Object logOperation(ProceedingJoinPoint joinPoint, OperationLog operationLog) throws Throwable {
        // 前処理: パラメータ取得
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        
        // メタデータ収集
        String userId = securityUtils.getCurrentUserId();
        String resourceType = operationLog.resource();
        String operationType = operationLog.operation();
        
        // リソースIDの抽出（パラメータから）
        String resourceId = extractResourceId(args, operationLog.resourceIdParam());
        
        // 前状態の記録（更新・削除の場合）
        Object beforeState = null;
        if (OperationType.UPDATE.equals(operationType) || 
            OperationType.DELETE.equals(operationType)) {
            beforeState = captureResourceState(resourceType, resourceId);
        }
        
        // メソッド実行
        Object result = null;
        OperationLogRecord logRecord = new OperationLogRecord();
        try {
            result = joinPoint.proceed();
            
            // 成功状態の設定
            logRecord.setResult(OperationResult.SUCCESS);
            
            // 後状態の記録（登録・更新の場合）
            if (OperationType.CREATE.equals(operationType) || 
                OperationType.UPDATE.equals(operationType)) {
                Object afterState = result;
                logRecord.setAfterState(afterState);
            }
        } catch (Exception e) {
            // 失敗状態の設定
            logRecord.setResult(OperationResult.FAILURE);
            logRecord.setErrorMessage(e.getMessage());
            throw e;
        } finally {
            // 操作ログの基本情報設定
            logRecord.setTimestamp(LocalDateTime.now());
            logRecord.setUserId(userId);
            logRecord.setUserName(securityUtils.getCurrentUserName());
            logRecord.setUserRoles(securityUtils.getCurrentUserRoles());
            logRecord.setIpAddress(securityUtils.getCurrentClientIp());
            logRecord.setOperationType(operationType);
            logRecord.setResourceType(resourceType);
            logRecord.setResourceId(resourceId);
            
            if (beforeState != null) {
                logRecord.setBeforeState(beforeState);
            }
            
            // クライアント情報、セッションID、リクエストID
            logRecord.setClientInfo(securityUtils.getCurrentClientInfo());
            logRecord.setSessionId(securityUtils.getCurrentSessionId());
            logRecord.setRequestId(MDC.get("requestId"));
            
            // ログの記録
            logService.recordOperationLog(logRecord);
        }
        
        return result;
    }
    
    // リソースIDをパラメータから抽出するヘルパーメソッド
    private String extractResourceId(Object[] args, String paramName) {
        // 実装...
    }
    
    // リソースの現在状態を取得するヘルパーメソッド
    private Object captureResourceState(String resourceType, String resourceId) {
        // 実装...
    }
}
```

#### 3.4.3 監査ログ記録

監査ログの記録方針を以下に定義する：

1. **セキュリティイベントの自動記録**:
   - Spring Security イベントリスナーによる認証・認可イベントの自動記録
   - セキュリティフィルターでのイベント捕捉

2. **改ざん防止措置**:
   - 監査ログの署名と暗号化
   - 追記専用ログの採用

3. **法的要件対応**:
   - 業界標準や法規制に準拠したログフォーマット
   - 監査証跡の一貫性と完全性の確保

```java
// 監査ログリスナーの例
@Component
public class SecurityAuditEventListener {
    @Autowired
    private AuditLogService auditLogService;
    
    // 認証成功イベントリスナー
    @EventListener
    public void handleAuthenticationSuccess(AuthenticationSuccessEvent event) {
        Authentication auth = event.getAuthentication();
        
        AuditLogRecord log = new AuditLogRecord();
        log.setTimestamp(LocalDateTime.now());
        log.setEventType(AuditEventType.AUTHENTICATION);
        log.setAction("LOGIN");
        log.setResult(AuditResult.SUCCESS);
        log.setUserId(auth.getName());
        
        // ユーザー情報の取得
        if (auth.getPrincipal() instanceof UserDetails) {
            UserDetails userDetails = (UserDetails) auth.getPrincipal();
            log.setUserRoles(userDetails.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.toList()));
        }
        
        // リクエスト情報の取得
        ServletRequestAttributes attrs = 
            (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        if (attrs != null) {
            HttpServletRequest request = attrs.getRequest();
            log.setIpAddress(request.getRemoteAddr());
            log.setClientInfo(request.getHeader("User-Agent"));
            log.setSessionId(request.getSession().getId());
        }
        
        log.setRequestId(MDC.get("requestId"));
        
        // 監査ログの記録
        auditLogService.recordAuditLog(log);
    }
    
    // 認証失敗イベントリスナー
    @EventListener
    public void handleAuthenticationFailure(AuthenticationFailureEvent event) {
        // 実装...
    }
    
    // アクセス拒否イベントリスナー
    @EventListener
    public void handleAccessDenied(AccessDeniedEvent event) {
        // 実装...
    }
}
```

### 3.5 ログローテーションと保持ポリシー

#### 3.5.1 ログローテーション

ログファイルのローテーション方針を以下に定義する：

1. **アプリケーションログ**:
   - ローテーション: 日次
   - ファイルサイズ上限: 100MB
   - 圧縮形式: GZIP
   - 命名規則: `application-{date}.log.gz`

2. **操作ログ・監査ログ**:
   - データベース保存: パーティショニング（月次）
   - アーカイブ: 四半期ごと
   - 命名規則: `audit-log-{year}-{quarter}.archive`

#### 3.5.2 保持ポリシー

環境ごとのログ保持ポリシーを以下に定義する：

| 環境 | ログ種別 | オンライン保持期間 | アーカイブ保持期間 |
|------|---------|-------------------|-------------------|
| 開発 | アプリケーションログ | 7日 | なし |
| 開発 | 操作ログ | 30日 | なし |
| 開発 | 監査ログ | 30日 | なし |
| テスト | アプリケーションログ | 14日 | なし |
| テスト | 操作ログ | 30日 | 90日 |
| テスト | 監査ログ | 30日 | 90日 |
| 本番 | アプリケーションログ | 30日 | 90日 |
| 本番 | 操作ログ | 90日 | 1年 |
| 本番 | 監査ログ | 1年 | 5年 |

### 3.6 ログ検索・分析

#### 3.6.1 検索機能

ログ検索機能の要件を以下に定義する：

1. **全文検索**:
   - ログメッセージ全体に対するキーワード検索
   - 正規表現検索

2. **構造化検索**:
   - 特定フィールドに対する条件検索
   - 複合条件検索（AND/OR）

3. **時間範囲検索**:
   - 日時範囲の指定
   - 相対時間の指定（例：過去1時間、本日など）

4. **コンテキスト検索**:
   - リクエストID、セッションIDによる関連ログの検索
   - ユーザーIDによるアクティビティ検索

#### 3.6.2 分析機能

ログ分析機能の要件を以下に定義する：

1. **トレンド分析**:
   - 時間経過に伴うログ発生頻度の分析
   - パターン検出と異常検知

2. **イベント相関分析**:
   - 関連するイベント間の相関関係の分析
   - 原因と結果の連鎖の特定

3. **ユーザー行動分析**:
   - ユーザーの操作パターンの分析
   - 異常行動の検出

4. **レポーティング**:
   - 定期的なログ分析レポートの生成
   - カスタムダッシュボードの作成

### 3.7 セキュリティと監査

#### 3.7.1 ログデータの保護

ログデータの保護措置を以下に定義する：

1. **暗号化**:
   - 転送中のログデータの暗号化（TLS）
   - 保存ログの暗号化（特に機密情報を含むログ）

2. **アクセス制御**:
   - ログ閲覧・管理権限の厳格な制御
   - 権限に基づくログフィルタリング

3. **匿名化**:
   - 個人情報の自動マスキング
   - 特定の機密情報のトークン化

#### 3.7.2 監査証跡の完全性

監査ログの完全性を確保する方法を以下に定義する：

1. **改ざん検知**:
   - ログエントリのハッシュ値計算
   - シーケンシャルなログエントリID付与

2. **証拠保全**:
   - WORM (Write Once Read Many) ストレージの使用
   - タイムスタンプと署名によるログの認証

3. **分離保存**:
   - 監査ログの分離保存
   - バックアップの安全な管理

## 4. UI設計

### 4.1 ログ閲覧・管理画面

システム管理者向けのログ閲覧・管理画面を以下に定義する：

#### 4.1.1 ログ検索画面

ログ検索画面の構成：

* **検索条件部**:
  - ログ種別選択（アプリケーション、操作、監査、システム）
  - 時間範囲指定（日時範囲、相対期間）
  - キーワード検索
  - 詳細検索条件（フィールド指定検索）
  - ユーザーID、リソースID、イベント種別などの条件
  - 検索ボタン、条件クリアボタン

* **検索結果部**:
  - ログ一覧表示（タイムスタンプ、レベル、メッセージなど）
  - ソート機能（各カラムでのソート）
  - フィルタリング（レベル、モジュールなどでのフィルタ）
  - ページング機能
  - ログ詳細表示（エントリクリックで詳細表示）
  - エクスポート機能（CSV、JSON形式）

#### 4.1.2 ログ分析ダッシュボード

ログ分析ダッシュボードの構成：

* **サマリー部**:
  - エラー発生数トレンド
  - アクティブユーザー数
  - システムパフォーマンス指標
  - セキュリティイベント概要

* **トレンドグラフ部**:
  - 時間帯別ログ発生量
  - エラーレベル別分布
  - モジュール別ログ発生量
  - ユーザー操作量推移

* **アラート部**:
  - 直近の重要アラート
  - アラート統計
  - 未解決アラート一覧

* **カスタムレポート部**:
  - 保存済みレポート一覧
  - 新規レポート作成
  - 定期レポート設定

#### 4.1.3 監査ログレビュー画面

監査目的のログレビュー画面の構成：

* **監査証跡検索部**:
  - 期間指定
  - ユーザー指定
  - イベント種別指定
  - リソース種別・ID指定

* **監査証跡表示部**:
  - 時系列表示
  - ユーザー別グループ化
  - リソース別グループ化
  - 操作連鎖の可視化
  - エビデンス出力機能（証明用）

## 5. API設計

### 5.1 ログ参照API

ログ参照のためのAPI：

| エンドポイント | メソッド | 説明 |
|----------------|----------|------|
| /api/v1/system/logs | GET | ログ検索・取得（種別、条件、ページング指定） |
| /api/v1/system/logs/{id} | GET | 特定ログエントリの詳細取得 |
| /api/v1/system/logs/export | GET | ログのエクスポート |
| /api/v1/system/logs/statistics | GET | ログ統計情報の取得 |

#### リクエスト例

```
GET /api/v1/system/logs?type=APPLICATION&level=ERROR&startTime=2025-05-01T00:00:00Z&endTime=2025-05-05T23:59:59Z&keyword=exception&page=0&size=20
```

#### レスポンス例

```json
{
  "content": [
    {
      "id": "log-8a7b9c3d2e1f",
      "timestamp": "2025-05-04T14:32:45.123Z",
      "level": "ERROR",
      "service": "project-service",
      "requestId": "req-8a7b9c3d2e1f",
      "userId": "user_12345",
      "source": "ProjectServiceImpl:createProject",
      "message": "プロジェクト作成中にデータベースエラーが発生しました",
      "stackTrace": "java.sql.SQLException: Duplicate entry 'プロジェクト名' for key 'unique_name'...",
      "additionalInfo": {
        "projectName": "新規SES案件管理システム開発",
        "errorCode": "E-02301"
      }
    },
    // ... 他のログエントリ
  ],
  "pageable": {
    "pageNumber": 0,
    "pageSize": 20,
    "totalElements": 156,
    "totalPages": 8
  }
}
```

### 5.2 操作ログ・監査ログAPI

操作ログ・監査ログのためのAPI：

| エンドポイント | メソッド | 説明 |
|----------------|----------|------|
| /api/v1/system/operation-logs | GET | 操作ログの検索・取得 |
| /api/v1/system/operation-logs/{id} | GET | 特定操作ログの詳細取得 |
| /api/v1/system/audit-logs | GET | 監査ログの検索・取得 |
| /api/v1/system/audit-logs/{id} | GET | 特定監査ログの詳細取得 |
| /api/v1/system/audit-trails | GET | 監査証跡の時系列取得 |
| /api/v1/system/audit-trails/resources/{resourceType}/{resourceId} | GET | 特定リソースの監査証跡取得 |
| /api/v1/system/audit-trails/users/{userId} | GET | 特定ユーザーの監査証跡取得 |

#### リクエスト例（監査ログ検索）

```json
{
  "eventTypes": ["AUTHENTICATION", "AUTHORIZATION"],
  "startDate": "2025-05-01T00:00:00Z",
  "endDate": "2025-05-05T23:59:59Z",
  "userIds": ["user_12345"],
  "results": ["SUCCESS", "FAILURE"],
  "page": 0,
  "size": 20,
  "sort": "timestamp,desc"
}
```

### 5.3 ログ設定API

ログ設定を管理するためのAPI：

| エンドポイント | メソッド | 説明 |
|----------------|----------|------|
| /api/v1/system/log-config | GET | 現在のログ設定取得 |
| /api/v1/system/log-config | PUT | ログ設定の更新 |
| /api/v1/system/log-config/levels | PUT | ログレベル設定の更新 |
| /api/v1/system/log-config/appenders | GET | ログアペンダー設定の取得 |
| /api/v1/system/log-config/appenders/{name} | PUT | 特定ログアペンダー設定の更新 |

## 6. 技術的実装

### 6.1 使用技術

ロギング機能の実装に使用する技術：

* **ロギングフレームワーク**: SLF4J + Logback
* **構造化ログ**: JSON形式（logstash-logback-encoder）
* **分散トレーシング**: Spring Cloud Sleuth
* **ログ収集**: Fluentd + Kafka
* **ログ保存・検索**: Elasticsearch
* **ログ可視化**: Kibana
* **ログモニタリング**: Elastalert

### 6.2 設定例

#### 6.2.1 Logback設定例

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- プロパティ -->
    <property name="LOG_PATH" value="${LOG_PATH:-./logs}" />
    <property name="APP_NAME" value="${APP_NAME:-ses-manager}" />
    
    <!-- アペンダー設定 -->
    <!-- コンソール出力 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder class="net.logstash.logback.encoder.LogstashEncoder">
            <includeMdc>true</includeMdc>
            <includeContext>false</includeContext>
            <customFields>{"application":"${APP_NAME}","environment":"${ENVIRONMENT:-development}"}</customFields>
        </encoder>
    </appender>
    
    <!-- ファイル出力 (JSON) -->
    <appender name="FILE_JSON" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/${APP_NAME}.json</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/${APP_NAME}-%d{yyyy-MM-dd}.json.gz</fileNamePattern>
            <maxHistory>30</maxHistory>
            <totalSizeCap>3GB</totalSizeCap>
        </rollingPolicy>
        <encoder class="net.logstash.logback.encoder.LogstashEncoder">
            <includeMdc>true</includeMdc>
            <includeContext>false</includeContext>
            <customFields>{"application":"${APP_NAME}","environment":"${ENVIRONMENT:-development}"}</customFields>
        </encoder>
    </appender>
    
    <!-- ファイル出力 (人間可読) -->
    <appender name="FILE_TEXT" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/${APP_NAME}.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/${APP_NAME}-%d{yyyy-MM-dd}.log.gz</fileNamePattern>
            <maxHistory>30</maxHistory>
            <totalSizeCap>3GB</totalSizeCap>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 非同期処理 -->
    <appender name="ASYNC_JSON" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="FILE_JSON" />
        <queueSize>512</queueSize>
        <discardingThreshold>0</discardingThreshold>
    </appender>
    
    <!-- Logger設定 -->
    <!-- アプリケーションログ -->
    <logger name="jp.co.sesmanager" level="${LOG_LEVEL:-INFO}" additivity="false">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="ASYNC_JSON" />
        <appender-ref ref="FILE_TEXT" />
    </logger>
    
    <!-- フレームワークログ -->
    <logger name="org.springframework" level="INFO" additivity="false">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="ASYNC_JSON" />
    </logger>
    <logger name="org.hibernate" level="INFO" additivity="false">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="ASYNC_JSON" />
    </logger>
    
    <!-- ルートロガー -->
    <root level="WARN">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="ASYNC_JSON" />
        <appender-ref ref="FILE_TEXT" />
    </root>
</configuration>
```

#### 6.2.2 Spring Boot設定例

```yaml
# application.yml
logging:
  config: classpath:logback-spring.xml
  level:
    root: WARN
    jp.co.sesmanager: INFO
    org.springframework.web: INFO
    org.hibernate.SQL: DEBUG  # 開発環境のみ

# 監査ログ設定
audit:
  enabled: true
  db-persistence: true
  file-persistence: true
  log-file: ${LOG_PATH:/logs}/audit-${APP_NAME:ses-manager}.log
  retention-days: 365

# 操作ログ設定
operation-log:
  enabled: true
  log-file: ${LOG_PATH:/logs}/operation-${APP_NAME:ses-manager}.log
  retention-days: 90
  masked-fields:
    - "password"
    - "*.password"
    - "*.secret"
    - "creditCard"
    - "*.creditCard"
```

### 6.3 コード実装例

#### 6.3.1 MDCフィルターの実装

```java
@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class LoggingMDCFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                   HttpServletResponse response, 
                                   FilterChain filterChain) 
                                   throws ServletException, IOException {
        try {
            // リクエストIDの生成・設定
            String requestId = UUID.randomUUID().toString();
            MDC.put("requestId", requestId);
            response.setHeader("X-Request-ID", requestId);
            
            // リクエスト情報の設定
            MDC.put("clientIp", request.getRemoteAddr());
            MDC.put("userAgent", request.getHeader("User-Agent"));
            MDC.put("requestUri", request.getRequestURI());
            MDC.put("requestMethod", request.getMethod());
            
            // セッション情報の設定
            HttpSession session = request.getSession(false);
            if (session != null) {
                MDC.put("sessionId", session.getId());
            }
            
            // ユーザー情報の設定
            Authentication auth = SecurityContextHolder.getContext().getAuthentication();
            if (auth != null && auth.isAuthenticated() && !(auth instanceof AnonymousAuthenticationToken)) {
                MDC.put("userId", auth.getName());
                
                if (auth.getPrincipal() instanceof UserDetails) {
                    UserDetails userDetails = (UserDetails) auth.getPrincipal();
                    MDC.put("userRoles", String.join(",", userDetails.getAuthorities().stream()
                        .map(GrantedAuthority::getAuthority)
                        .collect(Collectors.toList())));
                }
            }
            
            // フィルターチェーンの継続
            filterChain.doFilter(request, response);
        } finally {
            // MDCのクリア
            MDC.clear();
        }
    }
}
```

#### 6.3.2 操作ログアノテーションの実装

```java
// 操作ログアノテーション
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface LogOperation {
    String resource() default "";       // リソース種別
    String operation() default "";      // 操作種別
    String resourceIdParam() default ""; // リソースIDパラメータ名
    boolean includeRequest() default false; // リクエスト内容を含めるか
    boolean includeResponse() default false; // レスポンス内容を含めるか
    String[] maskedFields() default {}; // マスクするフィールド
}

// 操作ログサービス
@Service
public class OperationLogServiceImpl implements OperationLogService {
    private static final Logger log = LoggerFactory.getLogger("OPERATION_LOG");
    
    @Autowired
    private OperationLogRepository operationLogRepository;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Override
    public void recordOperationLog(OperationLogRecord logRecord) {
        // JSON形式でのログ出力
        try {
            log.info(objectMapper.writeValueAsString(logRecord));
        } catch (JsonProcessingException e) {
            log.error("Failed to serialize operation log", e);
        }
        
        // データベースへの保存
        try {
            OperationLog entity = convertToEntity(logRecord);
            operationLogRepository.save(entity);
        } catch (Exception e) {
            log.error("Failed to persist operation log", e);
        }
    }
    
    // レコードからエンティティへの変換
    private OperationLog convertToEntity(OperationLogRecord record) {
        // 実装...
    }
}
```

## 7. セキュリティ対策

### 7.1 機密情報の保護

ログ内の機密情報を保護するための対策：

1. **データマスキング**:
   - パスワード、クレジットカード番号などの自動マスキング
   - 正規表現ベースのパターンマッチングによる検出と置換

2. **プロパティフィルタリング**:
   - 特定オブジェクトの特定プロパティのマスキング設定
   - JSON処理時のプロパティフィルター適用

3. **データ最小化**:
   - 必要最小限の情報のみをログに記録
   - 詳細なデバッグ情報は開発環境のみに制限

### 7.2 アクセス制御

ログデータへのアクセス制御：

1. **ログ閲覧権限**:
   - ロールベースのアクセス制御
   - ログ種別ごとの閲覧権限設定

2. **監査ログアクセス**:
   - 監査ログへのアクセスは監査権限を持つユーザーのみに制限
   - 監査ログアクセス自体も監査対象とする

3. **ログ管理権限**:
   - ログ設定変更、削除などの管理権限は厳格に制限
   - 特権アクセスの監視と記録

### 7.3 ログのセキュリティ監視

ログを活用したセキュリティ監視：

1. **異常検知**:
   - ログインの失敗パターン
   - 権限変更の異常パターン
   - データアクセスの異常パターン

2. **不正アクセス検知**:
   - ブルートフォース攻撃の検出
   - セッションハイジャックの検出
   - 権限昇格の検出

3. **アラート設定**:
   - セキュリティイベントの即時通知
   - 閾値ベースのアラート
   - パターンベースのアラート

## 8. 課題と制限事項

* **ログボリューム管理**: 大量のログデータによるストレージと処理負荷の最適化
* **パフォーマンス影響**: ロギング処理によるアプリケーションパフォーマンスへの影響軽減
* **複雑な分散環境**: マイクロサービス環境における分散トレーシングの課題
* **ログの整合性**: 複数サービス・複数サーバー間でのログの時間的整合性の確保
* **コンプライアンス対応**: 業界特有の規制やコンプライアンス要件への継続的な対応