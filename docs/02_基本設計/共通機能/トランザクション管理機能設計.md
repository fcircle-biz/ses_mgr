# SES業務システム トランザクション管理機能 基本設計書

## 1. はじめに

### 1.1 目的
本ドキュメントはSES業務システムにおけるトランザクション管理機能の設計について定義します。システム全体でのデータ整合性を確保するためのトランザクション境界、分散トランザクション、例外処理における実装方針について詳細に記述します。

### 1.2 対象読者
- システム設計者
- 開発者
- データベース管理者
- QAエンジニア

### 1.3 前提条件
- システムはマイクロサービスアーキテクチャに基づいて構築されている
- バックエンドはSpring Bootを使用
- データベースはPostgreSQLを主要DBとして使用
- 一部のデータはNoSQLデータベース（MongoDB）に格納される

## 2. 機能概要

### 2.1 主な機能
1. **トランザクション境界管理**
   - サービスレベルのトランザクション境界定義
   - トランザクション伝播設定
   - 読み取り専用トランザクション最適化

2. **分散トランザクション管理**
   - マイクロサービス間トランザクション連携
   - 複数データソース間トランザクション制御
   - Saga パターンによる補償トランザクション

3. **トランザクション例外処理**
   - トランザクション失敗時の例外ハンドリング
   - リトライメカニズム
   - デッドロック検出と回避

4. **トランザクションログ**
   - トランザクションの監査ログ記録
   - パフォーマンスモニタリング
   - 異常検知

### 2.2 機能の適用範囲
トランザクション管理機能は、以下のような業務シナリオで特に重要となります：

- **契約管理**: 契約書生成、承認フロー、電子署名など複数ステップが連携する処理
- **請求支払管理**: 請求書生成、入金処理、支払処理など複数の台帳を更新する処理
- **マッチング機能**: 案件と技術者のマッチング処理、提案管理など複数エンティティの更新が必要な処理
- **勤怠工数管理**: 勤怠データ登録、承認、工数集計など連続した処理フロー

## 3. 詳細設計

### 3.1 トランザクション境界管理

トランザクション境界は、一連の処理が原子的に実行されるべき範囲を定義します。

#### 3.1.1 トランザクション境界設計原則

1. **サービスレイヤーでのトランザクション管理**
   - プレゼンテーションレイヤーやリポジトリレイヤーではなく、サービスレイヤーでトランザクションを管理
   - ビジネスロジックを含むメソッドをトランザクション境界として定義

2. **最小限のトランザクション範囲**
   - トランザクションの範囲は必要最小限に保つ
   - 長時間実行トランザクションを避ける

3. **読み取り/書き込みの分離**
   - 読み取り専用処理は明示的に指定して最適化
   - 書き込みを含む処理は適切な分離レベルで制御

#### 3.1.2 トランザクション属性の設計

**Spring 実装例**:

```java
@Service
public class ContractService {

    @Autowired
    private ContractRepository contractRepository;
    
    @Autowired
    private ContractHistoryRepository historyRepository;
    
    @Autowired
    private NotificationService notificationService;
    
    // 標準的なトランザクション（暗黙的にPROPAGATION_REQUIRED）
    @Transactional
    public Contract createContract(ContractDTO contractDTO) {
        // 契約データの作成処理
        Contract contract = new Contract();
        // プロパティのマッピング
        contract = contractRepository.save(contract);
        
        // 履歴データの作成
        ContractHistory history = new ContractHistory();
        history.setContract(contract);
        history.setAction(ActionType.CREATE);
        historyRepository.save(history);
        
        return contract;
    }
    
    // 読み取り専用トランザクション
    @Transactional(readOnly = true)
    public List<Contract> findContracts(SearchCriteria criteria) {
        return contractRepository.findByCriteria(criteria);
    }
    
    // 既存トランザクションに参加するが、なければ新規作成しない
    @Transactional(propagation = Propagation.SUPPORTS)
    public void logContractAccess(String contractId, String userId) {
        // アクセスログ記録処理
    }
    
    // 新規トランザクションを常に作成（既存のものがあっても別トランザクション）
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void sendContractNotification(String contractId) {
        Contract contract = contractRepository.findById(contractId)
            .orElseThrow(() -> new NotFoundException("契約が見つかりません"));
        
        // 通知送信処理（トランザクション失敗時にロールバックされないよう分離）
        notificationService.sendContractNotification(contract);
    }
    
    // トランザクション分離レベルを明示的に指定
    @Transactional(isolation = Isolation.SERIALIZABLE)
    public void approveContract(String contractId, String approverId) {
        // 承認処理（高い分離レベルで一貫性を保証）
    }
}
```

### 3.2 分散トランザクション管理

マイクロサービスアーキテクチャでは、複数のサービスやデータソースにまたがるトランザクション管理が必要となります。

#### 3.2.1 サービス間トランザクション連携パターン

本システムでは、以下のパターンを採用します：

1. **Saga パターン**
   - 複数のマイクロサービスにまたがる長時間実行トランザクション
   - 各ステップに対応する補償トランザクション（補償的アクション）を定義
   - 障害発生時は実行済みのステップを補償トランザクションで巻き戻し

2. **Two-Phase Commit（2PC）の回避**
   - パフォーマンスとスケーラビリティの観点から2PCは原則として使用しない
   - 代わりに結果整合性（Eventual Consistency）を許容するアプローチを採用

3. **イベントドリブンアプローチ**
   - トランザクション完了をイベントとして発行
   - 後続のサービスはイベントを受け取って処理を実行
   - 冪等性を確保して、イベントの重複処理に対応

#### 3.2.2 Saga パターンの実装

**オーケストレーション型Sagaの例（請求書発行処理）**:

```java
@Service
public class InvoiceOrchestrator {

    @Autowired
    private InvoiceService invoiceService;
    
    @Autowired
    private ProjectService projectService;
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private NotificationService notificationService;
    
    public InvoiceResult createAndSendInvoice(InvoiceRequest request) {
        InvoiceContext context = new InvoiceContext();
        context.setRequestId(UUID.randomUUID().toString());
        context.setInvoiceRequest(request);
        
        try {
            // ステップ1: 請求書データ作成
            InvoiceData invoiceData = invoiceService.createInvoice(request);
            context.setInvoiceId(invoiceData.getId());
            
            // ステップ2: プロジェクト状態更新
            projectService.updateProjectBillingStatus(request.getProjectId(), BillingStatus.INVOICED);
            
            // ステップ3: 支払い期日設定
            paymentService.createPaymentSchedule(invoiceData.getId(), invoiceData.getDueDate());
            
            // ステップ4: 顧客への通知
            notificationService.sendInvoiceNotification(invoiceData.getId());
            
            return InvoiceResult.success(invoiceData.getId());
            
        } catch (InvoiceCreationException e) {
            // ステップ1で失敗 - 補償アクションなし
            log.error("請求書作成に失敗しました", e);
            return InvoiceResult.failure("請求書作成エラー: " + e.getMessage());
            
        } catch (ProjectUpdateException e) {
            // ステップ2で失敗 - ステップ1を補償
            log.error("プロジェクト状態更新に失敗しました", e);
            compensateInvoiceCreation(context.getInvoiceId());
            return InvoiceResult.failure("プロジェクト更新エラー: " + e.getMessage());
            
        } catch (PaymentScheduleException e) {
            // ステップ3で失敗 - ステップ1と2を補償
            log.error("支払い期日設定に失敗しました", e);
            compensateProjectUpdate(request.getProjectId());
            compensateInvoiceCreation(context.getInvoiceId());
            return InvoiceResult.failure("支払いスケジュールエラー: " + e.getMessage());
            
        } catch (NotificationException e) {
            // ステップ4で失敗 - 通知は重要度が低いため補償なしでも可
            log.warn("請求書通知の送信に失敗しました", e);
            // トランザクション自体は成功とみなす
            return InvoiceResult.partialSuccess(context.getInvoiceId(), "請求書は作成されましたが、通知送信に失敗しました");
        }
    }
    
    // 補償トランザクション（補償的アクション）
    private void compensateInvoiceCreation(String invoiceId) {
        try {
            invoiceService.cancelInvoice(invoiceId);
        } catch (Exception e) {
            log.error("請求書作成の補償処理に失敗しました: " + invoiceId, e);
            // 補償失敗をモニタリングシステムに通知
            alertFailedCompensation("invoice_creation", invoiceId);
        }
    }
    
    private void compensateProjectUpdate(String projectId) {
        try {
            projectService.revertBillingStatus(projectId);
        } catch (Exception e) {
            log.error("プロジェクト更新の補償処理に失敗しました: " + projectId, e);
            alertFailedCompensation("project_update", projectId);
        }
    }
    
    private void alertFailedCompensation(String step, String entityId) {
        // モニタリングアラート送信
    }
}
```

#### 3.2.3 複数データソース間トランザクション

2つ以上のデータソースを使用する場合の実装例：

```java
@Configuration
@EnableTransactionManagement
public class TransactionConfig {

    @Autowired
    @Qualifier("primaryDataSource")
    private DataSource primaryDataSource;
    
    @Autowired
    @Qualifier("secondaryDataSource")
    private DataSource secondaryDataSource;
    
    @Primary
    @Bean(name = "primaryTransactionManager")
    public PlatformTransactionManager primaryTransactionManager() {
        return new DataSourceTransactionManager(primaryDataSource);
    }
    
    @Bean(name = "secondaryTransactionManager")
    public PlatformTransactionManager secondaryTransactionManager() {
        return new DataSourceTransactionManager(secondaryDataSource);
    }
    
    @Bean(name = "chainedTransactionManager")
    public ChainedTransactionManager chainedTransactionManager(
            @Qualifier("primaryTransactionManager") PlatformTransactionManager primaryTM,
            @Qualifier("secondaryTransactionManager") PlatformTransactionManager secondaryTM) {
        return new ChainedTransactionManager(primaryTM, secondaryTM);
    }
}

@Service
public class MultiDatabaseService {

    // ChainedTransactionManager を使用した複数データソース間のトランザクション
    @Transactional(value = "chainedTransactionManager")
    public void processMultiDatabaseOperation(EntityDto dto) {
        // 複数のデータソースにまたがる処理
    }
}
```

**注意事項**:
- ChainedTransactionManager は真のXAトランザクションではなく、順次コミットするため部分的な失敗の可能性がある
- 重要なビジネストランザクションでは、Saga パターンなどの追加的な仕組みを検討

### 3.3 トランザクション例外処理

#### 3.3.1 例外分類とハンドリング

例外は以下の2つに大きく分類します：

1. **チェック例外**: 回復可能な例外
   - ビジネスルール違反
   - 一時的なシステム障害
   - リソース制約

2. **非チェック例外**: 回復不可能な例外
   - システム内部エラー
   - データ破損
   - 予期しない障害

**例外ハンドリングの実装例**:

```java
@Service
public class BillingService {

    @Autowired
    private InvoiceRepository invoiceRepository;
    
    @Autowired
    private TransactionRetryHelper retryHelper;
    
    // リトライ可能なトランザクション
    @Transactional
    @Retryable(
        include = {ConcurrencyFailureException.class, LockTimeoutException.class},
        maxAttempts = 3,
        backoff = @Backoff(delay = 1000, multiplier = 2)
    )
    public Invoice generateInvoice(InvoiceGenerationRequest request) {
        // 請求書生成ロジック
        // ConcurrencyFailureExceptionやLockTimeoutExceptionが発生した場合は
        // 指定された回数だけリトライされる
    }
    
    // リカバリメソッド（最大リトライ回数を超えた場合に呼ばれる）
    @Recover
    public Invoice recoverFromTransactionFailure(Exception e, InvoiceGenerationRequest request) {
        // リトライ失敗後の回復処理
        // 例: 一時保存状態で請求書を作成し、手動処理用のタスクを作成
        Invoice incompleteInvoice = new Invoice();
        incompleteInvoice.setStatus(InvoiceStatus.DRAFT);
        incompleteInvoice.setErrorFlag(true);
        incompleteInvoice.setErrorMessage("トランザクション失敗: " + e.getMessage());
        
        // リトライ失敗を管理者に通知
        notifyAdminOfRetryFailure(request, e);
        
        return invoiceRepository.save(incompleteInvoice);
    }
    
    // デッドロック検出と特別処理
    @Transactional
    public void processPayment(String invoiceId, PaymentData paymentData) {
        try {
            // 支払い処理ロジック
        } catch (DeadlockLoserDataAccessException e) {
            // デッドロック検出時の特別処理
            log.warn("デッドロックを検出しました。処理を再スケジュールします: " + invoiceId);
            scheduleDeferredPaymentProcessing(invoiceId, paymentData);
            throw new PaymentProcessingException("デッドロックにより処理が延期されました", e);
        }
    }
}
```

#### 3.3.2 トランザクション監視とデバッグ

システムのトランザクション処理を監視するために、以下の仕組みを実装します：

1. **トランザクションログ**
   - トランザクション開始・終了
   - トランザクションID
   - 処理時間
   - 結果ステータス

2. **トランザクション統計**
   - トランザクション種別ごとの成功率
   - 平均処理時間
   - リトライ回数

**トランザクションアスペクトの実装例**:

```java
@Aspect
@Component
public class TransactionMonitoringAspect {

    private static final Logger log = LoggerFactory.getLogger(TransactionMonitoringAspect.class);
    
    @Autowired
    private TransactionStatisticsService statisticsService;
    
    // トランザクションメソッドをターゲットにするポイントカット
    @Pointcut("@annotation(org.springframework.transaction.annotation.Transactional)")
    public void transactionalMethod() {}
    
    @Around("transactionalMethod()")
    public Object monitorTransaction(ProceedingJoinPoint joinPoint) throws Throwable {
        String transactionId = UUID.randomUUID().toString();
        String methodName = joinPoint.getSignature().toShortString();
        long startTime = System.currentTimeMillis();
        
        MDC.put("transactionId", transactionId);
        log.info("トランザクション開始: {}", methodName);
        
        try {
            // トランザクションの実行
            Object result = joinPoint.proceed();
            
            // 成功記録
            long duration = System.currentTimeMillis() - startTime;
            log.info("トランザクション成功: {} (所要時間: {}ms)", methodName, duration);
            statisticsService.recordTransactionSuccess(methodName, duration);
            
            return result;
            
        } catch (Throwable t) {
            // 失敗記録
            long duration = System.currentTimeMillis() - startTime;
            log.error("トランザクション失敗: {} (所要時間: {}ms)", methodName, duration, t);
            statisticsService.recordTransactionFailure(methodName, t.getClass().getName(), duration);
            throw t;
            
        } finally {
            MDC.remove("transactionId");
        }
    }
}
```

### 3.4 アプリケーション固有のトランザクションシナリオ

#### 3.4.1 契約管理トランザクション

契約管理における重要なトランザクションシナリオ：

1. **契約書生成と保存**
   - 契約データ保存
   - 契約書ドキュメント生成
   - ファイルストレージへの保存
   - 履歴記録

2. **契約承認フロー**
   - 承認状態更新
   - 承認履歴記録
   - 次承認者への通知

#### 3.4.2 請求支払トランザクション

請求支払管理における重要なトランザクションシナリオ：

1. **請求書発行処理**
   - 請求データ作成
   - 請求明細生成
   - 消費税計算
   - PDF生成と保存
   - 請求履歴更新

2. **入金処理**
   - 入金データ登録
   - 請求残高更新
   - 入金消込処理
   - 消込状態更新

#### 3.4.3 勤怠工数承認トランザクション

勤怠工数管理における重要なトランザクションシナリオ：

1. **勤怠データ承認**
   - 勤怠データロック
   - 承認状態更新
   - 承認履歴記録
   - 集計データ更新

2. **工数データ集計**
   - 日次データロック
   - 月次集計
   - プロジェクト別集計
   - 請求データ連携

## 4. API設計

### 4.1 トランザクション管理に関するAPI

#### 4.1.1 トランザクション状態確認API

**エンドポイント**: `GET /api/v1/admin/transactions/{transactionId}`

**レスポンス例**:
```json
{
  "data": {
    "transactionId": "tx-12345",
    "status": "COMPLETED",
    "startTime": "2023-05-01T10:30:45.123Z",
    "endTime": "2023-05-01T10:30:48.456Z",
    "duration": 3333,
    "initiatedBy": "system",
    "steps": [
      {
        "stepId": 1,
        "name": "ContractDataCreation",
        "status": "COMPLETED",
        "startTime": "2023-05-01T10:30:45.123Z",
        "endTime": "2023-05-01T10:30:46.234Z"
      },
      {
        "stepId": 2,
        "name": "DocumentGeneration",
        "status": "COMPLETED",
        "startTime": "2023-05-01T10:30:46.235Z",
        "endTime": "2023-05-01T10:30:47.345Z"
      },
      {
        "stepId": 3,
        "name": "NotificationSending",
        "status": "COMPLETED",
        "startTime": "2023-05-01T10:30:47.346Z",
        "endTime": "2023-05-01T10:30:48.456Z"
      }
    ]
  }
}
```

#### 4.1.2 トランザクション管理ダッシュボードAPI

**エンドポイント**: `GET /api/v1/admin/transactions/dashboard`

**レスポンス例**:
```json
{
  "data": {
    "summary": {
      "totalTransactions": 1250,
      "successfulTransactions": 1230,
      "failedTransactions": 20,
      "successRate": 98.4,
      "averageDuration": 245.7
    },
    "byType": [
      {
        "type": "ContractCreation",
        "count": 350,
        "successRate": 99.1,
        "averageDuration": 320.5
      },
      {
        "type": "InvoiceGeneration",
        "count": 480,
        "successRate": 98.5,
        "averageDuration": 275.8
      },
      {
        "type": "PaymentProcessing",
        "count": 420,
        "successRate": 97.6,
        "averageDuration": 150.3
      }
    ],
    "recentFailures": [
      {
        "transactionId": "tx-12340",
        "type": "PaymentProcessing",
        "timestamp": "2023-05-01T09:45:23.456Z",
        "errorMessage": "デッドロックにより処理が失敗しました"
      },
      {
        "transactionId": "tx-12330",
        "type": "InvoiceGeneration",
        "timestamp": "2023-05-01T08:32:11.789Z",
        "errorMessage": "データベース接続タイムアウト"
      }
    ]
  }
}
```

### 4.2 補償トランザクションAPI

#### 4.2.1 補償トランザクション実行API

**エンドポイント**: `POST /api/v1/admin/transactions/{transactionId}/compensate`

**リクエスト例**:
```json
{
  "reason": "システム管理者による手動補償",
  "administratorId": "admin123"
}
```

**レスポンス例**:
```json
{
  "data": {
    "compensationId": "comp-45678",
    "transactionId": "tx-12345",
    "status": "COMPLETED",
    "steps": [
      {
        "stepId": 3,
        "name": "ReverseNotificationSending",
        "status": "COMPLETED"
      },
      {
        "stepId": 2,
        "name": "ReverseDocumentGeneration",
        "status": "COMPLETED"
      },
      {
        "stepId": 1,
        "name": "ReverseContractDataCreation",
        "status": "COMPLETED"
      }
    ],
    "completedAt": "2023-05-01T11:15:22.456Z"
  }
}
```

## 5. 技術実装

### 5.1 使用技術

- **トランザクション管理**: Spring Framework の `@Transactional`
- **分散トランザクション**: Saga パターン、Eventual Consistency
- **メッセージング**: RabbitMQ / Apache Kafka（イベント駆動アーキテクチャ用）
- **リトライ機構**: Spring Retry
- **モニタリング**: Micrometer + Prometheus + Grafana

### 5.2 トランザクション管理サービス

```java
@Service
public class TransactionLogService {

    @Autowired
    private TransactionLogRepository logRepository;
    
    @Autowired
    private TransactionStepRepository stepRepository;
    
    public void logTransactionStart(String transactionType, String initiatedBy) {
        String transactionId = generateTransactionId();
        MDC.put("transactionId", transactionId);
        
        TransactionLog log = new TransactionLog();
        log.setTransactionId(transactionId);
        log.setType(transactionType);
        log.setStatus(TransactionStatus.IN_PROGRESS);
        log.setStartTime(LocalDateTime.now());
        log.setInitiatedBy(initiatedBy);
        
        logRepository.save(log);
        
        return transactionId;
    }
    
    public void logTransactionStep(String transactionId, String stepName, TransactionStepStatus status) {
        TransactionStep step = new TransactionStep();
        step.setTransactionId(transactionId);
        step.setName(stepName);
        step.setStatus(status);
        step.setTimestamp(LocalDateTime.now());
        
        stepRepository.save(step);
    }
    
    public void completeTransaction(String transactionId, TransactionStatus status) {
        TransactionLog log = logRepository.findById(transactionId)
            .orElseThrow(() -> new IllegalArgumentException("トランザクションログが見つかりません: " + transactionId));
        
        log.setStatus(status);
        log.setEndTime(LocalDateTime.now());
        log.setDuration(Duration.between(log.getStartTime(), log.getEndTime()).toMillis());
        
        logRepository.save(log);
        MDC.remove("transactionId");
    }
    
    private String generateTransactionId() {
        return "tx-" + UUID.randomUUID().toString();
    }
}

@Service
public class CompensationTransactionService {

    @Autowired
    private TransactionLogService logService;
    
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    // コンペンセーションハンドラーのレジストリ
    private Map<String, CompensationHandler> handlers = new HashMap<>();
    
    // ハンドラー登録
    @PostConstruct
    public void registerHandlers() {
        handlers.put("ContractCreation", new ContractCreationCompensationHandler());
        handlers.put("InvoiceGeneration", new InvoiceGenerationCompensationHandler());
        // その他のハンドラー登録
    }
    
    // 補償トランザクション実行
    @Transactional
    public CompensationResult compensateTransaction(String transactionId, String reason, String requestedBy) {
        // トランザクションログ取得
        TransactionLog log = logRepository.findById(transactionId)
            .orElseThrow(() -> new NotFoundException("トランザクション " + transactionId + " が見つかりません"));
        
        // 補償可能かチェック
        if (log.getStatus() != TransactionStatus.COMPLETED && log.getStatus() != TransactionStatus.FAILED) {
            throw new IllegalStateException("補償できないトランザクション状態です: " + log.getStatus());
        }
        
        // 補償ID生成
        String compensationId = "comp-" + UUID.randomUUID().toString();
        
        try {
            // 補償ログ開始
            CompensationLog compLog = new CompensationLog();
            compLog.setCompensationId(compensationId);
            compLog.setTransactionId(transactionId);
            compLog.setReason(reason);
            compLog.setRequestedBy(requestedBy);
            compLog.setStatus(CompensationStatus.IN_PROGRESS);
            compLog.setStartTime(LocalDateTime.now());
            compensationLogRepository.save(compLog);
            
            // イベント発行
            eventPublisher.publishEvent(new CompensationStartedEvent(compensationId, transactionId));
            
            // 補償処理実行
            CompensationHandler handler = handlers.get(log.getType());
            if (handler == null) {
                throw new UnsupportedOperationException("補償ハンドラーが定義されていません: " + log.getType());
            }
            
            // 補償ステップを逆順で実行
            List<TransactionStep> steps = stepRepository.findByTransactionIdOrderByTimestampDesc(transactionId);
            List<CompensationStepResult> stepResults = new ArrayList<>();
            
            for (TransactionStep step : steps) {
                try {
                    // 補償ステップ実行
                    CompensationStepResult stepResult = handler.compensateStep(step.getName(), transactionId);
                    stepResults.add(stepResult);
                    
                    // ステップログ記録
                    logCompensationStep(compensationId, step.getName(), stepResult.isSuccess());
                    
                } catch (Exception e) {
                    // ステップ失敗ログ
                    logCompensationStep(compensationId, step.getName(), false);
                    throw new CompensationException("補償ステップの実行に失敗しました: " + step.getName(), e);
                }
            }
            
            // 補償完了ログ
            compLog.setStatus(CompensationStatus.COMPLETED);
            compLog.setEndTime(LocalDateTime.now());
            compLog.setDuration(Duration.between(compLog.getStartTime(), compLog.getEndTime()).toMillis());
            compensationLogRepository.save(compLog);
            
            // 元トランザクションを補償済みとしてマーク
            log.setCompensated(true);
            log.setCompensationId(compensationId);
            logRepository.save(log);
            
            // イベント発行
            eventPublisher.publishEvent(new CompensationCompletedEvent(compensationId, transactionId));
            
            return CompensationResult.success(compensationId, stepResults);
            
        } catch (Exception e) {
            // 補償失敗ログ
            CompensationLog compLog = compensationLogRepository.findById(compensationId)
                .orElseThrow(() -> new IllegalStateException("補償ログが見つかりません"));
            
            compLog.setStatus(CompensationStatus.FAILED);
            compLog.setEndTime(LocalDateTime.now());
            compLog.setDuration(Duration.between(compLog.getStartTime(), compLog.getEndTime()).toMillis());
            compLog.setErrorMessage(e.getMessage());
            compensationLogRepository.save(compLog);
            
            // イベント発行
            eventPublisher.publishEvent(new CompensationFailedEvent(compensationId, transactionId, e));
            
            throw new CompensationException("トランザクション補償に失敗しました: " + transactionId, e);
        }
    }
    
    private void logCompensationStep(String compensationId, String stepName, boolean success) {
        CompensationStep step = new CompensationStep();
        step.setCompensationId(compensationId);
        step.setStepName("Reverse" + stepName);
        step.setStatus(success ? CompensationStepStatus.COMPLETED : CompensationStepStatus.FAILED);
        step.setTimestamp(LocalDateTime.now());
        compensationStepRepository.save(step);
    }
}
```

### 5.3 実装上の注意点

1. **トランザクション伝播設定**
   - サービスメソッド間の呼び出しでトランザクション伝播に注意
   - 特に `REQUIRES_NEW` の使用は、新しいトランザクションを開始するため注意が必要

2. **リトライと冪等性**
   - リトライ可能な操作は冪等性を確保
   - ユニークなIDやバージョン管理で重複実行を検出

3. **長時間トランザクションの回避**
   - パフォーマンスとロック競合の観点から、長時間実行トランザクションを避ける
   - 長時間処理は複数の小さなトランザクションに分割

4. **デッドロック対策**
   - 一貫したリソースアクセス順序を維持
   - デッドロック検出時の適切なリトライ戦略

## 6. セキュリティ考慮事項

### 6.1 トランザクションセキュリティ

1. **トランザクション操作の監査**
   - トランザクション操作（特に補償トランザクション）はすべて監査ログに記録
   - 誰が、いつ、なぜ操作を行ったかを追跡可能に

2. **権限分離**
   - 通常のトランザクション実行と補償トランザクション実行の権限を分離
   - 補償トランザクション実行は上位権限者のみに制限

3. **トランザクションデータの保護**
   - トランザクションログには機密情報を含めない
   - 参照情報のみを保存し、詳細は別途セキュアに管理

## 7. 制限事項・今後の課題

### 7.1 現状の制限

- 現時点ではシステム内の一部の重要なトランザクションのみSagaパターンを適用
- 長時間実行トランザクションのモニタリングとタイムアウト処理の強化が必要
- 多数のサービスにまたがる分散トランザクションのエンドツーエンドテストが複雑

### 7.2 今後の拡張予定

- トランザクション進行状況の可視化ダッシュボード
- 障害検知と自動リカバリーメカニズムの強化
- AIベースのトランザクションパターン分析による問題予測

## 8. 参考資料

- [Spring Transaction Management](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction)
- [Saga Pattern](https://microservices.io/patterns/data/saga.html)
- [Patterns for Distributed Transactions within a Microservices Architecture](https://developers.redhat.com/blog/2018/10/01/patterns-for-distributed-transactions-within-a-microservices-architecture)
- [Eventual Consistency in Distributed Systems](https://www.allthingsdistributed.com/2008/12/eventually_consistent.html)