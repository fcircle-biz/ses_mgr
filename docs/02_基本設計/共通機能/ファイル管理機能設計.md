# ファイル管理機能設計書

## 1. 概要

ファイル管理機能は、SES業務システム全体で使用されるファイルを一元的に管理するための共通基盤である。この機能により、契約書、請求書、スキルシート、案件資料などのファイルを安全に保存、取得、管理することが可能になる。

### 1.1 目的

ファイル管理機能は以下の目的で設計される：

1. **一元管理**: 複数の業務モジュールで使用されるファイルを一元的に管理する
2. **安全性確保**: 機密性の高い文書も安全に保存・管理できる仕組みを提供する
3. **アクセス制御**: 各ファイルのアクセス権限を適切に管理する
4. **柔軟な保存期間**: ファイルの種類に応じた保存期間と削除ポリシーを提供する
5. **スケーラビリティ**: 増大するデータ量に対応できる拡張性の高い設計を実現する

### 1.2 ファイルの種類と用途

本システムでは以下の種類のファイルを管理する：

| ファイル種類 | 説明 | 関連業務モジュール |
|------------|------|-----------------|
| contract | 契約書、覚書、付属文書など | 契約管理 |
| invoice | 請求書、支払通知書など | 請求支払管理 |
| skill_sheet | 技術者のスキルシート | 技術者管理 |
| project_document | 案件説明書、要件定義書など | 案件管理 |
| common | システム共通で使用される資料 | 全般 |

### 1.3 ファイル形式

対応するファイル形式は以下の通り：

- **ドキュメント**: PDF, Word (.docx), Excel (.xlsx), PowerPoint (.pptx), Text (.txt)
- **画像**: JPEG (.jpg, .jpeg), PNG (.png), GIF (.gif), SVG (.svg)
- **圧縮ファイル**: ZIP (.zip)
- **その他**: CSV (.csv), JSON (.json)

セキュリティ上の理由から、実行可能ファイル（.exe, .bat, .sh など）はアップロード不可とする。

## 2. アーキテクチャ設計

### 2.1 全体アーキテクチャ

ファイル管理機能は以下のコンポーネントで構成される：

```
[業務アプリケーション] ---> [ファイル管理API] ---> [ファイルサービス]
                                    |                      |
                                    v                      v
                          [メタデータストレージ]    [ファイルストレージ]
                           (データベース)          (オブジェクトストレージ)
```

### 2.2 コンポーネント説明

#### 2.2.1 ファイル管理API

REST APIとして提供され、以下の機能を実装する：

- ファイルのアップロード
- ファイルのダウンロード
- ファイルメタデータの取得
- ファイルの削除（論理削除）

#### 2.2.2 ファイルサービス

ファイル操作のコアロジックを担当し、以下の責務を持つ：

- ファイルの保存と取得
- ファイルのバリデーション（サイズ、形式チェック）
- ファイルの暗号化と復号
- アクセス権限の検証
- ファイルメタデータの管理

#### 2.2.3 メタデータストレージ

ファイルに関するメタデータを保存するためのリレーショナルデータベース。以下の情報を管理する：

- ファイルID
- ファイル名
- MIME Type
- サイズ
- 作成者
- 作成日時
- ファイルの種類（contract, invoice など）
- 関連リソースID
- アクセス権限情報
- タグ情報
- 論理削除フラグ
- SHA-256ハッシュ値

#### 2.2.4 ファイルストレージ

実際のファイルバイナリデータを保存するためのオブジェクトストレージ。以下の特性を持つ：

- 暗号化ストレージ
- 冗長化構成
- スケーラブルな容量
- バックアップ機能

### 2.3 ストレージ構成

ファイルストレージの構成は以下の通り：

```
[ストレージサービス]
    |
    |-- [インメモリキャッシュ] - 頻繁に使用されるファイルの一時保存
    |
    |-- [ファイルシステム] - AES-256で暗号化された実体ファイル
    |   |
    |   |-- /contracts/YYYY/MM/[file-id]
    |   |-- /invoices/YYYY/MM/[file-id]
    |   |-- /skill_sheets/YYYY/MM/[file-id]
    |   |-- /project_documents/YYYY/MM/[file-id]
    |   |-- /common/YYYY/MM/[file-id]
    |
    |-- [アーカイブストレージ] - 長期保管用低コストストレージ
        |
        |-- /archived/contracts/YYYY/[file-id]
        |-- /archived/invoices/YYYY/[file-id]
        |-- ...
```

## 3. データモデル設計

### 3.1 ファイル（File）エンティティ

ファイルのメタデータを管理するエンティティ

```java
@Entity
@Table(name = "files")
public class File {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;
    
    @Column(nullable = false)
    private String fileName;
    
    @Column(nullable = false)
    private String mimeType;
    
    @Column(nullable = false)
    private long size;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private FileType fileType;
    
    @Column
    private String resourceId;
    
    @Column
    private String description;
    
    @Column
    private String path;  // ストレージ内の相対パス
    
    @Column(nullable = false)
    private String sha256Hash;  // ファイル整合性検証用ハッシュ値
    
    @ElementCollection
    @CollectionTable(name = "file_tags", joinColumns = @JoinColumn(name = "file_id"))
    @Column(name = "tag")
    private Set<String> tags = new HashSet<>();
    
    @Column(nullable = false)
    private boolean isPublic = false;
    
    @Column
    private LocalDateTime expiryDate;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    @Column
    private LocalDateTime updatedAt;
    
    @ManyToOne
    @JoinColumn(name = "created_by", nullable = false)
    private User createdBy;
    
    @Column(nullable = false)
    private boolean deleted = false;
    
    @Column
    private LocalDateTime deletedAt;
    
    // getters, setters, etc.
}
```

### 3.2 ファイルタイプ（FileType）列挙型

ファイルの種類を定義する列挙型

```java
public enum FileType {
    CONTRACT("契約書"),
    INVOICE("請求書"),
    SKILL_SHEET("スキルシート"),
    PROJECT_DOCUMENT("案件資料"),
    COMMON("共通資料");
    
    private final String displayName;
    
    FileType(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}
```

### 3.3 ファイルアクセス（FileAccess）エンティティ

ファイルへのアクセス権限を管理するエンティティ

```java
@Entity
@Table(name = "file_access")
public class FileAccess {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "file_id", nullable = false)
    private File file;
    
    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
    
    @ManyToOne
    @JoinColumn(name = "role_id")
    private Role role;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private AccessType accessType;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    // getters, setters, etc.
}
```

### 3.4 アクセスタイプ（AccessType）列挙型

アクセス権限のタイプを定義する列挙型

```java
public enum AccessType {
    READ,       // 読み取り権限
    WRITE,      // 書き込み権限
    DELETE,     // 削除権限
    ADMIN       // 管理者権限
}
```

### 3.5 ファイルダウンロード履歴（FileDownloadHistory）エンティティ

ファイルダウンロードの履歴を管理するエンティティ

```java
@Entity
@Table(name = "file_download_history")
public class FileDownloadHistory {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "file_id", nullable = false)
    private File file;
    
    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    @Column(nullable = false)
    private LocalDateTime downloadedAt;
    
    @Column
    private String ipAddress;
    
    @Column
    private String userAgent;
    
    // getters, setters, etc.
}
```

## 4. サービスインターフェース設計

### 4.1 ファイルサービス（FileService）

ファイルの基本操作を提供するサービス

```java
public interface FileService {
    // ファイルの保存
    FileDto saveFile(
        MultipartFile file,
        FileType fileType,
        String resourceId,
        String description,
        Set<String> tags,
        boolean isPublic,
        LocalDateTime expiryDate,
        String username
    );
    
    // ファイルの取得
    Resource getFileResource(UUID fileId, String username);
    
    // ファイルメタデータの取得
    FileDto getFileMetadata(UUID fileId, String username);
    
    // ファイルの論理削除
    void deleteFile(UUID fileId, String username, boolean permanent);
    
    // ファイルの検索
    Page<FileDto> searchFiles(
        FileType fileType,
        String resourceId,
        Set<String> tags,
        boolean includeDeleted,
        String searchText,
        Pageable pageable,
        String username
    );
    
    // ファイルの一括取得
    List<FileDto> getFilesByResourceId(String resourceId, String username);
    
    // 期限切れファイルのクリーンアップ
    int cleanupExpiredFiles();
    
    // 論理削除されたファイルのアーカイブ
    int archiveDeletedFiles(int daysAfterDeletion);
}
```

### 4.2 ファイルストレージサービス（FileStorageService）

ファイルの物理的な保存と取得を担当するサービス

```java
public interface FileStorageService {
    // ファイルの保存
    String storeFile(
        InputStream fileContent,
        String contentType,
        long contentLength,
        FileType fileType
    );
    
    // ファイルの取得
    Resource retrieveFile(String filePath);
    
    // ファイルの物理削除
    void deleteFile(String filePath);
    
    // ファイルのアーカイブ
    String archiveFile(String filePath);
    
    // SHA-256ハッシュ値の計算
    String calculateSha256(InputStream inputStream) throws IOException;
}
```

### 4.3 ファイルアクセス管理サービス（FileAccessService）

ファイルのアクセス権限を管理するサービス

```java
public interface FileAccessService {
    // アクセス権限の付与
    void grantAccess(UUID fileId, String username, AccessType accessType);
    
    // ロールへのアクセス権限付与
    void grantAccessToRole(UUID fileId, String roleName, AccessType accessType);
    
    // アクセス権限の取り消し
    void revokeAccess(UUID fileId, String username, AccessType accessType);
    
    // ユーザーのアクセス権限確認
    boolean hasAccess(UUID fileId, String username, AccessType accessType);
    
    // ファイルへのアクセス権限を持つユーザー一覧取得
    List<UserDto> getUsersWithAccess(UUID fileId, AccessType accessType);
    
    // ファイルアクセス権限のリセット（デフォルト設定に戻す）
    void resetAccessToDefault(UUID fileId);
}
```

### 4.4 ファイル検証サービス（FileValidationService）

アップロードされるファイルの検証を担当するサービス

```java
public interface FileValidationService {
    // MIME Type検証
    boolean isValidMimeType(String mimeType);
    
    // ファイルサイズ検証
    boolean isValidFileSize(long size);
    
    // ファイル内容の検証（マルウェアスキャンなど）
    ValidationResult validateFileContent(InputStream content);
    
    // ファイル名検証
    boolean isValidFileName(String fileName);
    
    // 検証結果を表す内部クラス
    class ValidationResult {
        private boolean valid;
        private String errorCode;
        private String errorMessage;
        
        // getters, setters, etc.
    }
}
```

## 5. API設計

### 5.1 ファイルアップロードAPI

```
POST /api/v1/common/files/upload
```

**リクエスト**: multipart/form-data

| パラメータ | 型 | 必須 | 説明 |
|-----------|----|----|------|
| file | file | 必須 | アップロードするファイル |
| file_type | string | 必須 | ファイルの種類（contract, invoice, skill_sheet, project_document, common） |
| resource_id | string | 任意 | 関連リソースのID（契約ID、請求書IDなど） |
| description | string | 任意 | ファイルの説明 |
| tags | string | 任意 | カンマ区切りのタグリスト |
| is_public | boolean | 任意 | 公開設定（デフォルト: false） |
| expiry_date | string | 任意 | 有効期限（ISO8601形式） |

**レスポンス**: 201 Created

```json
{
  "data": {
    "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "file_name": "契約書_2023_05.pdf",
    "file_type": "contract",
    "mime_type": "application/pdf",
    "size": 1248576,
    "description": "2023年5月締結の業務委託契約書",
    "tags": ["契約書", "業務委託", "2023年度"],
    "resource_id": "contract-123456",
    "is_public": false,
    "download_url": "/api/v1/common/files/f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "expiry_date": "2024-05-01T00:00:00.000Z",
    "created_at": "2023-05-01T10:30:00.000Z",
    "created_by": "550e8400-e29b-41d4-a716-446655440000"
  }
}
```

### 5.2 ファイルダウンロードAPI

```
GET /api/v1/common/files/{id}
```

**パスパラメータ**:

| パラメータ | 型 | 必須 | 説明 |
|-----------|----|----|------|
| id | string | 必須 | ファイルID |

**クエリパラメータ**:

| パラメータ | 型 | 必須 | 説明 |
|-----------|----|----|------|
| download | boolean | 任意 | ダウンロード指定（デフォルト: false） |

**レスポンス**: 200 OK

ファイルの内容とともに以下のヘッダーが返される：

```
Content-Type: {ファイルのMIMEタイプ}
Content-Length: {ファイルサイズ}
Content-Disposition: attachment; filename="{ファイル名}" (downloadパラメータが true の場合)
```

### 5.3 ファイルメタデータ取得API

```
GET /api/v1/common/files/metadata/{id}
```

**パスパラメータ**:

| パラメータ | 型 | 必須 | 説明 |
|-----------|----|----|------|
| id | string | 必須 | ファイルID |

**レスポンス**: 200 OK

```json
{
  "data": {
    "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "file_name": "契約書_2023_05.pdf",
    "file_type": "contract",
    "mime_type": "application/pdf",
    "size": 1248576,
    "description": "2023年5月締結の業務委託契約書",
    "tags": ["契約書", "業務委託", "2023年度"],
    "resource_id": "contract-123456",
    "resource_type": "contract",
    "is_public": false,
    "download_url": "/api/v1/common/files/f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "download_count": 5,
    "expiry_date": "2024-05-01T00:00:00.000Z",
    "created_at": "2023-05-01T10:30:00.000Z",
    "updated_at": "2023-05-02T15:45:00.000Z",
    "created_by": {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "name": "山田 太郎"
    },
    "sha256_hash": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
  }
}
```

### 5.4 ファイル削除API

```
DELETE /api/v1/common/files/{id}
```

**パスパラメータ**:

| パラメータ | 型 | 必須 | 説明 |
|-----------|----|----|------|
| id | string | 必須 | ファイルID |

**クエリパラメータ**:

| パラメータ | 型 | 必須 | 説明 |
|-----------|----|----|------|
| permanent | boolean | 任意 | 物理削除フラグ（デフォルト: false、管理者のみ指定可） |

**レスポンス**: 204 No Content

### 5.5 ファイル検索API

```
GET /api/v1/common/files/search
```

**クエリパラメータ**:

| パラメータ | 型 | 必須 | 説明 |
|-----------|----|----|------|
| file_type | string | 任意 | ファイルタイプでフィルタリング |
| resource_id | string | 任意 | 関連リソースIDでフィルタリング |
| tags | string | 任意 | タグでフィルタリング（カンマ区切り） |
| query | string | 任意 | 検索キーワード（ファイル名、説明で検索） |
| include_deleted | boolean | 任意 | 削除済みファイルを含むか（デフォルト: false） |
| page | number | 任意 | ページ番号（デフォルト: 0） |
| size | number | 任意 | ページサイズ（デフォルト: 20） |
| sort | string | 任意 | ソート条件（created_at:desc, file_name:asc など） |

**レスポンス**: 200 OK

```json
{
  "data": [
    {
      "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
      "file_name": "契約書_2023_05.pdf",
      "file_type": "contract",
      "mime_type": "application/pdf",
      "size": 1248576,
      "description": "2023年5月締結の業務委託契約書",
      "tags": ["契約書", "業務委託", "2023年度"],
      "resource_id": "contract-123456",
      "is_public": false,
      "download_url": "/api/v1/common/files/f47ac10b-58cc-4372-a567-0e02b2c3d479",
      "created_at": "2023-05-01T10:30:00.000Z",
      "created_by": {
        "id": "550e8400-e29b-41d4-a716-446655440000",
        "name": "山田 太郎"
      }
    },
    // ...他のファイル
  ],
  "pagination": {
    "current_page": 0,
    "page_size": 20,
    "total_pages": 5,
    "total_items": 93
  }
}
```

### 5.6 リソース関連ファイル取得API

```
GET /api/v1/common/files/by-resource/{resource_id}
```

**パスパラメータ**:

| パラメータ | 型 | 必須 | 説明 |
|-----------|----|----|------|
| resource_id | string | 必須 | 関連リソースID |

**クエリパラメータ**:

| パラメータ | 型 | 必須 | 説明 |
|-----------|----|----|------|
| file_type | string | 任意 | ファイルタイプでフィルタリング |

**レスポンス**: 200 OK

```json
{
  "data": [
    {
      "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
      "file_name": "契約書_2023_05.pdf",
      "file_type": "contract",
      "mime_type": "application/pdf",
      "size": 1248576,
      "description": "2023年5月締結の業務委託契約書",
      "tags": ["契約書", "業務委託", "2023年度"],
      "resource_id": "contract-123456",
      "download_url": "/api/v1/common/files/f47ac10b-58cc-4372-a567-0e02b2c3d479",
      "created_at": "2023-05-01T10:30:00.000Z"
    },
    // ...他のファイル
  ]
}
```

## 6. ファイルアクセス制御

### 6.1 基本アクセス制御ルール

| ファイルの種類 | アクセス権限を持つユーザー |
|--------------|------------------------|
| contract | 契約の作成者、契約に関連する取引先担当者、契約管理権限を持つユーザー、システム管理者 |
| invoice | 請求書の作成者、請求書に関連する取引先担当者、経理担当者、システム管理者 |
| skill_sheet | スキルシートの所有者（技術者）、技術者の直属マネージャー、マッチング担当者、システム管理者 |
| project_document | 案件の作成者、案件に関連するプロジェクトメンバー、マッチング担当者、システム管理者 |
| common | 全ての認証済みユーザー |

### 6.2 アクセス権限の実装方法

アクセス制御の実装には、以下の2つの方法を組み合わせて使用する：

1. **リソースベースのアクセス制御**:
   - 関連リソース（契約、請求書など）に対するアクセス権限をチェックする
   - リソースへのアクセス権限があれば、関連ファイルにもアクセスできる

2. **明示的なアクセス制御**:
   - `file_access`テーブルで定義された明示的なアクセス権限をチェックする
   - ユーザーまたはロールに対して付与された権限に基づいてアクセスを制御する

```java
@Service
public class FileAccessServiceImpl implements FileAccessService {
    
    @Autowired
    private FileRepository fileRepository;
    
    @Autowired
    private FileAccessRepository fileAccessRepository;
    
    @Autowired
    private ResourceAccessService resourceAccessService;
    
    @Override
    public boolean hasAccess(UUID fileId, String username, AccessType accessType) {
        // ファイルが存在するか確認
        File file = fileRepository.findById(fileId)
            .orElseThrow(() -> new ResourceNotFoundException("File not found"));
            
        // システム管理者は常にアクセス可能
        if (isSystemAdmin(username)) {
            return true;
        }
        
        // 公開ファイルの場合、READ権限があれば全ユーザーアクセス可能
        if (file.isPublic() && accessType == AccessType.READ) {
            return true;
        }
        
        // ファイル作成者は常にアクセス可能
        if (file.getCreatedBy().getUsername().equals(username)) {
            return true;
        }
        
        // 関連リソースへのアクセス権があるかチェック
        if (file.getResourceId() != null) {
            boolean hasResourceAccess = resourceAccessService.hasAccess(
                file.getFileType().toString().toLowerCase(),
                file.getResourceId(),
                username,
                convertToResourceAccessType(accessType)
            );
            
            if (hasResourceAccess) {
                return true;
            }
        }
        
        // 明示的に付与されたアクセス権をチェック
        return fileAccessRepository.existsByFileIdAndUserUsernameAndAccessType(
            fileId, username, accessType);
    }
    
    // その他のメソッド実装...
}
```

## 7. セキュリティと暗号化

### 7.1 ファイルの暗号化方法

ファイルセキュリティを確保するため、以下の暗号化方法を適用する：

1. **保存時の暗号化**：
   - AES-256-GCM暗号化アルゴリズムを使用
   - ファイルごとに一意の暗号化キーを生成
   - 暗号化キーは鍵管理サービスで保護

2. **転送時の暗号化**：
   - TLS 1.2以上による通信の暗号化
   - HTTPS通信の強制

3. **ハッシュ値による整合性検証**：
   - SHA-256ハッシュアルゴリズムによるファイル整合性の確認
   - ダウンロード時にハッシュ値を検証し、改ざんを検知

```java
@Service
public class FileEncryptionServiceImpl implements FileEncryptionService {
    
    @Autowired
    private KeyManagementService keyManagementService;
    
    @Override
    public InputStream encrypt(InputStream inputStream, UUID fileId) throws IOException {
        // ファイルごとに一意の暗号化キーを生成
        SecretKey key = keyManagementService.generateKey();
        
        // 生成したキーをKMSに保存（ファイルIDと関連付け）
        keyManagementService.storeKey(fileId, key);
        
        // 初期化ベクトル（IV）の生成
        byte[] iv = new byte[12]; // GCMモードでは12バイトのIVを使用
        SecureRandom random = new SecureRandom();
        random.nextBytes(iv);
        
        try {
            // AES-GCM暗号化の設定
            Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
            GCMParameterSpec spec = new GCMParameterSpec(128, iv);
            cipher.init(Cipher.ENCRYPT_MODE, key, spec);
            
            // 入力ストリームを暗号化
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            // IVを先頭に書き込む
            out.write(iv);
            
            byte[] buffer = new byte[8192];
            int bytesRead;
            
            // CipherOutputStreamを使用して暗号化
            try (CipherOutputStream cipherOut = new CipherOutputStream(out, cipher)) {
                while ((bytesRead = inputStream.read(buffer)) != -1) {
                    cipherOut.write(buffer, 0, bytesRead);
                }
            }
            
            return new ByteArrayInputStream(out.toByteArray());
        } catch (Exception e) {
            throw new IOException("Encryption failed", e);
        }
    }
    
    @Override
    public InputStream decrypt(InputStream encryptedStream, UUID fileId) throws IOException {
        try {
            // KMSから暗号化キーを取得
            SecretKey key = keyManagementService.retrieveKey(fileId);
            
            // 先頭からIVを読み込む
            byte[] iv = new byte[12];
            if (encryptedStream.read(iv) != iv.length) {
                throw new IOException("Invalid encrypted data");
            }
            
            // AES-GCM復号化の設定
            Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
            GCMParameterSpec spec = new GCMParameterSpec(128, iv);
            cipher.init(Cipher.DECRYPT_MODE, key, spec);
            
            // 復号化ストリームを返す
            return new CipherInputStream(encryptedStream, cipher);
        } catch (Exception e) {
            throw new IOException("Decryption failed", e);
        }
    }
}
```

### 7.2 ウイルススキャン

アップロードされるファイルに対して、セキュリティリスクを軽減するためのウイルススキャンを実施する：

1. **スキャンのタイミング**：
   - ファイルアップロード時に即時スキャン
   - バックグラウンドでの定期的な再スキャン

2. **スキャン方法**：
   - ClamAVなどのオープンソースウイルススキャンエンジンを使用
   - マルウェア検出シグネチャの定期的な更新

```java
@Service
public class VirusScanServiceImpl implements VirusScanService {
    
    private static final Logger logger = LoggerFactory.getLogger(VirusScanServiceImpl.class);
    
    @Value("${app.virus-scan.clamav.host}")
    private String clamavHost;
    
    @Value("${app.virus-scan.clamav.port}")
    private int clamavPort;
    
    @Override
    public ScanResult scanFile(InputStream inputStream) {
        try {
            // ClamAVサーバーへの接続
            try (Socket socket = new Socket(clamavHost, clamavPort);
                 OutputStream out = socket.getOutputStream();
                 InputStream in = socket.getInputStream()) {
                
                // INSTREAM コマンドを送信
                out.write("zINSTREAM\0".getBytes(StandardCharsets.US_ASCII));
                out.flush();
                
                // ファイル内容を送信
                byte[] buffer = new byte[2048];
                int bytesRead;
                while ((bytesRead = inputStream.read(buffer)) != -1) {
                    // チャンクサイズをネットワークバイトオーダーで送信
                    byte[] size = ByteBuffer.allocate(4).putInt(bytesRead).array();
                    out.write(size);
                    out.write(buffer, 0, bytesRead);
                }
                
                // 0バイトのチャンクを送信して終了
                out.write(ByteBuffer.allocate(4).putInt(0).array());
                out.flush();
                
                // レスポンスの読み取り
                ByteArrayOutputStream responseBuffer = new ByteArrayOutputStream();
                while ((bytesRead = in.read(buffer)) != -1) {
                    responseBuffer.write(buffer, 0, bytesRead);
                }
                
                String response = responseBuffer.toString(StandardCharsets.US_ASCII);
                
                // レスポンスの解析
                if (response.contains("OK")) {
                    return new ScanResult(true, null);
                } else {
                    String virusName = response.substring(response.indexOf(": ") + 2, response.indexOf(" FOUND"));
                    return new ScanResult(false, virusName);
                }
            }
        } catch (Exception e) {
            logger.error("Virus scan failed", e);
            return new ScanResult(false, "Scan error: " + e.getMessage());
        }
    }
}
```

## 8. 業務モジュールとの統合

### 8.1 統合パターン

業務モジュールとファイル管理機能の統合には、以下のパターンを使用する：

1. **直接API呼び出し**：
   - RESTful APIを通じた直接的な統合
   - マルチパートフォームでのファイルアップロード

2. **サービス呼び出し**：
   - 依存性注入を使用した内部サービス呼び出し
   - 同一JVM内での効率的な連携

### 8.2 統合例：契約書の添付

契約管理モジュールとファイル管理機能の統合例：

```java
@Service
public class ContractServiceImpl implements ContractService {
    
    @Autowired
    private ContractRepository contractRepository;
    
    @Autowired
    private FileService fileService;
    
    @Override
    @Transactional
    public ContractDto createContract(ContractCreateRequest request, MultipartFile contractFile) {
        // 契約エンティティの作成と保存
        Contract contract = new Contract();
        contract.setTitle(request.getTitle());
        contract.setContractType(request.getContractType());
        contract.setStartDate(request.getStartDate());
        contract.setEndDate(request.getEndDate());
        contract.setClientId(request.getClientId());
        contract.setAmount(request.getAmount());
        contract.setStatus(ContractStatus.DRAFT);
        contract.setCreatedBy(SecurityUtils.getCurrentUser());
        contract.setCreatedAt(LocalDateTime.now());
        
        contract = contractRepository.save(contract);
        
        // 契約書ファイルがある場合、アップロード
        if (contractFile != null && !contractFile.isEmpty()) {
            try {
                FileDto fileDto = fileService.saveFile(
                    contractFile,
                    FileType.CONTRACT,
                    contract.getId().toString(),
                    "契約書：" + contract.getTitle(),
                    Set.of("契約書", contract.getContractType().toString()),
                    false,
                    contract.getEndDate().plusYears(7).atStartOfDay(), // 契約終了後7年保存
                    SecurityUtils.getCurrentUsername()
                );
                
                // 契約書ファイルIDを契約に紐づける
                contract.setContractFileId(UUID.fromString(fileDto.getId()));
                contract = contractRepository.save(contract);
                
            } catch (Exception e) {
                // エラーハンドリング
                throw new FileUploadException("Failed to upload contract file", e);
            }
        }
        
        return contractMapper.toDto(contract);
    }
    
    @Override
    public Resource downloadContractFile(Long contractId) {
        Contract contract = contractRepository.findById(contractId)
            .orElseThrow(() -> new ResourceNotFoundException("Contract not found"));
            
        if (contract.getContractFileId() == null) {
            throw new ResourceNotFoundException("Contract file not found");
        }
        
        // ファイルサービスからファイルを取得
        return fileService.getFileResource(
            contract.getContractFileId(),
            SecurityUtils.getCurrentUsername()
        );
    }
}
```

### 8.3 統合例：スキルシートの管理

技術者管理モジュールとファイル管理機能の統合例：

```java
@Service
public class EngineerServiceImpl implements EngineerService {
    
    @Autowired
    private EngineerRepository engineerRepository;
    
    @Autowired
    private FileService fileService;
    
    @Override
    @Transactional
    public void uploadSkillSheet(Long engineerId, MultipartFile skillSheetFile) {
        Engineer engineer = engineerRepository.findById(engineerId)
            .orElseThrow(() -> new ResourceNotFoundException("Engineer not found"));
        
        // スキルシートのアップロード
        try {
            FileDto fileDto = fileService.saveFile(
                skillSheetFile,
                FileType.SKILL_SHEET,
                "engineer-" + engineerId,
                engineer.getName() + "のスキルシート",
                Set.of("スキルシート", "技術者情報"),
                false,
                null, // 有効期限なし
                SecurityUtils.getCurrentUsername()
            );
            
            // 過去のスキルシートがある場合は非アクティブ化
            if (engineer.getActiveSkillSheetId() != null) {
                Engineer finalEngineer = engineer;
                fileService.getFileMetadata(engineer.getActiveSkillSheetId(), SecurityUtils.getCurrentUsername())
                    .ifPresent(oldFile -> {
                        Set<String> tags = new HashSet<>(oldFile.getTags());
                        tags.add("旧バージョン");
                        oldFile.setTags(tags);
                        // タグを更新
                        fileService.updateFileTags(oldFile.getId(), tags, SecurityUtils.getCurrentUsername());
                    });
            }
            
            // 新しいスキルシートをアクティブに設定
            engineer.setActiveSkillSheetId(UUID.fromString(fileDto.getId()));
            engineer.setSkillSheetUpdatedAt(LocalDateTime.now());
            engineerRepository.save(engineer);
            
        } catch (Exception e) {
            throw new FileUploadException("Failed to upload skill sheet", e);
        }
    }
    
    @Override
    public List<FileDto> getEngineerSkillSheets(Long engineerId) {
        // 技術者が存在するか確認
        if (!engineerRepository.existsById(engineerId)) {
            throw new ResourceNotFoundException("Engineer not found");
        }
        
        // 技術者に関連する全てのスキルシートを取得
        return fileService.searchFiles(
            FileType.SKILL_SHEET,
            "engineer-" + engineerId,
            null,
            false,
            null,
            PageRequest.of(0, 100, Sort.by(Sort.Direction.DESC, "createdAt")),
            SecurityUtils.getCurrentUsername()
        ).getContent();
    }
}
```

## 9. パフォーマンスと最適化

### 9.1 キャッシュ戦略

ファイル管理機能のパフォーマンスを向上させるため、以下のキャッシュ戦略を導入する：

1. **メタデータキャッシュ**:
   - ファイルメタデータを対象とした軽量なキャッシュ
   - キー: ファイルID
   - 有効期間: 10分
   - Spring Cache + Caffeine

```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        SimpleCacheManager cacheManager = new SimpleCacheManager();
        List<Cache> caches = new ArrayList<>();
        
        // ファイルメタデータキャッシュ
        caches.add(new CaffeineCache("fileMetadata", 
            Caffeine.newBuilder()
                .expireAfterWrite(10, TimeUnit.MINUTES)
                .maximumSize(1000)
                .build()));
        
        // ファイルアクセス権限キャッシュ
        caches.add(new CaffeineCache("fileAccess", 
            Caffeine.newBuilder()
                .expireAfterWrite(5, TimeUnit.MINUTES)
                .maximumSize(2000)
                .build()));
        
        cacheManager.setCaches(caches);
        return cacheManager;
    }
}
```

2. **コンテンツキャッシュ**:
   - 頻繁にアクセスされる小さいファイル対象
   - 容量制限: 最大100MB
   - 有効期間: 最終アクセスから5分

```java
@Service
public class FileContentCacheServiceImpl implements FileContentCacheService {
    
    // LRUキャッシュの実装
    private final Map<UUID, CachedFileContent> contentCache = Collections.synchronizedMap(
        new LinkedHashMap<UUID, CachedFileContent>(16, 0.75f, true) {
            private static final long MAX_CACHE_SIZE_BYTES = 100 * 1024 * 1024; // 100MB
            private long currentSize = 0;
            
            @Override
            protected boolean removeEldestEntry(Map.Entry<UUID, CachedFileContent> eldest) {
                if (currentSize > MAX_CACHE_SIZE_BYTES) {
                    currentSize -= eldest.getValue().getSize();
                    return true;
                }
                return false;
            }
        });
    
    // ファイルコンテンツをキャッシュに保存
    @Override
    public void cacheFileContent(UUID fileId, byte[] content, String contentType) {
        if (content.length < 5 * 1024 * 1024) { // 5MB未満のファイルのみキャッシュ
            CachedFileContent cachedContent = new CachedFileContent(
                content,
                contentType,
                LocalDateTime.now().plusMinutes(5)
            );
            contentCache.put(fileId, cachedContent);
        }
    }
    
    // キャッシュからファイルコンテンツを取得
    @Override
    public Optional<CachedFileContent> getFileContent(UUID fileId) {
        CachedFileContent cachedContent = contentCache.get(fileId);
        
        if (cachedContent != null) {
            if (cachedContent.isExpired()) {
                contentCache.remove(fileId);
                return Optional.empty();
            }
            return Optional.of(cachedContent);
        }
        
        return Optional.empty();
    }
    
    // キャッシュの定期的なクリーンアップ
    @Scheduled(fixedRate = 300000) // 5分ごとに実行
    public void cleanupExpiredCache() {
        List<UUID> expiredKeys = contentCache.entrySet().stream()
            .filter(entry -> entry.getValue().isExpired())
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
            
        expiredKeys.forEach(contentCache::remove);
    }
    
    // キャッシュデータを表すクラス
    public static class CachedFileContent {
        private final byte[] content;
        private final String contentType;
        private final LocalDateTime expiresAt;
        
        // コンストラクタ、ゲッターなど
    }
}
```

### 9.2 非同期処理

大容量ファイルの処理や複数ファイルの一括処理には、非同期処理を採用する：

```java
@Service
public class AsyncFileServiceImpl implements AsyncFileService {
    
    @Autowired
    private FileService fileService;
    
    @Autowired
    private AsyncFileProcessRepository asyncFileProcessRepository;
    
    @Autowired
    private NotificationService notificationService;
    
    @Async
    @Override
    public CompletableFuture<String> processLargeFileAsync(MultipartFile file, FileType fileType, 
            String resourceId, String description, Set<String> tags, String username) {
        
        // 非同期処理の状態を保存
        AsyncFileProcess process = new AsyncFileProcess();
        process.setFileName(file.getOriginalFilename());
        process.setFileType(fileType);
        process.setStatus(AsyncProcessStatus.PROCESSING);
        process.setStartedAt(LocalDateTime.now());
        process.setUsername(username);
        process = asyncFileProcessRepository.save(process);
        
        final String processId = process.getId().toString();
        
        try {
            // ファイルの処理（大容量ファイルの場合は時間がかかる）
            FileDto fileDto = fileService.saveFile(
                file,
                fileType,
                resourceId,
                description,
                tags,
                false,
                null,
                username
            );
            
            // 処理成功を記録
            process.setStatus(AsyncProcessStatus.COMPLETED);
            process.setCompletedAt(LocalDateTime.now());
            process.setResultFileId(UUID.fromString(fileDto.getId()));
            asyncFileProcessRepository.save(process);
            
            // ユーザーに通知
            notificationService.notifyUser(
                username,
                "ファイル処理完了",
                String.format("ファイル「%s」の処理が完了しました。", file.getOriginalFilename())
            );
            
            return CompletableFuture.completedFuture(fileDto.getId());
            
        } catch (Exception e) {
            // エラー時の処理
            process.setStatus(AsyncProcessStatus.FAILED);
            process.setErrorMessage(e.getMessage());
            process.setCompletedAt(LocalDateTime.now());
            asyncFileProcessRepository.save(process);
            
            // エラー通知
            notificationService.notifyUser(
                username,
                "ファイル処理エラー",
                String.format("ファイル「%s」の処理中にエラーが発生しました。", file.getOriginalFilename())
            );
            
            return CompletableFuture.failedFuture(e);
        }
    }
    
    @Override
    public AsyncFileProcessDto getProcessStatus(String processId) {
        AsyncFileProcess process = asyncFileProcessRepository.findById(UUID.fromString(processId))
            .orElseThrow(() -> new ResourceNotFoundException("Process not found"));
            
        return AsyncFileProcessMapper.toDto(process);
    }
}
```

### 9.3 データベースとストレージの最適化

ファイル管理機能のパフォーマンスを維持するため、以下の最適化を行う：

1. **インデックス設計**:

```sql
-- ファイルテーブルのインデックス
CREATE INDEX idx_files_file_type ON files (file_type);
CREATE INDEX idx_files_resource_id ON files (resource_id);
CREATE INDEX idx_files_created_by ON files (created_by);
CREATE INDEX idx_files_created_at ON files (created_at);
CREATE INDEX idx_files_is_public ON files (is_public);

-- ファイルタグテーブルのインデックス
CREATE INDEX idx_file_tags_tag ON file_tags (tag);

-- ファイルアクセステーブルのインデックス
CREATE INDEX idx_file_access_user_id ON file_access (user_id);
CREATE INDEX idx_file_access_role_id ON file_access (role_id);
```

2. **パーティショニング**:

大量のファイルを扱う場合は、ファイルテーブルをパーティショニングする：

```sql
-- file_typeとcreated_atでパーティショニング
CREATE TABLE files (
    id UUID PRIMARY KEY,
    file_name VARCHAR(255) NOT NULL,
    -- 他のカラム定義
) PARTITION BY LIST (file_type);

-- 契約書パーティション
CREATE TABLE files_contract PARTITION OF files
    FOR VALUES IN ('CONTRACT');

-- 請求書パーティション
CREATE TABLE files_invoice PARTITION OF files
    FOR VALUES IN ('INVOICE');

-- スキルシートパーティション
CREATE TABLE files_skill_sheet PARTITION OF files
    FOR VALUES IN ('SKILL_SHEET');

-- 案件資料パーティション
CREATE TABLE files_project_document PARTITION OF files
    FOR VALUES IN ('PROJECT_DOCUMENT');

-- 共通資料パーティション
CREATE TABLE files_common PARTITION OF files
    FOR VALUES IN ('COMMON');
```

3. **ストレージライフサイクル管理**:

ファイルの使用頻度に基づいて、異なるストレージ層に移動させる：

- **ホットストレージ**: 最近アクセスされたファイル
- **ウォームストレージ**: 3ヶ月以上アクセスのないファイル
- **コールドストレージ**: 1年以上アクセスのないファイル

```java
@Service
@Scheduled(cron = "0 0 2 * * 0") // 毎週日曜日の午前2時に実行
public class StorageLifecycleManagerImpl implements StorageLifecycleManager {
    
    @Autowired
    private FileRepository fileRepository;
    
    @Autowired
    private StorageService hotStorage;
    
    @Autowired
    private StorageService warmStorage;
    
    @Autowired
    private StorageService coldStorage;
    
    @Override
    public void migrateFiles() {
        LocalDateTime now = LocalDateTime.now();
        
        // ウォームストレージへの移行（3ヶ月以上アクセスなし）
        List<File> filesToWarm = fileRepository.findFilesNotAccessedSince(
            now.minusMonths(3), now.minusMonths(12));
        
        filesToWarm.forEach(file -> {
            try {
                // ホットからウォームストレージへ移行
                Resource fileResource = hotStorage.getResource(file.getPath());
                String newPath = warmStorage.store(fileResource.getInputStream(), file.getMimeType());
                
                // パスの更新とストレージタイプの変更
                file.setPath(newPath);
                file.setStorageType(StorageType.WARM);
                fileRepository.save(file);
                
                // 元のファイルを削除
                hotStorage.delete(file.getPath());
            } catch (Exception e) {
                // エラーログ
            }
        });
        
        // コールドストレージへの移行（1年以上アクセスなし）
        List<File> filesToCold = fileRepository.findFilesNotAccessedSince(
            now.minusYears(1), null);
        
        filesToCold.forEach(file -> {
            try {
                // ウォームからコールドストレージへ移行（同様の処理）
                // ...
            } catch (Exception e) {
                // エラーログ
            }
        });
    }
}
```

## 10. 運用設計

### 10.1 バックアップと復元

データの安全性を確保するため、以下のバックアップ方針を適用する：

1. **データベースバックアップ**:
   - 完全バックアップ：週1回
   - 増分バックアップ：毎日
   - トランザクションログ：1時間ごと

2. **ファイルストレージバックアップ**:
   - フルバックアップ：週1回
   - 差分バックアップ：毎日

3. **バックアップの保持期間**:
   - 日次バックアップ：30日間
   - 週次バックアップ：3ヶ月間
   - 月次バックアップ：1年間

4. **リストアプロセス**:
   - RTO（目標復旧時間）：4時間以内
   - RPO（目標復旧時点）：1時間以内

### 10.2 監視とアラート

ファイル管理機能の可用性とパフォーマンスを確保するための監視設計：

1. **リソース監視**:
   - ストレージ使用率
   - データベース接続数
   - APIレスポンスタイム

2. **プロセス監視**:
   - ファイルアップロード失敗率
   - ファイル削除エラー率
   - 暗号化処理エラー率

3. **アラート設定**:
   - ストレージ使用率80%超過：警告
   - ストレージ使用率95%超過：緊急
   - APIレスポンスタイム1秒超過：警告
   - 連続ファイルアップロード失敗：緊急

### 10.3 ログとメトリクス

システム運用のための情報収集設計：

1. **アクセスログ**:
   - ファイルのダウンロード履歴
   - ユーザーごとのファイルアクセス情報
   - 権限エラーイベント

2. **操作ログ**:
   - ファイルアップロード／削除イベント
   - アクセス権限変更イベント
   - ファイルメタデータ更新イベント

3. **パフォーマンスメトリクス**:
   - ファイルアップロード処理時間
   - ファイルダウンロード処理時間
   - ストレージI/O統計

```java
@Aspect
@Component
public class FileOperationLoggingAspect {
    
    private static final Logger accessLogger = LoggerFactory.getLogger("file.access");
    private static final Logger operationLogger = LoggerFactory.getLogger("file.operation");
    
    @Around("execution(* com.example.service.FileService.getFileResource(..))")
    public Object logFileAccess(ProceedingJoinPoint joinPoint) throws Throwable {
        Object[] args = joinPoint.getArgs();
        UUID fileId = (UUID) args[0];
        String username = (String) args[1];
        
        long startTime = System.currentTimeMillis();
        Object result = joinPoint.proceed();
        long endTime = System.currentTimeMillis();
        
        // アクセスログの記録
        accessLogger.info("FILE_ACCESS fileId={} user={} time={}", 
            fileId, username, (endTime - startTime));
        
        return result;
    }
    
    @AfterReturning(
        pointcut = "execution(* com.example.service.FileService.saveFile(..))",
        returning = "result")
    public void logFileUpload(JoinPoint joinPoint, Object result) {
        Object[] args = joinPoint.getArgs();
        MultipartFile file = (MultipartFile) args[0];
        FileType fileType = (FileType) args[1];
        String username = (String) args[args.length - 1];
        
        FileDto fileDto = (FileDto) result;
        
        // 操作ログの記録
        operationLogger.info("FILE_UPLOAD fileId={} fileName={} type={} size={} user={}",
            fileDto.getId(), file.getOriginalFilename(), fileType, file.getSize(), username);
    }
    
    @AfterReturning("execution(* com.example.service.FileService.deleteFile(..))")
    public void logFileDelete(JoinPoint joinPoint) {
        Object[] args = joinPoint.getArgs();
        UUID fileId = (UUID) args[0];
        String username = (String) args[1];
        boolean permanent = (boolean) args[2];
        
        // 操作ログの記録
        operationLogger.info("FILE_DELETE fileId={} user={} permanent={}",
            fileId, username, permanent);
    }
}
```

## 11. まとめ

SES業務システムのファイル管理機能は、様々な業務プロセスで使用されるファイルを一元的に管理するための共通基盤として設計された。本機能は以下の特徴を持つ：

1. **柔軟なファイル分類**: 契約書、請求書、スキルシートなど、用途に応じたファイル分類をサポート
2. **堅牢なセキュリティ**: AES-256暗号化、アクセス制御、ウイルススキャンによる安全性確保
3. **効率的なメタデータ管理**: タグ、説明、関連リソースなどのメタデータによる検索と管理の効率化
4. **スケーラブルなストレージ設計**: 増大するデータ量に対応できるストレージライフサイクル管理
5. **業務プロセスとの統合**: 各業務モジュールとの密接な連携による使いやすさの向上
6. **高いパフォーマンス**: キャッシュ、非同期処理、データベース最適化によるパフォーマンス確保
7. **運用管理機能**: バックアップ、監視、ログ記録による安定運用のサポート

これらの特徴により、ファイル管理機能はSES業務システム全体の効率と信頼性の向上に貢献する。