# SES業務システム エラー処理・例外管理機能 基本設計書

## 1. はじめに

本書は、SES業務システムにおけるエラー処理・例外管理機能の基本設計を定義したものである。
システム全体で一貫したエラー処理の方針と実装方法について記述し、安定性の高いシステム運用を実現するための
基盤的な共通機能について定義する。

## 2. 機能概要

エラー処理・例外管理機能は、アプリケーション内で発生するさまざまな例外や異常状態を適切に処理し、
ユーザーにわかりやすいフィードバックを提供するとともに、開発者・運用者が問題を迅速に特定して
対応できるようにする基盤的な共通機能である。

## 3. エラー処理・例外管理機能設計

### 3.1 機能構成

エラー処理・例外管理機能は以下のサブ機能で構成される：

1. **統一エラーモデル**: システム全体で一貫したエラー表現モデル
2. **エラーコード管理**: 体系化されたエラーコードの定義と管理
3. **例外ハンドリング**: 各レイヤでの例外処理と集約
4. **エラーレスポンス生成**: クライアントへのエラー応答の構築
5. **エラーログ記録**: エラー情報の適切なログ記録

### 3.2 統一エラーモデル

#### 3.2.1 エラーモデル

エラーは以下の属性で表現する統一モデルを採用する：

| 属性 | 型 | 説明 |
|------|------|------|
| errorCode | String | 一意のエラーコード |
| errorType | Enum | エラー種別（検証エラー、システムエラー等） |
| message | String | ユーザー向けエラーメッセージ |
| details | List | エラー詳細情報（フィールドエラー等） |
| timestamp | DateTime | エラー発生日時 |
| requestId | String | リクエスト識別子 |
| path | String | エラー発生リソースパス |
| traceId | String | 分散トレースID（障害追跡用） |
| cause | String | 技術的なエラー原因（開発者向け、本番環境では非表示） |

#### 3.2.2 エラー種別

エラーは以下の種別に分類する：

1. **ValidationError（検証エラー）**:
   - ユーザー入力値の検証エラー
   - 必須項目、形式、範囲等のチェックエラー
   - クライアントサイド・サーバーサイド双方で検証

2. **BusinessError（業務エラー）**:
   - ビジネスルールに基づく制約違反エラー
   - マスタデータ整合性エラー
   - ステータス遷移制約エラー

3. **SystemError（システムエラー）**:
   - 内部的な技術エラー
   - データベースエラー
   - 外部サービス連携エラー

4. **SecurityError（セキュリティエラー）**:
   - 認証・認可に関するエラー
   - アクセス権限エラー
   - セキュリティ制約違反

5. **ResourceError（リソースエラー）**:
   - リソースが存在しないエラー
   - リソースへのアクセス制限エラー
   - 重複リソースエラー

### 3.3 エラーコード管理

#### 3.3.1 エラーコード体系

エラーコードは以下の体系で管理する：

```
E-AABCC
```

- **E-**: エラーコードを表す固定プレフィックス
- **AA**: モジュール識別子（01: 共通, 02: 案件管理, 03: 技術者管理, 04: 契約管理, など）
- **B**: エラー種別（1: 検証エラー, 2: 業務エラー, 3: システムエラー, 4: セキュリティエラー, 5: リソースエラー）
- **CC**: 連番（00-99）

例：
- **E-01101**: 共通モジュールの検証エラー01
- **E-02302**: 案件管理モジュールのシステムエラー02
- **E-03201**: 技術者管理モジュールの業務エラー01

#### 3.3.2 エラーコード定義

エラーコードは構成管理されたプロパティファイルで管理し、多言語対応を可能にする：

**messages_ja.properties の例**:
```properties
# 共通 - 検証エラー
E-01101=入力値「{0}」は必須項目です。
E-01102=入力値「{0}」が不正です。{1}の形式で入力してください。
E-01103=入力値「{0}」は{1}文字以上{2}文字以下で入力してください。
E-01104=入力値「{0}」は{1}以上{2}以下の値を入力してください。

# 共通 - システムエラー
E-01301=システムエラーが発生しました。しばらく経ってから再度お試しください。
E-01302=データベースアクセス中にエラーが発生しました。
E-01303=外部サービスとの通信中にエラーが発生しました。

# 共通 - セキュリティエラー
E-01401=認証に失敗しました。ユーザーIDとパスワードを確認してください。
E-01402=このリソースへのアクセス権限がありません。
E-01403=セッションの有効期限が切れました。再度ログインしてください。

# 案件管理 - 業務エラー
E-02201=指定された案件は既に{0}状態のため、この操作は実行できません。
E-02202=案件の開始日は終了日よりも前の日付である必要があります。
```

#### 3.3.3 エラーコードレジストリ

エラーコードを一元管理するレジストリを実装する：

```java
public interface ErrorCodeRegistry {
    // エラーコードの取得
    ErrorCode getErrorCode(String errorCodeId);
    
    // メッセージのフォーマット（引数置換）
    String formatMessage(String errorCodeId, Object... args);
    
    // エラーコードの存在確認
    boolean existsErrorCode(String errorCodeId);
    
    // 特定モジュールのエラーコード一覧取得
    List<ErrorCode> getModuleErrorCodes(String moduleId);
}
```

### 3.4 例外ハンドリング

#### 3.4.1 例外階層

システム内で使用する例外クラスの階層を以下のように定義する：

```
BaseException (基底例外)
├── ValidationException (検証例外)
├── BusinessException (業務例外)
├── SystemException (システム例外)
├── SecurityException (セキュリティ例外)
└── ResourceException (リソース例外)
    ├── ResourceNotFoundException (リソース未検出例外)
    ├── ResourceAlreadyExistsException (リソース重複例外)
    └── ResourceAccessDeniedException (リソースアクセス拒否例外)
```

各例外クラスは以下の情報を保持する：

```java
public abstract class BaseException extends RuntimeException {
    private final String errorCode; // エラーコード
    private final Object[] args;    // メッセージパラメータ
    private final Map<String, Object> additional = new HashMap<>(); // 追加情報
    
    // コンストラクタ、ゲッターなど
}
```

#### 3.4.2 グローバル例外ハンドラ

Spring MVCのControllerAdviceを使用して、集中的に例外を処理するグローバル例外ハンドラを実装する：

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    @Autowired
    private ErrorResponseBuilder errorResponseBuilder;
    
    @Autowired
    private ErrorLogger errorLogger;
    
    // アプリケーション定義例外
    @ExceptionHandler(BaseException.class)
    public ResponseEntity<ErrorResponse> handleBaseException(BaseException ex, WebRequest request) {
        // ログ記録
        errorLogger.logException(ex, request);
        
        // エラーレスポンス生成
        ErrorResponse errorResponse = errorResponseBuilder.build(ex, request);
        
        // HTTPステータス決定
        HttpStatus status = determineStatus(ex);
        
        return new ResponseEntity<>(errorResponse, status);
    }
    
    // バリデーション例外
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(
            MethodArgumentNotValidException ex, WebRequest request) {
        // 検証エラーの集約と変換処理
        // ...
    }
    
    // リソース未検出例外
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFoundException(
            ResourceNotFoundException ex, WebRequest request) {
        // ...
        return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
    }
    
    // 未処理例外のフォールバックハンドラ
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleUnexpectedException(
            Exception ex, WebRequest request) {
        // 予期しない例外の処理
        // ...
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
    
    // 例外の種類に基づいてHTTPステータスコードを決定
    private HttpStatus determineStatus(BaseException ex) {
        if (ex instanceof ValidationException) return HttpStatus.BAD_REQUEST;
        if (ex instanceof BusinessException) return HttpStatus.CONFLICT;
        if (ex instanceof SystemException) return HttpStatus.INTERNAL_SERVER_ERROR;
        if (ex instanceof SecurityException) return HttpStatus.FORBIDDEN;
        if (ex instanceof ResourceNotFoundException) return HttpStatus.NOT_FOUND;
        if (ex instanceof ResourceAlreadyExistsException) return HttpStatus.CONFLICT;
        
        return HttpStatus.INTERNAL_SERVER_ERROR;
    }
}
```

#### 3.4.3 トランザクション境界と例外処理

サービスレイヤーでのトランザクション管理と例外処理の関係：

```java
@Service
@Transactional
public class ProjectServiceImpl implements ProjectService {

    @Override
    public Project createProject(ProjectCreateDTO projectDTO) {
        try {
            // プロジェクト作成ロジック
            // ...
            
            return savedProject;
        } catch (DataIntegrityViolationException e) {
            // データ整合性エラー（一意制約違反など）を業務例外に変換
            throw new BusinessException("E-02203", "プロジェクト名が重複しています", e);
        } catch (DataAccessException e) {
            // データアクセスエラーをシステム例外に変換
            throw new SystemException("E-02301", "プロジェクト作成中にデータベースエラーが発生しました", e);
        }
    }
    
    @Override
    @Transactional(readOnly = true) // 読み取り専用トランザクション
    public Project findById(UUID id) {
        return projectRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("E-02501", "指定されたプロジェクトが見つかりません", id));
    }
}
```

### 3.5 エラーレスポンス生成

#### 3.5.1 エラーレスポンスモデル

API呼び出し時のエラーレスポンスフォーマット：

```json
{
  "status": "error",
  "errorCode": "E-02201",
  "message": "指定された案件は既に「完了」状態のため、この操作は実行できません。",
  "details": [
    {
      "field": "status",
      "message": "現在のステータスでは変更できません"
    }
  ],
  "timestamp": "2025-05-05T10:15:30.123Z",
  "requestId": "req-8a7b9c3d2e1f",
  "path": "/api/v1/projects/550e8400-e29b-41d4-a716-446655440000/status",
  "traceId": "4a7b9c3d2e1f8a7b9c3d2e1f"
}
```

#### 3.5.2 エラーレスポンスビルダー

エラーレスポンスを構築するサービス：

```java
@Component
public class ErrorResponseBuilder {
    @Autowired
    private ErrorCodeRegistry errorCodeRegistry;
    
    @Autowired
    private MessageSource messageSource;
    
    @Value("${app.environment:production}")
    private String environment;
    
    public ErrorResponse build(BaseException ex, WebRequest request) {
        ErrorResponse response = new ErrorResponse();
        
        // 基本情報の設定
        response.setStatus("error");
        response.setErrorCode(ex.getErrorCode());
        response.setTimestamp(LocalDateTime.now());
        response.setRequestId(extractRequestId(request));
        response.setPath(extractPath(request));
        response.setTraceId(extractTraceId());
        
        // メッセージのローカライズと引数置換
        Locale locale = extractLocale(request);
        String message = messageSource.getMessage(
            "error." + ex.getErrorCode(),
            ex.getArgs(),
            "An error occurred", // フォールバックメッセージ
            locale
        );
        response.setMessage(message);
        
        // エラー詳細情報の設定
        if (ex.getAdditional().containsKey("details")) {
            response.setDetails(ex.getAdditional().get("details"));
        }
        
        // 開発環境の場合のみ、技術的な詳細情報も含める
        if ("development".equals(environment) || "staging".equals(environment)) {
            response.setCause(ex.getCause() != null ? ex.getCause().getMessage() : null);
            // スタックトレースなどの追加情報
        }
        
        return response;
    }
    
    // リクエストIDの抽出
    private String extractRequestId(WebRequest request) {
        // 実装...
    }
    
    // パスの抽出
    private String extractPath(WebRequest request) {
        // 実装...
    }
    
    // トレースIDの抽出（分散トレーシングシステムから）
    private String extractTraceId() {
        // 実装...
    }
    
    // ロケールの抽出
    private Locale extractLocale(WebRequest request) {
        // 実装...
    }
}
```

### 3.6 エラーログ記録

#### 3.6.1 エラーログフォーマット

エラーログは以下の情報を含める：

1. **タイムスタンプ**: エラー発生日時
2. **ログレベル**: ERROR/WARN
3. **エラーコード**: 定義済みエラーコード
4. **メッセージ**: エラーの概要
5. **トレースID**: 分散トレースID
6. **ユーザーID**: エラーが発生したユーザーのID（存在する場合）
7. **リクエスト情報**: HTTPメソッド、URL、パラメータなど
8. **例外情報**: 例外クラス、メッセージ、スタックトレース

#### 3.6.2 エラーログ実装

エラーログ記録サービス：

```java
@Component
public class ErrorLogger {
    private static final Logger log = LoggerFactory.getLogger(ErrorLogger.class);
    
    @Autowired
    private ObjectMapper objectMapper;
    
    public void logException(BaseException ex, WebRequest request) {
        try {
            Map<String, Object> logData = new LinkedHashMap<>();
            
            // 基本情報の設定
            logData.put("timestamp", LocalDateTime.now());
            logData.put("errorCode", ex.getErrorCode());
            logData.put("errorType", ex.getClass().getSimpleName());
            logData.put("message", ex.getMessage());
            
            // リクエスト情報
            logData.put("request", extractRequestInfo(request));
            
            // ユーザー情報
            Authentication auth = SecurityContextHolder.getContext().getAuthentication();
            if (auth != null && auth.getPrincipal() != null) {
                logData.put("user", auth.getName());
            }
            
            // トレース情報
            logData.put("traceId", extractTraceId());
            
            // スタックトレース情報（開発環境のみ完全なスタックトレース）
            if ("production".equals(environment)) {
                logData.put("exception", ex.getClass().getName() + ": " + ex.getMessage());
            } else {
                StringWriter sw = new StringWriter();
                ex.printStackTrace(new PrintWriter(sw));
                logData.put("stackTrace", sw.toString());
            }
            
            // ログ出力
            if (ex instanceof SystemException) {
                log.error("System error occurred: {}", objectMapper.writeValueAsString(logData));
            } else if (ex instanceof SecurityException) {
                log.warn("Security error occurred: {}", objectMapper.writeValueAsString(logData));
            } else {
                log.warn("Application error occurred: {}", objectMapper.writeValueAsString(logData));
            }
        } catch (Exception e) {
            // ログ出力自体でエラーが発生した場合のフォールバック
            log.error("Error logging exception", e);
            log.error("Original exception", ex);
        }
    }
    
    private Map<String, Object> extractRequestInfo(WebRequest request) {
        // リクエスト情報の抽出処理...
    }
}
```

## 4. UI設計

### 4.1 フロントエンドのエラー表示

#### 4.1.1 入力フォームのエラー表示

入力検証エラーは、以下の方針で表示する：

1. **インラインエラー表示**:
   - 入力フィールドの直下に赤文字でエラーメッセージを表示
   - エラーのあるフィールドを赤枠で強調表示
   - 複数エラーがある場合は、各フィールドにそれぞれ表示

2. **フォーム全体のエラー表示**:
   - フォーム上部にエラーサマリを表示（オプション）
   - エラー数と概要を表示

#### 4.1.2 処理エラーの表示

処理実行時のエラーは、以下の方針で表示する：

1. **エラーダイアログ**:
   - 重大なエラーや操作中断を要するエラーはモーダルダイアログで表示
   - エラーコード、メッセージ、対処方法を表示
   - 「閉じる」「再試行」などのアクションボタンを提供

2. **エラー通知**:
   - 軽微なエラーはトースト通知で表示
   - 短時間で自動的に消える
   - エラーメッセージのみをシンプルに表示

3. **エラーページ**:
   - 致命的なエラーは専用のエラーページにリダイレクト
   - エラーコード、メッセージ、トラブルシューティング手順を表示
   - 管理者への連絡方法を提示

### 4.2 エラーコード管理画面

システム管理者向けのエラーコード管理画面を提供する：

* **エラーコード一覧部**:
  - モジュールごとのタブ表示
  - エラーコード、種別、メッセージ一覧
  - メッセージの編集機能
  - 多言語対応のための言語切り替え

* **エラーコード検索部**:
  - エラーコード、メッセージ内容による検索
  - モジュール、エラー種別によるフィルタリング

* **エラーログ検索部**:
  - エラーコードに関連するログの検索
  - 発生頻度の統計表示
  - 期間指定による絞り込み

## 5. API設計

### 5.1 エラーコード参照API

| エンドポイント | メソッド | 説明 |
|----------------|----------|------|
| /api/v1/system/error-codes | GET | エラーコード一覧取得 |
| /api/v1/system/error-codes/{code} | GET | 指定エラーコードの詳細取得 |
| /api/v1/system/error-codes/modules/{moduleId} | GET | モジュール別エラーコード取得 |
| /api/v1/system/error-codes/types/{errorType} | GET | 種別別エラーコード取得 |

#### リクエスト例

```
GET /api/v1/system/error-codes?page=0&size=20&sort=errorCode,asc
```

#### レスポンス例

```json
{
  "content": [
    {
      "errorCode": "E-01101",
      "errorType": "VALIDATION",
      "messageTemplate": "入力値「{0}」は必須項目です。",
      "moduleId": "01",
      "moduleName": "Common"
    },
    // ...他のエラーコード
  ],
  "pageable": {
    "pageNumber": 0,
    "pageSize": 20,
    "totalElements": 156,
    "totalPages": 8
  }
}
```

### 5.2 エラーログ参照API

| エンドポイント | メソッド | 説明 |
|----------------|----------|------|
| /api/v1/system/error-logs | GET | エラーログ一覧取得 |
| /api/v1/system/error-logs/{id} | GET | 指定エラーログの詳細取得 |
| /api/v1/system/error-logs/search | POST | 条件指定によるエラーログ検索 |
| /api/v1/system/error-logs/statistics | GET | エラー発生統計情報取得 |

#### リクエスト例（検索）

```json
{
  "errorCodes": ["E-01301", "E-02301"],
  "startDate": "2025-05-01T00:00:00Z",
  "endDate": "2025-05-05T23:59:59Z",
  "userId": "user123",
  "severity": ["ERROR"]
}
```

## 6. 技術的実装

### 6.1 使用技術

* **フレームワーク**: Spring Boot + Spring MVC
* **ロギング**: SLF4J + Logback
* **JSON処理**: Jackson
* **国際化**: Spring MessageSource
* **分散トレーシング**: Spring Cloud Sleuth + Zipkin

### 6.2 データモデル設計

以下のクラスを実装する：

```java
// エラーコードエンティティ
@Entity
@Table(name = "error_codes")
public class ErrorCode {
    @Id
    @Column(length = 10)
    private String errorCode;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private ErrorType errorType;
    
    @Column(length = 5, nullable = false)
    private String moduleId;
    
    @Column(nullable = false)
    private String messageTemplate;
    
    private String description;
    
    // ゲッター、セッターなど
}

// エラーログエンティティ
@Entity
@Table(name = "error_logs")
public class ErrorLog {
    @Id
    private UUID id;
    
    @Column(length = 10)
    private String errorCode;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private ErrorType errorType;
    
    @Column(nullable = false)
    private String message;
    
    @Column(columnDefinition = "TEXT")
    private String details;
    
    private String userId;
    
    private String requestUri;
    
    private String requestMethod;
    
    private String userAgent;
    
    private String traceId;
    
    @Column(nullable = false)
    private LocalDateTime occurredAt;
    
    // ゲッター、セッターなど
}
```

### 6.3 コード実装例

#### 6.3.1 カスタム例外クラス

```java
// 基底例外クラス
public abstract class BaseException extends RuntimeException {
    private final String errorCode;
    private final Object[] args;
    private final Map<String, Object> additional = new HashMap<>();
    
    public BaseException(String errorCode, String message, Throwable cause, Object... args) {
        super(message, cause);
        this.errorCode = errorCode;
        this.args = args;
    }
    
    // ゲッター、セッター、ユーティリティメソッド
}

// 業務例外クラス
public class BusinessException extends BaseException {
    public BusinessException(String errorCode, String message, Object... args) {
        super(errorCode, message, null, args);
    }
    
    public BusinessException(String errorCode, String message, Throwable cause, Object... args) {
        super(errorCode, message, cause, args);
    }
}

// その他の例外クラス（ValidationException, SystemException, など）
```

#### 6.3.2 グローバル例外ハンドラ実装例

```java
@RestControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {
    @Autowired
    private ErrorResponseBuilder errorResponseBuilder;
    
    @Autowired
    private ErrorLogger errorLogger;
    
    // アプリケーション定義例外
    @ExceptionHandler(BaseException.class)
    public ResponseEntity<Object> handleBaseException(BaseException ex, WebRequest request) {
        // ログ記録
        errorLogger.logException(ex, request);
        
        // エラーレスポンス生成
        ErrorResponse errorResponse = errorResponseBuilder.build(ex, request);
        
        // HTTPステータス決定
        HttpStatus status = determineStatus(ex);
        
        return handleExceptionInternal(ex, errorResponse, new HttpHeaders(), status, request);
    }
    
    // Bean Validation API例外
    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex, HttpHeaders headers, 
            HttpStatus status, WebRequest request) {
        
        // フィールドエラーの抽出
        List<Map<String, String>> fieldErrors = ex.getBindingResult().getFieldErrors().stream()
            .map(err -> {
                Map<String, String> fieldError = new HashMap<>();
                fieldError.put("field", err.getField());
                fieldError.put("message", err.getDefaultMessage());
                return fieldError;
            })
            .collect(Collectors.toList());
        
        // ValidationExceptionに変換
        ValidationException validationEx = new ValidationException(
            "E-01101", "入力値の検証に失敗しました");
        validationEx.addAdditional("details", fieldErrors);
        
        // ログとレスポンス
        errorLogger.logException(validationEx, request);
        ErrorResponse errorResponse = errorResponseBuilder.build(validationEx, request);
        
        return handleExceptionInternal(ex, errorResponse, headers, HttpStatus.BAD_REQUEST, request);
    }
    
    // 未処理例外のフォールバックハンドラ
    @ExceptionHandler(Exception.class)
    public ResponseEntity<Object> handleUnexpectedException(Exception ex, WebRequest request) {
        // 予期しない例外をSystemExceptionにラップ
        SystemException systemEx = new SystemException(
            "E-01301", "システムエラーが発生しました", ex);
        
        // ログとレスポンス
        errorLogger.logException(systemEx, request);
        ErrorResponse errorResponse = errorResponseBuilder.build(systemEx, request);
        
        return handleExceptionInternal(ex, errorResponse, new HttpHeaders(), 
            HttpStatus.INTERNAL_SERVER_ERROR, request);
    }
    
    // 例外の種類に基づいてHTTPステータスコードを決定
    private HttpStatus determineStatus(BaseException ex) {
        // 実装...
    }
}
```

## 7. セキュリティ対策

* **エラー情報の最小開示**: 
  - エンドユーザーには必要最小限のエラー情報のみを表示
  - スタックトレースなど詳細技術情報は非公開環境でのみ表示

* **機密情報の漏洩防止**:
  - エラーメッセージ内での機密情報（個人情報、認証情報など）の露出防止
  - ログ出力時の機密情報マスキング

* **エラー情報に基づく攻撃の防止**:
  - 詳細なシステム構成やバージョン情報の非開示
  - エラーメッセージの標準化によるシステム推測の防止

* **DoS対策**:
  - エラー発生時の処理負荷監視
  - 連続エラー発生時のレート制限

## 8. 運用管理

* **エラー監視**:
  - 重大エラーのアラート通知
  - エラー発生頻度のモニタリング
  - エラー種別ごとの傾向分析

* **エラーレポート**:
  - 日次/週次/月次のエラー発生レポート
  - ユーザー影響度の分析
  - 繰り返し発生するエラーの特定

* **改善プロセス**:
  - エラー分析に基づく改善点の特定
  - エラーコードとメッセージの定期的なレビューと改善
  - ユーザーフィードバックの収集と反映

## 9. 課題と制限事項

* **レガシーシステム連携**: 外部システム連携時のエラー変換と統一
* **エラー翻訳の精度**: 多言語対応時の翻訳品質とメンテナンス
* **パフォーマンス影響**: エラー処理による処理オーバーヘッドの最小化
* **エラーコード管理**: エラーコードの一貫性維持と重複防止の仕組み