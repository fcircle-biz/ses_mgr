# 通知機能設計書

## 1. 概要

通知機能は、SES業務システム内でユーザーに対して様々な情報を伝達するための重要な基盤機能である。案件のマッチング、承認依頼、契約更新、請求書発行などの重要なイベントを、適切なタイミングで関係者に通知することで、業務の効率化と確実性を向上させる。

### 1.1 目的

通知機能は以下の目的で設計される：

1. **リアルタイム情報提供**: システム内のイベントをタイムリーにユーザーに伝達する
2. **アクション喚起**: ユーザーが対応すべきタスクを明確に通知する
3. **重要事項の見落とし防止**: 締切や期限など重要事項を通知して見落としを防ぐ
4. **業務連携の効率化**: 複数の関係者間でのコミュニケーションを効率化する
5. **システム状態の通知**: メンテナンスなどのシステム状態を適切に伝達する

### 1.2 通知の種類

システムでは以下の4種類の通知をサポートする：

1. **システム通知**: システムからの一般的なお知らせ（メンテナンス情報など）
2. **タスク通知**: ユーザーによるアクションが必要なタスク（承認依頼、提案依頼など）
3. **アラート通知**: 緊急性の高い重要な通知（契約期限、支払期限など）
4. **イベント通知**: 特定のイベントに関する情報（案件登録、技術者アサインなど）

### 1.3 通知のライフサイクル

各通知は以下のライフサイクルを持つ：

1. **作成**: システムの各機能から通知が生成される
2. **配信**: 関連するユーザーに通知が配信される
3. **既読処理**: ユーザーが通知を確認すると既読状態になる
4. **削除/アーカイブ**: ユーザーによる削除または一定期間経過後の自動アーカイブ

## 2. アーキテクチャ設計

### 2.1 全体アーキテクチャ

通知機能は以下のコンポーネントで構成される：

```
[業務モジュール] --イベント発行--> [通知サービス] --保存--> [通知ストレージ]
                                    |
                                    ↓
                  [メール配信] <-- [配信エンジン] --> [WebSocket/SSE]
                                    |
                                    ↓
                            [通知REST API] <---- [フロントエンド]
```

### 2.2 コンポーネント説明

1. **通知サービス（NotificationService）**
   - 通知の作成、保存、取得、更新、削除を担当
   - 業務モジュールからイベントを受信し通知に変換
   - メール通知とアプリ内通知の統合管理

2. **配信エンジン（DeliveryEngine）**
   - 通知の配信方法（メール、アプリ内通知）を決定
   - リアルタイム通知のためのWebSocketまたはSSE管理
   - 通知テンプレートの適用と書式設定

3. **通知ストレージ（NotificationRepository）**
   - 通知の永続化と検索を担当
   - ユーザーごとの通知状態管理
   - 通知の保持期間管理

4. **通知REST API（NotificationController）**
   - フロントエンドへの通知情報提供
   - 通知の既読/未読処理
   - 通知のフィルタリングと検索

5. **イベントリスナー（NotificationEventListener）**
   - 業務モジュールからのイベントをリッスン
   - イベントを適切な通知タイプに変換
   - ターゲットユーザーの決定

### 2.3 通知生成パターン

通知は以下の2つの方法で生成される：

1. **イベント駆動型**
   - 業務モジュールがイベントを発行
   - `NotificationEventListener`がイベントをキャッチ
   - イベント情報から通知を生成

   ```java
   // イベント発行例
   applicationEventPublisher.publishEvent(new ProjectCreatedEvent(project));
   
   // イベントリスナー例
   @EventListener
   public void handleProjectCreatedEvent(ProjectCreatedEvent event) {
       Project project = event.getProject();
       notificationService.createNotification(
           NotificationType.EVENT,
           project.getAssignedUsers(),
           "新規案件が登録されました",
           String.format("「%s」という新しい案件が登録されました。", project.getName()),
           createMetadata(project)
       );
   }
   ```

2. **直接呼び出し型**
   - 業務モジュールが`NotificationService`を直接呼び出し
   - 通知の詳細情報を直接指定

   ```java
   // 直接呼び出し例
   notificationService.createNotification(
       NotificationType.TASK,
       targetUsers,
       "請求書の承認依頼があります",
       String.format("案件「%s」の請求書が発行され、あなたの承認待ちです。", invoice.getProjectName()),
       metadata
   );
   ```

### 2.4 リアルタイム通知の実装

リアルタイム通知は以下の方法で実装する：

1. **Server-Sent Events (SSE)方式**
   - 長期HTTP接続を利用した単方向通信
   - ブラウザ標準APIでサポートされており、追加ライブラリ不要
   - バックエンドではSpring WebFluxを利用したFlux<ServerSentEvent>の実装

   ```java
   @GetMapping(value = "/notifications/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
   public Flux<ServerSentEvent<NotificationDto>> streamNotifications(
           @AuthenticationPrincipal UserDetails user) {
       return notificationService.getNotificationStream(user.getUsername())
           .map(notification -> ServerSentEvent.builder(NotificationDto.from(notification))
               .id(notification.getId().toString())
               .event("notification")
               .build());
   }
   ```

2. **WebSocket方式（代替実装）**
   - 双方向通信が必要な場合に利用
   - STOMP over WebSocketを利用した実装
   - 接続管理の複雑さがあるためSSEを優先する

## 3. データモデル設計

### 3.1 通知（Notification）エンティティ

通知の基本構造を定義するエンティティ。

```java
@Entity
@Table(name = "notifications")
public class Notification {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private NotificationType type;
    
    @Column(nullable = false)
    private String title;
    
    @Column(nullable = false, length = 1000)
    private String body;
    
    @Convert(converter = JsonAttributeConverter.class)
    @Column(columnDefinition = "jsonb")
    private Map<String, Object> metadata;
    
    @ManyToOne
    @JoinColumn(name = "sender_id")
    private User sender;
    
    @ManyToOne
    @JoinColumn(name = "recipient_id", nullable = false)
    private User recipient;
    
    @Column(nullable = false)
    private boolean read = false;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    private LocalDateTime updatedAt;
    
    // getters, setters, etc.
}
```

### 3.2 通知タイプ（NotificationType）列挙型

通知の種類を定義する列挙型。

```java
public enum NotificationType {
    SYSTEM("システム"),
    TASK("タスク"),
    ALERT("アラート"),
    EVENT("イベント");
    
    private final String displayName;
    
    NotificationType(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}
```

### 3.3 通知設定（NotificationPreference）エンティティ

ユーザーごとの通知設定を管理するエンティティ。

```java
@Entity
@Table(name = "notification_preferences")
public class NotificationPreference {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private NotificationType notificationType;
    
    @Column(nullable = false)
    private boolean appEnabled = true;
    
    @Column(nullable = false)
    private boolean emailEnabled = true;
    
    @Column(nullable = false)
    private int retentionDays = 90;
    
    // getters, setters, etc.
}
```

### 3.4 通知テンプレート（NotificationTemplate）エンティティ

再利用可能な通知テンプレートを管理するエンティティ。

```java
@Entity
@Table(name = "notification_templates")
public class NotificationTemplate {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true)
    private String templateKey;
    
    @Column(nullable = false)
    private String titleTemplate;
    
    @Column(nullable = false, length = 2000)
    private String bodyTemplate;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private NotificationType notificationType;
    
    // getters, setters, etc.
}
```

## 4. サービスインターフェース設計

### 4.1 通知サービス（NotificationService）

通知の基本機能を提供するサービス。

```java
public interface NotificationService {
    // 通知の作成
    Notification createNotification(
        NotificationType type,
        List<User> recipients,
        String title,
        String body,
        Map<String, Object> metadata
    );
    
    // テンプレートベースの通知作成
    Notification createNotificationFromTemplate(
        String templateKey,
        List<User> recipients,
        Map<String, Object> parameters
    );
    
    // ユーザーの通知取得
    Page<Notification> getUserNotifications(
        String username,
        NotificationType type,
        Boolean readStatus,
        Pageable pageable
    );
    
    // 通知の詳細取得
    Notification getNotificationById(UUID id, String username);
    
    // 通知の既読設定
    Notification markAsRead(UUID id, String username);
    
    // 全通知の既読設定
    int markAllAsRead(String username, NotificationType type);
    
    // 通知の削除
    void deleteNotification(UUID id, String username);
    
    // 通知ストリームの取得（リアルタイム通知用）
    Flux<Notification> getNotificationStream(String username);
    
    // 期限切れ通知のアーカイブ
    void archiveExpiredNotifications();
}
```

### 4.2 配信サービス（DeliveryService）

通知の配信方法を管理するサービス。

```java
public interface DeliveryService {
    // メール通知の送信
    void sendEmailNotification(Notification notification);
    
    // アプリ内通知のプッシュ
    void pushInAppNotification(Notification notification);
    
    // 配信チャネルの決定
    Set<DeliveryChannel> determineDeliveryChannels(User user, NotificationType type);
    
    // 通知テンプレートの適用
    String applyTemplate(String template, Map<String, Object> parameters);
}
```

### 4.3 通知設定サービス（NotificationPreferenceService）

ユーザーの通知設定を管理するサービス。

```java
public interface NotificationPreferenceService {
    // 通知設定の取得
    List<NotificationPreference> getUserPreferences(String username);
    
    // 通知設定の更新
    NotificationPreference updatePreference(
        String username,
        NotificationType type,
        boolean appEnabled,
        boolean emailEnabled,
        int retentionDays
    );
    
    // デフォルト設定のリセット
    void resetToDefaults(String username);
    
    // 特定通知タイプの設定取得
    NotificationPreference getPreference(String username, NotificationType type);
}
```

## 5. API設計

### 5.1 通知一覧取得 API

ユーザーの通知一覧を取得するAPI。

```
GET /api/v1/common/notifications
```

**クエリパラメータ：**
- `page`: ページ番号（デフォルト: 1）
- `page_size`: 1ページあたりの件数（デフォルト: 20, 最大: 100）
- `type`: 通知タイプでフィルタリング（system, task, alert, event）
- `read_status`: 既読状態でフィルタリング（read, unread, all）（デフォルト: all）
- `sort`: ソート順（created_at:desc, created_at:asc）（デフォルト: created_at:desc）

**レスポンス例：**
```json
{
  "data": [
    {
      "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
      "type": "task",
      "title": "新しい案件の提案依頼があります",
      "body": "株式会社テクノロジーの案件「Javaエンジニア募集」に対して提案依頼がありました。",
      "read": false,
      "created_at": "2023-05-01T10:30:00.000Z",
      "metadata": {
        "project_id": "550e8400-e29b-41d4-a716-446655440000",
        "project_name": "Javaエンジニア募集",
        "client_name": "株式会社テクノロジー",
        "action_url": "/projects/550e8400-e29b-41d4-a716-446655440000"
      }
    },
    // その他の通知...
  ],
  "pagination": {
    "current_page": 1,
    "page_size": 20,
    "total_pages": 2,
    "total_items": 25
  },
  "summary": {
    "unread_count": 12,
    "total_count": 25
  }
}
```

### 5.2 通知詳細取得 API

特定の通知の詳細を取得するAPI。

```
GET /api/v1/common/notifications/{id}
```

**パスパラメータ：**
- `id`: 取得する通知のID

**レスポンス例：**
```json
{
  "data": {
    "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "type": "task",
    "title": "新しい案件の提案依頼があります",
    "body": "株式会社テクノロジーの案件「Javaエンジニア募集」に対して提案依頼がありました。\n\n詳細を確認し、適切な技術者を選定して提案してください。",
    "read": false,
    "created_at": "2023-05-01T10:30:00.000Z",
    "updated_at": "2023-05-01T10:30:00.000Z",
    "metadata": {
      "project_id": "550e8400-e29b-41d4-a716-446655440000",
      "project_name": "Javaエンジニア募集",
      "client_name": "株式会社テクノロジー",
      "required_skills": ["Java", "Spring", "MySQL"],
      "deadline": "2023-05-10T17:00:00.000Z",
      "action_url": "/projects/550e8400-e29b-41d4-a716-446655440000",
      "importance": "high"
    },
    "sender": {
      "id": "6ba7b812-9dad-11d1-80b4-00c04fd430c8",
      "name": "営業担当 佐藤"
    },
    "recipient": {
      "id": "6ba7b813-9dad-11d1-80b4-00c04fd430c8",
      "name": "マッチング担当 田中"
    }
  }
}
```

### 5.3 通知既読設定 API

指定された通知を既読状態に更新するAPI。

```
PUT /api/v1/common/notifications/{id}/read
```

**パスパラメータ：**
- `id`: 既読にする通知のID

**レスポンス例：**
```json
{
  "data": {
    "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "read": true,
    "updated_at": "2023-05-02T14:45:00.000Z"
  }
}
```

### 5.4 全通知既読設定 API

ユーザーの全ての未読通知を既読状態に更新するAPI。

```
PUT /api/v1/common/notifications/read-all
```

**クエリパラメータ：**
- `type`: 特定タイプの通知のみを既読にする場合（system, task, alert, event）

**レスポンス例：**
```json
{
  "data": {
    "marked_as_read": 12,
    "updated_at": "2023-05-02T14:50:00.000Z"
  }
}
```

### 5.5 通知削除 API

指定された通知を削除するAPI。

```
DELETE /api/v1/common/notifications/{id}
```

**パスパラメータ：**
- `id`: 削除する通知のID

**レスポンス例：**
No Content (204)

### 5.6 通知設定取得 API

ユーザーの通知設定を取得するAPI。

```
GET /api/v1/common/notification-preferences
```

**レスポンス例：**
```json
{
  "data": [
    {
      "notification_type": "system",
      "app_enabled": true,
      "email_enabled": true,
      "retention_days": 90
    },
    {
      "notification_type": "task",
      "app_enabled": true,
      "email_enabled": true,
      "retention_days": 90
    },
    {
      "notification_type": "alert",
      "app_enabled": true,
      "email_enabled": true,
      "retention_days": 180
    },
    {
      "notification_type": "event",
      "app_enabled": true,
      "email_enabled": false,
      "retention_days": 60
    }
  ]
}
```

### 5.7 通知設定更新 API

ユーザーの通知設定を更新するAPI。

```
PUT /api/v1/common/notification-preferences/{type}
```

**パスパラメータ：**
- `type`: 更新する通知タイプ（system, task, alert, event）

**リクエスト例：**
```json
{
  "app_enabled": true,
  "email_enabled": false,
  "retention_days": 60
}
```

**レスポンス例：**
```json
{
  "data": {
    "notification_type": "event",
    "app_enabled": true,
    "email_enabled": false,
    "retention_days": 60,
    "updated_at": "2023-05-03T09:10:00.000Z"
  }
}
```

### 5.8 リアルタイム通知ストリーム API

Server-Sent Events（SSE）を使用したリアルタイム通知のストリーミングAPI。

```
GET /api/v1/common/notifications/stream
```

**レスポンス形式：**
text/event-stream

**イベント例：**
```
event: notification
id: f47ac10b-58cc-4372-a567-0e02b2c3d479
data: {"id":"f47ac10b-58cc-4372-a567-0e02b2c3d479","type":"task","title":"新しい案件の提案依頼があります","body":"株式会社テクノロジーの案件「Javaエンジニア募集」に対して提案依頼がありました。","read":false,"created_at":"2023-05-01T10:30:00.000Z"}

```

## 6. フロントエンド統合

### 6.1 通知コンポーネント

フロントエンドでは以下の通知関連コンポーネントを実装する：

1. **通知ヘッダーアイコン**
   - ヘッダーバーに表示される通知アイコン
   - 未読通知数をバッジで表示
   - クリックでドロップダウンメニューを表示

2. **通知ドロップダウン**
   - 最新の未読通知を表示（3〜5件程度）
   - 「すべての通知を見る」リンク
   - 「すべて既読にする」ボタン

3. **通知一覧画面**
   - タブによる通知種類の切り替え
   - フィルタリングと検索機能
   - ページネーション

4. **通知詳細モーダル**
   - 通知の詳細情報表示
   - 関連アクションへのリンク
   - 既読/未読切り替え、削除機能

5. **通知設定画面**
   - 通知タイプごとの設定
   - メール通知の有効/無効
   - アプリ内通知の有効/無効
   - 保持期間の設定

### 6.2 リアルタイム通知の実装

フロントエンドでのリアルタイム通知の実装例：

```typescript
// SSEを使用した通知ストリームの購読
class NotificationService {
  private eventSource: EventSource | null = null;

  subscribeToNotifications() {
    if (this.eventSource) {
      this.eventSource.close();
    }

    this.eventSource = new EventSource('/api/v1/common/notifications/stream');
    
    this.eventSource.addEventListener('notification', (event) => {
      const notification = JSON.parse(event.data);
      this.addNotification(notification);
      this.showNotificationAlert(notification);
    });

    this.eventSource.onerror = (error) => {
      console.error('EventSource failed:', error);
      this.eventSource?.close();
      // 再接続ロジック
      setTimeout(() => this.subscribeToNotifications(), 5000);
    };
  }

  private addNotification(notification: Notification) {
    // ストアに通知を追加
    store.dispatch(addNotification(notification));
  }

  private showNotificationAlert(notification: Notification) {
    // トースト通知を表示
    toastService.show({
      title: notification.title,
      body: notification.body,
      type: notification.type,
      duration: 5000,
      onClick: () => this.navigateToNotification(notification)
    });
  }

  private navigateToNotification(notification: Notification) {
    // 通知関連ページへ遷移
    if (notification.metadata && notification.metadata.action_url) {
      router.navigate(notification.metadata.action_url);
    } else {
      router.navigate(`/notifications/${notification.id}`);
    }
  }
}
```

## 7. 業務モジュールとの統合

### 7.1 統合パターン

業務モジュールは以下のパターンで通知機能と統合する：

1. **イベント発行パターン**
   - Spring ApplicationEventを使用
   - 業務ロジックと通知ロジックの分離
   - 疎結合な設計

2. **サービス直接呼び出しパターン**
   - NotificationServiceの直接注入
   - 細かい制御が必要な場合に使用
   - 強結合だが直接的な制御が可能

### 7.2 統合例

#### 7.2.1 案件管理モジュールとの統合例

案件の状態変更時に通知を発行する例：

```java
@Service
public class ProjectServiceImpl implements ProjectService {

    private final ApplicationEventPublisher eventPublisher;
    
    @Autowired
    public ProjectServiceImpl(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }
    
    @Override
    @Transactional
    public Project createProject(ProjectDto projectDto) {
        // 案件の作成ロジック
        Project project = projectMapper.toEntity(projectDto);
        project = projectRepository.save(project);
        
        // イベント発行
        eventPublisher.publishEvent(new ProjectCreatedEvent(project));
        
        return project;
    }
    
    @Override
    @Transactional
    public Project updateProjectStatus(Long projectId, ProjectStatus newStatus) {
        Project project = projectRepository.findById(projectId)
            .orElseThrow(() -> new ResourceNotFoundException("Project not found"));
            
        ProjectStatus oldStatus = project.getStatus();
        project.setStatus(newStatus);
        project = projectRepository.save(project);
        
        // 状態変更イベント発行
        eventPublisher.publishEvent(
            new ProjectStatusChangedEvent(project, oldStatus, newStatus)
        );
        
        return project;
    }
}
```

対応するイベントリスナー：

```java
@Component
public class ProjectNotificationListener {

    private final NotificationService notificationService;
    private final UserService userService;
    
    @Autowired
    public ProjectNotificationListener(
            NotificationService notificationService,
            UserService userService) {
        this.notificationService = notificationService;
        this.userService = userService;
    }
    
    @EventListener
    public void handleProjectCreatedEvent(ProjectCreatedEvent event) {
        Project project = event.getProject();
        
        // 通知対象ユーザーの特定
        List<User> recipients = userService.findUsersByRole("ROLE_PROJECT_MANAGER");
        
        // メタデータの作成
        Map<String, Object> metadata = new HashMap<>();
        metadata.put("project_id", project.getId());
        metadata.put("project_name", project.getName());
        metadata.put("client_name", project.getClient().getName());
        metadata.put("project_type", project.getType().name());
        metadata.put("action_url", "/projects/" + project.getId());
        
        // 通知の作成
        notificationService.createNotification(
            NotificationType.EVENT,
            recipients,
            "新しい案件が登録されました",
            String.format("「%s」という新しい案件が登録されました。詳細を確認してください。", project.getName()),
            metadata
        );
    }
    
    @EventListener
    public void handleProjectStatusChangedEvent(ProjectStatusChangedEvent event) {
        Project project = event.getProject();
        ProjectStatus oldStatus = event.getOldStatus();
        ProjectStatus newStatus = event.getNewStatus();
        
        // 特定の状態変更のみ通知する
        if (newStatus == ProjectStatus.READY_FOR_MATCHING) {
            // マッチング担当者に通知
            List<User> recipients = userService.findUsersByRole("ROLE_MATCHER");
            
            Map<String, Object> metadata = new HashMap<>();
            metadata.put("project_id", project.getId());
            metadata.put("project_name", project.getName());
            metadata.put("old_status", oldStatus.name());
            metadata.put("new_status", newStatus.name());
            metadata.put("action_url", "/matching/" + project.getId());
            
            notificationService.createNotification(
                NotificationType.TASK,
                recipients,
                "マッチング待ちの案件があります",
                String.format("案件「%s」がマッチング待ち状態になりました。技術者のマッチングを行ってください。", project.getName()),
                metadata
            );
        }
    }
}
```

#### 7.2.2 請求管理モジュールとの統合例

請求書の承認依頼時に通知を発行する例：

```java
@Service
public class InvoiceServiceImpl implements InvoiceService {

    private final NotificationService notificationService;
    private final UserService userService;
    
    @Autowired
    public InvoiceServiceImpl(
            NotificationService notificationService,
            UserService userService) {
        this.notificationService = notificationService;
        this.userService = userService;
    }
    
    @Override
    @Transactional
    public Invoice requestApproval(Long invoiceId) {
        Invoice invoice = invoiceRepository.findById(invoiceId)
            .orElseThrow(() -> new ResourceNotFoundException("Invoice not found"));
            
        invoice.setStatus(InvoiceStatus.WAITING_APPROVAL);
        invoice.setRequestedAt(LocalDateTime.now());
        invoice = invoiceRepository.save(invoice);
        
        // 承認者を取得
        User approver = invoice.getProject().getApprover();
        List<User> recipients = Collections.singletonList(approver);
        
        // 期限の設定（3営業日後）
        LocalDate deadlineDate = LocalDate.now().plusDays(3); 
        // 休日調整などのロジックは省略
        
        // メタデータの作成
        Map<String, Object> metadata = new HashMap<>();
        metadata.put("invoice_id", invoice.getId());
        metadata.put("invoice_number", invoice.getInvoiceNumber());
        metadata.put("project_id", invoice.getProject().getId());
        metadata.put("project_name", invoice.getProject().getName());
        metadata.put("client_name", invoice.getClient().getName());
        metadata.put("amount", invoice.getTotalAmount());
        metadata.put("deadline_date", deadlineDate.toString());
        metadata.put("action_url", "/invoices/" + invoice.getId() + "/approve");
        metadata.put("importance", "high");
        
        // 通知の作成（直接呼び出し）
        notificationService.createNotification(
            NotificationType.TASK,
            recipients,
            "請求書の承認依頼があります",
            String.format("案件「%s」の請求書（%s）が発行され、あなたの承認待ちです。%sまでに対応してください。", 
                invoice.getProject().getName(), 
                invoice.getInvoiceNumber(),
                deadlineDate.format(DateTimeFormatter.ofPattern("M月d日"))),
            metadata
        );
        
        return invoice;
    }
}
```

## 8. セキュリティと権限

### 8.1 通知のアクセス制御

通知に関する操作は適切なアクセス制御を適用する：

1. **通知の参照**
   - 通知の受信者のみが参照可能
   - 管理者は全ての通知を参照可能（監査目的）

2. **通知の状態変更**
   - 通知の受信者のみが既読/未読の状態を変更可能
   - 削除も受信者のみが可能

3. **通知の作成**
   - 認証されたシステムコンポーネントのみが作成可能
   - 一般ユーザーは通知の作成不可

### 8.2 実装例

Spring Securityを用いたアクセス制御の実装例：

```java
@RestController
@RequestMapping("/api/v1/common/notifications")
public class NotificationController {

    private final NotificationService notificationService;
    
    // コンストラクタ注入
    
    @GetMapping
    public ResponseEntity<?> getUserNotifications(
            @RequestParam(required = false) NotificationType type,
            @RequestParam(required = false) Boolean read,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @AuthenticationPrincipal UserDetails userDetails) {
        
        Page<Notification> notifications = notificationService.getUserNotifications(
            userDetails.getUsername(), type, read, PageRequest.of(page, size)
        );
        
        // レスポンス構築
        return ResponseEntity.ok(buildPageResponse(notifications));
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<?> getNotificationById(
            @PathVariable UUID id,
            @AuthenticationPrincipal UserDetails userDetails) {
        
        try {
            Notification notification = notificationService.getNotificationById(
                id, userDetails.getUsername()
            );
            return ResponseEntity.ok(buildResponse(notification));
        } catch (AccessDeniedException e) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                .body(buildErrorResponse("FORBIDDEN", "この通知へのアクセス権限がありません。"));
        } catch (ResourceNotFoundException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(buildErrorResponse("RESOURCE_NOT_FOUND", "指定された通知が存在しません。"));
        }
    }
    
    @PutMapping("/{id}/read")
    public ResponseEntity<?> markAsRead(
            @PathVariable UUID id,
            @AuthenticationPrincipal UserDetails userDetails) {
        
        try {
            Notification notification = notificationService.markAsRead(
                id, userDetails.getUsername()
            );
            return ResponseEntity.ok(buildReadStatusResponse(notification));
        } catch (AccessDeniedException e) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                .body(buildErrorResponse("FORBIDDEN", "この通知へのアクセス権限がありません。"));
        } catch (ResourceNotFoundException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(buildErrorResponse("RESOURCE_NOT_FOUND", "指定された通知が存在しません。"));
        }
    }
    
    // その他のメソッド
}
```

サービス層での権限チェック：

```java
@Service
public class NotificationServiceImpl implements NotificationService {

    // 依存性注入など
    
    @Override
    public Notification getNotificationById(UUID id, String username) {
        Notification notification = notificationRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Notification not found"));
            
        // 受信者チェック
        if (!notification.getRecipient().getUsername().equals(username)) {
            throw new AccessDeniedException("You don't have permission to access this notification");
        }
        
        return notification;
    }
    
    // その他のメソッド実装
}
```

## 9. 性能と拡張性

### 9.1 キャッシュ戦略

通知の高速な取得のためにキャッシュを適用する：

```java
@Service
public class CachedNotificationServiceImpl implements NotificationService {

    @Autowired
    private NotificationRepository notificationRepository;
    
    @Autowired
    private CacheManager cacheManager;
    
    @Override
    @Cacheable(value = "userNotificationCount", key = "#username")
    public NotificationSummary getUserNotificationSummary(String username) {
        long unreadCount = notificationRepository.countByRecipientUsernameAndReadFalse(username);
        long totalCount = notificationRepository.countByRecipientUsername(username);
        
        return new NotificationSummary(unreadCount, totalCount);
    }
    
    @Override
    @CacheEvict(value = "userNotificationCount", key = "#username")
    public Notification markAsRead(UUID id, String username) {
        // 既読処理の実装
        return notification;
    }
    
    @Override
    @CacheEvict(value = "userNotificationCount", key = "#username")
    public int markAllAsRead(String username, NotificationType type) {
        // 全既読処理の実装
        return markedCount;
    }
    
    // その他のメソッド
}
```

### 9.2 非同期処理

通知の作成と配信を非同期で処理する：

```java
@Service
public class AsyncNotificationServiceImpl implements NotificationService {

    @Autowired
    private NotificationRepository notificationRepository;
    
    @Autowired
    private DeliveryService deliveryService;
    
    @Override
    @Async
    public CompletableFuture<Notification> createNotificationAsync(
            NotificationType type,
            List<User> recipients,
            String title,
            String body,
            Map<String, Object> metadata) {
        
        // 複数の受信者がいる場合、それぞれに通知を作成
        List<CompletableFuture<Notification>> futures = recipients.stream()
            .map(recipient -> createSingleNotificationAsync(type, recipient, title, body, metadata))
            .collect(Collectors.toList());
        
        // 最初の通知を返す（複数ある場合）
        return futures.get(0);
    }
    
    @Async
    private CompletableFuture<Notification> createSingleNotificationAsync(
            NotificationType type,
            User recipient,
            String title,
            String body,
            Map<String, Object> metadata) {
        
        Notification notification = new Notification();
        notification.setType(type);
        notification.setTitle(title);
        notification.setBody(body);
        notification.setMetadata(metadata);
        notification.setRecipient(recipient);
        notification.setCreatedAt(LocalDateTime.now());
        notification.setRead(false);
        
        // 通知を保存
        notification = notificationRepository.save(notification);
        
        // 配信処理（メール、プッシュ通知など）
        deliveryService.deliverNotification(notification);
        
        return CompletableFuture.completedFuture(notification);
    }
    
    // その他のメソッド
}
```

### 9.3 パフォーマンス最適化

1. **インデックス設計**

通知テーブルには以下のインデックスを設定：

```sql
-- 受信者ごとの通知クエリの高速化
CREATE INDEX idx_notification_recipient_created_at 
ON notifications(recipient_id, created_at DESC);

-- 未読通知のクエリ高速化
CREATE INDEX idx_notification_recipient_read
ON notifications(recipient_id, read);

-- 通知タイプによるフィルタリングの高速化
CREATE INDEX idx_notification_recipient_type
ON notifications(recipient_id, type);
```

2. **ページング処理の最適化**

大量の通知を効率的に取得するためのページング処理：

```java
@Repository
public interface NotificationRepository extends JpaRepository<Notification, UUID> {

    @Query("SELECT n FROM Notification n WHERE n.recipient.username = :username " +
           "AND (:type IS NULL OR n.type = :type) " +
           "AND (:read IS NULL OR n.read = :read) " +
           "ORDER BY n.createdAt DESC")
    Page<Notification> findByRecipientUsername(
        @Param("username") String username,
        @Param("type") NotificationType type,
        @Param("read") Boolean read,
        Pageable pageable
    );
    
    // カウントクエリの最適化
    @Query("SELECT COUNT(n) FROM Notification n WHERE n.recipient.username = :username " +
           "AND n.read = false")
    long countByRecipientUsernameAndReadFalse(@Param("username") String username);
}
```

3. **読み取り/書き込み分離**

高負荷環境での最適化として読み取り/書き込み分離パターンを適用：

```java
@Configuration
@EnableJpaRepositories(
    basePackages = "com.example.repository.read",
    entityManagerFactoryRef = "readEntityManagerFactory",
    transactionManagerRef = "readTransactionManager"
)
public class ReadRepositoryConfig {
    // 読み取り専用リポジトリの設定
}

@Configuration
@EnableJpaRepositories(
    basePackages = "com.example.repository.write",
    entityManagerFactoryRef = "writeEntityManagerFactory",
    transactionManagerRef = "writeTransactionManager"
)
public class WriteRepositoryConfig {
    // 書き込み用リポジトリの設定
}
```

## 10. 運用設計

### 10.1 通知の保持期間とアーカイブ

通知の保持期間ポリシーは以下の通り：

- **既読通知**: 30日間保存後に自動アーカイブ
- **未読通知**: 90日間保存後に自動アーカイブ
- **重要通知**: 180日間保存後に自動アーカイブ

アーカイブ処理の実装：

```java
@Service
public class NotificationMaintenanceService {

    @Autowired
    private NotificationRepository notificationRepository;
    
    @Autowired
    private NotificationArchiveRepository notificationArchiveRepository;
    
    @Autowired
    private NotificationPreferenceService preferenceService;
    
    @Scheduled(cron = "0 0 1 * * ?") // 毎日午前1時に実行
    public void archiveExpiredNotifications() {
        log.info("Starting notification archiving process");
        
        LocalDateTime now = LocalDateTime.now();
        
        // ユーザーごとの設定に基づいてアーカイブ
        List<User> allUsers = userRepository.findAll();
        
        for (User user : allUsers) {
            // ユーザーごとの通知設定を取得
            Map<NotificationType, NotificationPreference> preferences = 
                preferenceService.getUserPreferencesAsMap(user.getUsername());
                
            for (NotificationType type : NotificationType.values()) {
                NotificationPreference pref = preferences.get(type);
                int retentionDays = pref != null ? pref.getRetentionDays() : 90; // デフォルト値
                
                // 既読通知のアーカイブ（保持期間の半分の日数で）
                LocalDateTime readCutoff = now.minusDays(retentionDays / 2);
                List<Notification> readNotifications = notificationRepository
                    .findByRecipientAndTypeAndReadIsTrueAndCreatedAtBefore(
                        user, type, readCutoff);
                
                archiveNotifications(readNotifications);
                
                // 未読通知のアーカイブ（フル保持期間で）
                LocalDateTime unreadCutoff = now.minusDays(retentionDays);
                List<Notification> unreadNotifications = notificationRepository
                    .findByRecipientAndTypeAndReadIsFalseAndCreatedAtBefore(
                        user, type, unreadCutoff);
                    
                archiveNotifications(unreadNotifications);
            }
        }
        
        log.info("Notification archiving process completed");
    }
    
    private void archiveNotifications(List<Notification> notifications) {
        if (notifications.isEmpty()) {
            return;
        }
        
        // 通知をアーカイブテーブルに移動
        List<NotificationArchive> archives = notifications.stream()
            .map(this::convertToArchive)
            .collect(Collectors.toList());
            
        notificationArchiveRepository.saveAll(archives);
        
        // 元の通知を削除
        notificationRepository.deleteAll(notifications);
        
        log.info("Archived {} notifications", notifications.size());
    }
    
    private NotificationArchive convertToArchive(Notification notification) {
        NotificationArchive archive = new NotificationArchive();
        // プロパティのコピー
        archive.setOriginalId(notification.getId());
        archive.setType(notification.getType());
        archive.setTitle(notification.getTitle());
        archive.setBody(notification.getBody());
        archive.setMetadata(notification.getMetadata());
        archive.setRecipientId(notification.getRecipient().getId());
        archive.setRecipientUsername(notification.getRecipient().getUsername());
        archive.setSenderId(notification.getSender() != null ? notification.getSender().getId() : null);
        archive.setRead(notification.isRead());
        archive.setCreatedAt(notification.getCreatedAt());
        archive.setUpdatedAt(notification.getUpdatedAt());
        archive.setArchivedAt(LocalDateTime.now());
        
        return archive;
    }
}
```

### 10.2 モニタリングと監視

通知システムの安定運用のためのモニタリング設計：

1. **メトリクス収集**

```java
@Configuration
public class NotificationMetricsConfig {

    @Bean
    public MeterRegistry meterRegistry() {
        return new SimpleMeterRegistry();
    }
    
    @Bean
    public NotificationMetrics notificationMetrics(MeterRegistry meterRegistry) {
        return new NotificationMetrics(meterRegistry);
    }
}

@Component
public class NotificationMetrics {

    private final Counter notificationCreatedCounter;
    private final Counter notificationDeliveredCounter;
    private final Counter notificationReadCounter;
    private final Timer notificationDeliveryTimer;
    
    public NotificationMetrics(MeterRegistry registry) {
        notificationCreatedCounter = registry.counter("notification.created");
        notificationDeliveredCounter = registry.counter("notification.delivered");
        notificationReadCounter = registry.counter("notification.read");
        notificationDeliveryTimer = registry.timer("notification.delivery.time");
    }
    
    public void recordNotificationCreated(NotificationType type) {
        notificationCreatedCounter.increment();
        registry.counter("notification.created." + type.name().toLowerCase()).increment();
    }
    
    public void recordNotificationDelivered(NotificationType type, String channel) {
        notificationDeliveredCounter.increment();
        registry.counter("notification.delivered." + type.name().toLowerCase() + "." + channel).increment();
    }
    
    public void recordNotificationRead() {
        notificationReadCounter.increment();
    }
    
    public Timer.Sample startDeliveryTimer() {
        return Timer.start(registry);
    }
    
    public void stopDeliveryTimer(Timer.Sample sample, NotificationType type, String channel) {
        sample.stop(registry.timer("notification.delivery.time." + type.name().toLowerCase() + "." + channel));
    }
}
```

2. **ログ記録**

```java
@Aspect
@Component
public class NotificationLoggingAspect {

    private static final Logger log = LoggerFactory.getLogger(NotificationLoggingAspect.class);
    
    @Around("execution(* com.example.service.NotificationService.createNotification(..))")
    public Object logNotificationCreation(ProceedingJoinPoint joinPoint) throws Throwable {
        Object[] args = joinPoint.getArgs();
        NotificationType type = (NotificationType) args[0];
        List<User> recipients = (List<User>) args[1];
        String title = (String) args[2];
        
        log.info("Creating {} notification '{}' for {} recipients", 
            type, title, recipients.size());
            
        long startTime = System.currentTimeMillis();
        Object result = joinPoint.proceed();
        long endTime = System.currentTimeMillis();
        
        log.info("Created notification in {}ms", (endTime - startTime));
        
        return result;
    }
    
    // その他のロギングポイント
}
```

3. **ヘルスチェック**

```java
@Component
public class NotificationHealthIndicator implements HealthIndicator {

    @Autowired
    private NotificationRepository notificationRepository;
    
    @Autowired
    private DeliveryService deliveryService;
    
    @Override
    public Health health() {
        Health.Builder builder = new Health.Builder();
        
        try {
            // データベース接続チェック
            long count = notificationRepository.count();
            builder.withDetail("notification_count", count);
            
            // 配信サービスチェック
            boolean deliveryServiceOk = deliveryService.checkHealth();
            builder.withDetail("delivery_service", deliveryServiceOk ? "UP" : "DOWN");
            
            if (deliveryServiceOk) {
                return builder.up().build();
            } else {
                return builder.down()
                    .withDetail("error", "Delivery service is not available")
                    .build();
            }
        } catch (Exception e) {
            return builder.down()
                .withDetail("error", e.getMessage())
                .build();
        }
    }
}
```

## 11. まとめ

通知機能は、SES業務システム内で多様な業務イベントをユーザーに効率的に伝達するための重要な共通基盤である。本設計では以下の特徴を持つ通知システムを定義した：

1. **多様な通知タイプ**: システム、タスク、アラート、イベントの4種類の通知タイプをサポート
2. **複数の配信チャネル**: アプリ内通知とメール通知の組み合わせによる確実な情報伝達
3. **リアルタイム通知**: SSEを用いたプッシュ型のリアルタイム通知の実現
4. **柔軟な統合パターン**: イベント駆動と直接呼び出しの2つの統合パターンによる業務モジュールとの連携
5. **パフォーマンスと拡張性**: キャッシュと非同期処理による高いパフォーマンスと拡張性の確保
6. **運用管理機能**: 通知のライフサイクル管理、アーカイブ、モニタリングによる安定運用

この通知機能を導入することで、ユーザーは重要な情報をタイムリーに受け取り、必要なアクションを迅速に実行できるようになり、業務の効率化と利便性の向上に貢献する。